1
00:00:01,570 --> 00:00:07,360
Welcome to Peer to Peer, where you
can watch our experts solve tech problems.

2
00:00:07,370 --> 00:00:09,200
Our guest today is Camille Baldock

3
00:00:09,600 --> 00:00:12,970
who by day writes Ruby and
JavaScript for the British Government.

4
00:00:13,060 --> 00:00:18,260
And by night mentors junior
developers and teaches programming in schools.

5
00:00:18,260 --> 00:00:20,340
Our host is Tom Stuart.

6
00:00:20,391 --> 00:00:22,995
And the challenge that we set for Camille is called

7
00:00:22,995 --> 00:00:25,090
Ranking Poker Hands

8
00:00:25,910 --> 00:00:29,220
TS: So Camille, would you like to
read out the problem statement ?

9
00:00:29,490 --> 00:00:34,266
CB: Sure. A"hand" in poker consists of five
playing cards drawn from a standard deck.

10
00:00:34,746 --> 00:00:37,831
Apparently today I'm going to
implement a system which can decide

11
00:00:37,830 --> 00:00:44,737
which of two hands has the highest ranking,
according to the standard poker ranking rules.

12
00:00:44,740 --> 00:00:46,720
Do you know the standard poker ranking rules ?

13
00:00:46,728 --> 00:00:48,450
CB: I do !  Which is fortunate.

14
00:00:48,453 --> 00:00:53,560
CB: OK, right, so this is nice and vague !

15
00:00:54,740 --> 00:01:00,480
CB: If I'm doing something like
that I need some way of knowing

16
00:01:00,480 --> 00:01:05,537
this is hand A and this is
hand B and the program will sort it out.

17
00:01:05,610 --> 00:01:10,684
And I need to think of how to tell
people to tell me what their hand looks like.

18
00:01:10,693 --> 00:01:14,035
TS: OK

19
00:01:14,340 --> 00:01:19,822
The first 'off the top of my head', easy
thing, is to you have some sort of string or array

20
00:01:19,822 --> 00:01:26,090
that says you have an array of 5 things,
that says I have a 5 of Hearts and the 6 of Diamonds.

21
00:01:26,106 --> 00:01:33,710
I could put that in an array or represent
that as ['4H', '5D']. (4 Hearts 5 Diamonds).

22
00:01:33,760 --> 00:01:38,115
Put that in an array and then
two arrays. And create the problem

23
00:01:38,110 --> 00:01:38,782
TS: OK.

24
00:01:38,782 --> 00:01:44,222
CB: So we'll get started with that.

25
00:01:44,420 --> 00:01:47,831
So, I'm just going to switch to where I put code.

26
00:01:50,462 --> 00:01:52,497
We'll have our own folder today.

27
00:01:54,110 --> 00:01:58,088
What I'm going to do is make
sure I've got a couple of things in place

28
00:01:58,080 --> 00:02:02,690
Like a spec_helper.rb. And then, we can get started.

29
00:02:06,110 --> 00:02:13,520
The first thing I want to do is enter
some kind of array 'thing' and it creates...

30
00:02:13,528 --> 00:02:16,977
I don't know what it creates.

31
00:02:16,990 --> 00:02:20,204
So, if I'm going to be comparing hands...

32
00:02:20,204 --> 00:02:24,666
A hand has several cards in it, and I
need some way to represent what a card is

33
00:02:24,710 --> 00:02:27,066
and a hand that has several cards in it.

34
00:02:27,060 --> 00:02:30,820
And then I want to be taking
the hand, and taking the other Hand object

35
00:02:30,880 --> 00:02:32,986
and then somehow comparing them.

36
00:02:33,000 --> 00:02:38,862
So the first thing I probably
want to have in place is some kind of Hand object

37
00:02:38,880 --> 00:02:43,155
and some kind of Card
object in which I can put 'things'.

38
00:02:43,155 --> 00:02:46,480
Yes, so we can go ahead and start that.

39
00:02:47,582 --> 00:02:51,650
So the first thing I want to do is...

40
00:02:51,820 --> 00:02:54,520
I have an array that says 5H and 6 Diamond.

41
00:02:54,570 --> 00:03:01,066
And on the other end, and this is my
Hand object with those card 'things' inside it.

42
00:03:01,075 --> 00:03:03,050
So we'll start with that I think.

43
00:03:04,000 --> 00:03:06,920
TS: Are you talking about an array of strings?

44
00:03:06,920 --> 00:03:09,150
CB: As an input or...
TS: Yes

45
00:03:11,973 --> 00:03:16,044
CB: I'm not too concerned about that at
the moment. I don't think it matters that much,

46
00:03:16,044 --> 00:03:20,337
Since I don't want to keep them as an array
of strings, but do interesting things afterwards.

47
00:03:20,330 --> 00:03:22,008
So I don't think it should matter that much.

48
00:03:22,026 --> 00:03:25,050
TS: So this is just going
to be a serialisation format.

49
00:03:25,057 --> 00:03:30,250
CB: Yes, a hand parser type thing. Let's call it that.

50
00:03:31,420 --> 00:03:35,100
So, if I have a hand parser 'thing'.

51
00:03:36,340 --> 00:03:41,440
Ok, so this is the 'I can't type moment'. (laughter)

52
00:03:42,250 --> 00:03:46,770
So if we have some kind
of object called HandParser

53
00:03:51,770 --> 00:03:59,440
It probably should 'parses the
array of strings representing the cards'

54
00:03:59,440 --> 00:04:03,848
(this is quite verbose), but let's get to that.

55
00:04:03,840 --> 00:04:08,542
Actually this is going to
fail so how about we run this.

56
00:04:08,570 --> 00:04:13,377
And this is not very happy and
'uninitialized constant HandParser'

57
00:04:13,420 --> 00:04:16,890
Yes, this is my first failure - here we go !

58
00:04:18,450 --> 00:04:22,020
So I'm going to have to
have a HandParser sitting somewhere.

59
00:04:22,530 --> 00:04:25,090
I need to create that file in there.

60
00:04:25,850 --> 00:04:28,770
And let's create a  parser
that does absolutely nothing.

61
00:04:29,280 --> 00:04:35,970
But that should make my test happy
enough, unless I don't require it, obviously.

62
00:04:36,080 --> 00:04:39,928
Because otherwise it wouldn't know where to look.

63
00:04:40,020 --> 00:04:44,791
So let's give that a try... OK, zero
examples, zero failures. So far so good.

64
00:04:45,710 --> 00:04:48,808
What I probably want to do is...

65
00:04:48,840 --> 00:04:56,778
If I create a HandParser and I give it the
array of string things that will represent cards

66
00:04:56,778 --> 00:05:02,181
then on the other hand I want
to check what the output of that is.

67
00:05:02,180 --> 00:05:10,334
Let's have ... so the subject is
HandParser, so if we have described_class.

68
00:05:10,340 --> 00:05:15,920
If I create HandParser and hopefully
have some kind of thing that says parse

69
00:05:16,590 --> 00:05:22,785
and it will take the array
of cards, which I need to define.

70
00:05:24,523 --> 00:05:27,400
Let's have a look at how
I'm going to put those cards in.

71
00:05:27,403 --> 00:05:32,058
So we can have those as 5 Hearts 6 of Diamonds.

72
00:05:32,545 --> 00:05:35,258
That's not an array (Laughter).

73
00:05:38,370 --> 00:05:40,436
You choose the cards.

74
00:05:40,480 --> 00:05:42,167
TS: King, Queen, Ace.

75
00:05:45,310 --> 00:05:53,338
CB: Yes, King of Spades, what's
the other suit? Clubs, that's the one.

76
00:05:53,370 --> 00:05:59,323
So Queen of Clubs, and then we
can have ... let's have an annoying card in there.

77
00:05:59,330 --> 00:06:01,800
Just so we have a bit of fun.

78
00:06:02,269 --> 00:06:04,340
Which is Ace.

79
00:06:08,280 --> 00:06:13,607
Let's keep Ace as one and see where
that takes us. I reckon that matters somehow.

80
00:06:13,740 --> 00:06:17,709
But I have no idea, so we shall see.

81
00:06:17,700 --> 00:06:20,792
And this should give me some kind of 'thing'.

82
00:06:22,087 --> 00:06:26,443
This is already going to fail so I'm
not even going to put an expectation in there

83
00:06:26,440 --> 00:06:30,705
I'm going to go ahead and
run my tests and this should fail nicely, because

84
00:06:30,700 --> 00:06:32,414
I don't have a method parse.

85
00:06:32,421 --> 00:06:33,229
TS: OK.

86
00:06:33,220 --> 00:06:39,076
(Camille types)

87
00:06:39,080 --> 00:06:44,661
If I have a method parse that
takes an array of things (cards).

88
00:06:44,660 --> 00:06:46,540
It's not these things.

89
00:06:46,540 --> 00:06:53,323
(Camille ponders)

90
00:06:53,410 --> 00:06:57,658
Well - this test tests nothing.
But at least it's not erroring any more.

91
00:06:57,650 --> 00:07:01,450
On the other hand - I want it to be a hand and...

92
00:07:05,629 --> 00:07:09,338
I want this to be some
kind of Hand object type of thing.

93
00:07:09,330 --> 00:07:12,989
So ... (Camille ponders)

94
00:07:13,000 --> 00:07:15,450
So, I want to create a Hand object type of thing.

95
00:07:15,450 --> 00:07:16,320
TS: OK.

96
00:07:20,250 --> 00:07:22,080
Oh, how do we even do this in RSpec.

97
00:07:23,480 --> 00:07:26,603
I don't want to do something like this, right.

98
00:07:26,620 --> 00:07:29,690
How do you get a thing and check the class of it?

99
00:07:29,690 --> 00:07:34,400
Actually, do I even care about the
class of it? No I actually care about how it quacks.

100
00:07:34,407 --> 00:07:42,807
So I expect my
hand.cards.count to equal 5 for example,

101
00:07:42,800 --> 00:07:45,432
And actually ...

102
00:07:45,454 --> 00:07:51,687
this doesn't test that anymore
so let's rewire this thing a little bit.

103
00:07:51,690 --> 00:07:59,309
We'll just give this 5 cards
and it returns back a hand of cards.

104
00:07:59,300 --> 00:08:04,254
So here we want it to have exactly
the same number of things that we have.

105
00:08:04,250 --> 00:08:08,749
I'm going to gloss over the issue and
give it an array of cards that only has 4 cards.

106
00:08:08,749 --> 00:08:11,770
If it falls over, let's just not go there for now!

107
00:08:11,780 --> 00:08:15,876
We'll just assume that our users
are going to put correct things in there.

108
00:08:15,870 --> 00:08:17,054
TS: OK.

109
00:08:17,956 --> 00:08:22,530
CB: So yes let's just start with
that, this will already fail quite nicely.

110
00:08:27,930 --> 00:08:28,940
Right, excellent.

111
00:08:31,620 --> 00:08:36,945
This needs to return a thing that quacks .cards.

112
00:08:37,050 --> 00:08:38,770
TS: OK.

113
00:08:38,770 --> 00:08:42,843
(Silence)

114
00:08:51,600 --> 00:08:55,396
Look at me failing ... that's
sublime, beautiful. (laughter)

115
00:08:57,710 --> 00:09:04,560
OK, so if it has that then...
This should complain for different reasons now.

116
00:09:05,780 --> 00:09:08,720
No, wrong shortcut, OK

117
00:09:08,740 --> 00:09:13,083
uninitialized constant
HandParser::Hand... so far so good.

118
00:09:16,050 --> 00:09:21,338
This doesn't know what Hand
is so let's quickly require it.

119
00:09:21,738 --> 00:09:23,570
And now back to our tests.

120
00:09:27,512 --> 00:09:30,785
OK, undefined method count, it has nothing in it.

121
00:09:30,780 --> 00:09:36,298
Right, so... (silence)

122
00:09:36,510 --> 00:09:39,900
This should fail for a slightly nicer reason now.

123
00:09:39,900 --> 00:09:43,112
(Silence)

124
00:09:43,130 --> 00:09:46,487
So now we have an array that has
nothing in it. And we should have 5 things.

125
00:09:46,480 --> 00:09:51,490
and now I'll actually implement
the things because it's about time!

126
00:09:51,498 --> 00:09:54,552
So if we have an array of cards and it has 5 things,

127
00:09:54,552 --> 00:09:59,054
then what I want to do is
create a hand with some cards in it.

128
00:09:59,060 --> 00:10:05,949
So if we have some 'thing'
that takes the array of cards

129
00:10:10,270 --> 00:10:14,807
which is essentially an array of string
cards, or however you want to call that.

130
00:10:15,040 --> 00:10:23,040
And I want it to basically... (Camille ponders)

131
00:10:23,060 --> 00:10:28,365
from that string of card be able to
say, make me a Card object type 'thing'.

132
00:10:28,400 --> 00:10:29,702
TS: Right.

133
00:10:29,850 --> 00:10:32,460
and then eventually I'll want to feed it into Hand.

134
00:10:32,580 --> 00:10:34,640
but one thing at a time.

135
00:10:34,770 --> 00:10:38,194
OK, so that can live here.

136
00:10:38,200 --> 00:10:45,600
So if I have make_card thing,
this is going to move to Card object later.

137
00:10:45,600 --> 00:10:47,062
Let's get to that in a second.

138
00:10:47,062 --> 00:10:48,674
TS: OK.

139
00:10:49,770 --> 00:10:53,737
I don't like the interface of
this, it is quite unnatural.

140
00:10:53,730 --> 00:10:57,485
I quite like the fact that my parsing
logic is going to sit somewhere else.

141
00:10:57,480 --> 00:11:00,194
I don't want to have to do
crazy regexes and things like that

142
00:11:00,205 --> 00:11:03,440
as part of a thing that is
supposed to be comparing cards.

143
00:11:03,450 --> 00:11:07,851
But, at the same time, like
here, I'm creating a new card.

144
00:11:07,851 --> 00:11:11,462
TS: So why are you
approaching it in this particular way ?

145
00:11:11,460 --> 00:11:15,382
if you're saying you don't want this
method to be here, why are you putting it here?

146
00:11:15,390 --> 00:11:23,977
CB: I'm not quite sure how much logic...
what my Card.new type method should be accepting.

147
00:11:23,980 --> 00:11:28,468
In a perfect world, I would like it
to say 'if it's a 5 of Diamond' it takes

148
00:11:28,480 --> 00:11:32,800
Card.new 5 and a Diamond symbol type thing.

149
00:11:33,200 --> 00:11:38,845
So I want a tiny bit of pre-processing before hand
to check that there are two things in this string.

150
00:11:38,902 --> 00:11:42,000
And H maps to Hearts, and something like that.

151
00:11:42,011 --> 00:11:42,540
TS: Fine

152
00:11:42,540 --> 00:11:42,651
CB: So this is where I want this to live. I'm not quite sure yet.
TS: Fine

153
00:11:42,651 --> 00:11:46,011
CB: So this is where I want this to live. I'm not quite sure yet.

154
00:11:46,057 --> 00:11:50,308
TS: So you're expecting later on that you're
going to have a better idea of what's going on here.

155
00:11:50,308 --> 00:11:50,960
CB: Yes.

156
00:11:50,971 --> 00:11:54,800
TS: OK let's see what happens.

157
00:11:54,811 --> 00:12:01,497
CB: OK, so this is a thing, and it takes a card string.

158
00:12:01,510 --> 00:12:06,491
And, if I remember rightly, my card
string has 5 H or something like that.

159
00:12:06,490 --> 00:12:09,794
So what I'm going to do is...

160
00:12:09,800 --> 00:12:18,674
create Card.new and I'm taking
card_string[0] card_string[1] but actually not.

161
00:12:20,971 --> 00:12:26,251
How do I want my cards to look,
how do I want them to quack.

162
00:12:27,080 --> 00:12:32,765
It's going to be easier for me as a
human, to have my suits (as in Hearts/Diamonds etc)

163
00:12:32,777 --> 00:12:34,880
written out in plain letters not as H and D etc.

164
00:12:34,880 --> 00:12:35,942
TS: OK

165
00:12:36,140 --> 00:12:42,651
I just want to do a very quick pre-parsing of ...

166
00:12:42,710 --> 00:12:52,377
if this is 'h' then just give me
:heart. and this is 'd' give me :diamond.

167
00:12:52,380 --> 00:12:57,828
Actually, this could very well live in
a hash, why am I doing a terrible switch?

168
00:12:57,828 --> 00:13:02,034
Let's have a hash sitting here.

169
00:13:02,050 --> 00:13:13,142
We have all the suits, so we
have H, Diamonds, Clubs, Spades.

170
00:13:13,268 --> 00:13:14,370
That seems correct.

171
00:13:14,742 --> 00:13:16,548
TS: That's all of them yes.

172
00:13:16,540 --> 00:13:20,765
(Camille types).

173
00:13:20,910 --> 00:13:23,908
CB: This is the slightly tedious typing part.

174
00:13:23,940 --> 00:13:30,605
Oh right ! Spades, cool.

175
00:13:30,660 --> 00:13:33,668
So, this goes bye bye.

176
00:13:33,690 --> 00:13:39,280
TS: So now you can just look up with a
hash rather than using a switch statement.

177
00:13:39,310 --> 00:13:44,994
CB: And I actually want it to fall over
quite loudly, if I have something crazy as my suit.

178
00:13:45,110 --> 00:13:47,220
TS: How are you going to make it fall over?

179
00:13:47,220 --> 00:13:54,548
CB: With fetch. It means that if I put
say 5 A in there that, fetch is going to complain,

180
00:13:54,570 --> 00:14:00,297
because there is no suit with key A
and therefore it will throw an exception.

181
00:14:00,290 --> 00:14:02,057
This is a bit...

182
00:14:02,057 --> 00:14:05,970
I should probably be handling this
in a different way if I'm doing that.

183
00:14:05,970 --> 00:14:10,308
I definitely don't want to have a
default value because there's no such thing.

184
00:14:10,340 --> 00:14:12,420
I should be thinking about things like,

185
00:14:12,770 --> 00:14:15,890
do I want capital H in
there and little things like that.

186
00:14:15,890 --> 00:14:20,891
But for now I'm doing it with
the minimum viable array string parser.

187
00:14:20,902 --> 00:14:22,400
And see where that takes me.

188
00:14:22,410 --> 00:14:28,548
TS: So your motivation here sounds
like you don't want it to silently fail ?

189
00:14:28,548 --> 00:14:30,600
If there's bad input, you want it to complain.

190
00:14:30,600 --> 00:14:31,910
CB: Yes, that's it.

191
00:14:31,910 --> 00:14:36,937
In the same way here for
example, it takes the first symbol.

192
00:14:36,960 --> 00:14:41,634
So if someone puts H5 for
example, that would also fail quite loudly.

193
00:14:41,702 --> 00:14:45,470
If someone puts HH however,
it's not going to fail loudly.

194
00:14:46,540 --> 00:14:52,308
But, I'm not in a statically typed language
and I don't want to spend time on it now.

195
00:14:52,540 --> 00:14:55,260
I'll clean it up a bit later.

196
00:14:56,280 --> 00:15:00,308
What I would usually do If I'm
writing things I want to ship is ...

197
00:15:02,140 --> 00:15:14,445
I would put a TODO and 'fail loudly and
with better errors with unexpected inputs'.

198
00:15:14,440 --> 00:15:24,068
much in the same way I would probably
be happy having #TODO: fail nicely when not 5.

199
00:15:25,177 --> 00:15:26,491
TS: Right.

200
00:15:28,420 --> 00:15:33,188
There's other things... of there's
two 5 of Hearts... you have a cheat.

201
00:15:33,310 --> 00:15:35,850
And things like that, but let's not even go there !

202
00:15:35,850 --> 00:15:39,691
Let's assume that that our players
are trying to be honest, at least.

203
00:15:39,710 --> 00:15:45,428
TS: we'll, I don't know enough about the
variance of Poker to say whether that's illegal.

204
00:15:45,480 --> 00:15:48,514
CB: I think if you have one deck
and you have 2 x 5 of Hearts

205
00:15:48,570 --> 00:15:52,228
you can reasonably assume that
somebody's messing with the game.

206
00:15:52,220 --> 00:15:54,000
TS: Fair enough.

207
00:15:54,170 --> 00:15:59,062
CB: So that's going to fail quite nicely because
I'm obviously missing quite a lot of objects.

208
00:15:59,325 --> 00:16:03,074
But let's see where it's failing.

209
00:16:03,390 --> 00:16:08,662
So, undefined method... Oh of course, I did something...

210
00:16:09,680 --> 00:16:15,131
Here I'm assuming that make_card
is available on my string, which it isn't.

211
00:16:15,450 --> 00:16:18,731
TS: You don't want to make it available.

212
00:16:18,770 --> 00:16:21,862
I thought you were going to
do some monkey patching and...

213
00:16:24,050 --> 00:16:27,611
Well, if you want to do it
for fun, to do crazy things, (laughter)

214
00:16:27,680 --> 00:16:37,245
and then see how I fail later, then sure,
but I love myself too much to do that to myself.

215
00:16:42,940 --> 00:16:46,640
[inaudible] here we go.

216
00:16:46,640 --> 00:16:49,880
Now it's complaining that
we don't have whatever that is.

217
00:16:49,950 --> 00:16:52,500
so we should re-create a 'whatever that is'.

218
00:16:54,240 --> 00:16:57,817
inaudible B and for now, to be honest

219
00:16:57,828 --> 00:17:02,580
I don't see it doing anything
really smart so it's just going to have...

220
00:17:03,794 --> 00:17:09,805
It's called 'Pips' in English, that's the
number on the face of the card, is it not?

221
00:17:09,820 --> 00:17:14,811
TS: I think I've heard the word
'rank' but 'Pips' also seems sensible.

222
00:17:14,840 --> 00:17:17,120
I'm going to stick with 'Pips'.

223
00:17:17,120 --> 00:17:21,280
I reckon, since I'm also doing
hand ranker, rank is going to confuse things.

224
00:17:21,280 --> 00:17:25,177
TS: Oh .. that's a good point.
Separate words for separate ideas.

225
00:17:26,850 --> 00:17:29,771
CB: I hear that's helpful. (laughter)

226
00:17:33,570 --> 00:17:38,060
OK, so I have some kind of
silly strap that doesn't do much here.

227
00:17:39,250 --> 00:17:42,820
I just want to acquire it -
rather than leave it sitting around here.

228
00:17:43,400 --> 00:17:46,137
And let's go back to our spec.

229
00:17:50,020 --> 00:17:56,034
Excellent, we still have nothing and that is
simply because I still haven't implemented it.

230
00:17:57,634 --> 00:18:05,890
Now Hand takes cards and we're
just going to initialize it with cards.

231
00:18:07,870 --> 00:18:09,130
I can get rid of that.

232
00:18:11,020 --> 00:18:14,617
And make that cards available.

233
00:18:18,540 --> 00:18:22,160
This should hopefully stop complaining.

234
00:18:23,554 --> 00:18:28,620
No, because it did a zero
failure, so that is the one I want.

235
00:18:28,620 --> 00:18:33,040
Camille ponders ...

236
00:18:33,080 --> 00:18:34,570
Let's have a look.

237
00:18:35,640 --> 00:18:43,165
I'm creating my hand... (sounds of amazement)

238
00:18:43,730 --> 00:18:46,822
My favorite way is also to spell initialize with 's'.

239
00:18:46,820 --> 00:18:49,954
And then I spent 2 minutes
thinking Oh! American spelling.

240
00:18:49,954 --> 00:18:50,940
TS: Yes.

241
00:18:50,940 --> 00:18:53,954
(silence)

242
00:18:54,000 --> 00:18:56,468
CB: Yes, good, slightly more convincing isn't it?

243
00:18:56,468 --> 00:18:58,605
TS: Yes, very good.

244
00:18:59,290 --> 00:19:02,685
CB: I now have some 'thing' and
it has the right number of things.

245
00:19:02,685 --> 00:19:06,700
I don't actually know that
it does parse the cards correctly.

246
00:19:07,250 --> 00:19:11,680
And if the array looks like I want it to look.

247
00:19:11,680 --> 00:19:14,920
so what I can do is...

248
00:19:15,540 --> 00:19:20,514
Because, currently my parser
doesn't care how many cards I'm parsing in

249
00:19:21,120 --> 00:19:28,411
I can do a very quick check so
it returns the right cards as a test.

250
00:19:28,410 --> 00:19:31,017
I can just do a very quick ...

251
00:19:31,051 --> 00:19:37,851
And if my array_of_cards is
just the one, let's say 6 of Diamonds.

252
00:19:38,050 --> 00:19:43,268
Then I go for exact the same test.

253
00:19:43,570 --> 00:19:45,450
And what I want is...

254
00:19:46,080 --> 00:19:48,200
I take my hand, I take the cards in there.

255
00:19:48,680 --> 00:19:54,840
I take the first one and I
want to check the suit is Diamonds

256
00:19:56,200 --> 00:19:59,540
I also want to check that my Pips are equal to six.

257
00:19:59,690 --> 00:20:00,210
TS: OK.

258
00:20:00,620 --> 00:20:03,908
CB: And I reckon we're
going to have a surprising 'thing'

259
00:20:03,908 --> 00:20:07,565
because I haven't cast it to an
integer or anything like that.

260
00:20:10,220 --> 00:20:18,045
Since I want to compare them, it's a lot
easier to look at if they're integers, than strings

261
00:20:18,045 --> 00:20:20,520
Yes, expected an integer and got a string !

262
00:20:21,280 --> 00:20:26,210
What I'm going to do is not really good practice,

263
00:20:26,340 --> 00:20:30,320
but that should please it for now.

264
00:20:30,400 --> 00:20:35,470
So now I can have a 'thing' and
when I put several things in there,

265
00:20:35,620 --> 00:20:39,302
it puts them in a hand with cards, and then I can check

266
00:20:39,314 --> 00:20:41,931
that if I do put a card it seems relatively OK.

267
00:20:42,262 --> 00:20:48,670
If I wanted to be really exhaustive I would go
through and check Spades, check Hearts, check Clubs.

268
00:20:48,680 --> 00:20:51,794
Just to see that that matching is OK.

269
00:20:51,794 --> 00:20:55,737
And that would give me a bit more
certainty about what on Earth I am doing !

270
00:20:55,740 --> 00:20:57,302
TS: Ok.

271
00:20:57,340 --> 00:21:01,211
But that kind of does the thing, that is good enough.

272
00:21:01,250 --> 00:21:04,370
Now I'm going to start focusing on...

273
00:21:05,510 --> 00:21:08,982
If I have those two hand objects and I can look at cards on them.

274
00:21:08,982 --> 00:21:13,051
And I have a nice interface with
my cards, it gives me Pips and Suits

275
00:21:13,074 --> 00:21:14,930
How do I compare them?

276
00:21:15,554 --> 00:21:19,405
This is a step away from
the computer for a second.

277
00:21:19,410 --> 00:21:24,811
TS: Yes, it felt like this
was an administrative thing...

278
00:21:24,820 --> 00:21:29,965
Your warmed up now, you can make two
hands of cards. And now it's back to compare them ?

279
00:21:29,988 --> 00:21:31,908
CB: Yes, that's about it.

280
00:21:34,400 --> 00:21:40,148
The first thing we can do is
have some way of having a hand,

281
00:21:40,148 --> 00:21:45,748
and it tells me 'you have a Flush' or 'you
have a Pair' and that is actually your best thing.

282
00:21:45,740 --> 00:21:50,171
Not just 'you still happen to have a
Pair' because the last thing I want to do is ...

283
00:21:50,170 --> 00:21:54,582
I have a card that has, for example,
3 of a kind which is better than 2 of a kind

284
00:21:54,594 --> 00:22:00,308
which I'm assuming you know,
which isn't very nice (laughter)

285
00:22:00,340 --> 00:22:04,720
TS: I am roughly familiar with the rules of Poker.

286
00:22:04,800 --> 00:22:09,097
CB: I'm just being unnecessarily
verbose, if you get bored you can stop me.

287
00:22:09,120 --> 00:22:11,680
TS: No, no, talk me through it.

288
00:22:11,970 --> 00:22:15,245
CB: If I have 3 of a kind, the last thing
I want to do is for my hand to tell me,

289
00:22:15,257 --> 00:22:20,114
"We have two of a kind, excellent", whereas
the best thing I could do with this is 3 of a kind.

290
00:22:20,120 --> 00:22:24,331
TS: So for any individual hand there
might be several possible classifications

291
00:22:24,330 --> 00:22:29,611
of the cards in it, but we want to use the one that's
most likely to cause this hand to beat another one.

292
00:22:29,620 --> 00:22:36,022
CB: Yes, you want the highest possible
rank of things you can get in Poker.

293
00:22:36,050 --> 00:22:43,394
so if I have 4 fours then I want 4 of a kind,
not 3 of a kind, and definitely not a Pair.

294
00:22:43,417 --> 00:22:47,748
Definitely not a high card.

295
00:22:50,540 --> 00:22:57,714
TS: It sounds like your first line
of interest, is classifying these hands

296
00:22:57,710 --> 00:23:02,434
according to what kind they are.
How were you expecting to approach that?

297
00:23:02,520 --> 00:23:06,220
CB: Essentially I want to look at a
hand and it gives me what the rank is.

298
00:23:06,220 --> 00:23:08,340
so it tells me if it's a straight or thing.

299
00:23:08,970 --> 00:23:13,668
So it feels to me like we're going to
have some kind of rank method on the Hand

300
00:23:13,668 --> 00:23:17,725
that is going to return a "and this
is the thing that you can do with it".

301
00:23:17,720 --> 00:23:20,502
That is the best possible one.

302
00:23:22,970 --> 00:23:25,440
which we can half implement for now.

303
00:23:25,474 --> 00:23:28,354
The first thing I'm going to
do is create a spec for my Hand,

304
00:23:28,377 --> 00:23:31,245
because we're going to start adding stuff to that.

305
00:23:33,530 --> 00:23:38,480
Quick housekeeping. TS: Yes.

306
00:23:38,680 --> 00:23:41,828
CB: And I'm going to be describing my Hand.

307
00:23:42,850 --> 00:23:49,862
And, I want some kind of method - I'll call it 'Rank'.

308
00:23:51,680 --> 00:23:56,868
I have no particular reason to know
whether that's a good idea or not now.

309
00:23:56,910 --> 00:24:02,011
So I'll keep it as it is. And what it does is, it returns...

310
00:24:02,034 --> 00:24:15,330
the best type of hand, from it's own cards.

311
00:24:19,702 --> 00:24:24,114
There is no way I'm going to
implement in just one test, all the rules of Poker.

312
00:24:24,110 --> 00:24:25,245
TS: OK. (laughter)

313
00:24:25,245 --> 00:24:32,410
CB: I'm going to assume that I'm playing in
a simplified world where the only thing is a pair.

314
00:24:32,600 --> 00:24:34,430
Which seems easy.

315
00:24:35,370 --> 00:24:41,405
And I might regret this because maybe
it's not the easiest choice I could have made.

316
00:24:41,400 --> 00:24:45,920
(silence)

317
00:24:45,931 --> 00:24:49,977
I'm not going to put in a context
for now I'm not sure where I'm going.

318
00:24:49,980 --> 00:24:54,491
So, I have a Hand and...

319
00:24:54,502 --> 00:24:57,851
(Camille ponders)

320
00:24:58,090 --> 00:25:03,885
So this is where things get
a bit annoying. What I want is ...

321
00:25:05,382 --> 00:25:13,280
I have some kind of hand around.
And what I want on that hand is ...

322
00:25:14,850 --> 00:25:17,240
For now I'm going to use the HandParser.

323
00:25:17,428 --> 00:25:20,560
Which makes me feel this is
not the right interface for the problem,

324
00:25:20,580 --> 00:25:29,851
if I have to use it in such a way,
but if I have say, 5 of Hearts, 5 of Diamonds.

325
00:25:30,140 --> 00:25:35,200
We're actually going to take a
Pair. And see where it takes us.

326
00:25:35,540 --> 00:25:38,594
7 of Diamonds, 8 of Diamonds.

327
00:25:38,594 --> 00:25:46,800
(Camille ponders)

328
00:25:46,811 --> 00:25:52,980
This should just say "we have a Pair
and by the way that Pair is a Pair of 5s".

329
00:25:53,620 --> 00:25:57,405
For now let's start with 'you have a Pair' in there.

330
00:25:57,417 --> 00:26:00,605
TS: As you said, that might be enough information.

331
00:26:00,620 --> 00:26:04,354
If there's another hand that doesn't have
a Pair in it, you've already determined that.

332
00:26:04,354 --> 00:26:05,554
CB: Yes, that's exactly it.

333
00:26:05,570 --> 00:26:08,970
The first thing you want to
know is do I have a better hand?

334
00:26:09,200 --> 00:26:14,914
and then if your two hands are not
the same rank, then you try calculating it.

335
00:26:15,260 --> 00:26:20,594
My initial reckoning is that it will be
easier to calculate what the highest card is

336
00:26:20,605 --> 00:26:22,754
at the time I'm also establishing the rank.

337
00:26:23,060 --> 00:26:29,165
So for now I want my interface
to just return the type of hand.

338
00:26:29,170 --> 00:26:35,382
But in future, I also want it to say, this is the
type of hand and this is the highest card that counts.

339
00:26:35,530 --> 00:26:38,982
Just in case there's a tie. TS: Alright.

340
00:26:40,910 --> 00:26:45,737
CB: Let's assume that's my hand and I want hand.rank.

341
00:26:47,130 --> 00:26:53,131
So 'expect' hand.rank  to equal, and then...

342
00:26:57,910 --> 00:27:03,920
It turns information about
the winning potential of the hand.

343
00:27:09,200 --> 00:27:11,142
This is a terrible description !

344
00:27:11,140 --> 00:27:14,022
(silence)

345
00:27:14,820 --> 00:27:17,782
I'm just going to let it go, because in a minute,

346
00:27:17,800 --> 00:27:21,542
I will probably change my
mind about what this should look like.

347
00:27:21,540 --> 00:27:26,045
(Camille ponders)

348
00:27:26,050 --> 00:27:30,011
So if I expect the hand equals that...

349
00:27:31,260 --> 00:27:32,540
Not that.

350
00:27:34,590 --> 00:27:42,034
This is failing quite nicely because
I haven't done all my requiring correctly.

351
00:27:42,030 --> 00:27:46,937
(Camille ponders)

352
00:27:47,040 --> 00:27:50,590
I'm doing silly thing with
silly shortcuts here (laughter).

353
00:27:51,800 --> 00:27:54,600
I also don't have my HandParser.

354
00:27:55,910 --> 00:28:00,662
What I don't like about that is
that now I can call this extra class

355
00:28:00,662 --> 00:28:04,285
and I have this extra thing
that has all this logic here.

356
00:28:04,310 --> 00:28:09,005
So rethinking it now I would
probably move that logic around.

357
00:28:09,000 --> 00:28:16,788
And have my hand.new
that handles things like that.

358
00:28:16,810 --> 00:28:28,217
And my hand.new can take a
HandParser as one of it's attributes of the method.

359
00:28:28,770 --> 00:28:32,930
and I can make sure that
the logic of if it's H it's Hearts,

360
00:28:32,970 --> 00:28:36,011
and if it's D it's Diamonds, just goes somewhere else.

361
00:28:36,020 --> 00:28:38,330
I'm not happy about that interface.

362
00:28:43,200 --> 00:28:47,417
Because I don't like stopping in
the middle of a 'thing' #TODO...

363
00:28:48,400 --> 00:28:52,810
This is not a nice interface, not what I wanted to do.

364
00:28:52,845 --> 00:28:55,450
TS: So your queuing up a bit of re-factoring to do ?

365
00:28:56,710 --> 00:29:00,450
CB: Yes, my tests have passed so
I can't afford to just go off on a tangent

366
00:29:00,650 --> 00:29:02,480
and go to fix all the things.

367
00:29:04,410 --> 00:29:07,017
So let's just have a quick...

368
00:29:07,010 --> 00:29:16,937
(silence)

369
00:29:16,940 --> 00:29:22,217
OK, so that's parsing, and that's failing. Cool.

370
00:29:22,217 --> 00:29:27,810
rank returns nil which is pretty much
what you'd expect because it returns nil.

371
00:29:27,900 --> 00:29:32,948
OK, so I've got all my cards,
and how do I want to detect a Pair?

372
00:29:33,370 --> 00:29:39,120
Array of cards - if I want to detect a
Pair, all I care about is the Pips on the cards.

373
00:29:40,720 --> 00:29:46,102
I have all the cards, I can look
at how many Pips there are for each of those cards

374
00:29:46,102 --> 00:29:53,314
and I can count for each possible
Pip value, how many of that Pip I have.

375
00:29:53,314 --> 00:29:53,782
TS: OK.

376
00:29:53,782 --> 00:30:00,680
So if I have say, 55678 here.

377
00:30:01,970 --> 00:30:05,074
There was 2 x 5s, 1 x 6, 1 x7 and 1 x 8

378
00:30:05,074 --> 00:30:09,908
TS: I see so you're counting
them by how many Pips they have.

379
00:30:09,910 --> 00:30:14,365
You want to somehow say
I've got 2 x 5s, I've got 1 x 6 etc.

380
00:30:14,370 --> 00:30:17,165
CB: Yes, I want some kind of Pip counter

381
00:30:17,180 --> 00:30:20,788
that sort of mashes them up in
some structure it can read nicely.

382
00:30:24,650 --> 00:30:30,422
Ideally, if I had a thing like that then I
would have something along the lines of...

383
00:30:31,180 --> 00:30:38,937
I'm going to do that as a hash but I
would expect my result to look a bit like this.

384
00:30:38,970 --> 00:30:41,600
I would like a magical
thing that does that for me.

385
00:30:43,940 --> 00:30:53,462
And once I have that then I can check if I
have any things that so happen to have 2 of the 'thing'.

386
00:30:53,480 --> 00:30:59,542
And if I do then it's a Pair.
Otherwise, it's a highest card.

387
00:30:59,730 --> 00:31:00,910
So that's about it.

388
00:31:02,020 --> 00:31:04,040
I want to implement a thing that does that.

389
00:31:04,850 --> 00:31:06,780
So what does this do ?

390
00:31:09,740 --> 00:31:14,262
I would say it's a 'Pip counter',
but it's not a great word for it.

391
00:31:14,260 --> 00:31:22,068
It's a ... who knows (laughter).

392
00:31:22,170 --> 00:31:25,300
I'm going to call it Pip counter and...

393
00:31:25,300 --> 00:31:29,611
(silence)

394
00:31:29,740 --> 00:31:36,240
This is a silly thing I do, and I may as
well do it on camera, (the world will laugh),

395
00:31:36,340 --> 00:31:40,982
so when I have a terrible name
for a thing, I just put a ##bob.

396
00:31:41,050 --> 00:31:45,100
I was given the clean code
thing when I started programming.

397
00:31:45,100 --> 00:31:48,994
And it has this amazing thing about
how you should not name your methods.

398
00:31:49,005 --> 00:31:53,154
Things like holy hand grenade
for destroy, and silly things like that,

399
00:31:53,154 --> 00:31:59,680
so I always put a bob when I have
bad naming thing, and I usually have fun

400
00:31:59,720 --> 00:32:02,971
figuring out the interface
when I'm finishing off an object.

401
00:32:03,000 --> 00:32:06,468
So let's say it's pip_count, for now.

402
00:32:06,480 --> 00:32:08,057
TS: OK.

403
00:32:08,510 --> 00:32:10,297
So what does my pip_count do,

404
00:32:10,605 --> 00:32:12,422
Hey, we can write a test !

405
00:32:14,170 --> 00:32:17,428
That is going to do that for me.

406
00:32:17,428 --> 00:32:19,474
So if I have a pip_count...

407
00:32:22,850 --> 00:32:27,074
now whether that should be
in the public interface is debatable.

408
00:32:27,080 --> 00:32:28,388
TS: Right.

409
00:32:28,420 --> 00:32:33,131
CB: But I'm just going to keep it there
for now. As I don't yet know where we're going.

410
00:32:33,140 --> 00:32:43,074
If I have a pip_count and I am parsing exactly
that hand then this is exactly the thing I want.

411
00:32:46,020 --> 00:32:49,257
I'm going to stop returning that.

412
00:32:51,220 --> 00:32:52,171
There we go...

413
00:32:52,170 --> 00:32:56,891
That should fail quite loudly, let's run this test.

414
00:32:57,440 --> 00:32:58,800
There we go...

415
00:32:59,000 --> 00:33:00,450
Yes, we've got nil, excellent.

416
00:33:00,740 --> 00:33:04,422
So how are we going
implement this.  I have my cards

417
00:33:04,510 --> 00:33:08,342
And for each of those cards I have Pips.

418
00:33:08,480 --> 00:33:11,920
I can just...

419
00:33:13,080 --> 00:33:15,954
Suddenly here I have an array of numbers,

420
00:33:15,950 --> 00:33:23,714
(Camille ponders)

421
00:33:23,710 --> 00:33:31,314
For a thing like this I need my documentation,
because I don't remember everything.

422
00:33:32,720 --> 00:33:36,902
There is a Ruby collect on Ruby array.

423
00:33:38,540 --> 00:33:44,434
This is dash...
It's a documentation tool that I like to use.

424
00:33:45,050 --> 00:33:48,370
TS: So you have all of the Ruby API documentation.

425
00:33:49,710 --> 00:33:55,680
CB: This is just a quick reminder for me
because I reckon this has already been solved.

426
00:33:57,120 --> 00:34:00,750
But maybe not, who knows.

427
00:34:00,850 --> 00:34:07,085
Essentially I want to loop over my array
and count the number of incidences of each 'thing'.

428
00:34:07,310 --> 00:34:15,860
Which actually I could do in any number of ways.

429
00:34:16,450 --> 00:34:19,668
I can't remember off the top of my
head how I would do that in pure Ruby.

430
00:34:19,660 --> 00:34:24,480
Any suggestions welcome,
before I re-invent the wheel!

431
00:34:24,510 --> 00:34:28,662
TS: I don't know that there is a
method in the array that does that.

432
00:34:28,680 --> 00:34:33,028
the only thing that comes to mind is a
group_by method, which won't do what you want

433
00:34:33,028 --> 00:34:39,840
but will do a related thing, which is group
together all of the 5s, all of the 6s and all of the 7s,

434
00:34:39,880 --> 00:34:41,850
but that doesn't give you what you want.

435
00:34:41,850 --> 00:34:44,170
CB: Does that give me an array of arrays then ?

436
00:34:44,170 --> 00:34:47,588
TS: It gives you a hash.

437
00:34:47,800 --> 00:34:52,651
The key in the hash would be 5
and the elements in the array would be

438
00:34:52,662 --> 00:34:54,845
all of the 5 Pip cards that it had found.

439
00:34:54,857 --> 00:34:57,474
and then the key would be 6
and the value would be...

440
00:34:57,480 --> 00:35:02,194
CB: I could map on that quite easily.

441
00:35:02,220 --> 00:35:05,960
Let's do a group_by and see how that works.

442
00:35:10,845 --> 00:35:12,400
So group_by...

443
00:35:12,400 --> 00:35:18,834
(Camille ponders)

444
00:35:18,830 --> 00:35:20,160
TS: Does it not exist?

445
00:35:20,200 --> 00:35:21,790
CB: It's not in Array.

446
00:35:21,820 --> 00:35:24,297
TS: It will be in Enumerable I expect.

447
00:35:24,290 --> 00:35:27,714
(Camille ponders)

448
00:35:27,862 --> 00:35:29,942
CB: Let's just search...

449
00:35:29,970 --> 00:35:36,262
No it's not letting me search.
I'm in the wrong scope for it.

450
00:35:39,510 --> 00:35:42,697
Enumerable group_by... no, no no.

451
00:35:43,325 --> 00:35:46,628
It's just giving me Ansible stuff.

452
00:35:46,628 --> 00:35:48,365
TS: Maybe that was a bad idea.

453
00:35:48,491 --> 00:35:49,880
CB: All of the documentation.

454
00:35:51,910 --> 00:35:53,770
TS: If you can implement it yourself.

455
00:35:53,770 --> 00:35:58,982
CB: I shall implement it in like a minute.
That should be fine, I've got all my Pips.

456
00:35:58,990 --> 00:36:03,280
What I'm wondering is, do I want just 52617181

457
00:36:03,310 --> 00:36:09,565
or do I want all of the keys of all the
possible things and then how many cards I have.

458
00:36:09,600 --> 00:36:12,020
But I don't think it makes a lot of difference.

459
00:36:13,340 --> 00:36:15,542
TS: It depends what you want.

460
00:36:16,994 --> 00:36:20,102
CB: I want to use group_by, I was very excited by this.

461
00:36:20,674 --> 00:36:24,251
So ... here we go...

462
00:36:24,680 --> 00:36:27,060
OK, yes fair enough.

463
00:36:27,820 --> 00:36:32,040
TS: That's not quite what you said, but it's close.

464
00:36:32,170 --> 00:36:36,388
In that you would get the right keys but
for the values, instead of being how many

465
00:36:36,420 --> 00:36:39,211
cards there were it would be an array of those cards.

466
00:36:39,230 --> 00:36:45,657
CB: I'm just wondering... inaudible

467
00:36:45,714 --> 00:36:51,017
This is not particularly pretty.
It probably has a better way of doing it.

468
00:36:51,020 --> 00:36:53,565
it might be the default for that.

469
00:36:54,514 --> 00:36:58,080
Let's run the tests and see what that returns.

470
00:36:59,340 --> 00:37:02,190
Yes, that gives me arrays.

471
00:37:02,200 --> 00:37:05,150
Now we can just have a 'thing'.

472
00:37:06,130 --> 00:37:14,514
This is my grouped_cards,
and then I can say grouped_cards

473
00:37:15,000 --> 00:37:19,165
and then for each of my things, I can say...

474
00:37:19,160 --> 00:37:23,177
(typing)

475
00:37:25,170 --> 00:37:26,822
TS: Ah, OK,

476
00:37:27,220 --> 00:37:31,782
So you are turning each of those
arrays into a number by counting it.

477
00:37:31,800 --> 00:37:34,708
CB: Yes so let's see how that works.

478
00:37:34,720 --> 00:37:42,422
It's not very elegant but it should
make the test pass... so that's close enough.

479
00:37:43,462 --> 00:37:46,594
We still have a failure
because we're not ranking stuff.

480
00:37:50,220 --> 00:37:55,177
We are in the magical world
where only 2 rankings exists.

481
00:37:55,188 --> 00:37:58,194
There is Pair and high card.

482
00:37:58,190 --> 00:37:59,645
TS: Right.

483
00:38:00,880 --> 00:38:06,891
If these are all my grouped
cards, and if I have 'anywhere',

484
00:38:09,250 --> 00:38:18,948
in the number of group cards I have a 2,
then it's a win, and otherwise it's not.

485
00:38:20,200 --> 00:38:25,405
This is my minimal viable code,
it's something along the lines of...

486
00:38:26,850 --> 00:38:29,520
so this should return...

487
00:38:29,720 --> 00:38:37,462
I have a rank of type Pair,
otherwise I have a rank of type highest.

488
00:38:37,474 --> 00:38:40,182
I'm not quite sure about line 10 now.

489
00:38:42,510 --> 00:38:45,257
So I have all the values, I need to find...

490
00:38:45,250 --> 00:38:48,937
(Camille types)

491
00:38:53,110 --> 00:38:55,520
I think this is where tests help me.

492
00:38:55,554 --> 00:38:58,280
TS: Yes (laughter).

493
00:39:00,200 --> 00:39:05,954
CB: Undefined local variable
grouped_cards. I've done something silly.

494
00:39:06,130 --> 00:39:10,525
Of course... this is called Pip count.

495
00:39:11,485 --> 00:39:13,451
Right, let's try that again.

496
00:39:14,680 --> 00:39:17,640
So it does something,
and for the sake of completeness

497
00:39:17,680 --> 00:39:26,148
I also want to start using better names now.

498
00:39:29,010 --> 00:39:31,782
Here I have a hand with just a Pair.

499
00:39:32,020 --> 00:39:36,160
and here I will have
a hand with nothing in it,

500
00:39:36,370 --> 00:39:39,790
which I will call 'highest', as a type.

501
00:39:42,850 --> 00:39:48,434
So if I have a highest hand,
I essentially want it to be pretty much this,

502
00:39:48,740 --> 00:39:55,257
but I'm just going to put something in
there, which as you see actually is a straight.

503
00:39:55,420 --> 00:39:57,794
This shouldn't be ranking as highest, but ...

504
00:39:57,810 --> 00:39:59,500
TS: Does that matter at this point?

505
00:40:00,030 --> 00:40:02,640
CB: No I'm quite happy about that.

506
00:40:03,910 --> 00:40:10,594
It's fine, it's just setting the scope
of the problem to solving a very small 'thing'.

507
00:40:10,620 --> 00:40:15,017
TS: Yes, you said before, you're
imagining a smaller version of Poker

508
00:40:15,017 --> 00:40:18,400
that only has 5 cards right?

509
00:40:18,450 --> 00:40:22,100
CB: Yes, a simpler and more boring world.

510
00:40:24,480 --> 00:40:25,910
And now we have no failures.

511
00:40:25,931 --> 00:40:31,782
I have a way of getting arrays
and then suddenly I have 'one pair',

512
00:40:31,782 --> 00:40:38,537
'one thing with a pair' and
'another with nothing' and it does rankings.

513
00:40:38,740 --> 00:40:42,857
So now we have some kind of
way, in an oversimplified game of Poker

514
00:40:42,970 --> 00:40:46,480
to say I have a Pair and I have a highest.

515
00:40:49,770 --> 00:40:56,285
So what I would really like to do
is start implementing a few more things.

516
00:40:56,570 --> 00:41:01,074
So I think the super easy way to
go is we're not going to do just Pairs

517
00:41:01,170 --> 00:41:05,588
but we're going to find 3 of a kind, and 4 of
a kind and make sure the right thing comes out,

518
00:41:05,600 --> 00:41:12,628
and by that I mean, if I create a 3 of a kind,

519
00:41:13,291 --> 00:41:15,805
let's call it a three_of_a_kind_hand.

520
00:41:19,220 --> 00:41:23,170
So if we have a three_of_a_kind_hand, it's going to be...

521
00:41:25,770 --> 00:41:29,840
I need 5 of Hearts, Diamonds and Spades.

522
00:41:30,280 --> 00:41:34,891
and that at the moment it's
going to return a Pair, I presume.

523
00:41:34,970 --> 00:41:40,228
but actually we want it to
return 3 of a kind, so this, should be...

524
00:41:42,594 --> 00:41:44,925
If I have a rank there should be a type three.

525
00:41:45,000 --> 00:41:48,011
So if I start running this file now....

526
00:41:49,200 --> 00:41:51,050
Not like this,

527
00:41:51,220 --> 00:41:52,770
and not like this either.

528
00:41:52,800 --> 00:41:56,040
I think I'm doing something wrong... there we go.

529
00:41:56,310 --> 00:42:03,314
I do have a failure because it is assuming
that I have type :highest and not type :three.

530
00:42:03,510 --> 00:42:08,057
because I am matching for
exactly 2, and obviously it's 3.

531
00:42:08,110 --> 00:42:12,285
This might make my life a bit
easier because I don't need to make sure

532
00:42:12,310 --> 00:42:17,040
that I'm doing things in the right
order, for that specific comparison.

533
00:42:17,080 --> 00:42:22,045
I reckon it does matter for other things
but, let's get to that when we get to that.

534
00:42:24,890 --> 00:42:27,600
I'm starting to write some pretty terrible code now.

535
00:42:29,210 --> 00:42:32,331
Shameless green is...

536
00:42:34,480 --> 00:42:39,290
so if I have 3 then it becomes :three_of_a_kind

537
00:42:40,830 --> 00:42:51,817
and if I have 4 then
suddenly it becomes :four_of_a_kind.

538
00:42:54,480 --> 00:42:56,468
But that is pretty bad.

539
00:42:58,800 --> 00:43:03,710
I'm just going to check that my tests do pass nicely.

540
00:43:03,940 --> 00:43:09,851
And as they don't... it is :three_of_a_kind
and this is 3, so this should now pass.

541
00:43:10,590 --> 00:43:13,130
This now knows what a 3 of a kind is.

542
00:43:14,030 --> 00:43:19,954
I could write a quick 4 of a kind
that we haven't covered for the future

543
00:43:19,950 --> 00:43:21,794
where we're going to be adding more things.

544
00:43:21,817 --> 00:43:25,260
I want to make sure that I'm not breaking things.

545
00:43:29,000 --> 00:43:33,970
let's just create some test
data with a four_of_a_kind_hand.

546
00:43:34,370 --> 00:43:42,765
This is terribly verbose, but we should
have here 5 of Clubs and that should pass.

547
00:43:45,340 --> 00:43:46,960
This is working out fine.

548
00:43:47,060 --> 00:43:55,074
This however, looks pretty terrible.
So there must be a smarter way of doing this.

549
00:43:56,680 --> 00:44:02,777
I could jump in right there and try to do some
kind of look at the Pip count and the values

550
00:44:02,920 --> 00:44:06,090
and then if it's 2 it's a Pair,
3 of a kind, 4 four of a kind.

551
00:44:06,280 --> 00:44:11,634
What I'm thinking now is that it
matters about things along the lines of,

552
00:44:14,240 --> 00:44:19,634
 for example I'm going to take a
problematic example of the full house,

553
00:44:19,668 --> 00:44:22,891
where at the moment my code
would give me back a 3 of a kind.

554
00:44:23,080 --> 00:44:27,051
I definitely don't want it to
say that. I want it to be a full house.

555
00:44:27,110 --> 00:44:34,617
What I want to avoid now is making
an abstraction on this logic of Pip counts

556
00:44:34,880 --> 00:44:41,870
when actually, it's not clear to
me as to where that should live.

557
00:44:42,000 --> 00:44:45,782
What I would like to try doing
now is try implementing full house

558
00:44:45,805 --> 00:44:50,285
which has 3 of a kind, 2 of a kind in the same hand.

559
00:44:50,370 --> 00:44:57,051
Get that working and then at that point hopefully,
I will know how I want to look at those card counts.

560
00:44:57,080 --> 00:44:57,680
TS: Ok.

561
00:44:57,720 --> 00:44:58,970
CB: So I can extract that.

562
00:44:58,970 --> 00:45:05,531
I'm going to leave this horror in a tiny bit longer
until I know with more certainty where I'm heading.

563
00:45:05,640 --> 00:45:10,125
TS: So even though you're unhappy with your
code you're going to hold off from refactoring it

564
00:45:10,140 --> 00:45:15,051
because you're not confident
that your solution to it is complete yet.

565
00:45:15,074 --> 00:45:19,577
You don't want to introduce
an abstraction that won't fit.

566
00:45:19,580 --> 00:45:23,017
You're worried that if you extract
it at this point, then you will end up 

567
00:45:23,028 --> 00:45:25,620
with something that won't support full house.

568
00:45:25,680 --> 00:45:26,660
CB: Yes, absolutely.

569
00:45:27,140 --> 00:45:33,771
My initial premature abstraction is I just
map the number of pip count values to a type.

570
00:45:34,080 --> 00:45:38,230
and I can sense that that's
going to fail when I get to full house.

571
00:45:39,120 --> 00:45:44,342
I want to see how I will implement full house,
which is going to create more cruft in this code.

572
00:45:44,380 --> 00:45:47,805
but I think it would help
me finding the right abstraction.

573
00:45:47,850 --> 00:45:50,731
I think there is such a
thing as premature abstraction,

574
00:45:50,742 --> 00:45:54,020
I find myself guilty of it a lot of times.

575
00:45:59,930 --> 00:46:04,510
CB: I'm going to create a quick
test for my full house hand.

576
00:46:04,940 --> 00:46:14,600
and it has 5 of Hearts, 5 of Diamonds,
5 of Spades, 6 of Clubs and 6 of Hearts.

577
00:46:14,970 --> 00:46:18,790
So we have inaudible 6s, and here we go.

578
00:46:19,080 --> 00:46:25,462
This is going to fail nicely, because we haven't
implemented that yet and it's detecting a Pair.

579
00:46:26,600 --> 00:46:29,480
Which is not what we want.

580
00:46:30,925 --> 00:46:35,702
So a couple of things to start
with, the first thing is, OK, so ...

581
00:46:37,170 --> 00:46:38,860
Right now with my code I'm saying

582
00:46:38,880 --> 00:46:43,170
if there's 2 let's go there, if there's
three let's go there, if there's four let's go there.

583
00:46:43,540 --> 00:46:46,110
This feels counter intuitive because in Poker,

584
00:46:46,110 --> 00:46:51,622
what I want to check is do I
have a royal flush, or a straight flush etc.

585
00:46:51,620 --> 00:46:57,302
There is an order in which you would check because
you would start (in your head) with the highest hand

586
00:46:57,570 --> 00:47:03,520
and if you don't have the best possible thing,
you would lower the expectations of your hand

587
00:47:03,565 --> 00:47:06,502
and try to get as far down as you can.

588
00:47:07,340 --> 00:47:12,777
The way I have written this code is wrong in
terms of how a human would try to solve the problem.

589
00:47:12,820 --> 00:47:15,000
I can also see it as part of a full house.

590
00:47:15,150 --> 00:47:22,731
so if we do a bit of reshuffling,
and by that I mean check things.

591
00:47:23,110 --> 00:47:31,668
(This is terrible code by the way), but check things
in a way so I start with the nicest possible outcome.

592
00:47:31,880 --> 00:47:37,050
And as I go along I get less
desirable outcomes from my hand.

593
00:47:37,280 --> 00:47:41,560
then that would have given
me a 3 of a kind, as a full house.

594
00:47:41,931 --> 00:47:46,365
Which is less wrong but still pretty wrong !

595
00:47:46,400 --> 00:47:53,794
TS: But what you've done there is you've built
into your code because you were explaining it...

596
00:47:53,870 --> 00:47:56,240
then you were saying there is this implied thing.

597
00:47:56,510 --> 00:48:03,097
But if you're explaining what a 3 of a kind is
there's this implication, well it's not a 4 of a kind

598
00:48:03,220 --> 00:48:06,274
a Pair is not a 4 of a kind,nor a 3 of a kind, 

599
00:48:06,297 --> 00:48:10,354
and so it seems now your
code more accurately reflects that.

600
00:48:10,370 --> 00:48:15,190
Whereas before it was
just working what by accident?

601
00:48:15,420 --> 00:48:21,691
CB: It was working only in the case
where a specific hand only has for example,

602
00:48:21,720 --> 00:48:23,405
only 3 of a kind and nothing else.

603
00:48:23,417 --> 00:48:26,620
TS: I see, it's the full house
that's going to bring this out.

604
00:48:26,770 --> 00:48:31,988
CB: The full house is bringing this out and I think
that other hands are going to bring this out anyway

605
00:48:32,110 --> 00:48:35,770
because if you have a flush that
also happens to have a Pair in there

606
00:48:35,770 --> 00:48:39,200
you want to check flush first,
it doesn't matter if you have a Pair.

607
00:48:42,080 --> 00:48:46,850
In the case of a full house,
terrible code would go along the lines of

608
00:48:46,940 --> 00:48:51,760
if I happen to have 3 in my pip
count values then two things can happen.

609
00:48:51,820 --> 00:48:59,542
Either I have also in my pip count a value that
is 2, so I have a 3 and a 2 and therefore a full house.

610
00:48:59,650 --> 00:49:04,628
Otherwise, the best thing I do have is 3 of a kind.

611
00:49:05,850 --> 00:49:11,640
So that would make my test
pass, but it's beginning to look terrible

612
00:49:11,740 --> 00:49:15,600
First let's check that I didn't get this one wrong.

613
00:49:15,714 --> 00:49:19,590
So now that passes nicely and this looks awful !

614
00:49:26,600 --> 00:49:30,440
I believe there's a problem in how I'm testing those.

615
00:49:32,920 --> 00:49:34,660
TS: What's the problem?

616
00:49:34,800 --> 00:49:39,120
CB: I'm checking that an
array includes a certain number.

617
00:49:39,250 --> 00:49:45,771
and what I want to know is does my array,
in the case of 4 of a kind it includes 4, for sure.

618
00:49:45,931 --> 00:49:47,600
and I don't need to look at the rest.

619
00:49:47,600 --> 00:49:53,120
But in the others there are a
number of things that we want to look at.

620
00:49:57,080 --> 00:49:59,990
What I want to try doing is...

621
00:50:03,620 --> 00:50:07,394
TS: It sounds like you're
switching into refactoring. CB: Yes.

622
00:50:07,640 --> 00:50:09,931
TS: Why have you chosen this point?

623
00:50:09,950 --> 00:50:14,514
Because you said there are some other
hands that you haven't implemented yet.

624
00:50:14,600 --> 00:50:18,674
Do you feel that you have come to a point
now where you have sufficient confidence

625
00:50:18,685 --> 00:50:21,710
in your implementation
so far to start refactoring it ?

626
00:50:21,710 --> 00:50:25,220
CB: I think I have sufficient
confidence to start thinking about it.

627
00:50:25,220 --> 00:50:29,382
But I might hit a mental
block in a few seconds (laughter).

628
00:50:29,382 --> 00:50:32,388
I want to see how the
other hands are going to work out.

629
00:50:32,388 --> 00:50:34,380
TS: I see, alright.

630
00:50:38,080 --> 00:50:42,171
CB: All my other hands are
along the lines of straight and flush,

631
00:50:42,171 --> 00:50:45,371
and we can assume that's already out of the way.

632
00:50:45,370 --> 00:50:48,491
By the time the code will hit
those and now we're counting the cards

633
00:50:48,491 --> 00:50:52,171
we've already excluded a couple of those things.

634
00:50:54,680 --> 00:50:56,430
I still don't like this.

635
00:50:56,480 --> 00:51:02,902
I don't like entering this type of code because
if 4 of a kind is better than a flush, for example.

636
00:51:02,925 --> 00:51:05,360
So I want to look at those things later.

637
00:51:06,220 --> 00:51:11,577
I am starting to imagine
that I am creating as I go along,

638
00:51:11,570 --> 00:51:13,737
this is a list of all the things you can do in Poker.

639
00:51:13,782 --> 00:51:18,605
and this is how well they rank in the world of poker.

640
00:51:18,710 --> 00:51:25,085
The highest and the lowest ranking
 And a straight flush is as high as it gets.

641
00:51:31,310 --> 00:51:41,325
What I am creating in my head is some kind of
thing along the lines of a thing called Poker ranks

642
00:51:41,620 --> 00:51:44,640
which is something along the lines of...

643
00:51:45,680 --> 00:51:49,700
The most desirable 'thing' is a straight flush.

644
00:51:50,680 --> 00:51:52,030
Let's give that a rating of...

645
00:51:52,040 --> 00:51:54,731
I don't know how many different
types of cards there are in Poker. 

646
00:51:54,730 --> 00:51:57,554
Let's say 10, but I think that's wrong. 

647
00:51:57,550 --> 00:52:05,165
and then we have a 4 of a kind and that
would be a rating 9, and then so on and so forth.

648
00:52:06,220 --> 00:52:11,645
And then each of those can have a
method that checks the card is what it is.

649
00:52:11,710 --> 00:52:16,891
But that would re-use quite a lot
of code and I'm not happy about that either.

650
00:52:16,891 --> 00:52:19,131
So, let's not do that.

651
00:52:19,130 --> 00:52:23,862
TS: OK, so you're talking about
having some sort of scoring system.

652
00:52:24,110 --> 00:52:26,940
What was your motivation for wanting to score them?

653
00:52:30,170 --> 00:52:33,680
CB: I'm motivated to have some defined order

654
00:52:33,680 --> 00:52:39,200
which looks for the best
and worst possible outcomes

655
00:52:39,340 --> 00:52:43,700
other than it checks for them
in a different order in the code.

656
00:52:44,050 --> 00:52:46,020
TS: So you want to make that more explicit

657
00:52:46,020 --> 00:52:50,091
rather than writing a method that
looks like you could do it in any order.

658
00:52:50,091 --> 00:52:51,177
CB: Yes.

659
00:53:03,450 --> 00:53:07,820
I'm going to start doing a tiny bit
of extract method, for my own sanity.

660
00:53:18,310 --> 00:53:20,502
Just so I can see where things are going.

661
00:53:20,514 --> 00:53:22,020
This is all going to be private.

662
00:53:22,940 --> 00:53:27,320
I'm going to quickly go through those...

663
00:53:27,320 --> 00:53:32,594
(silence)

664
00:53:32,605 --> 00:53:33,942
That was a bit odd...

665
00:53:35,897 --> 00:53:36,537
There we go.

666
00:53:36,600 --> 00:53:44,068
Now we are assuming that we have those
magical methods: has_four, has_three, has_two.

667
00:53:44,170 --> 00:53:50,217
And checks whether there is a Pair
or a 3 or a combination of 4 in there.

668
00:53:50,400 --> 00:53:52,720
Which doesn't mean it's a three of a kind.

669
00:53:52,770 --> 00:53:57,290
it means there happens to be
3 cards of the same kind in there.

670
00:53:57,420 --> 00:54:03,337
So if we have has_four, then this
is still include(4) and in much the same way

671
00:54:03,337 --> 00:54:10,034
let's assume I have has_three and has_two
and that's going to be pretty much what you think it is.

672
00:54:10,340 --> 00:54:13,337
and that's a bit verbose but
I'm not so bothered about that 

673
00:54:13,371 --> 00:54:16,710
because it's hidden away in private
methods and I can get round to it later

674
00:54:17,020 --> 00:54:20,430
if I feel it is necessary.

675
00:54:20,570 --> 00:54:22,980
This feels more readable to me.

676
00:54:23,300 --> 00:54:29,200
It feels like the 4 of a kind
type has the has_four check.

677
00:54:29,200 --> 00:54:32,740
And for the full house, this needs
to be true and this needs to be true.

678
00:54:32,880 --> 00:54:37,588
3 of a kind check this only needs
to be true. Pair has_pair needs to be true.

679
00:54:37,620 --> 00:54:43,965
So suddenly I have all my cards. All
of the types of things I can do in Poker.

680
00:54:44,050 --> 00:54:49,714
and I have a combination of methods that can tell me exactly why that would be.

681
00:54:50,140 --> 00:54:52,080
So the easy way of doing it would be:

682
00:54:54,330 --> 00:54:58,377
If has_four then that. This is still verbose.

683
00:54:59,390 --> 00:55:02,857
I start refactoring and then usually
I add a lot of stuff, make it very explicit

684
00:55:02,857 --> 00:55:05,337
then start compressing later.

685
00:55:06,000 --> 00:55:08,765
So elsif full_house.

686
00:55:10,110 --> 00:55:13,360
Then :type => :full_house.

687
00:55:13,420 --> 00:55:21,394
Elsif has_three then... 3 of
a kind, elsif has_pair, then Pair.

688
00:55:21,680 --> 00:55:24,274
I'm going to have to implement full house quickly.

689
00:55:27,020 --> 00:55:31,760
Missing a def here. Here we go, it's has_three and...

690
00:55:33,680 --> 00:55:35,710
Maybe not multiply these (laughter).

691
00:55:37,050 --> 00:55:40,457
I don't know what that does
actually, if you multiply two methods.

692
00:55:40,502 --> 00:55:42,600
It complains loudly but I don't know how.

693
00:55:43,000 --> 00:55:46,060
This feels more readable.

694
00:55:48,050 --> 00:55:52,570
That's kind of what I would like to check.

695
00:55:52,571 --> 00:55:54,490
No it absolutely doesn't.

696
00:55:55,820 --> 00:55:59,910
That's because question marks are nice

697
00:55:59,965 --> 00:56:04,045
(Camille ponders)

698
00:56:04,091 --> 00:56:07,020
It's maybe not the day to invent new methods in Ruby.

699
00:56:07,020 --> 00:56:17,931
Undefined local variable or method
has_pair simply because I called it has_two.

700
00:56:18,170 --> 00:56:19,390
Let's keep it that way.

701
00:56:22,630 --> 00:56:24,068
Go...

702
00:56:24,170 --> 00:56:29,005
And now we're back in action, this is more readable.

703
00:56:29,050 --> 00:56:30,680
We're checking things in order.

704
00:56:30,937 --> 00:56:34,628
There is a better way of doing that
but let's wait until I have a couple more hands

705
00:56:34,640 --> 00:56:36,845
and I can drive out something a bit better.

706
00:56:36,845 --> 00:56:40,491
I had an idea with a ranking
but I'm not quite happy with it yet.

707
00:56:40,502 --> 00:56:41,360
TS: Ok.

708
00:56:41,360 --> 00:56:45,577
CB: So, what are our next hands?

709
00:56:45,620 --> 00:56:48,510
Do you have a favorite
hand that you want to implement next ?

710
00:56:48,510 --> 00:56:51,817
TS: Well I don't want to prejudice
you. What's your favorite hand ?

711
00:56:51,850 --> 00:56:52,880
CB: A straight flush.

712
00:56:52,880 --> 00:56:54,250
TS: Then go with that.

713
00:56:57,800 --> 00:56:59,270
CB: We'll have a straight flush.

714
00:56:59,280 --> 00:57:03,930
TS: Seems a bit optimistic as you
don't have straights or flushes yet

715
00:57:04,150 --> 00:57:05,280
but if you want to yes.

716
00:57:05,280 --> 00:57:09,120
I think that's going to
drive out the changes quickly.

717
00:57:09,280 --> 00:57:12,010
But yes you're right, may be a bit optimistic.

718
00:57:14,685 --> 00:57:18,420
In much the same way that full
house is a has_two and has_three situation.

719
00:57:18,422 --> 00:57:21,740
a straight flush is a straight and is a flush.

720
00:57:21,748 --> 00:57:24,777
TS: Is straight or flush easier to do?

721
00:57:27,220 --> 00:57:28,754
I reckon flush.

722
00:57:28,765 --> 00:57:30,170
TS: Why don't we do flush then.

723
00:57:30,170 --> 00:57:31,245
CB: Alright.

724
00:57:32,880 --> 00:57:36,960
Let's quickly create a flush hand.

725
00:57:39,680 --> 00:57:44,754
The test definition is right at
the top. This file is getting verbose.

726
00:57:46,080 --> 00:57:50,034
TS: It's a good job you've got that
hand parser otherwise it would be even worse.

727
00:57:51,450 --> 00:57:55,565
CB: I don't want to imagine what it would
look like if we had to do doubles for this.

728
00:57:57,760 --> 00:58:02,170
So flush, let's go for all Hearts.

729
00:58:02,170 --> 00:58:06,822
(Camille types)

730
00:58:06,880 --> 00:58:12,540
I'm going to give myself a very disappointing hand.

731
00:58:12,910 --> 00:58:16,980
If you had that hand in Poker, you would say WHY !!!

732
00:58:18,850 --> 00:58:23,417
So that should give me a flush and
I'm going to check that it's definitely failing.

733
00:58:24,020 --> 00:58:25,400
TS: What does it think it is ?

734
00:58:27,480 --> 00:58:30,400
CB:  Oh! That's an interesting one. So...

735
00:58:32,480 --> 00:58:33,800
We have a new problem now.

736
00:58:33,805 --> 00:58:34,822
TS: What's gone wrong?

737
00:58:35,690 --> 00:58:42,617
CB: Well, 10, it's got two numbers.
So it's not parsing it properly.

738
00:58:42,610 --> 00:58:47,760
I'm taking the first character only and in
the second I'm taking the second character only.

739
00:58:48,845 --> 00:58:50,620
There's two ways we can solve this...

740
00:58:50,620 --> 00:58:55,954
I represent 10 in another way, like zero
or something silly. I don't want to do that,

741
00:58:55,950 --> 00:59:00,845
We can just very quickly change the
parser so that it doesn't take the zero, and the one,

742
00:59:00,857 --> 00:59:02,940
and it takes something a bit smarter.

743
00:59:02,940 --> 00:59:07,314
TS: The error that's coming out there is
that because you did the fetch on the hash ?

744
00:59:07,310 --> 00:59:11,062
CB: Yes, if I hadn't done a fetch on
a hash, and I had put a default value.

745
00:59:11,080 --> 00:59:16,422
Who knows what would happen
in that parser #TODO: fail loudly.

746
00:59:16,434 --> 00:59:18,034
TS: Yes, it's already paying off.

747
00:59:18,040 --> 00:59:22,731
CB: It is failing loudly, so OK...

748
00:59:22,740 --> 00:59:28,651
So here we're taking only the first
character, and here only the last character.

749
00:59:28,680 --> 00:59:32,674
What I want to do is take the last one.

750
00:59:33,211 --> 00:59:39,405
So how do I get the last char out
of a string? I can do something along the lines of:

751
00:59:39,400 --> 00:59:40,365
(Camille thinking)

752
00:59:44,020 --> 00:59:45,460
Oh! I don't even know.

753
00:59:45,510 --> 00:59:49,097
Now how I would do that, (and I know that's incorrect),

754
00:59:53,360 --> 00:59:55,450
would be something along those lines.

755
00:59:56,340 --> 00:59:58,310
There must be a better way though.

756
00:59:58,320 --> 00:59:59,108
(Camille types)

757
01:00:02,910 --> 01:00:08,137
I know there's a way of doing it with minus
ones but I don't want to do that right now.

758
01:00:08,480 --> 01:00:10,140
I'm feeling particularly lazy.

759
01:00:11,170 --> 01:00:14,857
Here, I want to go up to cards.

760
01:00:15,230 --> 01:00:17,710
String length minus one, take that as a string.

761
01:00:18,740 --> 01:00:23,325
I want to run the spec quickly
because I reckon I've got this wrong.

762
01:00:24,200 --> 01:00:27,714
Wrong number of arguments,
what have we done now?

763
01:00:27,710 --> 01:00:32,228
(silence)

764
01:00:35,000 --> 01:00:37,554
This is still fetching a string.

765
01:00:38,000 --> 01:00:45,017
I will make sure I've got a test
that does the 10 might as well...

766
01:00:46,857 --> 01:00:49,920
Let's just run this file now.

767
01:00:50,000 --> 01:00:56,262
Now we have a hand parser...
line 20...length, so that's not right.

768
01:00:56,420 --> 01:01:01,005
So hand parser on
line 20 calling length on...

769
01:01:01,000 --> 01:01:03,771
(Camille ponders)

770
01:01:06,220 --> 01:01:08,380
It's an array, no.

771
01:01:10,760 --> 01:01:13,931
No it's called card string,
I would suspect that it's a string.

772
01:01:14,000 --> 01:01:18,800
So wrong number of arguments one for
zero why does it think it has an argument?

773
01:01:19,120 --> 01:01:22,297
because parentheses...

774
01:01:25,400 --> 01:01:29,420
Ah, extract method, this is terrible.

775
01:01:30,148 --> 01:01:33,668
So last number of...

776
01:01:36,310 --> 01:01:41,028
This is terrible, I should just do it with minus ones.

777
01:01:41,080 --> 01:01:42,970
TS: How does the minus one thing work ?

778
01:01:42,970 --> 01:01:46,840
CB: I believe it puts you
in an imaginary space between

779
01:01:47,050 --> 01:01:50,630
the start and end of your
array, but I might be wrong.

780
01:01:50,720 --> 01:02:00,800
So what I will do is... it's the end of the
card number index, that's where I want to be.

781
01:02:01,360 --> 01:02:06,902
This should be something along those lines, and
here I want to go up to the end of card number index

782
01:02:09,017 --> 01:02:12,468
(silence)

783
01:02:12,514 --> 01:02:17,108
And here I want to go from
zero to the end card index minus one

784
01:02:17,140 --> 01:02:19,880
No, I want to go to the end of card index

785
01:02:20,560 --> 01:02:24,400
and here I want to go to this.

786
01:02:26,050 --> 01:02:27,780
So this should still fail.

787
01:02:27,782 --> 01:02:30,068
I reckon I've got something else wrong.

788
01:02:30,891 --> 01:02:32,388
TS: That's not very optimistic.

789
01:02:32,420 --> 01:02:34,068
CB: We have key not found.

790
01:02:34,060 --> 01:02:36,948
(Camille ponders)

791
01:02:37,880 --> 01:02:41,360
Fetch is failing again. That's relatively good news.

792
01:02:42,050 --> 01:02:46,914
So my card string of this is not working out.

793
01:02:46,970 --> 01:02:58,480
So this is nil because end of card
number plus one is not quite what I want it to be.

794
01:02:59,480 --> 01:03:01,737
Why is old code popping up ?

795
01:03:04,430 --> 01:03:08,140
So now that it has been
determined that I am terrible at array indexing

796
01:03:09,570 --> 01:03:12,150
Let's get back to our tests.

797
01:03:12,510 --> 01:03:15,040
It's lucky that I spotted that when I did.

798
01:03:15,040 --> 01:03:17,954
(silence)

799
01:03:19,770 --> 01:03:23,400
This is the failure which led us to another failure.

800
01:03:23,850 --> 01:03:25,400
But this is good.

801
01:03:27,080 --> 01:03:29,000
Now, where is our flush ?

802
01:03:29,490 --> 01:03:35,480
This is where I don't know Poker
quite as we'll as I would like to

803
01:03:36,080 --> 01:03:41,405
So elsif flush, type flush.

804
01:03:43,510 --> 01:03:46,260
Where does flush belong on this sort of thing?

805
01:03:47,020 --> 01:03:52,925
It is above full house. Yes.

806
01:03:53,710 --> 01:03:55,220
TS: It doesn't actually matter.

807
01:03:55,220 --> 01:04:00,845
CB: No, that's right but it would
matter to someone who plays Poker perhaps.

808
01:04:00,840 --> 01:04:06,914
TS: At the moment you don't have any code
that compares two hands to find out which one is better.

809
01:04:06,914 --> 01:04:09,577
as long as they are correctly classified that's OK.

810
01:04:09,577 --> 01:04:15,211
CB: Yes, so let's implement a very quick flush.

811
01:04:18,217 --> 01:04:23,954
So what my flush is... in much the same way as
I'm doing do I have two cards of the same thing.

812
01:04:23,950 --> 01:04:28,251
I'm saying can you look at all my
suits and tell me if they're all the same.

813
01:04:28,251 --> 01:04:31,154
and that's about it.

814
01:04:31,490 --> 01:04:34,662
Much in the same way I'm doing
the pip count, I probably want something 

815
01:04:34,674 --> 01:04:40,910
along the lines of a suit
count, that does this but with suits.

816
01:04:41,000 --> 01:04:51,020
And here I'm going to do the dupe
flag which means I've copy/pasted this.

817
01:04:51,620 --> 01:04:54,940
Maybe there's a better abstraction to use here.

818
01:04:55,250 --> 01:04:57,394
So here I'm grouping it by suits.

819
01:04:59,650 --> 01:05:03,680
I'm going to write a quick test to
make sure this is doing what I think it is

820
01:05:04,740 --> 01:05:11,520
because I'm not confident enough
to reckon that it's all going to be fine.

821
01:05:11,600 --> 01:05:17,691
So in this hand I have my Pair hand which I am using.

822
01:05:17,760 --> 01:05:21,760
It has 4 Diamonds and 1 Heart.

823
01:05:22,740 --> 01:05:28,480
So I should have Heart 1 and Diamonds 4.

824
01:05:29,200 --> 01:05:33,405
It shouldn't be the pip
count, it should be the suit count

825
01:05:33,405 --> 01:05:36,740
I believe that's what I called it. Yes.

826
01:05:39,770 --> 01:05:42,777
Now I have two failures.
This is the expected failure.

827
01:05:43,020 --> 01:05:44,650
Expected method suits.

828
01:05:46,200 --> 01:05:54,651
Not the interface I was programming
to. So this should be suit and not suits.

829
01:05:55,760 --> 01:05:56,948
TS: OK.

830
01:05:56,970 --> 01:06:02,948
CB: And now it seems to be working and
we're back on our problem, which is permitting flush.

831
01:06:03,000 --> 01:06:06,502
But now if I have some kind of flush count

832
01:06:06,525 --> 01:06:12,971
Oh no, suit count, then
suddenly my life is quite a lot easier.

833
01:06:12,970 --> 01:06:20,914
Because, if I can type... (laughter).

834
01:06:20,937 --> 01:06:24,948
I can implement this... let's see ...

835
01:06:25,005 --> 01:06:26,000
Now I have a flush.

836
01:06:26,000 --> 01:06:32,194
(Camille types)

837
01:06:33,828 --> 01:06:35,970
So very quickly a straight.

838
01:06:38,310 --> 01:06:44,925
This should be more interesting and more
complicated. It's not something we've done so far.

839
01:06:45,370 --> 01:06:50,571
So I have 5 of Hearts, 6 of Hearts 7,
of Hearts, 8 of Hearts and a 9 of Diamonds,

840
01:06:50,571 --> 01:06:54,430
because it's not a straight flush.

841
01:06:54,650 --> 01:06:57,140
Let's check if this is failing nicely. Yes.

842
01:06:57,840 --> 01:07:02,308
And let's put our straight somewhere in there.

843
01:07:08,605 --> 01:07:09,890
There we go.

844
01:07:09,920 --> 01:07:13,588
And if flush and straight
in much the same way...

845
01:07:15,680 --> 01:07:19,040
Let's have a look and see if those...

846
01:07:19,680 --> 01:07:22,410
What I care about is the straight and not the suits.

847
01:07:22,540 --> 01:07:28,342
I'm going to look at the cards and their face
values and I need to make sure they are consecutive.

848
01:07:28,350 --> 01:07:29,680
TS: Ok.

849
01:07:30,250 --> 01:07:31,800
CB: How will I do that?

850
01:07:32,170 --> 01:07:33,120
TS: Good question.

851
01:07:34,110 --> 01:07:37,570
CB: The first thing I would
probably want to do is extract out

852
01:07:37,600 --> 01:07:40,937
of the cards array just the array of values.

853
01:07:40,940 --> 01:07:42,811
Because this is what I care about.

854
01:07:46,000 --> 01:07:47,790
Let's see, where are our cards ?

855
01:07:48,650 --> 01:07:50,120
What I want is this:

856
01:07:50,910 --> 01:07:56,200
Now I have some kind of array
that is 3567, something like that.

857
01:07:56,450 --> 01:08:01,748
In all likelihood it could be
47892 and be completely unsorted.

858
01:08:05,600 --> 01:08:16,788
So let's just sort that really
quickly... And we have sorted card values

859
01:08:17,000 --> 01:08:19,570
I don't know why I'm doing it in a destructive way.

860
01:08:22,020 --> 01:08:25,850
I just like bangs, but that's a bit silly.

861
01:08:26,440 --> 01:08:32,000
So I have sorted card values.
I want to know if they are consecutive.

862
01:08:35,370 --> 01:08:40,560
Is there something that does that
in ruby or do I need to re-implement it?

863
01:08:40,560 --> 01:08:41,480
TS: I'm not sure.

864
01:08:41,500 --> 01:08:46,331
CB: OK, so what I care about if I'm
trying to determine if things are consecutive.

865
01:08:47,280 --> 01:08:50,920
Let's assume we live in
a world where Aces don't exist.

866
01:08:51,370 --> 01:08:51,870
TS: OK.

867
01:08:53,970 --> 01:08:57,062
CB: Because Aces... no I don't want to go there.

868
01:08:57,080 --> 01:09:02,860
So if I have 12345 as
in Ace 2345, that's a straight.

869
01:09:03,250 --> 01:09:07,220
but I can also count Ace as the high card,
so after King.

870
01:09:08,170 --> 01:09:15,474
My initial idea was I could just have a bunch
of numbers and all I need to care about is...

871
01:09:15,720 --> 01:09:18,110
I look at the face
value on there and on there,

872
01:09:18,280 --> 01:09:23,942
they are sorted, so if the difference between
this Pair and this Pair and this Pair is always one,

873
01:09:24,220 --> 01:09:25,820
then I've won and it's a straight.

874
01:09:26,720 --> 01:09:30,160
But I can't really do that if
I'm doing Aces because

875
01:09:30,280 --> 01:09:34,470
my Ace would potentially sit on
one side or other of the array.

876
01:09:38,110 --> 01:09:41,000
Let's assume Aces are just ones for now.

877
01:09:41,910 --> 01:09:46,708
And then I'm going to make sure that I write a test

878
01:09:46,720 --> 01:10:00,765
which is "it works with a straight with high
Ace", and it works with a straight with low ace.

879
01:10:01,000 --> 01:10:04,102
TS: Which one of those is the special case ?

880
01:10:04,170 --> 01:10:07,080
CB: It depends how I classify an Ace.

881
01:10:07,800 --> 01:10:12,651
If Ace is a one in the way I write
it then low Ace isn't my special case.

882
01:10:12,800 --> 01:10:18,617
But if I write Ace as an A for example,
which then puts it in the category of King Queen....

883
01:10:18,970 --> 01:10:22,450
which I would assign a higher point value.

884
01:10:22,750 --> 01:10:29,977
So then 10 is 10, Jack is 11,
Queen is 12, King is 13, then ace is both one and 14.

885
01:10:29,977 --> 01:10:31,337
TS: OK.

886
01:10:33,131 --> 01:10:35,640
CB: Which might be how I implement it.

887
01:10:36,090 --> 01:10:41,337
If you see an Ace in there...
look at the array and count it as a one,

888
01:10:41,348 --> 01:10:46,331
and then look at the array and
count it as 14, and see where it takes you.

889
01:10:47,820 --> 01:10:53,325
You can't really have a straight that takes
both anyway so that should sort us out nicely.

890
01:10:53,380 --> 01:10:57,840
We might be looking later at
what is my high card, on a hand,

891
01:10:57,880 --> 01:11:04,960
then that's also going to come into
play, this both 1 and 14 type of thing.

892
01:11:05,050 --> 01:11:12,114
Let's assume that we are taking Aces
as... (do I have any examples here?) No.

893
01:11:12,310 --> 01:11:17,691
So I'm going to write Aces with an A because
of just personal preference. No particular reason.

894
01:11:17,702 --> 01:11:23,820
My special case is going to be it
works with straight with a low Ace

895
01:11:32,620 --> 01:11:36,540
I've just realized something
that I had completely forgotten about.

896
01:11:38,080 --> 01:11:40,285
Right now if we look at the hand parser. 

897
01:11:40,285 --> 01:11:48,354
I've chosen cards that
translate in a lovely way to integers,

898
01:11:48,354 --> 01:11:50,510
 but if I do something like that....

899
01:11:52,880 --> 01:11:59,805
Let's say Queen of Diamonds.
Let's say 10 is 10 Jack is 11, Queen is 12.

900
01:12:00,140 --> 01:12:02,080
I actually would want this to happen.

901
01:12:04,570 --> 01:12:06,540
Number 12, got zero, excellent.

902
01:12:08,050 --> 01:12:13,245
Let's go back into my hand parser, this is
going to be another one of those special cases.

903
01:12:15,710 --> 01:12:19,530
So let's say Pips for heads.

904
01:12:22,110 --> 01:12:23,310
TS: What does that mean?

905
01:12:23,310 --> 01:12:32,582
CB: This is me being terrible at English
for heads I mean Jack, Queen, King, Ace.

906
01:12:32,740 --> 01:12:42,982
Let's say, if you get a Q card, then
I'm going to assign it the value 12.

907
01:12:46,510 --> 01:12:52,468
Let's start with a Jack, and that's an
11 and then I have Queen and that's 12,

908
01:12:53,200 --> 01:12:58,411
and that's a King and that's 13, and the Ace is 14.

909
01:13:04,540 --> 01:13:07,810
So this is number of Pips.

910
01:13:08,340 --> 01:13:13,840
I'm going to put it into a different
variable because this is getting too crowded.

911
01:13:15,110 --> 01:13:18,045
Number of Pips equals this for now.

912
01:13:18,210 --> 01:13:22,605
Just to check I haven't done
something stupid. There we go.

913
01:13:22,840 --> 01:13:27,080
So expected 12, got zero, perfect, so now

914
01:13:27,080 --> 01:13:35,360
what I want is "check if the beginning
of that string is one of those special cases,

915
01:13:35,394 --> 01:13:38,120
otherwise you should just go with face value.

916
01:13:39,600 --> 01:13:46,137
So I can have something like
Pips for heads dot fetch.

917
01:13:51,000 --> 01:13:55,897
This is what I said at the
beginning, before I specified suit.

918
01:13:56,220 --> 01:14:01,360
This is my Pips string. And this is what it looks like.

919
01:14:01,794 --> 01:14:03,782
So what I'm going to do is...

920
01:14:05,200 --> 01:14:08,274
I take Pips for heads and I fetch my Pips string.

921
01:14:08,270 --> 01:14:13,040
(silence)

922
01:14:13,200 --> 01:14:19,828
So, if it's in there we can go forward
and if it's not then I want it to fail gracefully

923
01:14:20,170 --> 01:14:21,080
and do this...

924
01:14:21,110 --> 01:14:27,382
Now, the issue with that is, for example
if someone goes along the lines of

925
01:14:27,480 --> 01:14:31,177
entering a queen with a
capital Q, then that would not work.

926
01:14:31,700 --> 01:14:38,320
Because it will try to translate it into an
integer and that would not work very nicely.

927
01:14:40,780 --> 01:14:46,777
If I want to do something foolproof
I would put something along the lines of...

928
01:14:46,940 --> 01:14:50,450
"and by the way can you check
that the pip string only has digits in it",

929
01:14:50,600 --> 01:14:58,834
before I cast it to an integer. Which will save
me the pain of how do I handle Queens a bit later on.

930
01:14:59,080 --> 01:15:00,680
TS: Are you worried about that ?

931
01:15:00,680 --> 01:15:02,840
CB: No. (laughter)

932
01:15:03,600 --> 01:15:06,840
If I was shipping this then yes, but no.

933
01:15:11,450 --> 01:15:15,540
Assumes correct
capitalization,

934
01:15:15,760 --> 01:15:20,600
correct letters all kinds of assumptions.

935
01:15:22,310 --> 01:15:23,080
and that's fine.

936
01:15:23,080 --> 01:15:24,940
I'm making that compromise for now

937
01:15:24,940 --> 01:15:29,510
because I don't think that's part
of the problem that I'm most interested in.

938
01:15:30,740 --> 01:15:32,960
So now we have a 'thing' and it parses queens

939
01:15:32,960 --> 01:15:36,580
12 of Diamonds and that's all working out fine

940
01:15:36,740 --> 01:15:39,240
Now, I've got my card values.

941
01:15:39,250 --> 01:15:42,140
Let's go back to our hand spec and see where

942
01:15:42,220 --> 01:15:43,020
that leaves us.

943
01:15:43,370 --> 01:15:46,330
TS:  Is your priority now
to implement ordinary straights

944
01:15:46,370 --> 01:15:51,080
or are you going straight for
the one that has an Ace in it ?

945
01:15:51,200 --> 01:15:54,650
CB: I'm going with an ordinary straight.

946
01:15:54,860 --> 01:15:57,730
So my straight hand in here just has....

947
01:15:57,820 --> 01:16:01,050
56789, which is quite reasonable.

948
01:16:02,220 --> 01:16:04,370
I've accidentally broken things because

949
01:16:04,820 --> 01:16:08,660
my straight is broken and
tells me that everything is fine.

950
01:16:08,710 --> 01:16:10,550
but now other tests are failing.

951
01:16:11,540 --> 01:16:17,820
inaudible or irrelevant.

952
01:16:18,280 --> 01:16:22,500
This is a more sensible place to be in.

953
01:16:22,820 --> 01:16:29,090
I have sorted card values
and I want to look at each of the things

954
01:16:29,250 --> 01:16:30,940
They are in a sorted order and I'm

955
01:16:30,940 --> 01:16:33,800
going to calculate the
difference between all of them

956
01:16:33,800 --> 01:16:37,710
If at the end I am in an array of only ones.

957
01:16:38,820 --> 01:16:40,170
I will be quite happy.

958
01:16:40,250 --> 01:16:40,960
TS: I see.

959
01:16:41,020 --> 01:16:45,170
CB: And if it's not then.... I'm not happy.

960
01:16:45,310 --> 01:16:46,620
So far so good.

961
01:16:51,000 --> 01:16:54,400
I'm going to go for a
naive implementation of this now

962
01:16:54,400 --> 01:16:58,530
because I don't
quite know where I'm going yet.

963
01:16:58,810 --> 01:17:00,840
I look at my card values.

964
01:17:00,930 --> 01:17:03,250
Actually that's not what I want to do.

965
01:17:03,480 --> 01:17:05,280
I want to use each_with_index

966
01:17:05,400 --> 01:17:08,800
because I want to know where I am in that array.

967
01:17:08,970 --> 01:17:11,490
I have my value and my index

968
01:17:11,530 --> 01:17:13,810
and I am looking at
my sorted card values

969
01:17:13,820 --> 01:17:15,680
and what I want is....

970
01:17:18,740 --> 01:17:20,040
so I have my card in sorted_card_values

971
01:17:20,370 --> 01:17:24,340
and I want to
compare it to the next card value

972
01:17:25,570 --> 01:17:27,680
So I want to compare those two values.

973
01:17:30,820 --> 01:17:32,600
and I only want to go....

974
01:17:33,620 --> 01:17:35,920
this is going to throw a very...

975
01:17:35,940 --> 01:17:38,320
reached the end of the array situation.

976
01:17:38,420 --> 01:17:40,080
which is not where I want to be.

977
01:17:48,400 --> 01:17:52,160
This is silly, I always have 5 cards, it's a hand

978
01:17:52,200 --> 01:17:55,920
so I'm going to put a magic number in there.

979
01:17:56,000 --> 01:17:56,680
I'm sorry.

980
01:17:56,740 --> 01:17:57,760
TS: No, no.

981
01:18:02,680 --> 01:18:05,850
This is the kind of thing where
going to production

982
01:18:05,850 --> 01:18:10,520
you have a thing that defines what 5 is somewhere

983
01:18:10,620 --> 01:18:12,290
So magic number 4...

984
01:18:17,250 --> 01:18:21,330
OK always 5 cards per hand

985
01:18:22,680 --> 01:18:24,790
It is reasonable for me to say,

986
01:18:24,860 --> 01:18:26,750
and by the way do this 4 times.

987
01:18:33,720 --> 01:18:37,450
I need to start with an
assumption that's just wrong

988
01:18:37,470 --> 01:18:40,820
and then I have some kind of integer.

989
01:18:40,820 --> 01:18:42,120
and then....

990
01:18:42,200 --> 01:18:44,420
there's got to be a better way of doing this,

991
01:18:44,420 --> 01:18:46,800
but this is the first thing that comes to mind.

992
01:18:47,080 --> 01:18:49,110
So I'm looking at my sorted card value

993
01:18:49,110 --> 01:18:52,080
and also at my other sorted card value.

994
01:18:54,080 --> 01:18:54,710
This is it.

995
01:18:56,620 --> 01:18:58,710
Let's try something like...

996
01:18:59,330 --> 01:19:04,150
this, the zero index, and

997
01:19:05,400 --> 01:19:06,000
TS: I see.

998
01:19:06,420 --> 01:19:09,180
So these two things I want to compare.

999
01:19:09,280 --> 01:19:11,160
Just get rid of that.

1000
01:19:15,280 --> 01:19:18,470
I want the absolute
difference between the two.

1001
01:19:18,500 --> 01:19:19,350
They are sorted.

1002
01:19:26,080 --> 01:19:26,800
What I want is...

1003
01:19:34,710 --> 01:19:36,300
So the first naive thing is...

1004
01:19:40,250 --> 01:19:41,690
actually the result is...

1005
01:19:43,820 --> 01:19:48,220
old result and

1006
01:19:49,220 --> 01:19:52,190
This is equals to one, so now

1007
01:19:54,960 --> 01:19:56,840
This will have to go somewhere else

1008
01:19:56,840 --> 01:19:58,400
because it's getting verbose.

1009
01:19:58,420 --> 01:20:02,540
What this chuck of code
is doing there is saying...

1010
01:20:07,220 --> 01:20:10,220
difference between cards.

1011
01:20:11,880 --> 01:20:15,140
And different Pips on a card.

1012
01:20:23,290 --> 01:20:24,040
Dislike.

1013
01:20:27,080 --> 01:20:28,970
TS: Yes, it's getting the value of that...

1014
01:20:29,400 --> 01:20:31,220
CB: Yes, I absolutely don't like this.

1015
01:20:31,940 --> 01:20:37,850
For now use a variable before I do something silly and unnecessary.

1016
01:20:40,000 --> 01:20:41,740
This should be the loop.

1017
01:20:43,200 --> 01:20:44,600
Let's get rid of that.

1018
01:20:45,050 --> 01:20:46,910
A slightly misguided abstraction.

1019
01:20:48,400 --> 01:20:51,360
If my difference_between_pips is one,

1020
01:20:52,450 --> 01:20:53,520
then I continue.

1021
01:20:53,740 --> 01:20:56,270
Actually I don't like how I'm doing this

1022
01:20:56,680 --> 01:20:58,170
inaudible

1023
01:21:00,510 --> 01:21:01,980
difference is always one.

1024
01:21:06,880 --> 01:21:09,120
So what I want to do is say:

1025
01:21:09,340 --> 01:21:12,380
difference of one is true to start with

1026
01:21:12,510 --> 01:21:14,670
and the second I get a difference that is not

1027
01:21:15,040 --> 01:21:17,160
one between the cards, I exit out of the loop

1028
01:21:17,160 --> 01:21:18,400
and get out of there.

1029
01:21:18,880 --> 01:21:19,940
So I start with true

1030
01:21:20,250 --> 01:21:21,650
and while it's true

1031
01:21:25,400 --> 01:21:28,490
And my index is below 4

1032
01:21:28,710 --> 01:21:30,170
or sorted_card_values.count

1033
01:21:41,170 --> 01:21:42,870
Magic number 4 that's fine.

1034
01:21:43,680 --> 01:21:46,370
While difference_always_one we do that.

1035
01:21:48,650 --> 01:21:50,620
So if difference_between_pips is that

1036
01:21:50,620 --> 01:21:52,310
and difference_always_1 is...

1037
01:21:55,250 --> 01:21:58,250
and the new difference_between_pips is one.

1038
01:21:59,940 --> 01:22:01,320
This we no longer need.

1039
01:22:02,310 --> 01:22:03,640
Those we no longer need.

1040
01:22:04,110 --> 01:22:07,680
This is called 'i' because I don't
want to rename all the variables.

1041
01:22:09,450 --> 01:22:11,020
I need to close my loops.

1042
01:22:12,370 --> 01:22:15,070
And now what I want to do is....

1043
01:22:17,880 --> 01:22:20,680
maybe initialize that,
that seems like a good idea.

1044
01:22:24,110 --> 01:22:26,260
I start at index zero

1045
01:22:26,480 --> 01:22:28,750
I'm assuming that
it is going to be a straight.

1046
01:22:28,770 --> 01:22:31,780
and then I continue until
something proves me wrong.

1047
01:22:31,800 --> 01:22:34,560
so either I'm done with my calculation

1048
01:22:37,080 --> 01:22:38,360
or that's failed.

1049
01:22:40,050 --> 01:22:42,340
So if it's not equal to one it should be false.

1050
01:22:42,480 --> 01:22:44,480
and then exit and it's all quite nice.

1051
01:22:45,050 --> 01:22:47,000
So now, test time.

1052
01:22:55,820 --> 01:22:58,250
And now the computer fails (laughter).

1053
01:22:58,510 --> 01:23:00,510
TS: It looks like it's got stuck in a loop

1054
01:23:01,880 --> 01:23:03,970
CB: Maybe because I have an infinite loop.

1055
01:23:05,800 --> 01:23:08,880
I think I haven't incremented
the index, there we go

1056
01:23:15,250 --> 01:23:17,560
Every time, just failing.

1057
01:23:17,600 --> 01:23:20,960
This is now still failing

1058
01:23:21,720 --> 01:23:23,210
but this is OK.

1059
01:23:23,970 --> 01:23:25,140
Still the same failure.

1060
01:23:25,970 --> 01:23:27,350
So different straight.

1061
01:23:27,680 --> 01:23:29,880
TS: When that loop finishes, how do you know

1062
01:23:30,200 --> 01:23:32,820
whether or not it was a straight?

1063
01:23:35,560 --> 01:23:36,360
Ah, OK.

1064
01:23:37,370 --> 01:23:38,860
CB: I'm missing a return value

1065
01:23:42,020 --> 01:23:44,780
By the time we get there, I want, if it's a straight

1066
01:23:44,880 --> 01:23:47,110
to exit because of this failing.

1067
01:23:47,800 --> 01:23:49,800
and then it should return the result.

1068
01:23:50,940 --> 01:23:52,020
Which is still wrong.

1069
01:23:52,710 --> 01:23:53,820
OK, so let's have a look.

1070
01:23:56,040 --> 01:23:58,660
So I start an index here and as I go along

1071
01:23:58,880 --> 01:24:02,150
my difference is....

1072
01:24:02,290 --> 01:24:04,650
have I sorted them....yes.

1073
01:24:05,170 --> 01:24:07,590
I would do something naughty now

1074
01:24:12,510 --> 01:24:15,260
print the thing out so I know

1075
01:24:15,270 --> 01:24:16,480
where I'm heading.

1076
01:24:16,540 --> 01:24:19,740
I've got 56789 which seems 'straightish'

1077
01:24:20,370 --> 01:24:22,160
Now let's walk through this.

1078
01:24:22,220 --> 01:24:24,480
So difference_always_1 is true.

1079
01:24:24,940 --> 01:24:28,150
While this is true,
the difference between Pips is

1080
01:24:28,910 --> 01:24:29,770
this minus this

1081
01:24:30,110 --> 01:24:31,110
this should be one

1082
01:24:31,200 --> 01:24:33,480
difference_always_1, this is

1083
01:24:34,110 --> 01:24:34,910
equals to one

1084
01:24:39,250 --> 01:24:41,190
Yet, this returns as false.

1085
01:24:47,370 --> 01:24:49,650
I'm going to run one test

1086
01:24:51,050 --> 01:24:52,960
that one 5679

1087
01:24:53,460 --> 01:24:55,280
I'm going to shell out a few things.

1088
01:24:56,340 --> 01:24:58,530
Because I don't know what's going on.

1089
01:24:58,620 --> 01:25:00,370
TS: It looked like it passed there.

1090
01:25:01,000 --> 01:25:04,280
CB: Yes, this is why I'm a bit confused.

1091
01:25:04,340 --> 01:25:06,280
TS: Is it a different test that's failing ?

1092
01:25:06,280 --> 01:25:07,000
CB: Good point.

1093
01:25:07,020 --> 01:25:10,920
Maybe one of my cases is actually a straight.

1094
01:25:14,650 --> 01:25:16,360
Let's get rid of those.

1095
01:25:17,250 --> 01:25:18,970
I'm going to run this entire file

1096
01:25:19,710 --> 01:25:20,910
and where is my failure?

1097
01:25:22,880 --> 01:25:25,050
Should be a highest and it got a straight.

1098
01:25:26,850 --> 01:25:30,510
Oh yes, one of my test cases is a straight

1099
01:25:31,650 --> 01:25:37,310
I'm feeling really clever
now because...

1100
01:25:37,310 --> 01:25:41,310
and it's not a flush so it's not
going to cause me sorrow at any point.

1101
01:25:43,540 --> 01:25:44,390
Yes, it's all fine.

1102
01:25:44,400 --> 01:25:44,970
TS: Great.

1103
01:25:49,200 --> 01:25:54,590
I have an Ace which is a 14
but it's also a 1 when I want it to be

1104
01:25:58,400 --> 01:26:02,760
So straight hand low Ace,
still straight, same result.

1105
01:26:08,710 --> 01:26:10,950
If we do this, and we have a hand parser.

1106
01:26:13,820 --> 01:26:15,600
Actually, no we don't want to do that.

1107
01:26:17,140 --> 01:26:19,400
We have an Ace now, we don't want a one.

1108
01:26:21,880 --> 01:26:24,020
So we have 2345 and A.

1109
01:26:25,200 --> 01:26:25,640
TS: Ok,

1110
01:26:29,050 --> 01:26:30,310
The order doesn't matter

1111
01:26:30,310 --> 01:26:33,520
CB: The order shouldn't matter
because I'm sorting them anyway.

1112
01:26:33,520 --> 01:26:35,030
TS: So that's going to show up as

1113
01:26:35,030 --> 01:26:37,140
just being a high card hand.
CB: Correct.

1114
01:26:37,140 --> 01:26:40,370
This is showing up as a highest,
and I want it to be a straight.

1115
01:26:40,880 --> 01:26:42,980
Let's go in there and implement that.

1116
01:26:45,420 --> 01:26:48,350
This is a method that takes sorted card values

1117
01:26:48,680 --> 01:26:50,880
then it can work out if it's a straight or not.

1118
01:26:51,000 --> 01:26:53,390
Now if I have an Ace in my hand,

1119
01:26:54,000 --> 01:26:58,480
I want it to work out,
is this a straight if it behaves like a 14 ?

1120
01:26:58,480 --> 01:27:00,880
and is this a straight if it behaves like a one ?

1121
01:27:05,350 --> 01:27:09,560
If this fails, if I treat my Ace
as a 14, then just do again with a one.

1122
01:27:12,400 --> 01:27:14,730
let's extract that method out.

1123
01:27:16,970 --> 01:27:19,200
and this takes an array of cards

1124
01:27:19,200 --> 01:27:21,300
and determines if they are consecutive.

1125
01:27:22,400 --> 01:27:23,880
So, consecutive cards

1126
01:27:36,370 --> 01:27:39,520
This says my cards are consecutive.

1127
01:27:39,620 --> 01:27:41,710
I don't like the fact that it's living here.

1128
01:27:43,880 --> 01:27:45,360
This is just odd.

1129
01:27:48,450 --> 01:27:55,220
If I had more time I would want to move this to a helper somewhere.

1130
01:27:55,710 --> 01:27:57,600
This is a utility type function.

1131
01:27:58,820 --> 01:28:01,160
which has no business being here.

1132
01:28:01,190 --> 01:28:03,160
TS: It doesn't have to be an instance method?

1133
01:28:06,280 --> 01:28:08,250
CB: it's got nothing to do with the hand.

1134
01:28:08,250 --> 01:28:10,510
The concept of numbers being consecutive

1135
01:28:11,480 --> 01:28:13,620
The hand needs it in order to rank itself.

1136
01:28:13,620 --> 01:28:17,240
but the actual
implementation of it does not live here.

1137
01:28:17,400 --> 01:28:18,800
TS: It could be any numbers?

1138
01:28:18,850 --> 01:28:22,770
CB: Absolutely, it could
be just some random thing,

1139
01:28:23,020 --> 01:28:25,820
That takes an array and
determines whether they are

1140
01:28:25,850 --> 01:28:27,480
in some sort of nice order.

1141
01:28:27,480 --> 01:28:27,900
TS: OK.

1142
01:28:31,510 --> 01:28:34,080
I'm just going to check that it is still

1143
01:28:37,880 --> 01:28:39,090
behaving nicely.

1144
01:28:48,110 --> 01:28:51,440
In the case where sorted card values include

1145
01:28:51,850 --> 01:28:54,960
the value 14, which is the Ace, I also want to

1146
01:28:56,110 --> 01:29:00,420
change that array and do
the same thing with the one.

1147
01:29:01,110 --> 01:29:02,770
and then check if it's a straight.

1148
01:29:03,540 --> 01:29:07,280
So let's say sorted card values.

1149
01:29:13,620 --> 01:29:17,060
I'm going to do
something naive, if it includes 14

1150
01:29:26,650 --> 01:29:31,930
This is where I want to know
what my Array lets me do.

1151
01:29:37,340 --> 01:29:39,690
No that's drop a certain number of things.

1152
01:29:39,740 --> 01:29:43,020
I want to delete a thing from an array.

1153
01:29:43,310 --> 01:29:47,970
that is not the array documentation

1154
01:29:50,080 --> 01:29:51,200
I do this all the time.

1155
01:29:51,220 --> 01:29:54,280
I have a bad memory,

1156
01:29:54,280 --> 01:29:56,610
when it comes to
remembering all the things.

1157
01:29:56,880 --> 01:29:58,830
TS: it's probably not a good idea to try

1158
01:29:58,830 --> 01:30:00,440
to memorize them anyway.

1159
01:30:00,540 --> 01:30:03,710
CB: Once you start programming
in more than three languages,

1160
01:30:03,710 --> 01:30:05,280
it becomes a little difficult.

1161
01:30:08,360 --> 01:30:12,000
TS: So you're going to
delete all of the 14s from the array ?

1162
01:30:12,170 --> 01:30:16,340
CB: Yes, and I need to know
how many 14s I'm deleting

1163
01:30:17,000 --> 01:30:19,140
In order to add that exact
number of 1s on the other side

1164
01:30:19,140 --> 01:30:23,960
otherwise I might end up with something
crazy such as an array with only three cards

1165
01:30:26,280 --> 01:30:28,960
which will explode because it is
expecting a certain number of things in there;

1166
01:30:29,110 --> 01:30:30,910
remember my magic number in there?

1167
01:30:30,910 --> 01:30:32,250
It would not be a good idea.

1168
01:30:41,770 --> 01:30:42,320
delete 14.

1169
01:30:46,000 --> 01:30:48,820
According to the Ruby
documentation this is deleted.

1170
01:30:56,340 --> 01:31:00,970
This gives me back all that it's deleted.

1171
01:31:02,050 --> 01:31:03,910
TS: It returns the last deleted item?

1172
01:31:04,640 --> 01:31:07,210
CB:  Yes, but it doesn't
tell me how many, interesting.

1173
01:31:11,820 --> 01:31:15,080
I want to know how many 14s I have,

1174
01:31:16,600 --> 01:31:20,750
So I want to count the
number of things that match.

1175
01:31:25,970 --> 01:31:26,860
How do I do that?

1176
01:31:31,600 --> 01:31:34,400
My implementation is this.

1177
01:31:38,650 --> 01:31:40,560
This can go somewhere else,

1178
01:31:41,020 --> 01:31:43,290
and be called what it actually is

1179
01:31:46,540 --> 01:31:48,770
and if my number of Aces is bigger than one.

1180
01:31:49,200 --> 01:31:51,480
then I want to delete all the Aces.

1181
01:31:53,560 --> 01:31:57,910
and add two sorted card values, ones,

1182
01:31:58,080 --> 01:32:00,970
but I want to do that
exactly the number of aces times.

1183
01:32:04,220 --> 01:32:07,000
I could do it in a better way by concatenating

1184
01:32:07,480 --> 01:32:11,520
two sorted card values in an array of exactly

1185
01:32:14,200 --> 01:32:15,540
the number of aces as ones.

1186
01:32:16,000 --> 01:32:18,460
but let's leave that for now

1187
01:32:18,460 --> 01:32:21,880
and let's check if things have gone wrong.

1188
01:32:22,200 --> 01:32:23,000
They have.

1189
01:32:25,480 --> 01:32:27,870
This is terrible parenthesis use.

1190
01:32:30,450 --> 01:32:34,340
because it turns out
blocks don't take round brackets.

1191
01:32:39,310 --> 01:32:43,370
It's not working but it's not failing any more.

1192
01:32:45,680 --> 01:32:48,370
TS: Is it because your
number of Aces is equal to one

1193
01:32:48,940 --> 01:32:50,050
not greater than one ?

1194
01:32:54,420 --> 01:32:56,840
CB: Yes, and there is also the fact that

1195
01:33:00,650 --> 01:33:02,540
I think it's going to fail another way.

1196
01:33:04,420 --> 01:33:05,600
And let me explain why,

1197
01:33:07,570 --> 01:33:12,460
I think what I just wrote
is going to fail in the case of

1198
01:33:13,110 --> 01:33:17,570
high ace, because of how I've implemented it.

1199
01:33:18,770 --> 01:33:21,620
To prove my point I'm going to write

1200
01:33:24,770 --> 01:33:26,680
There we go straight_hand_high_ace.

1201
01:33:31,850 --> 01:33:35,400
What I mean by that... and do that.

1202
01:33:36,540 --> 01:33:38,800
Undefined method `add` for array.
Interesting.

1203
01:33:39,200 --> 01:33:40,540
TS: There are two failures,

1204
01:33:40,540 --> 01:33:41,910
on both of those Ace tests.

1205
01:33:42,220 --> 01:33:43,110
CB: Correct.

1206
01:33:44,050 --> 01:33:47,650
So this is you can't add
and I expect it's insert. Yes.

1207
01:33:54,480 --> 01:33:57,660
So now it's actually going in
the loop which is good news.

1208
01:34:01,170 --> 01:34:03,450
Undefined '-' method class.

1209
01:34:04,480 --> 01:34:06,140
Let's debug our way through this

1210
01:34:08,220 --> 01:34:10,220
It's happening on consecutive cards

1211
01:34:12,340 --> 01:34:14,310
and it's happening on line eighty three

1212
01:34:15,600 --> 01:34:16,310
Which is here.

1213
01:34:21,420 --> 01:34:23,510
TS: What does the documentation
for insert say?

1214
01:34:25,110 --> 01:34:26,620
CB: it's not destructive is it ?

1215
01:34:28,280 --> 01:34:31,020
TS: it sets the given value with
the given index

1216
01:34:31,240 --> 01:34:32,930
so you have to provide an index.

1217
01:34:32,930 --> 01:34:33,650
CB: OK, alright.

1218
01:34:35,600 --> 01:34:39,250
I'm going to insert it at the
start because it doesn't really matter

1219
01:34:45,600 --> 01:34:47,210
I could go for the lazy option.

1220
01:34:57,770 --> 01:34:58,800
TS: Has that fixed it?

1221
01:34:59,000 --> 01:35:02,250
CB: No, so many things going wrong right now.

1222
01:35:05,680 --> 01:35:08,220
This is take my sorted card values and give me

1223
01:35:10,200 --> 01:35:15,110
other possible card values for Aces.

1224
01:35:22,740 --> 01:35:23,540
bit premature.

1225
01:35:26,510 --> 01:35:28,720
If the number of Aces is bigger than one

1226
01:35:29,420 --> 01:35:32,190
then I want to have...

1227
01:35:36,140 --> 01:35:39,040
Aces as ones.

1228
01:35:40,600 --> 01:35:42,620
Which is just like sorted card values

1229
01:35:44,600 --> 01:35:46,350
I want to manipulate that.

1230
01:35:46,610 --> 01:35:49,140
TS: So you're going to
leave the original one alone?

1231
01:35:49,140 --> 01:35:51,020
CB: Correct. I don't want to touch that.

1232
01:35:51,020 --> 01:35:54,930
And then in the case
of straight I want to check

1233
01:35:55,280 --> 01:35:58,770
either it works out fine
with the usual way of doing it.

1234
01:35:59,280 --> 01:36:05,200
Or it works out with the using
Ace as ones, way of doing it.

1235
01:36:06,200 --> 01:36:07,960
So either is true.

1236
01:36:09,000 --> 01:36:13,790
If the number of Aces is none,

1237
01:36:15,600 --> 01:36:17,480
then it's the usual check:

1238
01:36:18,400 --> 01:36:19,860
do I have consecutive cards.

1239
01:36:22,050 --> 01:36:24,800
Now that's going to fail
nicely in places, excellent.

1240
01:36:27,110 --> 01:36:29,870
It still doesn't work with a straight with low ace.

1241
01:36:35,770 --> 01:36:38,510
I want to check what my Aces as ones is like.

1242
01:36:40,480 --> 01:36:44,010
This is my best chance of
understanding what's going on.

1243
01:36:45,110 --> 01:36:47,320
Aces as ones looks like 123, aha !

1244
01:36:47,450 --> 01:36:48,320
it's not sorted

1245
01:36:49,570 --> 01:36:52,670
I'm doing my sort here and I am doing

1246
01:36:52,680 --> 01:36:53,870
my sort again.

1247
01:36:55,140 --> 01:37:00,990
How about... we just don't sort them here

1248
01:37:01,170 --> 01:37:04,450
TS: And then consecutive cards
is going to be in charge of that.

1249
01:37:04,600 --> 01:37:10,630
I'll give it any number of cards
in any odd number called card values

1250
01:37:11,220 --> 01:37:15,680
and inside here my job is just to sort them.

1251
01:37:17,930 --> 01:37:18,400
TS: OK.

1252
01:37:18,650 --> 01:37:22,080
And then go ahead with the rest of the code.

1253
01:37:24,060 --> 01:37:27,360
Which I have changed variable names

1254
01:37:27,390 --> 01:37:29,960
so it should be less angry at me.

1255
01:37:33,460 --> 01:37:35,930
Good, straights with low Aces
and straights with high Aces.

1256
01:37:37,280 --> 01:37:41,250
TS: Ok so we are nearly out of time now,
what would you like to do to wrap this up.

1257
01:37:43,680 --> 01:37:47,320
I was supposed to write a hand comparer,
and now I've written a hand ranker,

1258
01:37:47,800 --> 01:37:52,270
I'd like to try that out and see what happens

1259
01:37:52,420 --> 01:37:54,220
TS: So ranking the hands you've
already implemented

1260
01:37:55,680 --> 01:37:57,220
There are a few hands missing

1261
01:37:58,520 --> 01:38:00,080
but not a lot of work left to do.

1262
01:38:03,970 --> 01:38:05,990
Let me just correct this

1263
01:38:08,420 --> 01:38:13,050
so that we are following the rules of poker.

1264
01:38:14,540 --> 01:38:16,820
I've got a hand, it's told me what the rank it is

1265
01:38:17,020 --> 01:38:19,020
but if I had two cards, I want to give my

1266
01:38:19,020 --> 01:38:20,510
hand to my other hand and say

1267
01:38:21,650 --> 01:38:24,040
Are you better than that hand.
TS: Ok.

1268
01:38:25,170 --> 01:38:27,720
In my public interface with
my hand I would like

1269
01:38:30,560 --> 01:38:32,680
to have, is_better? than other hand.

1270
01:38:34,200 --> 01:38:36,280
TS: And it's going to return true or false.

1271
01:38:36,280 --> 01:38:37,880
CB: Yes, exactly.

1272
01:38:38,770 --> 01:38:41,540
How about we have a very quick,

1273
01:38:42,400 --> 01:38:44,560
I will describe 'better than'

1274
01:38:50,020 --> 01:38:50,910
We can just say:

1275
01:38:57,990 --> 01:39:01,200
It tells me if the hand is better.

1276
01:39:05,420 --> 01:39:08,520
We already have some very handy hands

1277
01:39:10,680 --> 01:39:13,070
We know, for example, the 4 of a kind hand

1278
01:39:15,420 --> 01:39:17,560
should be better than full house.

1279
01:39:18,420 --> 01:39:19,600
let's start with those

1280
01:39:19,650 --> 01:39:25,480
so full_house.better_than? 4 of a kind hand

1281
01:39:25,850 --> 01:39:27,040
So I expect

1282
01:39:28,820 --> 01:39:30,810
all of this to be true.

1283
01:39:34,480 --> 01:39:37,350
TS: Is that the right way round?

1284
01:39:37,850 --> 01:39:39,770
A full house is better than 4 of a kind.

1285
01:39:39,770 --> 01:39:41,360
CB: No it's not - thank you.

1286
01:39:45,420 --> 01:39:46,740
That looks more sensible.

1287
01:39:49,940 --> 01:39:51,090
Let's run this.

1288
01:39:52,000 --> 01:39:53,910
I want to find a 'better than' for hand

1289
01:39:54,200 --> 01:39:57,360
Oh that's because I've
implemented it as a Poker method

1290
01:39:59,740 --> 01:40:00,870
let's run this

1291
01:40:01,400 --> 01:40:03,710
and now it's getting nil, excellent

1292
01:40:06,680 --> 01:40:11,410
So I have the rank of both hands
and I want to know which is the better.

1293
01:40:12,340 --> 01:40:13,820
This comes back to the thing

1294
01:40:13,820 --> 01:40:17,370
which I was thinking about an hour ago.

1295
01:40:17,450 --> 01:40:20,820
If only I'd known there was a
ranking that told me the best hand.

1296
01:40:23,620 --> 01:40:26,030
and next possible best hand.

1297
01:40:26,400 --> 01:40:28,040
So this is what we want.

1298
01:40:28,420 --> 01:40:31,420
If we have big poker ranks

1299
01:40:34,200 --> 01:40:37,000
and it's an array and ordered thing for now.

1300
01:40:40,280 --> 01:40:42,320
and if we go forward and say.....

1301
01:40:43,140 --> 01:40:45,800
this is a naive implementation

1302
01:40:46,080 --> 01:40:49,880
So if we have 4 of a
kind, full house and straight.

1303
01:40:50,540 --> 01:40:56,110
What I could do is in POKER_RANKS

1304
01:40:57,650 --> 01:41:00,360
I can just get the index of rank

1305
01:41:00,650 --> 01:41:03,080
and compare that to the POKER_RANKS

1306
01:41:04,050 --> 01:41:05,400
index of the other hand

1307
01:41:05,820 --> 01:41:09,220
and that would give me a straightforward answer for [inaudible]

1308
01:41:12,970 --> 01:41:15,740
I'm assuming that the
index is here, I'm not really sure

1309
01:41:18,740 --> 01:41:23,550
This is me, this is
my rank, and this is confusing.

1310
01:41:26,340 --> 01:41:28,530
TS: You're putting the worst first

1311
01:41:29,220 --> 01:41:31,850
CB: Yes because it's a lower rank

1312
01:41:32,420 --> 01:41:35,070
And if it's a high rank
I want to be happier with it.

1313
01:41:35,250 --> 01:41:38,750
TS: The the question will
be is my index greater than

1314
01:41:40,740 --> 01:41:43,620
CB: Yes and I am going to
say it's strictly greater than

1315
01:41:43,620 --> 01:41:45,220
I'll get back to that in a second

1316
01:41:47,940 --> 01:41:51,450
but yes, index one doesn't exist obviously.

1317
01:41:52,220 --> 01:41:55,790
Let's now assume if we
have some method on the array

1318
01:41:56,400 --> 01:41:59,450
That is find index, that's the
one I probably want

1319
01:42:06,540 --> 01:42:08,310
Yes, it returns the index of a thing,

1320
01:42:08,310 --> 01:42:12,000
so just index would have worked better.

1321
01:42:14,310 --> 01:42:15,490
Let's go back here...

1322
01:42:21,570 --> 01:42:25,220
Go and define method something for nil class.
Excellent.

1323
01:42:32,680 --> 01:42:35,760
This is apparently nil.

1324
01:42:36,110 --> 01:42:38,850
TS: Because it was not
finding the rank in that array.

1325
01:42:38,850 --> 01:42:39,450
CB: Correct.

1326
01:42:48,510 --> 01:42:52,590
I am comparing four of a kind and full house.

1327
01:42:55,080 --> 01:43:00,280
I'm going to print out the
rank of the other hands because

1328
01:43:01,110 --> 01:43:04,050
I'm running out of time so
I don't want to spend ages

1329
01:43:04,480 --> 01:43:05,480
debugging this.

1330
01:43:07,610 --> 01:43:09,040
Oh of course it's a hash.

1331
01:43:13,430 --> 01:43:15,000
So I'm not comparing that.

1332
01:43:17,290 --> 01:43:18,940
I'm just assuming there is a type.

1333
01:43:18,950 --> 01:43:22,340
If there isn't a type then I should
be wary so I'm going to let that fail.

1334
01:43:25,600 --> 01:43:26,800
And we have no failures.

1335
01:43:27,710 --> 01:43:29,470
Now we can compare two hands.

1336
01:43:29,600 --> 01:43:31,220
There is a tiny bit of work left

1337
01:43:31,600 --> 01:43:34,400
there's a few hands I haven't implemented.

1338
01:43:34,940 --> 01:43:36,970
And there's a bit of work left in terms of:

1339
01:43:37,770 --> 01:43:41,050
well, we should probably
have all the rankings in nice order.

1340
01:43:41,250 --> 01:43:43,220
There's an obvious refactoring step

1341
01:43:43,710 --> 01:43:47,110
which is, well, now I have a list of things

1342
01:43:47,140 --> 01:43:48,800
that rank things and then

1343
01:43:49,820 --> 01:43:55,340
my rank method is executing
and checking for things in a certain order.

1344
01:43:56,740 --> 01:43:59,510
The order that I'm
defining in this POKER_RANKS array

1345
01:44:00,100 --> 01:44:03,200
Is the exact same one which
I want to be ranking those cards

1346
01:44:03,200 --> 01:44:05,830
so I should be doing something really clever here.

1347
01:44:08,200 --> 01:44:10,710
The big piece of functionality that's missing is...

1348
01:44:11,850 --> 01:44:14,760
If I have two straights, how do I know who has one.

1349
01:44:14,850 --> 01:44:19,220
and this is why I'm returning
this rank as type something

1350
01:44:19,600 --> 01:44:23,880
because I had in mind, I
don't only care about the type of hand

1351
01:44:23,910 --> 01:44:26,790
I also care about
the highest card in that hand

1352
01:44:28,340 --> 01:44:30,310
For a straight, for example,

1353
01:44:30,320 --> 01:44:34,280
I would get the highest card in that hand.

1354
01:44:34,820 --> 01:44:39,280
With the mix of Ace
should be counted as 1 or 14

1355
01:44:40,200 --> 01:44:42,650
depending on the
kind of straight that I have.

1356
01:44:42,650 --> 01:44:44,870
and I would return that as the type of rank.

1357
01:44:45,370 --> 01:44:48,740
and if my rank method gives
me back not just the type of my hand

1358
01:44:48,940 --> 01:44:52,540
but also the highest possible tie breaker

1359
01:44:54,540 --> 01:44:57,110
in some hands but in
others it's different things,

1360
01:44:57,620 --> 01:45:00,970
then I can definitely determine
if my hand has won or not.

1361
01:45:01,450 --> 01:45:02,520
TS: Ok, great.

1362
01:45:02,620 --> 01:45:05,400
TS: Well I think that would
be a good place to wrap it up.

1363
01:45:05,650 --> 01:45:08,170
Thank  you very much
for showing us this today

1364
01:45:08,170 --> 01:45:10,280
It's been fascinating watching you work.

1365
01:45:10,280 --> 01:45:11,770
So again, thank you very much.

1366
01:45:11,770 --> 01:45:12,400
CB: Thanks.

