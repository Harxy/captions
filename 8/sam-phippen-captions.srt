1
00:00:00,960 --> 00:00:02,777
NARRATOR: Welcome to Peer to Peer

2
00:00:02,777 --> 00:00:06,770
where you can hone your skills
by watching live coding videos.

3
00:00:06,891 --> 00:00:09,245
Our guest today is Sam Phippen

4
00:00:09,240 --> 00:00:12,228
Who's a swashbuckling hacker from London, UK.

5
00:00:12,880 --> 00:00:16,754
He fixes every size of data problem and inaud plausible solutions.

6
00:00:17,771 --> 00:00:22,240
He helps fight the forces of justice
as a member of RSpec core team.

7
00:00:22,514 --> 00:00:25,280
And he's sad that he can't hug every cat.

8
00:00:26,114 --> 00:00:28,400
Our host is Camille Baldock.

9
00:00:28,400 --> 00:00:31,017
And the challenge that she's set for Sam is called

10
00:00:31,010 --> 00:00:34,228
Building a Spy library.

11
00:00:34,440 --> 00:00:36,880
CAMILLE BALLDOCK; So Sam, do you
want to start by reading the challenge?

12
00:00:36,880 --> 00:00:37,851
SAM PHIPPEN: Sure.

13
00:00:38,811 --> 00:00:42,640
Write a simple library to enable testing with spies.

14
00:00:42,811 --> 00:00:46,628
Here's a simple Ruby app
which interacts with a RESTful API.

15
00:00:46,750 --> 00:00:52,308
The app has a passing test suite, but the tests
are an incomplete specification of its behaviour.

16
00:00:52,340 --> 00:00:56,525
Add a set of isolated tests that
spy on collaborations between objects

17
00:00:56,520 --> 00:00:58,205
to complete the test suite.

18
00:00:58,380 --> 00:01:00,548
Chapter 01

19
00:01:02,662 --> 00:01:07,588
CB: Right! So do you want to have a
quick look at what this Ruby app is and does.

20
00:01:07,640 --> 00:01:10,388
And we can have a play with that
before we actually dive into the challenge.

21
00:01:10,422 --> 00:01:13,020
SP: Sure... so...

22
00:01:13,020 --> 00:01:19,017
It looks like we've got a gem file and
a jem file.block lib and test directory.

23
00:01:19,280 --> 00:01:26,377
So I guess the first thing we should do
is check that all the tests are passing.

24
00:01:26,982 --> 00:01:31,554
The project has a test helper,
so we'll run that... it should run

25
00:01:33,291 --> 00:01:35,645
We have tests and they're passing so...

26
00:01:35,640 --> 00:01:39,771
I'm going to start by looking at what the tests do.

27
00:01:40,457 --> 00:01:42,765
Seems like a reasonable place to begin.

28
00:01:42,880 --> 00:01:49,908
So we've got a sort of standard mini test inaud and we're requiring a file called Counter Client,

29
00:01:49,900 --> 00:01:55,222
which is presumably the RESTful
client the challenge mentions.

30
00:01:55,220 --> 00:01:59,885
And we can see here that
we've got our counter client test class,

31
00:01:59,908 --> 00:02:05,920
Which inherits from Vtest test
and it has a set up phase, but

32
00:02:05,920 --> 00:02:09,394
it doesn't look like it has any actual tests in it.

33
00:02:09,390 --> 00:02:16,880
Instead it's just used to do the set up, and then
this child class integrated counter client test

34
00:02:16,880 --> 00:02:20,274
is the one that's actually running the tests.

35
00:02:20,270 --> 00:02:29,268
And that does it's own minor piece of set up
providing I guess, the integrated collaborator.

36
00:02:31,405 --> 00:02:35,782
CB: Inaud using HDP for the client right?

37
00:02:35,780 --> 00:02:42,297
SP: Yes so whatever this LHTTP thing is
erm... that's presumably making the real

38
00:02:42,290 --> 00:02:46,365
HTTP requests giving our integrated test.

39
00:02:46,380 --> 00:02:51,668
And then we have our test
for the degenerate case erm...

40
00:02:51,660 --> 00:02:58,274
... so that uninitialized key has a count
of zero and then 1 and a random number.

41
00:02:59,714 --> 00:03:01,988
These test seem like they are pretty good,

42
00:03:02,045 --> 00:03:05,177
covering for the behaviour of the actual object.

43
00:03:07,805 --> 00:03:11,805
CB: Yes, let's have a look at what the
object does, we can only see a couple of methods

44
00:03:12,011 --> 00:03:15,302
SP: Sure so...

45
00:03:15,474 --> 00:03:21,154
... counter client object can
be initialized with an HTTP,

46
00:03:21,150 --> 00:03:29,874
it has a get method which delegates onto the HTTP
and an increment method which does the same.

47
00:03:29,870 --> 00:03:33,885
So that gives us the API that we're dealing with here.

48
00:03:33,880 --> 00:03:39,474
And it's worth noting that there's a small
fix we can make here before we move on.

49
00:03:40,068 --> 00:03:45,160
At the top of the file here we're
acquiring LHTTP but it looks like it's actually...

50
00:03:45,160 --> 00:03:46,434
CB: We're not actually using it anywhere here.

51
00:03:46,430 --> 00:03:52,960
SP: Sure, but it's being dependency injected so
I guess sometime in the past this file needed that.

52
00:03:53,040 --> 00:03:55,782
CB: Alright and it's going to inaud to get that out.

53
00:03:55,780 --> 00:03:59,954
SP: We should be able to play
that away and still pass all the tests.

54
00:03:59,950 --> 00:04:02,937
[Sam thinks]

55
00:04:06,920 --> 00:04:12,960
And the reason we're failing is that
it's not being required in the test,

56
00:04:12,994 --> 00:04:18,770
which is where it should be
being required, so let's also fix that.

57
00:04:21,805 --> 00:04:26,765
And I've put the require at the
top there but it can go either way.

58
00:04:26,760 --> 00:04:29,634
Great, so we've past all of our tests.

59
00:04:30,120 --> 00:04:32,811
Back to green... that's nice. 

60
00:04:32,857 --> 00:04:39,782
So we've made a more change without having
to think too hard about anything in particular.

61
00:04:39,780 --> 00:04:48,377
So, the challenge adequately
describes the problem with these tests.

62
00:04:49,360 --> 00:04:58,520
There's no actual evidence here of any real collaborations between the inaud HTTP and the counter client.

63
00:04:58,960 --> 00:05:06,445
If you look in these tests, no actual
interactions occur with LHTTP and the test itself.

64
00:05:06,600 --> 00:05:10,960
It's assumed therefore that the client is
delegating that, and we know that's the case,

65
00:05:10,971 --> 00:05:15,794
but it would be nice to have
evidence in test as well as evidence in code.

66
00:05:15,790 --> 00:05:20,834
CB: Right so when we look at that test, we have
no confidence that there is a HTTP thing going on,

67
00:05:20,830 --> 00:05:24,011
and someone might have just put a hash and memory....

68
00:05:24,010 --> 00:05:29,622
SP: Right, exactly, so I think it would
be a good idea to add some isolated tests

69
00:05:29,620 --> 00:05:35,062
which use the the fact that the
counter client is already dependency injection

70
00:05:35,060 --> 00:05:42,400
to specify the contract effectively between
the object, which will be an isolated test.

71
00:05:42,400 --> 00:05:48,125
CB: So here we don't care about that it's
using HTTP, all we care about is that our HTTP thing

72
00:05:48,120 --> 00:05:50,228
that we've dependency
injected in our counter client,

73
00:05:50,262 --> 00:05:53,634
is going to be called in lots
of different ways and do the work.

74
00:05:53,630 --> 00:05:55,817
Not just something else, right?

75
00:05:55,810 --> 00:06:05,588
SP: Yes, effectively the counter client and
doing HTTP are at different levels of construction.

76
00:06:06,788 --> 00:06:09,600
The specific languages here are different.

77
00:06:09,600 --> 00:06:15,542
The counter client has methods that
are talking in terms of our domain rate, inaud

78
00:06:15,540 --> 00:06:21,657
And the HTTP client has inaud that is talking in terms of HTTP inaud get post URLs

79
00:06:21,690 --> 00:06:29,760
and then here we also we have conversion
from the string to the integer response body

80
00:06:29,840 --> 00:06:37,188
because we have integer counts but
we obviously can't specify the HTTP body.

81
00:06:37,337 --> 00:06:42,948
So I think it would be a good
idea to add a set of isolated tests,

82
00:06:43,050 --> 00:06:45,051
which will take us into our spying library.

83
00:06:45,050 --> 00:06:50,651
CB: OK, so let's go back to our tests and can
you show me where you would like to get started

84
00:06:50,650 --> 00:06:54,925
in terms of what is it we would
like to look at on this HTTP object.

85
00:06:54,920 --> 00:06:59,771
SP: Sure, so we'll start by adding a test to get that.

86
00:06:59,770 --> 00:07:05,074
So we're going to have a new test case
which will be isolated counter client test.

87
00:07:05,165 --> 00:07:08,880
Which is itself going to inherit
from the counter client test base.

88
00:07:09,325 --> 00:07:11,611
The same way our previous one did.

89
00:07:11,862 --> 00:07:16,948
It's going to have a set up block, and
here it's going to be mostly the same.

90
00:07:17,460 --> 00:07:24,068
except we are going to need to provide
an isolated dependency, not the HTTP client,

91
00:07:24,080 --> 00:07:26,548
so that we can observe interactions.

92
00:07:27,062 --> 00:07:30,788
So this is going to be our spy object.

93
00:07:31,588 --> 00:07:34,765
CB: OK, so I'm going to let you go on for a few seconds

94
00:07:34,760 --> 00:07:38,022
then I'm going to ask you lots of
obnoxious questions about spies.

95
00:07:38,194 --> 00:07:43,840
SP: So we need a name for our spying library.

96
00:07:45,085 --> 00:07:52,650
I was thinking Bond... so we'll
say that each HTTP is a new bond.

97
00:07:55,108 --> 00:07:59,382
CB: We're getting very British Government with
this and I can only whole heartedly approve.

98
00:07:59,460 --> 00:08:04,960
SP: So we'll pretend for the moment
there exists a module called Bond,

99
00:08:05,051 --> 00:08:10,788
which provides us this
method and then we'll run the test.

100
00:08:10,780 --> 00:08:16,514
CB: So what do you imagine this method
doing, what is our Bond history going to do?

101
00:08:19,234 --> 00:08:26,050
The Bond object is going to be
a minimum viable implementation.

102
00:08:26,148 --> 00:08:30,388
Or something that looks like
how spies are implemented in RSpec.

103
00:08:31,302 --> 00:08:35,828
CB: So why don't we talk about how that
works, as in the minimum viable stuff in there.

104
00:08:36,594 --> 00:08:42,765
SP: In RSpec, spy objects respond to all method calls,

105
00:08:42,760 --> 00:08:50,651
that is, whenever you invoke any method on
a spy it will actually succeed and then return self.

106
00:08:50,880 --> 00:08:54,100
which means you can do inaud, because when you get the object back

107
00:08:54,100 --> 00:08:56,822
it's the same object which can respond to any method

108
00:08:56,820 --> 00:09:04,034
so you can do eg. spy. inaud and that would work because it's just returning spy on each inaud

109
00:09:04,830 --> 00:09:08,160
The job of spies, and why they are useful in testing, 

110
00:09:08,182 --> 00:09:12,262
is they record all the method
calls that are made upon them,

111
00:09:12,260 --> 00:09:18,091
which means that at the end of our test
we can assert on the calls that have been made

112
00:09:18,148 --> 00:09:20,354
to allow us to observe the interactions.

113
00:09:20,350 --> 00:09:24,297
And so here, what we will do when we write our tests,

114
00:09:24,308 --> 00:09:30,971
is the counter client will send the
various methods to our spy object.

115
00:09:30,970 --> 00:09:34,731
We'll record them and then we'll assert on them after the inaud

116
00:09:34,840 --> 00:09:37,942
CB: So we're doing the exact same tests we're doing on inaud

117
00:09:37,965 --> 00:09:40,605
but on top of that we're going to
have a spy listening in the middle.

118
00:09:40,600 --> 00:09:43,657
And making sure the right things
happen with a collaborator in the middle?

119
00:09:43,650 --> 00:09:46,994
[New Chapter]

120
00:09:47,737 --> 00:09:51,060
SP: So we need to write this library now.

121
00:09:51,060 --> 00:10:01,440
And I think we'll do that as a new gem
and so we'll move out of our project,

122
00:10:01,440 --> 00:10:06,194
and do bundle gem bond.

123
00:10:06,190 --> 00:10:13,520
This will have bundler initialise and create the
new gem for us with all of the necessary set up.

124
00:10:15,908 --> 00:10:18,354
It's done that.

125
00:10:18,445 --> 00:10:22,034
CB: There's got to be a gem
called bond out there in the world.

126
00:10:22,030 --> 00:10:26,617
SP: I'm sure we're stomping on someone else gem in inaud space but...

127
00:10:26,610 --> 00:10:28,308
CB: It's experimental.

128
00:10:28,300 --> 00:10:31,634
SP: This will be fine for what we're doing.

129
00:10:31,630 --> 00:10:36,685
So this is what our project looks like
after bundler has generated for us.

130
00:10:36,680 --> 00:10:39,977
There's a bit more in here.

131
00:10:40,045 --> 00:10:44,468
One thing that's worth noting is we
now have a spec directory not a test directory

132
00:10:44,460 --> 00:10:49,725
and that's got bundler set up to
automatically include RSpec into projects for me.

133
00:10:51,165 --> 00:10:55,257
CB: So are we going to write our tests for inaud

134
00:10:55,250 --> 00:10:58,080
RSpec and then revert back
to mini-test for our client.

135
00:10:58,080 --> 00:11:05,794
SP: Yes, so the idea would be that,
our spy library, we can test it in whatever,

136
00:11:05,790 --> 00:11:07,200
it doesn't really matter.

137
00:11:07,200 --> 00:11:13,291
And then it's actually just going to be a
module that we can include into any set of tests,

