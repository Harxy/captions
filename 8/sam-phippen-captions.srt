1
00:00:00,960 --> 00:00:02,777
NARRATOR: Welcome to Peer to Peer

2
00:00:02,777 --> 00:00:06,770
where you can hone your skills
by watching live coding videos.

3
00:00:06,891 --> 00:00:09,245
Our guest today is Sam Phippen

4
00:00:09,240 --> 00:00:12,228
Who's a swashbuckling hacker from London, UK.

5
00:00:12,880 --> 00:00:16,754
He fixes every size of data problem and inaud plausible solutions.

6
00:00:17,771 --> 00:00:22,240
He helps fight the forces of justice
as a member of RSpec core team.

7
00:00:22,514 --> 00:00:25,280
And he's sad that he can't hug every cat.

8
00:00:26,114 --> 00:00:28,400
Our host is Camille Baldock.

9
00:00:28,400 --> 00:00:31,017
And the challenge that she's set for Sam is called

10
00:00:31,010 --> 00:00:34,228
Building a Spy library.

11
00:00:34,440 --> 00:00:36,880
CAMILLE BALLDOCK; So Sam, do you
want to start by reading the challenge?

12
00:00:36,880 --> 00:00:37,851
SAM PHIPPEN: Sure.

13
00:00:38,811 --> 00:00:42,640
Write a simple library to enable testing with spies.

14
00:00:42,811 --> 00:00:46,628
Here's a simple Ruby app
which interacts with a RESTful API.

15
00:00:46,750 --> 00:00:52,308
The app has a passing test suite, but the tests
are an incomplete specification of its behaviour.

16
00:00:52,340 --> 00:00:56,525
Add a set of isolated tests that
spy on collaborations between objects

17
00:00:56,520 --> 00:00:58,205
to complete the test suite.

18
00:00:58,380 --> 00:01:00,548
Chapter 01

19
00:01:02,662 --> 00:01:07,588
CB: Right! So do you want to have a
quick look at what this Ruby app is and does.

20
00:01:07,640 --> 00:01:10,388
And we can have a play with that
before we actually dive into the challenge.

21
00:01:10,422 --> 00:01:13,020
SP: Sure... so...

22
00:01:13,020 --> 00:01:19,017
It looks like we've got a gem file and
a jem file.block lib and test directory.

23
00:01:19,280 --> 00:01:26,377
So I guess the first thing we should do
is check that all the tests are passing.

24
00:01:26,982 --> 00:01:31,554
The project has a test helper,
so we'll run that... it should run

25
00:01:33,291 --> 00:01:35,645
We have tests and they're passing so...

26
00:01:35,640 --> 00:01:39,771
I'm going to start by looking at what the tests do.

27
00:01:40,457 --> 00:01:42,765
Seems like a reasonable place to begin.

28
00:01:42,880 --> 00:01:49,908
So we've got a sort of standard mini test inaud and we're requiring a file called Counter Client,

29
00:01:49,900 --> 00:01:55,222
which is presumably the RESTful
client the challenge mentions.

30
00:01:55,220 --> 00:01:59,885
And we can see here that
we've got our counter client test class,

31
00:01:59,908 --> 00:02:05,920
Which inherits from Vtest test
and it has a set up phase, but

32
00:02:05,920 --> 00:02:09,394
it doesn't look like it has any actual tests in it.

33
00:02:09,390 --> 00:02:16,880
Instead it's just used to do the set up, and then
this child class integrated counter client test

34
00:02:16,880 --> 00:02:20,274
is the one that's actually running the tests.

35
00:02:20,270 --> 00:02:29,268
And that does it's own minor piece of set up
providing I guess, the integrated collaborator.

36
00:02:31,405 --> 00:02:35,782
CB: Inaud using HDP for the client right?

37
00:02:35,780 --> 00:02:42,297
SP: Yes so whatever this LHTTP thing is
erm... that's presumably making the real

38
00:02:42,290 --> 00:02:46,365
HTTP requests giving our integrated test.

39
00:02:46,380 --> 00:02:51,668
And then we have our test
for the degenerate case erm...

40
00:02:51,660 --> 00:02:58,274
... so that uninitialized key has a count
of zero and then 1 and a random number.

41
00:02:59,714 --> 00:03:01,988
These test seem like they are pretty good,

42
00:03:02,045 --> 00:03:05,177
covering for the behaviour of the actual object.

43
00:03:07,805 --> 00:03:11,805
CB: Yes, let's have a look at what the
object does, we can only see a couple of methods

44
00:03:12,011 --> 00:03:15,302
SP: Sure so...

45
00:03:15,474 --> 00:03:21,154
... counter client object can
be initialized with an HTTP,

46
00:03:21,150 --> 00:03:29,874
it has a get method which delegates onto the HTTP
and an increment method which does the same.

47
00:03:29,870 --> 00:03:33,885
So that gives us the API that we're dealing with here.

48
00:03:33,880 --> 00:03:39,474
And it's worth noting that there's a small
fix we can make here before we move on.

49
00:03:40,068 --> 00:03:45,160
At the top of the file here we're
acquiring LHTTP but it looks like it's actually...

50
00:03:45,160 --> 00:03:46,434
CB: We're not actually using it anywhere here.

51
00:03:46,430 --> 00:03:52,960
SP: Sure, but it's being dependency injected so
I guess sometime in the past this file needed that.

52
00:03:53,040 --> 00:03:55,782
CB: Alright and it's going to inaud to get that out.

53
00:03:55,780 --> 00:03:59,954
SP: We should be able to play
that away and still pass all the tests.

54
00:03:59,950 --> 00:04:02,937
[Sam thinks]

55
00:04:06,920 --> 00:04:12,960
And the reason we're failing is that
it's not being required in the test,

56
00:04:12,994 --> 00:04:18,770
which is where it should be
being required, so let's also fix that.

57
00:04:21,805 --> 00:04:26,765
And I've put the require at the
top there but it can go either way.

58
00:04:26,760 --> 00:04:29,634
Great, so we've past all of our tests.

59
00:04:30,120 --> 00:04:32,811
Back to green... that's nice.

60
00:04:32,857 --> 00:04:39,782
So we've made a more change without having
to think too hard about anything in particular.

61
00:04:39,780 --> 00:04:48,377
So, the challenge adequately
describes the problem with these tests.

62
00:04:49,360 --> 00:04:58,520
There's no actual evidence here of any real collaborations between the inaud HTTP and the counter client.

63
00:04:58,960 --> 00:05:06,445
If you look in these tests, no actual
interactions occur with LHTTP and the test itself.

64
00:05:06,600 --> 00:05:10,960
It's assumed therefore that the client is
delegating that, and we know that's the case,

65
00:05:10,971 --> 00:05:15,794
but it would be nice to have
evidence in test as well as evidence in code.

66
00:05:15,790 --> 00:05:20,834
CB: Right so when we look at that test, we have
no confidence that there is a HTTP thing going on,

67
00:05:20,830 --> 00:05:24,011
and someone might have just put a hash and memory....

68
00:05:24,010 --> 00:05:29,622
SP: Right, exactly, so I think it would
be a good idea to add some isolated tests

69
00:05:29,620 --> 00:05:35,062
which use the the fact that the
counter client is already dependency injection

70
00:05:35,060 --> 00:05:42,400
to specify the contract effectively between
the object, which will be an isolated test.

71
00:05:42,400 --> 00:05:48,125
CB: So here we don't care about that it's
using HTTP, all we care about is that our HTTP thing

72
00:05:48,120 --> 00:05:50,228
that we've dependency
injected in our counter client,

73
00:05:50,262 --> 00:05:53,634
is going to be called in lots
of different ways and do the work.

74
00:05:53,630 --> 00:05:55,817
Not just something else, right?

75
00:05:55,810 --> 00:06:05,588
SP: Yes, effectively the counter client and
doing HTTP are at different levels of construction.

76
00:06:06,788 --> 00:06:09,600
The specific languages here are different.

77
00:06:09,600 --> 00:06:15,542
The counter client has methods that
are talking in terms of our domain rate, inaud

78
00:06:15,540 --> 00:06:21,657
And the HTTP client has inaud that is talking in terms of HTTP inaud get post URLs

79
00:06:21,690 --> 00:06:29,760
and then here we also we have conversion
from the string to the integer response body

80
00:06:29,840 --> 00:06:37,188
because we have integer counts but
we obviously can't specify the HTTP body.

81
00:06:37,337 --> 00:06:42,948
So I think it would be a good
idea to add a set of isolated tests,

82
00:06:43,050 --> 00:06:45,051
which will take us into our spying library.

83
00:06:45,050 --> 00:06:50,651
CB: OK, so let's go back to our tests and can
you show me where you would like to get started

84
00:06:50,650 --> 00:06:54,925
in terms of what is it we would
like to look at on this HTTP object.

85
00:06:54,920 --> 00:06:59,771
SP: Sure, so we'll start by adding a test to get that.

86
00:06:59,770 --> 00:07:05,074
So we're going to have a new test case
which will be isolated counter client test.

87
00:07:05,165 --> 00:07:08,880
Which is itself going to inherit
from the counter client test base.

88
00:07:09,325 --> 00:07:11,611
The same way our previous one did.

89
00:07:11,862 --> 00:07:16,948
It's going to have a set up block, and
here it's going to be mostly the same.

90
00:07:17,460 --> 00:07:24,068
except we are going to need to provide
an isolated dependency, not the HTTP client,

91
00:07:24,080 --> 00:07:26,548
so that we can observe interactions.

92
00:07:27,062 --> 00:07:30,788
So this is going to be our spy object.

93
00:07:31,588 --> 00:07:34,765
CB: OK, so I'm going to let you go on for a few seconds

94
00:07:34,760 --> 00:07:38,022
then I'm going to ask you lots of
obnoxious questions about spies.

95
00:07:38,194 --> 00:07:43,840
SP: So we need a name for our spying library.

96
00:07:45,085 --> 00:07:52,650
I was thinking Bond... so we'll
say that each HTTP is a new bond.

97
00:07:55,108 --> 00:07:59,382
CB: We're getting very British Government with
this and I can only whole heartedly approve.

98
00:07:59,460 --> 00:08:04,960
SP: So we'll pretend for the moment
there exists a module called Bond,

99
00:08:05,051 --> 00:08:10,788
which provides us this
method and then we'll run the test.

100
00:08:10,780 --> 00:08:16,514
CB: So what do you imagine this method
doing, what is our Bond history going to do?

101
00:08:19,234 --> 00:08:26,050
The Bond object is going to be
a minimum viable implementation.

102
00:08:26,148 --> 00:08:30,388
Or something that looks like
how spies are implemented in RSpec.

103
00:08:31,302 --> 00:08:35,828
CB: So why don't we talk about how that
works, as in the minimum viable stuff in there.

104
00:08:36,594 --> 00:08:42,765
SP: In RSpec, spy objects respond to all method calls,

105
00:08:42,760 --> 00:08:50,651
that is, whenever you invoke any method on
a spy it will actually succeed and then return self.

106
00:08:50,880 --> 00:08:54,100
which means you can do inaud, because when you get the object back

107
00:08:54,100 --> 00:08:56,822
it's the same object which can respond to any method

108
00:08:56,820 --> 00:09:04,034
so you can do eg. spy. inaud and that would work because it's just returning spy on each inaud

109
00:09:04,830 --> 00:09:08,160
The job of spies, and why they are useful in testing,

110
00:09:08,182 --> 00:09:12,262
is they record all the method
calls that are made upon them,

111
00:09:12,260 --> 00:09:18,091
which means that at the end of our test
we can assert on the calls that have been made

112
00:09:18,148 --> 00:09:20,354
to allow us to observe the interactions.

113
00:09:20,350 --> 00:09:24,297
And so here, what we will do when we write our tests,

114
00:09:24,308 --> 00:09:30,971
is the counter client will send the
various methods to our spy object.

115
00:09:30,970 --> 00:09:34,731
We'll record them and then we'll assert on them after the inaud

116
00:09:34,840 --> 00:09:37,942
CB: So we're doing the exact same tests we're doing on inaud

117
00:09:37,965 --> 00:09:40,605
but on top of that we're going to
have a spy listening in the middle.

118
00:09:40,600 --> 00:09:43,657
And making sure the right things
happen with a collaborator in the middle?

119
00:09:43,650 --> 00:09:46,994
[New Chapter]

120
00:09:47,737 --> 00:09:51,060
SP: So we need to write this library now.

121
00:09:51,060 --> 00:10:01,440
And I think we'll do that as a new gem
and so we'll move out of our project,

122
00:10:01,440 --> 00:10:06,194
and do bundle gem bond.

123
00:10:06,190 --> 00:10:13,520
This will have bundler initialise and create the
new gem for us with all of the necessary set up.

124
00:10:15,908 --> 00:10:18,354
It's done that.

125
00:10:18,445 --> 00:10:22,034
CB: There's got to be a gem
called bond out there in the world.

126
00:10:22,030 --> 00:10:26,617
SP: I'm sure we're stomping on someone else gem in inaud space but...

127
00:10:26,610 --> 00:10:28,308
CB: It's experimental.

128
00:10:28,300 --> 00:10:31,634
SP: This will be fine for what we're doing.

129
00:10:31,630 --> 00:10:36,685
So this is what our project looks like
after bundler has generated for us.

130
00:10:36,680 --> 00:10:39,977
There's a bit more in here.

131
00:10:40,045 --> 00:10:44,468
One thing that's worth noting is we
now have a spec directory not a test directory

132
00:10:44,460 --> 00:10:49,725
and that's got bundler set up to
automatically include RSpec into projects for me.

133
00:10:51,165 --> 00:10:55,257
CB: So are we going to write our tests for inaud

134
00:10:55,250 --> 00:10:58,080
RSpec and then revert back
to mini-test for our client.

135
00:10:58,080 --> 00:11:05,794
SP: Yes, so the idea would be that,
our spy library, we can test it in whatever,

136
00:11:05,790 --> 00:11:07,200
it doesn't really matter.

137
00:11:07,200 --> 00:11:13,291
And then it's actually just going to be a
module that we can include into any set of tests,

138
00:11:13,290 --> 00:11:14,948
And it should work.

139
00:11:16,685 --> 00:11:23,428
The nice thing about using inaud Ruby is they all communicate failures the same way.

140
00:11:23,420 --> 00:11:29,108
Which is they raise
exceptions when expectations fail.

141
00:11:29,100 --> 00:11:34,240
So all we need to do to make Bond
compatible with both RSpec and mini-test,

142
00:11:34,240 --> 00:11:38,548
is have it raise the appropriate
exceptions at the appropriate times.

143
00:11:38,540 --> 00:11:41,702
and inaud our tests fail.

144
00:11:41,700 --> 00:11:49,245
CB: OK, a question before we go on... inaud Bond so our license inaud or what?

145
00:11:50,380 --> 00:11:55,017
SP: Yes, we have an MIT license, we have
a gem file which has a gem speck in it,

146
00:11:55,085 --> 00:12:02,845
and then the Bond gem speck declares development dependencies on bundler and inaud.

147
00:12:02,840 --> 00:12:08,308
It has 2 Ds here, we'll just fix those.

148
00:12:08,445 --> 00:12:11,474
[Sam thinks]

149
00:12:12,980 --> 00:12:18,765
We'll just fix all of this we
cant have any 'to dos' left or...

150
00:12:18,788 --> 00:12:22,091
CB: Why what would happen?

151
00:12:22,090 --> 00:12:28,217
SP: My understanding is that bundler
won't let you compile into a complete gem

152
00:12:28,210 --> 00:12:32,914
if you have 'to dos' left in your summary or description or inaud page.

153
00:12:33,085 --> 00:12:38,262
So it's to force you to put
something meaningful in there.

154
00:12:38,365 --> 00:12:44,342
This one is fine because there's this response to
thing in here so we can actually just blow this away.

155
00:12:44,434 --> 00:12:46,537
That's from private gems.

156
00:12:47,291 --> 00:12:51,154
CB: Alright so if you have your own internal Ruby inaud, OK.

157
00:12:51,860 --> 00:12:58,937
SP: One thing that's worth noting is...
we haven't got a dependency on RSpec declared here.

158
00:12:59,017 --> 00:13:01,200
CB: Do you want to add a test
development dependency on there?

159
00:13:01,200 --> 00:13:09,485
SP: I'm actually going to put it in the gem file,
because we're going to pull RSpec from GitHub Master.

160
00:13:10,170 --> 00:13:13,874
This is a thing I tend to do in
my projects because I work on RSpec

161
00:13:13,897 --> 00:13:17,360
and I want to be able to find
bugs when I'm actually using it.

162
00:13:17,360 --> 00:13:19,862
CB: So you just work breeding RSpec or something?

163
00:13:19,860 --> 00:13:25,017
SP: Yes, but I am uniquely qualified. [Laughter]

164
00:13:25,010 --> 00:13:28,697
No, if that goes wrong we'll find bugs in it.

165
00:13:28,777 --> 00:13:30,490
CB: Yes, no question about that.

166
00:13:30,571 --> 00:13:36,205
SP: One of the nice things about doing
this is not only do we have all of our own testing,

167
00:13:36,200 --> 00:13:43,005
which on RSpec is pretty strong, but it
means it's getting some real world usage on master.

168
00:13:43,000 --> 00:13:48,811
We have a pretty strict no red merges policy.

169
00:13:48,810 --> 00:13:55,714
So it's very rare that
master RSpec is non functional.

170
00:13:57,097 --> 00:14:00,834
CB: But you have a bunch of tests
that you run on a bunch of Rubys?

171
00:14:00,830 --> 00:14:05,097
SP: Yes, but we'll see. [Laughter]

172
00:14:05,090 --> 00:14:10,445
CB: Who knows what today has in store for us.

173
00:14:10,960 --> 00:14:19,142
SP: The other thing we will do quickly is GitHub the
project and add the gem file and the gem spec.

174
00:14:19,874 --> 00:14:25,600
And we've got RSpec and spec
helper, and we'll see what those do.

175
00:14:25,600 --> 00:14:32,000
That is the default test that bundler has
generated which I am going to delete.

176
00:14:33,200 --> 00:14:40,342
And with green with some
examples... so that's a good initial...

177
00:14:40,468 --> 00:14:45,211
CB: I love this failing test initially bundler,
it,s a great way to test your set up.

178
00:14:45,210 --> 00:14:53,817
SP: Yes, I typically blow it away as soon as I
see it hasn't run, but it's useful to have a test there.

179
00:14:53,810 --> 00:14:56,788
[Silence]

180
00:14:58,890 --> 00:15:05,908
So we sort of specified the API a
little bit, back in our mini-test.

181
00:15:05,920 --> 00:15:10,285
So we have the Bond module
which we can include into test classes,

182
00:15:10,280 --> 00:15:15,874
And that provides us with our DSL,
which is basically just a method

183
00:15:15,885 --> 00:15:18,834
which will return us an object and it takes a name.

184
00:15:18,830 --> 00:15:24,891
The reason we tried that name is so
we can put it in the inspect strings.

185
00:15:24,890 --> 00:15:28,457
Obviously if you have multiple
spies flying through your system

186
00:15:28,468 --> 00:15:32,685
you don't necessary know which one
is which so it can be useful to tag them.

187
00:15:32,680 --> 00:15:35,931
CB: OK so you use a name to
uniquely identify your things.

188
00:15:35,930 --> 00:15:41,805
SP: Yes, this is a thing that I do with
all my RSpec doubles and all of my RSpec spies.

189
00:15:41,800 --> 00:15:46,285
I give them a name which is
the first parameter they all take.

190
00:15:46,331 --> 00:15:50,994
So that we don't have to think
hard about where it came from later.

191
00:15:50,990 --> 00:15:54,560
CB: So this is when you do your let in RSpec and specify inaud double.

192
00:15:54,560 --> 00:16:02,651
SP: Exactly.  So given that we've
specified a public API that seems OK,

193
00:16:03,005 --> 00:16:09,000
I'm going to start by writing a high
level failing test which shows that off.

194
00:16:09,394 --> 00:16:14,765
I'm not opposed to that API changing at some point
if the tests are indicating that's a good thing to do.

195
00:16:14,857 --> 00:16:17,645
But it seems like a sensible place to start.

196
00:16:19,440 --> 00:16:27,394
So let's open the Bond spec backup
and the first thing we're going to describe

197
00:16:27,390 --> 00:16:32,868
is the .bond class method.

198
00:16:33,645 --> 00:16:36,937
And the reason it's a dot and not a hash

199
00:16:36,930 --> 00:16:40,868
is that the Bond method will be
available on the Bond module itself.

200
00:16:41,782 --> 00:16:48,925
Not an instance method... no that's wrong,
it should be a hash, I'm talking no sense.

201
00:16:48,920 --> 00:16:51,234
CB: Ok so we're going for an instance method Bond.

202
00:16:51,230 --> 00:16:58,571
SP: Because when you do like this: that
makes all the methods from that module available

203
00:16:58,570 --> 00:17:04,680
Right, so when we have a test method like
test these, right, that is an instance method call.

204
00:17:04,680 --> 00:17:11,097
Not a pass method call, I was wrong,
but I had to work it out by saying it,

205
00:17:11,131 --> 00:17:12,914
so that's fine.

206
00:17:12,910 --> 00:17:17,577
The other thing I want to check
before we get too deep into this

207
00:17:17,570 --> 00:17:25,097
is the contents of the spec helper, of the project.

208
00:17:25,630 --> 00:17:32,365
I'm checking that because it's useful to know
how your test configurations actually happen.

209
00:17:32,360 --> 00:17:37,200
I can immediately see something
here that I would like to change,

210
00:17:37,200 --> 00:17:45,257
which is to do with how the requires, and also
there's no RSpec configuration block here at all.

211
00:17:46,137 --> 00:17:51,040
This is a thing bundler has clearly generated
for us, but it's not exactly what we want.

212
00:17:51,040 --> 00:17:57,988
So I'm going to have RSpec overwrite the
bundler configuration with its own defaults,

213
00:17:59,520 --> 00:18:02,548
CB: So this is your inaud RSpec yes?

214
00:18:02,540 --> 00:18:08,674
SP: Yes, so BER is just an alias
that expands to bundle exec RSpec.

215
00:18:09,600 --> 00:18:18,342
[Big sigh] it's inaud a lot, so now if I just close the spec helper and re-open it.

216
00:18:18,445 --> 00:18:21,680
That should have changed but it hasn't.

217
00:18:21,874 --> 00:18:24,685
Am I doing something wrong?

218
00:18:27,417 --> 00:18:30,857
CB: Can you do something to force it or remove it?

219
00:18:30,914 --> 00:18:37,234
Maybe.  That's interesting,
I usually don't have this problem.

220
00:18:38,365 --> 00:18:44,960
Let's just delete the whole spec directory, that
will make sure we just have exactly what we want.

221
00:18:45,040 --> 00:18:51,611
Great, and now we have the default
generated RSpec configuration.

222
00:18:51,908 --> 00:18:57,630
This is a file filled with comments, I'm going to
blow most of them away, that's what I usually do.

223
00:19:00,880 --> 00:19:04,388
There's a lot of stuff that's usuful in here.

224
00:19:04,380 --> 00:19:09,897
CB: I actually like it, it gives you the options
available without having to configure it.

225
00:19:10,148 --> 00:19:13,142
[Sam dictates what he writes]

226
00:19:14,765 --> 00:19:20,068
SP: This is a setting I turn on inaud my spec helpers.

227
00:19:20,060 --> 00:19:24,251
It basically stops RSpec from going away,

228
00:19:24,250 --> 00:19:29,737
and patching methods onto
all objects and classes, whatever.

229
00:19:29,730 --> 00:19:35,508
So it disables the inaud syntax, but it also disables bare describe.

230
00:19:35,657 --> 00:19:48,034
This is a lesser known thing it does, but if we reopen our one spec inaud file, which I deleted,

231
00:19:49,188 --> 00:19:56,342
Require spec helper, and then type inaud describe, like we had before with bundler.

232
00:19:56,834 --> 00:20:05,480
This won't work because we're in main,
we're not in the main object, right.

233
00:20:05,668 --> 00:20:06,857
CB: OK.

234
00:20:06,850 --> 00:20:14,217
SP: So disable monkey patching has
removed describe from module and object.

235
00:20:14,210 --> 00:20:16,205
We're at inaud spider fault.

236
00:20:16,200 --> 00:20:19,497
CB: So why would you recommend inaud these tests.

237
00:20:19,660 --> 00:20:25,314
SP: It's mostly so if you end up writing
an object which has a method called describe,

238
00:20:25,805 --> 00:20:29,108
RSpec doesn't stomp on you, which people actually do.

239
00:20:29,100 --> 00:20:32,742
It' not like describe is such an uncommon word.

240
00:20:32,880 --> 00:20:35,577
And nor should it specifically belong to RSpec.

241
00:20:35,570 --> 00:20:39,840
CB: So is it specifically describe,
or are there other things going on here?

242
00:20:39,840 --> 00:20:47,302
It's a bunch of RSpec DSL methods so
it also removes the example and specify.

243
00:20:48,114 --> 00:20:54,342
And basically those are all aliases of each
other that delegate on to doing the same thing.

244
00:20:54,340 --> 00:20:55,760
CB: They all describe inaud

245
00:20:55,760 --> 00:21:02,868
SP: Yes, but the point is that's it's
better not to have to think about that.

246
00:21:02,860 --> 00:21:07,725
The only trade off is it means you have
to write RSpec.describe at the top of your file.

247
00:21:07,720 --> 00:21:12,457
But once your in here you can write
describe as normal, and the reason for that

248
00:21:12,450 --> 00:21:16,731
is that we're inside inaud we have trust.

249
00:21:17,740 --> 00:21:24,457
We've got out MT test set up and
we need to write first test which will sort of

250
00:21:25,020 --> 00:21:31,977
help us begin to push the feature, which means
we need the method to have it do something.

251
00:21:32,251 --> 00:21:37,000
I think we will start by having
it return a Bond spy object.

252
00:21:38,125 --> 00:21:41,485
We're basically just going to make the class

253
00:21:41,480 --> 00:21:45,805
then assert on getting an
object of the correct type back.

254
00:21:45,897 --> 00:21:51,920
This isn't the best test for where we want
to end up, but it's good enough to begin

255
00:21:51,920 --> 00:21:56,148
bootstrapping it and it will
probably go away at some point as well.

256
00:21:56,308 --> 00:22:03,142
I generally try not to have object type checks
by the time I've done rating my tests but...

257
00:22:03,211 --> 00:22:06,685
CB: But how do you test for inaud if it responds to all of the methods?

258
00:22:07,314 --> 00:22:09,005
Quaks, like, all the Ducks.

259
00:22:09,370 --> 00:22:14,377
SP: Fortunately, there is a protocol in Ruby we can use,

260
00:22:15,062 --> 00:22:20,600
regardless of how pathological
the interface to our object is.

261
00:22:20,994 --> 00:22:27,142
We might end up using that internally as
we're writing... it's the triple equals protocol.

262
00:22:31,070 --> 00:22:36,971
What RSpec does internally is it will
triple equals. the class against the object.

263
00:22:37,005 --> 00:22:43,360
If we say, expect this to be a kind of
that, it will use triple equals to do that.

264
00:22:44,194 --> 00:22:49,405
We don't need to worry about designing
an object that doesn't work against RSpec,

265
00:22:49,400 --> 00:22:56,354
because RSpec really is designed
for all kinds of screwy objects like this

266
00:22:57,702 --> 00:23:04,000
What we are going to end up doing
will end up being similar but more powerful

267
00:23:04,000 --> 00:23:08,468
than, for example to how active
record defines attributes methods.

268
00:23:08,460 --> 00:23:13,108
where, like, they're missing and then
they get defined when you ask for them,

269
00:23:13,100 --> 00:23:16,011
And it's kind of magical, but this should be fine.

270
00:23:16,010 --> 00:23:21,394
So I'm going to say it returns a Bond spy.

271
00:23:21,680 --> 00:23:24,640
Which I need to type correctly!

272
00:23:24,640 --> 00:23:32,445
Bond spy and then we'll
say expect Bond - this is arbitrary,

273
00:23:32,440 --> 00:23:35,280
[Sam thinks]

274
00:23:35,280 --> 00:23:40,262
... to be a kind of Bond spy.

275
00:23:40,365 --> 00:23:49,428
The other thing we need to make
this work is to include Bond into our tests.

276
00:23:49,782 --> 00:24:00,845
And so, we've actually taken a reasonably large
step here, but given that we defined the API earlier,

277
00:24:00,840 --> 00:24:04,868
I sort of want to get that down
into paper before I run the test.

278
00:24:04,860 --> 00:24:09,965
We could have done inaud Bond, watch it fail, call the method, watch it fail,

279
00:24:11,080 --> 00:24:14,080
Watch the class beyond
defined and then define that,

280
00:24:14,114 --> 00:24:18,937
but I think it's useful at this
point to have all that written down.

281
00:24:19,234 --> 00:24:23,337
In the strictest sense, we've skipped
some steps but again I think that's fine.

282
00:24:23,330 --> 00:24:25,668
CB: In the strictest sense, but your also
trying to show me where you're going,

283
00:24:25,660 --> 00:24:29,085
so it's useful to have the API right there.

284
00:24:29,080 --> 00:24:32,628
SP: Sure, alright let's run it and see what happens.

285
00:24:33,130 --> 00:24:41,560
So we failed with undefined method Bond for RSpec inaud Bond, which is great.

286
00:24:41,720 --> 00:24:50,891
So to fix that we can just go to
the bond module, define the method,

287
00:24:50,920 --> 00:24:54,697
and that should get us to the next failure.

288
00:24:55,900 --> 00:24:59,005
Doing that, we still have undefined method Bond,

289
00:24:59,000 --> 00:25:02,788
so let's work out what's
going on to the documentation.

290
00:25:02,780 --> 00:25:03,942
CB: OK

291
00:25:05,302 --> 00:25:08,251
SP: This is pretty standard.

292
00:25:12,800 --> 00:25:18,102
It's probably worth me pointing out here
that I'm totally fine with Googling stuff like this

293
00:25:18,137 --> 00:25:21,165
all the time, even though I should know it.

294
00:25:21,160 --> 00:25:27,200
I think having the stuff offloaded into the
collective brain of the Internet is a good thing.

295
00:25:27,200 --> 00:25:31,508
None of this is what we want, although we could...

296
00:25:31,500 --> 00:25:33,817
CB: Module spy!

297
00:25:33,810 --> 00:25:36,354
SP: No say, [Laughter]

298
00:25:36,350 --> 00:25:38,731
CB: Distance.

299
00:25:38,730 --> 00:25:45,360
SP: I think what we should do here, instead
of screwing around with RSpec too much,

300
00:25:45,360 --> 00:25:50,891
we can have a subject object
which can be included into it.

301
00:25:50,890 --> 00:25:53,874
[Silence]

302
00:25:54,331 --> 00:26:00,914
So here I'm going to do object.new.tap.

303
00:26:01,988 --> 00:26:07,817
And then we're going to extend Bond.

304
00:26:07,810 --> 00:26:10,845
[Silence]

305
00:26:12,434 --> 00:26:16,674
Let's just format this so it makes sense.

306
00:26:16,670 --> 00:26:22,662
Basically, we are going to make a new object,

307
00:26:22,660 --> 00:26:31,760
and then the tap gives us the ability
to mutate that object and then return it.

308
00:26:33,440 --> 00:26:38,948
Sending extend there should work...
I can't remember if extend is private...

309
00:26:42,034 --> 00:26:47,394
So if we do Bond holder.bond arbitrary.

310
00:26:49,211 --> 00:26:52,514
Undefined method bond inaud object... [Sam thinks]

311
00:26:52,510 --> 00:26:56,697
CB: OK, we are extending the
module, are we extending the right thing

312
00:26:56,690 --> 00:27:00,491
and are we requiring the right things?

313
00:27:00,537 --> 00:27:05,622
SP: That's a good question... what's going on here...

314
00:27:05,977 --> 00:27:09,245
CB: I don't know how you are including all your files...

315
00:27:09,240 --> 00:27:13,622
SP: Let's just see if that magically
makes it work... it totally does.

316
00:27:13,620 --> 00:27:19,097
My guess would be, Bond version, the versoion inaud was being loaded,

317
00:27:19,090 --> 00:27:24,868
but not the whole module,
because this file defines the module.

318
00:27:24,860 --> 00:27:29,348
CB: inaud no methods and try to inaud methods over it and not including them.

319
00:27:30,457 --> 00:27:32,660
Ah Ruby....

320
00:27:32,754 --> 00:27:37,657
SP: Yes, even RSpec inaud sometimes.

321
00:27:38,180 --> 00:27:42,640
CB: I do like that it's really explicit though
and you don't have magical things happening,

322
00:27:42,685 --> 00:27:44,994
It's a good thing that it fails.

323
00:27:44,990 --> 00:27:47,645
SP: So if we do this now, does it work?

324
00:27:48,057 --> 00:27:52,948
Yes totally, great, awesome.

325
00:27:52,940 --> 00:27:57,805
It's nice to know Ruby works
how I think it works. [Laughter]

326
00:27:57,800 --> 00:28:01,874
CB: Is there a mysterious thing to tack on the end inaud.

327
00:28:01,920 --> 00:28:07,040
So our test failure was, got
one argument, expected zero,

328
00:28:07,040 --> 00:28:10,491
So we can fix that with inaud name in here.

329
00:28:10,490 --> 00:28:15,520
And we run all the tests and now
we have uninitialized constant, Bond spy.

330
00:28:15,520 --> 00:28:18,102
And now we're cooking.

331
00:28:18,100 --> 00:28:23,451
And so because Bond is the top level of our library,

332
00:28:23,450 --> 00:28:28,388
I'm going to have it pull in
most of the constants we define here.

333
00:28:28,380 --> 00:28:32,502
So we'll require a Bond spy here in just a second.

334
00:28:32,560 --> 00:28:38,594
The reason I'm not going to require
that in the test is... I like to think of...

335
00:28:38,590 --> 00:28:42,640
... at least these really high level
tests of library, as if they're a direct client,

336
00:28:42,640 --> 00:28:49,897
and you're never going to see Bond
spy in your own usage of the library,

337
00:28:49,890 --> 00:28:54,320
It's going to be a detail which is hidden from you.

338
00:28:54,320 --> 00:28:59,280
Your just going to rely on the testing API
that we provide, so you don't need to know about it.

339
00:28:59,310 --> 00:29:03,931
So we'll require it here at
the top level of the library.

340
00:29:03,960 --> 00:29:07,577
If I was planning on
maintaining this library forever,

341
00:29:07,570 --> 00:29:13,222
I would also mark the
Bond spy constant as API private,

342
00:29:13,220 --> 00:29:17,680
so that people knew not
to interface with it directly.

343
00:29:17,760 --> 00:29:29,451
Given this is a toy, we'll add that
require there and we'll make lib bond spy.rp

344
00:29:29,542 --> 00:29:36,840
which will be module bond class spy, that
should be enough to get us to the next test failure.

345
00:29:36,914 --> 00:29:42,411
And right, we've got expected
nil to be a kind of Bond spy.

346
00:29:43,760 --> 00:29:51,508
To satisfy this we can just do bond spy.new and I'm going to thread the inaud through here,

347
00:29:51,520 --> 00:29:56,971
and cheat slightly, and pass that in as well.

348
00:29:56,970 --> 00:30:01,908
So now when we run this
my test should pass... and it does.

349
00:30:01,900 --> 00:30:11,474
So now we've written this new bond spy
class it's probably useful to start writing tests

350
00:30:11,470 --> 00:30:14,822
that describe the
behaviour of this class in detail

351
00:30:14,820 --> 00:30:23,942
before we  pop back up and begin talking about
the library, because I cheated very slightly here.

352
00:30:24,090 --> 00:30:34,560
We could also think about writing
a top level test on the bond library itself.

353
00:30:34,700 --> 00:30:36,775
CB: Alright, what did you have in mind?

354
00:30:36,770 --> 00:30:43,191
SP: So the next test would be 'it responds to all method calls'.

355
00:30:43,786 --> 00:30:50,550
But because this is just like a DSL
that wraps the object construction,

356
00:30:50,610 --> 00:30:54,302
I'm tempted to make these
tests appear on the spy class itself.

357
00:30:55,090 --> 00:31:01,632
They could go in either place and I want
to make sure there's no test duplication as well.

358
00:31:01,790 --> 00:31:04,816
Although the nice thing about
having them on the top level is that it

359
00:31:04,810 --> 00:31:10,544
provides very explicit usage documentation because we're interfacing with the inaud API.

360
00:31:10,672 --> 00:31:13,376
So maybe let's start there.

361
00:31:13,370 --> 00:31:19,424
CB: We can always move them around later on.
SP: That's true.

362
00:31:20,240 --> 00:31:30,400
The next test we're going to write will cover
the entire behaviour work flow of the library.

363
00:31:30,448 --> 00:31:35,160
of the library, now that I think we've got it all connected together,

364
00:31:35,160 --> 00:31:39,712
It's useful to think about how
the library is actually going to work.

365
00:31:39,710 --> 00:31:49,264
So I think an adequate description here
is 'responds to all method calls and records them'.

366
00:31:49,260 --> 00:31:54,256
And we'll write the simplest
possible way to verify that.

367
00:31:54,250 --> 00:32:06,624
So my spy is a bond... these names are arbitrary... inaud method name.

368
00:32:06,700 --> 00:32:12,656
and we need another method for
our library which is creating expectations

369
00:32:12,670 --> 00:32:15,792
for the methods that were actually received.

370
00:32:15,870 --> 00:32:21,456
And that method can't live on the spy
object itself, it needs to live on the library.

371
00:32:21,456 --> 00:32:28,032
And the reason is because the spy object
responds to all method calls and records them.

372
00:32:28,030 --> 00:32:38,288
So bond did you receive? Something like this...

373
00:32:38,528 --> 00:32:40,832
And this could be a symbol, or a string ...

374
00:32:40,830 --> 00:32:45,904
CB: So is this another test because we have the inaud something,

375
00:32:45,936 --> 00:32:52,432
and then we have the action knows how to
tell me whether the things I want have happened.

376
00:32:52,430 --> 00:33:03,504
SP: Yes, the other test we could write is...
it fails the test when it didn't receive a method call.

377
00:33:04,176 --> 00:33:09,088
CB: And this is the usual inaud reception thing which is the default test.

378
00:33:09,080 --> 00:33:15,024
SP: We expect this to raise error, we don't really care about the inaud pass right now.

379
00:33:16,640 --> 00:33:19,472
So this is all the behaviour we probably need.

380
00:33:19,504 --> 00:33:24,112
It's just a case of which one
we want to go after first.

381
00:33:24,256 --> 00:33:30,624
I think it's going to be easier to write small
amounts of code to get the raise error to pass.

382
00:33:30,896 --> 00:33:36,270
Before having to implement
the 'it records everything'.

383
00:33:36,270 --> 00:33:45,120
So for the moment, I'm going to make
this an exit so it doesn't run all our tests.

384
00:33:45,312 --> 00:33:51,536
And so if we run everything now,
we have our return to bond spy.

385
00:33:51,530 --> 00:33:54,016
CB: We've got one that's skipped.

386
00:33:54,010 --> 00:34:01,488
[Sam reads the message on screen].

387
00:34:01,480 --> 00:34:06,144
CB: We're trying to be generic and RSpec is helping us not be inaud.

388
00:34:06,190 --> 00:34:15,040
SP: So, that warning is useful and it's telling
us we need to specify an error class or a message.

389
00:34:15,040 --> 00:34:22,576
And I think what I'll do for the moment,
so we don't get a constant missing failure,

390
00:34:22,608 --> 00:34:36,176
is have an expected to receive,
and then it's this method name.

391
00:34:36,928 --> 00:34:40,464
This is useful because we can just close this other pane for a moment,

392
00:34:40,608 --> 00:34:49,290
we can see that we've now got a tiny bit of
duplication in our test, that I'd like to get rid of.

393
00:34:49,290 --> 00:34:53,872
So we'll lift that into a let.

394
00:34:53,870 --> 00:34:56,896
[Silence]

395
00:34:59,408 --> 00:35:02,432
That can be this erm.....

396
00:35:02,430 --> 00:35:05,440
[Silence]

397
00:35:06,256 --> 00:35:08,752
And then...

398
00:35:10,560 --> 00:35:17,248
Now that expectation and the bond that you receive
have the same string being assigned to them.

399
00:35:17,392 --> 00:35:20,560
It's like 'called out' is
the thing were comparing on.

400
00:35:20,750 --> 00:35:24,800
One thing I like to do,
when writing these kinds of tests,

401
00:35:25,280 --> 00:35:31,008
is call out anything that is going
to be a comparison, into a let,

402
00:35:31,120 --> 00:35:38,896
because where you pass it in your being
extremely explicit that it's the exact same thing.

403
00:35:40,016 --> 00:35:45,664
For example, imagine that we were testing
something that used numbers, and said, that is a 5

404
00:35:45,660 --> 00:35:50,384
Well, there it's much more obvious
that the method names are the same.

405
00:35:50,380 --> 00:35:59,840
But if I have a 5 here and another 5 here,
it's not so explicit that that's what's going on.

406
00:36:01,184 --> 00:36:07,584
So yes, that will be the first test that we
get working, and then we'll look at the other ones.

407
00:36:07,580 --> 00:36:11,936
So if I run this now it's going to fail.

408
00:36:12,016 --> 00:36:17,408
[Sam reads the message on screen]

409
00:36:17,600 --> 00:36:20,944
Which is super useful.

410
00:36:20,940 --> 00:36:25,904
So, that needs to go on bond itself.

411
00:36:27,312 --> 00:36:35,872
It takes a spy or a bond, I think spy is the
wrong name, so this is a spy and this is a method name.

412
00:36:36,640 --> 00:36:41,696
And all we need to do to make this test pass,

413
00:36:41,690 --> 00:36:52,544
is raise expected to receive...

414
00:36:53,600 --> 00:37:00,592
So that is incredibly obvious but
it has caused the test to pass.

415
00:37:00,620 --> 00:37:10,304
So, in the true sense of the word
we've done, like a little bit of tdd inaud,

416
00:37:11,216 --> 00:37:16,890
we've written our test and then we've
done a really stupid thing to make it pass.

417
00:37:17,136 --> 00:37:21,408
CB: OK, how about we inaud some actual logic now. [Laughter]

418
00:37:23,760 --> 00:37:33,488
SP: OK so we've got our easy test passing
with something really simple, the degenerate case.

419
00:37:34,304 --> 00:37:42,368
Now let's re-enable the test
that is expecting a method call to go through

420
00:37:42,360 --> 00:37:47,664
implementing that, so I'll just
delete and then run the tests.

421
00:37:47,776 --> 00:37:54,560
And we get our failure that we were expecting,
undefined this method name for bond spy.

422
00:37:54,560 --> 00:37:58,640
CB: Something interesting happens when your inaud, can you scroll out to er...

423
00:37:59,424 --> 00:38:09,088
SP: Sure, so the test run started here and
what I have set up is, every time I run my tests,

424
00:38:10,480 --> 00:38:17,136
it runs a bunch of git commands to work
out if anything has changed, what's changed,

425
00:38:17,136 --> 00:38:25,920
and then it will run the tests and
depending on whether they pass or fail,

426
00:38:26,576 --> 00:38:32,112
it will move us onto a branch and then
check everything in with status red or green.

427
00:38:32,110 --> 00:38:36,384
CB: Great, so if we check on GitHub now
it's going to be red, red green, red, or...

428
00:38:36,380 --> 00:38:42,912
SP: Yes, like our last test was red
because it failed, and then green red green.

429
00:38:42,910 --> 00:38:45,968
CB: inaud

430
00:38:45,960 --> 00:38:54,832
SP: Sure, we had two greens in a row,
we were stuck in red for a while, that happens.

431
00:38:55,680 --> 00:39:00,940
One thing I tend to observe is,
when I've had an integration test,

432
00:39:00,940 --> 00:39:05,696
you get many more red commits
as your pulling all the pieces together

433
00:39:06,192 --> 00:39:12,110
but then once your beginning to
flow you get a red/green switching.

434
00:39:12,110 --> 00:39:17,728
It's worth noting now that we have this
failing test as we begin to implement this class,

435
00:39:17,744 --> 00:39:23,760
it will be red for quite a while, because
we will be making individual unit tests.

436
00:39:23,904 --> 00:39:26,112
CB: So your just going from
failure to failure to failure.

437
00:39:26,110 --> 00:39:31,536
SP: Yes, but the important thing to
note there is that it's incrementally moving

438
00:39:31,550 --> 00:39:39,664
towards getting things working and we'll have more
green tests at the end of each run, hopefully.

439
00:39:41,360 --> 00:39:46,528
I'm actually going to change this
test very slightly before we carry on.

440
00:39:46,576 --> 00:39:52,880
And it's the same change that we
made before to our failure case test.

441
00:39:52,880 --> 00:39:58,128
Where we called method name into a let.

442
00:39:58,120 --> 00:40:03,488
This test has that same sort of duplication but
it's harder to spot because this is a method call

443
00:40:03,480 --> 00:40:10,176
and this is a piece of data,
but they are indicating the same thing,

444
00:40:10,170 --> 00:40:15,840
so I'm going to change this
to public send on the method name.

445
00:40:15,888 --> 00:40:21,760
And this one to method name as well.

446
00:40:21,904 --> 00:40:26,544
That's just the same as calling the method,
but it eliminates that piece of data duplication.

447
00:40:26,540 --> 00:40:29,024
which I think is useful.

448
00:40:29,020 --> 00:40:32,848
CB: inaud

449
00:40:32,840 --> 00:40:38,496
SP: Well it's the difference between
making sure the method is public

450
00:40:38,490 --> 00:40:43,008
and it being any method on that object.

451
00:40:43,344 --> 00:40:50,480
Tests generally shouldn't reach inside objects
and using public send is one way to achieve that.

452
00:40:50,480 --> 00:40:57,520
CB: So in our case we want it to respond
o public methods and private methods on the spy?

453
00:40:57,520 --> 00:41:05,888
SP: Well our spy doesn't present private methods.

454
00:41:05,880 --> 00:41:09,312
CB: It just responds to everything publicly?

455
00:41:09,310 --> 00:41:15,360
SP: Yes, but no object should
know that that difference exists.

456
00:41:15,360 --> 00:41:22,032
Even if you send a method,
your not caring about it's visibility

457
00:41:22,030 --> 00:41:27,472
There are weird cases around that and we're not
going to think too much about any of them today.

458
00:41:27,530 --> 00:41:35,648
Like what happens if you try and
access the private methods of the spy object.

459
00:41:35,760 --> 00:41:41,568
Mostly because this library is
for interface contract verification

460
00:41:41,560 --> 00:41:48,800
and obviously you don't do
contract verification on private methods.

461
00:41:48,976 --> 00:41:49,984
I think this is fine.

462
00:41:49,980 --> 00:41:54,208
CB: Yes, absolutely, I think it's
just one of those funny things.

463
00:41:54,200 --> 00:41:58,320
SP: So let's just run again
to make sure we're still failing.

464
00:41:58,320 --> 00:42:01,040
An undefined method name for bond spy.

465
00:42:01,040 --> 00:42:07,456
So let's switch to our spy object, it's empty.

466
00:42:07,450 --> 00:42:13,520
And now we're going to start
writing tests for this specific class.

467
00:42:13,600 --> 00:42:18,336
To do that I'm just going to open a vim inaud with the spec file in.

468
00:42:18,330 --> 00:42:22,656
And make sure the directory exists for it.

469
00:42:22,890 --> 00:42:28,256
And now this test is ready to go,
so we'll pull in the spec helper.

470
00:42:28,360 --> 00:42:39,632
Will describe spy and we'll
put this inside the bond module.

471
00:42:39,630 --> 00:42:46,208
That's just so we can reference things without having to put bond inaud in front of everything.

472
00:42:46,400 --> 00:42:53,392
Because we're describing our spy,
we'll immediately make the subject of our test

473
00:42:53,390 --> 00:43:01,024
the spy, and we'll do spy.new, and again
I think this name is arbitrary for the moment.

474
00:43:01,020 --> 00:43:05,008
So we'll just pass in a symbol there.

475
00:43:05,000 --> 00:43:09,104
One thing I tend to do is when I'm inaud values like this,

476
00:43:09,100 --> 00:43:14,160
I use a name like arbitrary, or doesn't matter,
to indicate to anyone that might be reading it

477
00:43:14,160 --> 00:43:21,040
that it's not important to
read too much into that detail.

478
00:43:21,040 --> 00:43:25,776
The moment comparisons begin
to happen, I'll pull that out into a let.

479
00:43:25,770 --> 00:43:30,512
CB: How do you go about
using describe class, in general?

480
00:43:30,768 --> 00:43:40,608
SP: Sure, it's true that putting that
constant in there twice is a bit of a duplication,

481
00:43:40,600 --> 00:43:49,632
but I usually don't care about
that because I think that you get a lot

482
00:43:49,648 --> 00:43:54,032
from explicitly referencing the class.

483
00:43:54,030 --> 00:44:01,296
CB: inaud the favorite part of your files. [Laughter].

484
00:44:02,032 --> 00:44:07,770
SP: Anyway, we need to write
a test now, and usually at this point,

485
00:44:07,770 --> 00:44:13,072
when your writing unit tests, you would
write a test on a specific method name.

486
00:44:13,070 --> 00:44:18,560
But, we have a strange object here in
that we're not testing any specific method name.

487
00:44:18,560 --> 00:44:26,256
We test that it's going to respond to everything,
so that's going to be the name of our describe.

488
00:44:30,280 --> 00:44:34,080
It's very important to consider
how we're going to make this happen,

489
00:44:34,128 --> 00:44:40,256
so I'm going to start with something obvious
and see how we can easily contravene that.

490
00:44:40,380 --> 00:44:47,232
So let's say for the moment that
our method name is method name

491
00:44:47,264 --> 00:44:50,784
and I think we're fine to make this a symbol here.

492
00:44:53,488 --> 00:44:59,568
So firstly, we're going to do
some Ruby level API checking.

493
00:44:59,920 --> 00:45:06,464
Respond to should always return
true for any method on this object.

494
00:45:06,976 --> 00:45:13,152
It should also inaud, but we'll worry about that later.

495
00:45:14,890 --> 00:45:18,784
And this might be a good place to
describe the response to method like this

496
00:45:18,832 --> 00:45:22,656
to indicate that's what were doing.

497
00:45:22,704 --> 00:45:26,490
And there are a couple of things
that are important to note here.

498
00:45:26,752 --> 00:45:32,960
Respond to is actually a
two argument method in Ruby.

499
00:45:32,960 --> 00:45:36,448
Most people implement it with one
argument which is the method name,

500
00:45:36,440 --> 00:45:40,944
but it also takes a inaud true/false, which indicates whether or not the method is private.

501
00:45:41,000 --> 00:45:47,456
but were going to ignore that, but
I just wanted to make sure that's correct.

502
00:45:47,664 --> 00:45:54,192
So because our object responds
to all methods, it's going to return true.

503
00:45:54,190 --> 00:46:01,744
So expect subject.respond
(I can't type) this should be spy.

504
00:46:01,856 --> 00:46:08,256
Respond to method, aim to be true.

505
00:46:08,380 --> 00:46:14,432
And, that should fail in an exciting way.

506
00:46:14,464 --> 00:46:18,750
We need to acquire the constant.

507
00:46:18,750 --> 00:46:21,760
[Silence]

508
00:46:22,704 --> 00:46:26,752
Undefined method, method name for bond spy.

509
00:46:26,960 --> 00:46:32,960
That's our integration test
failing so it's true or false.

510
00:46:32,960 --> 00:46:37,184
At this point we can just make this pass.

511
00:46:40,944 --> 00:46:48,848
Private is a reserved word, I think it would be better if we call inaud method private.

512
00:46:49,024 --> 00:46:53,920
We can just stick the word true
in here and that should work.

513
00:46:53,920 --> 00:46:56,912
[Silence]

514
00:46:56,910 --> 00:46:59,840
Can't have question marks or variable names

515
00:47:00,208 --> 00:47:03,392
CB: I was going to ask about
that, those are pretty cool.

516
00:47:03,390 --> 00:47:09,648
SP: I'm just bad at Ruby.

517
00:47:09,872 --> 00:47:16,192
Right so the method is private,
it's optional, it defaults to false I think.

518
00:47:16,190 --> 00:47:19,440
Let's check that.

519
00:47:21,808 --> 00:47:24,896
Again, never be afraid to Google.

520
00:47:24,890 --> 00:47:30,448
[Sam reads from screen]

521
00:47:30,440 --> 00:47:34,896
CB: Can't include all also mean include private?

522
00:47:34,960 --> 00:47:37,328
Sure, but actually it doesn't matter,

523
00:47:37,344 --> 00:47:41,856
because we're just implementing
this method in the most obvious way.

524
00:47:42,336 --> 00:47:47,296
We will be removing this
definition in a bit, but for the moment

525
00:47:47,290 --> 00:47:51,760
this is just enough to get us going.

526
00:47:52,624 --> 00:47:58,656
So that test now passes and
our integration test is still failing.

527
00:47:58,650 --> 00:48:07,680
So now we've set it up to respond we
need to describe what happens when it returns.

528
00:48:07,760 --> 00:48:13,520
And I'm going to say that it
returns self because that's our...

529
00:48:13,520 --> 00:48:16,800
CB: Yes, it's going to be useful to do inaud.bar type.

530
00:48:17,008 --> 00:48:19,520
SP: Yes, so we can dot chain.

531
00:48:19,744 --> 00:48:22,704
[Silence]

532
00:48:25,296 --> 00:48:33,728
[Sam dictates what he writes on screen]

533
00:48:34,480 --> 00:48:40,736
It's probably worth noting here, that the reason I'm using B here instead of inaud

534
00:48:41,040 --> 00:48:46,480
is that B does exact object comparison
so we know it's definitely the same object.

535
00:48:46,512 --> 00:48:47,968
CB: It's an object ID whereas....

536
00:48:47,960 --> 00:48:49,568
SP: Yes not just one that compares.

537
00:48:49,560 --> 00:48:53,504
CB: So behind the scenes B is comparing
objects, what's the actual implementation here.

538
00:48:53,568 --> 00:48:58,160
SP: It delegates onto something in Ruby.

539
00:48:58,160 --> 00:49:04,560
I can't remember exactly,
but that's the desired media.

540
00:49:04,752 --> 00:49:11,984
So if we run that it's going to fail
with undefined method name for bond spy.

541
00:49:12,192 --> 00:49:21,392
And here's where I'm going to be
adversarial in the way I do my implementation.

542
00:49:21,568 --> 00:49:23,968
So I'm actually just going to write the method.

543
00:49:23,960 --> 00:49:27,952
CB: Oh of course, inaud to make it pass.

544
00:49:27,950 --> 00:49:34,144
SP: Totally, and now I can blow away
my respond to definition and run this.

545
00:49:34,140 --> 00:49:40,992
And those test should pass, and they
do, only our integration test has failed.

546
00:49:43,100 --> 00:49:50,960
What we're seeing is, because this
method name is static we're never going to

547
00:49:51,008 --> 00:49:57,344
be able to force the implementation of
the spy via test to respond to everything.

548
00:49:57,664 --> 00:50:01,616
So we need a more powerful construct here.

549
00:50:01,610 --> 00:50:07,312
My understanding is that in Ruby
basically any string is a valid method.

550
00:50:07,310 --> 00:50:14,176
Valid method name if you
use send [they both talk at once].

551
00:50:14,544 --> 00:50:20,128
There's that fun gist like when you
define imogee as your method names.

552
00:50:20,656 --> 00:50:26,960
So I'm going to treat this
like the tests are external.

553
00:50:26,960 --> 00:50:29,584
Entirely external to the object.

554
00:50:30,224 --> 00:50:36,400
So we can use secure random.hex to pass the method in.

555
00:50:36,680 --> 00:50:42,288
Because the object has no way of knowing
in advance what that method name is going to be.

556
00:50:42,304 --> 00:50:44,368
So you can't fake it out.

557
00:50:44,360 --> 00:50:46,848
CB: So you're randomizing a method name.

558
00:50:47,136 --> 00:50:49,872
Silly question but can you have a method as such inaud that?

559
00:50:49,870 --> 00:50:55,456
SP: I believe so, as long as you use
define method I think any string is valid.

560
00:50:55,520 --> 00:50:59,920
If we get errors we can just
stick a letter on the front of it.

561
00:51:00,000 --> 00:51:04,464
But this seems like a reasonable place
to start, so we'll just stick that in there.

562
00:51:05,184 --> 00:51:08,992
And we'll require the secure random.

563
00:51:09,424 --> 00:51:13,968
At this point I expect both of these tests to fail.

564
00:51:13,960 --> 00:51:21,008
And they do, with false and
undefined method 916 etc 4 bond spy.

565
00:51:21,056 --> 00:51:29,376
So now both of our tests are putting pressure
on us to come up with a better representation.

566
00:51:29,370 --> 00:51:33,632
It seems to me the best thing to
do here is to use method messing,

567
00:51:33,936 --> 00:51:39,488
in order to define the behaviour
which will work for any method.

568
00:51:39,480 --> 00:51:45,200
inaud

569
00:51:45,232 --> 00:51:48,960
We have a method missing but here we are.

570
00:51:48,960 --> 00:51:53,200
CB: I can't believe I'm going to let someone do inaud

571
00:51:53,200 --> 00:51:57,216
SP: So the inaud method missing is it takes the method name

572
00:51:57,210 --> 00:52:02,304
and then the ARGS that were
passed to the method in a block.

573
00:52:02,944 --> 00:52:06,768
And we specified that we were going to
return self, so we'll stick self in there for a moment.

574
00:52:06,760 --> 00:52:10,704
And then the other thing we need to do is make the inaud check work.

575
00:52:10,720 --> 00:52:15,210
To do that we could override
respond to and return true.

576
00:52:15,790 --> 00:52:19,296
But that's not strictly correct.

577
00:52:19,312 --> 00:52:26,528
Ruby provides us with a hook to tell it about
method missing implementations that we support.

578
00:52:26,520 --> 00:52:32,096
That's the method respond to missing,
which is invoked as part of respond to checks,

579
00:52:32,090 --> 00:52:36,688
and as part of method missing dispatch to
know whether or not we actually respond to that.

580
00:52:36,680 --> 00:52:44,368
So I think the signature is method name
and visibility but we should check that.

581
00:52:44,360 --> 00:52:50,736
In fact we happen to be right there,
thanks Google, include all true or false.

582
00:52:50,864 --> 00:52:59,152
We're actually not going to use that
property and the property is not optional

583
00:52:59,150 --> 00:53:05,568
so we don't need to pass a default.

584
00:53:05,808 --> 00:53:12,976
Great, so if we run our tests now, hopefully we'll have
that one failure, which is our integration test.

585
00:53:13,216 --> 00:53:15,520
And the rest are working.

586
00:53:15,520 --> 00:53:18,656
[New Chapter]

587
00:53:19,024 --> 00:53:24,640
So we've now got that first piece
of behaviour working on our spy object.

588
00:53:24,640 --> 00:53:27,984
It's responding to everything, it's returning self.

589
00:53:27,980 --> 00:53:33,808
Let's just pop back to our integration
test and check where we're at.

590
00:53:33,920 --> 00:53:36,896
We still haven't done this
bond did you receive method.

591
00:53:36,890 --> 00:53:47,024
So if we run that we can see...
expect to receive method name.

592
00:53:47,040 --> 00:53:50,040
CB: Is that because we're including
something that has all the methods?

593
00:53:50,940 --> 00:53:55,424
SP: So we're getting this failure because
we implemented one did you receive

594
00:53:55,440 --> 00:53:58,912
to automatically raise
whenever the method is sent.

595
00:53:58,960 --> 00:54:07,536
Now we need to go back into that method
and begin to change it to make that work.

596
00:54:07,712 --> 00:54:13,296
And in order to do that we're going to
have to do a couple of things to the spy class,

597
00:54:13,290 --> 00:54:16,864
But let's not get ahead of ourselves.

598
00:54:17,136 --> 00:54:24,384
So here, we really need to ask
the question, "if the spy receives the method"

599
00:54:24,496 --> 00:54:29,840
then do nothing, otherwise raise, that can be inaud less.

600
00:54:32,016 --> 00:54:37,296
And then we need to think
about how (they both talk at once).

601
00:54:39,200 --> 00:54:42,208
CB: How do you feel about that interface?

602
00:54:42,200 --> 00:54:45,648
SP: Well, we're going to
change the interface a little bit.

603
00:54:45,640 --> 00:54:49,072
CB: So how do you see the method on the spy, how do you...

604
00:54:49,216 --> 00:54:54,832
SP: Let's just start poking towards it, right.

605
00:54:55,184 --> 00:54:58,224
We're going to make this method
private, that is an implementation detail,

606
00:54:58,220 --> 00:55:01,152
nothing else really cares about it.

607
00:55:02,832 --> 00:55:05,664
[Sam dictates what he writes on screen]

608
00:55:06,110 --> 00:55:12,608
Now we have a problem and that is,

609
00:55:12,730 --> 00:55:21,504
we've defined the public interface of the
spy to respond to everything all the time, forever,

610
00:55:21,968 --> 00:55:30,368
so we can't add method to our spy to allow us to
interface with the calls that are being made to it.

611
00:55:30,360 --> 00:55:32,608
We need something else.

612
00:55:32,600 --> 00:55:40,768
So I'm going to change the construction
of spies to include another object.

613
00:55:41,488 --> 00:55:43,232
Which we are going to call proxy.

614
00:55:43,310 --> 00:55:49,616
And we'll then ask the proxy object
for each spy what's happened to it

615
00:55:49,616 --> 00:55:51,040
during the execution of the test.

616
00:55:51,040 --> 00:55:53,312
CB: So you still have your spy
that responds to all the things,

617
00:55:53,310 --> 00:55:56,976
and there's also the proxy thing that
will have methods along the the lines of

618
00:55:57,040 --> 00:56:01,712
have you received the method, and that
thing is going to be keeping terms on the spy

619
00:56:01,760 --> 00:56:05,648
to check that the right things have happened
without messing around with the methods on the spy.

620
00:56:05,690 --> 00:56:08,080
SP: Exactly.

621
00:56:08,080 --> 00:56:10,752
CB: Is that how RSpec works behind the scenes?

622
00:56:10,750 --> 00:56:17,984
SP: Kind of, but it's a little
bit more complicated than that.

623
00:56:18,090 --> 00:56:20,400
But this is a good approximation.

624
00:56:20,416 --> 00:56:27,872
Basically in RSpec, whenever you stub a
mock on an object or you create a double or a spy,

625
00:56:28,000 --> 00:56:35,408
a companion object is created for
that object which tracks a bunch of details

626
00:56:35,400 --> 00:56:41,408
about methods that have been
replaced and called and arguments and stuff.

627
00:56:41,504 --> 00:56:47,856
We're going to implement some of that, but because
this library has a lower complexity boundary,

628
00:56:47,850 --> 00:56:55,392
and also because it doesn't tough user objects,
we're going to get away with doing a lot less.

629
00:56:55,584 --> 00:57:04,144
So when we construct our spies we're
going to need one of these proxy objects.

630
00:57:04,140 --> 00:57:09,216
And we need to be able to get it back afterwords.

631
00:57:09,328 --> 00:57:21,856
So in the bond module I'm going
to have registered proxys hash.

632
00:57:22,544 --> 00:57:26,400
This is going to be really simple for the moment.

633
00:57:26,560 --> 00:57:29,568
[Silence]

634
00:57:34,688 --> 00:57:37,040
CB: Why are you hesitating on this one?

635
00:57:37,040 --> 00:57:43,088
SP: I'm trying to remember if this
wants to be single 'at' or a double 'at'.

636
00:57:43,232 --> 00:57:47,328
inaud proxys with the memorization.

637
00:57:47,320 --> 00:57:52,560
Which probably means that there's a design problem.

638
00:57:53,712 --> 00:57:59,392
I'm going to do something
really gross and I'm going to fix it.

639
00:57:59,664 --> 00:58:02,672
[Sam dictates what he writes]

640
00:58:04,140 --> 00:58:07,504
CB: Ok, so your making an
object to keep your proxys open.

641
00:58:07,500 --> 00:58:13,648
SP: Yes, we're going to make an object and use the single inaud module.

642
00:58:14,928 --> 00:58:21,530
Which is gross but it seems
like a reasonable place to start.

643
00:58:21,888 --> 00:58:25,792
Actually, the other thing we could do...

644
00:58:26,640 --> 00:58:39,360
is just have a... this... and then we can
reference bond concom proxys and do things to it

645
00:58:39,360 --> 00:58:42,688
just until we're working,
and then we can reflect on it.

646
00:58:44,672 --> 00:58:48,400
CB: When you have an idea like this or something
you definitely want to get rid of in the future,

647
00:58:48,400 --> 00:58:52,880
Do you lead yourself or comment
yourself or something like that?

648
00:58:54,368 --> 00:59:02,768
SP: The real problem here is that
this is a module and not an object.

649
00:59:02,940 --> 00:59:06,976
Maybe we should fix that at some
point, but the nice thing about modules

650
00:59:06,992 --> 00:59:11,328
is that they can just be included into the tests.

651
00:59:11,968 --> 00:59:16,112
Actually, no I think this should be a class variable.

652
00:59:16,688 --> 00:59:20,400
I think I like this more.

653
00:59:20,640 --> 00:59:23,664
[Silence]

654
00:59:25,200 --> 00:59:29,504
CB: Let's see where it takes us and
we can consider the pros and cons in a bit.

655
00:59:29,500 --> 00:59:34,096
SP: I'm pretty sure that a single app would work there.

656
00:59:34,090 --> 00:59:39,120
Mostly because it's going to happen
during the execution of a single test.

657
00:59:40,736 --> 00:59:43,616
CB: So you would re-register
your proxys on every single run?

658
00:59:43,610 --> 00:59:48,672
SP: Yes, this could just be an instance
method, it doesn't need to be a class method,

659
00:59:48,720 --> 00:59:51,248
and that should work fine.

660
00:59:51,240 --> 00:59:57,968
One thing RSpec does is keep track of proxys
globally, but we don't need to worry about that here.

661
00:59:57,960 --> 01:00:01,104
So this should work just fine.

662
01:00:01,168 --> 01:00:07,536
And then we need to create and
register a proxy object for each spy.

663
01:00:07,584 --> 01:00:11,488
So to do that we'll parse... [Sam types]

664
01:00:16,288 --> 01:00:23,440
We're actually going to do...
this is going to be slightly nuts.

665
01:00:23,744 --> 01:00:32,304
So we're going to pass a lambda
into the spy, which will call itself.

666
01:00:32,448 --> 01:00:44,976
So this is the spy, and then we do
register proxies [Sam dictates what he writes]

667
01:00:44,970 --> 01:00:51,408
This line of code has gone
terrible so let's just pull that out.

668
01:00:53,408 --> 01:00:57,856
And in fact we can give this a
method name, this is a proxy factory.

669
01:01:02,576 --> 01:01:06,352
So basically...

670
01:01:09,136 --> 01:01:12,752
And actually, this isn't a factory, it's a callback

671
01:01:15,472 --> 01:01:17,792
CB: Oh good point.

672
01:01:17,790 --> 01:01:22,528
So basically...

673
01:01:22,520 --> 01:01:25,536
[Silence]

674
01:01:29,952 --> 01:01:32,368
We need proxy to be returned from the left.

675
01:01:32,360 --> 01:01:40,624
So, this looks slightly crazy so it's
worth explaining what this is going to do.

676
01:01:40,768 --> 01:01:45,152
[Sam thinks]

677
01:01:45,950 --> 01:01:55,056
When we call the proxy callback in the
spy it will pass the spy in so that we can basically

678
01:01:55,070 --> 01:01:59,792
look the proxy up by the spy object
itself later in the execution of the test.

679
01:01:59,950 --> 01:02:04,480
I'm just trying to think about whether
we need to immediately cover this with

680
01:02:04,528 --> 01:02:06,480
unit test coverage before we move on.

