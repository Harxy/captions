1
00:00:01,450 --> 00:00:02,710
Welcome to Peer to Peer

2
00:00:02,820 --> 00:00:05,650
where you can watch how
experts solve tech problems.

3
00:00:06,480 --> 00:00:08,640
Our guest today is Tom Stuart,

4
00:00:08,680 --> 00:00:12,720
author of Understanding
Computation and veteran Rubyist.

5
00:00:13,140 --> 00:00:15,146
I'm your host Drew Neil,

6
00:00:15,170 --> 00:00:17,450
and the challenge
I've set for Tom is called ...

7
00:00:17,450 --> 00:00:19,450
Counting Tree Nodes.

8
00:00:21,940 --> 00:00:25,020
DN: So Tom would you like
to start by reading out the problem.

9
00:00:25,020 --> 00:00:26,493
TS: Sure, it says:

10
00:00:26,666 --> 00:00:28,906
Model a tree of max depth 5

11
00:00:29,200 --> 00:00:32,293
Given a collection of such trees,
let me sort by these properties:

12
00:00:32,293 --> 00:00:33,906
Total number of ancestors,

13
00:00:34,040 --> 00:00:35,760
Total number of terminals,

14
00:00:36,106 --> 00:00:40,573
These totals should be correct following
any operation that adds or removes a node.

15
00:00:40,573 --> 00:00:42,110
OK.

16
00:00:42,110 --> 00:00:43,240
DN: Is that clear?

17
00:00:43,240 --> 00:00:45,320
TS: Well ... I'm not entirely sure

18
00:00:45,333 --> 00:00:48,386
what you mean by
either of those things.

19
00:00:48,386 --> 00:00:52,093
By terminals do you
mean leaves of the tree?

20
00:00:53,140 --> 00:00:56,253
DN: Ok, so a leaf can be
anything that has no children.

21
00:00:56,880 --> 00:01:00,000
By terminal I mean a
leaf at the maximum depth.

22
00:01:00,480 --> 00:01:02,826
It's a leaf that cannot have any children.

23
00:01:04,110 --> 00:01:07,200
In fact if you turn to the
next page there's an illustration.

24
00:01:11,000 --> 00:01:13,480
There we have the root at the center

25
00:01:13,510 --> 00:01:15,666
and then there's 4 concentric circles.

26
00:01:15,710 --> 00:01:19,840
I've said max depth 5, you might
prefer to call it max depth 4

27
00:01:21,600 --> 00:01:24,420
depending on whether you
call the root a level or not.

28
00:01:26,080 --> 00:01:28,186
In that picture the terminals are the ones

29
00:01:28,200 --> 00:01:30,400
farthest from the root, pictured in red.

30
00:01:31,940 --> 00:01:33,420
The blue ones are ancestors.

31
00:01:33,420 --> 00:01:34,970
Some of them happen to be leaves,

32
00:01:34,970 --> 00:01:36,746
some of them do have children

33
00:01:37,693 --> 00:01:41,080
but it's only a terminal if
it's on the outermost ring and

34
00:01:41,093 --> 00:01:44,280
it's not possible for it have any more children.

35
00:01:44,740 --> 00:01:47,080
TS: Well this answers
my other two questions.

36
00:01:47,080 --> 00:01:49,173
One was what you meant by depth

37
00:01:49,173 --> 00:01:52,880
because from the problem description

38
00:01:52,940 --> 00:01:57,573
I didn't know if you were
including the root in that.

39
00:01:57,600 --> 00:02:00,253
If I remember my
graph theory correctly,

40
00:02:01,013 --> 00:02:05,680
one of the measures in
any tree is depth but I think

41
00:02:05,706 --> 00:02:08,280
it's about how many
edges you have to traverse

42
00:02:08,280 --> 00:02:10,450
whereas that's not
exactly what you want.

43
00:02:10,450 --> 00:02:13,426
So you're talking about
how many fence posts there are

44
00:02:13,420 --> 00:02:15,973
not how many spaces
between the fence posts.

45
00:02:15,973 --> 00:02:17,310
DN: Yes.

46
00:02:17,310 --> 00:02:19,853
OC: And I was going to
ask you about ancestors.

47
00:02:19,866 --> 00:02:23,490
This here is not what I expected.

48
00:02:23,600 --> 00:02:25,600
I thought by ancestors you would mean

49
00:02:26,200 --> 00:02:27,826
nodes that had children

50
00:02:28,800 --> 00:02:33,733
since an ancestor is
your parents' parents etc.

51
00:02:33,893 --> 00:02:35,420
DN: So you're looking upward.

52
00:02:37,280 --> 00:02:41,466
OC: But this is looking
at the root as being .....

53
00:02:45,680 --> 00:02:47,626
I'd use the word descendants for that.

54
00:02:47,626 --> 00:02:50,160
DN: Yes that's obviously a
better word. (laughter)

55
00:02:50,173 --> 00:02:53,440
It doesn't matter ....

56
00:02:55,510 --> 00:02:57,370
TS: Do I need to
know what this is for.

57
00:02:57,370 --> 00:02:59,813
Is this the entire
scope of the problem?

58
00:03:02,140 --> 00:03:04,000
DN: Yes, but if you feel it's too much

59
00:03:04,020 --> 00:03:07,040
we can make it sortable by one of those fields.

60
00:03:07,600 --> 00:03:09,310
You can pick whichever you like.

61
00:03:09,320 --> 00:03:13,546
TS: One more question.
The count you've called ancestors

62
00:03:13,546 --> 00:03:17,346
is how many nodes
there are in the tree

63
00:03:17,786 --> 00:03:19,000
apart from the root.

64
00:03:19,020 --> 00:03:19,893
DN: Yes.

65
00:03:21,910 --> 00:03:23,850
TS: I'm hoping that that will always be

66
00:03:24,340 --> 00:03:27,013
the number of nodes
in the tree minus one

67
00:03:27,173 --> 00:03:29,546
because you're not considering the root.

68
00:03:29,546 --> 00:03:30,213
DN: Exactly.

69
00:03:31,620 --> 00:03:35,013
TS: Is the absolute value
of that number important

70
00:03:35,080 --> 00:03:36,680
or is just its relative values?

71
00:03:36,680 --> 00:03:39,620
For example if we did
count the root would that matter,

72
00:03:39,620 --> 00:03:41,820
or is the only reason
to count this number

73
00:03:41,820 --> 00:03:43,140
so you can sort the trees?

74
00:03:45,650 --> 00:03:47,850
DN: Yes, it is so that
you can sort the trees.

75
00:03:48,650 --> 00:03:50,940
TS: Presumably it's not
going to be a problem

76
00:03:50,940 --> 00:03:53,350
to subtract one from
whatever that number is.

77
00:03:53,360 --> 00:03:55,130
DN: I've used the word ancestors but

78
00:03:55,130 --> 00:03:57,430
if you want to call them descendants,

79
00:03:57,440 --> 00:04:00,430
forget that I ever called
them ancestors (laughter).

80
00:04:01,190 --> 00:04:03,730
TS: It's tempting to
go with the terminology

81
00:04:03,850 --> 00:04:05,260
that you've presented here

82
00:04:05,260 --> 00:04:06,850
unless you feel uncomfortable with it.

83
00:04:06,870 --> 00:04:09,880
If you want to change
the problem then do so.

84
00:04:10,020 --> 00:04:11,650
DN: Yes, let's change the problem

85
00:04:11,680 --> 00:04:12,970
and call them descendants.

86
00:04:15,780 --> 00:04:16,750
TS: Shall we get started then?

87
00:04:16,760 --> 00:04:18,140
DN: Let's do that.

88
00:04:22,220 --> 00:04:23,680
OK, I'm going to make a ....

89
00:04:23,820 --> 00:04:25,630
let's call it trees.

90
00:04:34,310 --> 00:04:36,170
I would like to start by ...

91
00:04:40,410 --> 00:04:43,310
clarifying what we want in here

92
00:04:43,310 --> 00:04:44,940
by writing an acceptance test.

93
00:04:45,020 --> 00:04:47,020
So I'm going to use cucumber for that.

94
00:04:47,810 --> 00:04:51,530
Let me be strange about this ...

95
00:04:57,650 --> 00:05:00,000
This might take a
while to install cucumber.

96
00:05:00,000 --> 00:05:02,310
I should have done
it before we started.

97
00:05:11,480 --> 00:05:13,770
Ordinary I would use cucumber

98
00:05:13,770 --> 00:05:15,650
when I'm building a web application.

99
00:05:15,650 --> 00:05:17,220
It's an obvious
benefit for me

100
00:05:17,220 --> 00:05:18,940
to have all that
stuff written down.

101
00:05:18,950 --> 00:05:20,550
More tenuous here I think

102
00:05:21,370 --> 00:05:22,970
but I'm just
going to go with it

103
00:05:23,000 --> 00:05:25,080
because it will give
me an opportunity

104
00:05:25,080 --> 00:05:27,080
to write down the problem

105
00:05:27,080 --> 00:05:28,800
before I start thinking about it.

106
00:05:29,600 --> 00:05:32,390
So to crystallize that
conversation we just had ...

107
00:05:32,390 --> 00:05:33,420
about what you mean.

108
00:05:35,450 --> 00:05:38,500
So I'm going to run Cucumber.

109
00:05:43,850 --> 00:05:48,400
And now it will
hopefully run zero scenarios.

110
00:05:48,710 --> 00:05:49,830
I'm going to make ....

111
00:05:52,570 --> 00:05:55,120
what shall we call it, a trees feature?

112
00:05:55,540 --> 00:05:57,620
I suppose the actual feature that we're

113
00:05:57,620 --> 00:05:59,880
talking about is the ability to sort them.

114
00:05:59,900 --> 00:06:01,880
So I'll call that sorting feature.

115
00:06:03,080 --> 00:06:05,510
So feature sorting trees ....

116
00:06:05,730 --> 00:06:07,490
and I suppose I'm
going to be writing this

117
00:06:07,500 --> 00:06:08,860
from the point of view of.....

118
00:06:10,570 --> 00:06:13,080
ordinarily, if you're writing an
acceptance test for a web application

119
00:06:13,080 --> 00:06:16,100
you would be thinking
about a particular kind of user,

120
00:06:17,920 --> 00:06:22,880
From the perspective of
a client of an API

121
00:06:22,930 --> 00:06:26,120
You haven't said there has
to be buttons to be clicked on.

122
00:06:26,130 --> 00:06:27,420
So I'm going to say:

123
00:06:27,420 --> 00:06:32,180
"as a user of the tree data structure".

124
00:06:33,450 --> 00:06:36,960
I want to be able to sort collections of trees.

125
00:06:36,960 --> 00:06:39,420
by various criteria.

126
00:06:40,940 --> 00:06:42,150
so that ...

127
00:06:42,150 --> 00:06:43,650
I don't really know why,

128
00:06:43,820 --> 00:06:45,910
it's just part of
the problem statement.

129
00:06:45,930 --> 00:06:46,800
I'm going to say:

130
00:06:46,800 --> 00:06:51,440
So that my collections are in the right order.

131
00:06:51,660 --> 00:06:54,310
In a real situation I
would interrogate you further

132
00:06:54,310 --> 00:06:57,140
about why you want these
trees to be in the right order.

133
00:07:02,760 --> 00:07:04,510
TS: So one of your scenarios was

134
00:07:08,940 --> 00:07:13,170
sort by total
number of descendants.

135
00:07:24,170 --> 00:07:31,820
Your other one was sort
by total number of terminals.

136
00:07:38,800 --> 00:07:41,410
Given that I have a collection of trees

137
00:07:54,140 --> 00:07:58,200
Let's say when I sort it by
total number of descendants,

138
00:07:58,200 --> 00:08:01,530
then it should be ordered by...

139
00:08:01,540 --> 00:08:04,320
DN: 'It' being the collection
rather than an individual tree?

140
00:08:04,340 --> 00:08:06,220
TS: Does that make sense?

141
00:08:06,226 --> 00:08:07,333
DN: Yes it does.

142
00:08:07,400 --> 00:08:09,080
TS: That pronoun is referring to

143
00:08:09,080 --> 00:08:11,110
the thing I was talking about before.

144
00:08:11,850 --> 00:08:14,910
So this is going to be exactly the same,

145
00:08:15,850 --> 00:08:21,960
but this will say sorted
by total number of terminals.

146
00:08:22,680 --> 00:08:24,940
And this will be total
number of terminals.

147
00:08:25,370 --> 00:08:26,600
Are you happy with that?

148
00:08:26,600 --> 00:08:27,480
DN: Yes that's fine.

149
00:08:32,220 --> 00:08:34,680
TS: think I will
change this to 'the collection'

150
00:08:34,680 --> 00:08:39,990
just because... Are we sorting the
nodes of the tree or the collection?

151
00:08:40,340 --> 00:08:42,540
DN: The collection
is what we are sorting.

152
00:08:49,820 --> 00:08:53,550
TS: So that's slightly more
verbose but hopefully clearer,

153
00:08:54,910 --> 00:08:56,020
which is what we want.

154
00:08:56,420 --> 00:08:57,930
I'll run that feature.

155
00:09:03,650 --> 00:09:06,740
It has complained that I
haven't defined these steps

156
00:09:06,750 --> 00:09:08,520
and it has given me everything I need

157
00:09:08,530 --> 00:09:15,320
so I will make a features step definitions.

158
00:09:16,980 --> 00:09:19,440
Tree steps file.

159
00:09:22,000 --> 00:09:24,420
DN: You're using Control P
there to create a file.

160
00:09:24,420 --> 00:09:26,890
TS: Yes. By hitting control Y.

161
00:09:29,140 --> 00:09:33,390
And it creates all
the parent directories.

162
00:09:33,650 --> 00:09:36,520
It saves me
dropping to the terminal.

163
00:09:36,890 --> 00:09:39,000
DN: Yes a good user interface.

164
00:09:42,540 --> 00:09:44,910
Before I start
implementing these, I can see

165
00:09:45,740 --> 00:09:47,540
that I've got a couple of when steps

166
00:09:47,710 --> 00:09:49,310
that are essentially the same.

167
00:09:49,650 --> 00:09:51,600
They differ only
in their final word.

168
00:09:52,140 --> 00:09:53,600
And ditto these.

169
00:09:53,600 --> 00:09:55,820
It's bothering me
that I don't know

170
00:09:55,820 --> 00:09:59,160
what the correct
spelling of descendants is.

171
00:10:00,420 --> 00:10:02,030
I'm going to look it up.

172
00:10:03,420 --> 00:10:06,630
I'm sure that's
right but to be sure ....

173
00:10:06,740 --> 00:10:10,350
Yes that's right.

174
00:10:11,800 --> 00:10:13,410
I am much more confident now.

175
00:10:17,740 --> 00:10:20,800
When I write this I want
there to be a block argument here

176
00:10:20,820 --> 00:10:26,150
that says something
like 'order by' and then,

177
00:10:26,940 --> 00:10:29,280
to keep this compact, I'm going to say

178
00:10:29,290 --> 00:10:31,400
case order by and I'm expecting

179
00:10:31,400 --> 00:10:34,220
there to be a descendants case,

180
00:10:34,280 --> 00:10:37,740
and a terminals
case, so I don't end up

181
00:10:37,970 --> 00:10:41,260
duplicating what I'm doing here.

182
00:10:41,600 --> 00:10:44,090
This will just be anything...

183
00:10:44,110 --> 00:10:46,080
Oh! well I should
have done that here.

184
00:10:48,530 --> 00:10:51,650
So when I sort my collection
by total number of 'something',

185
00:10:51,650 --> 00:10:53,430
and then I can
put my code in there.

186
00:10:53,440 --> 00:10:56,340
There's going to be
something very similar here I think.

187
00:10:59,600 --> 00:11:02,650
This is going to be 'Something'.

188
00:11:04,000 --> 00:11:04,450
and then:

189
00:11:06,620 --> 00:11:08,600
So that's the
skeleton of what we want.

190
00:11:10,850 --> 00:11:14,413
In here I want to have
trees be equal to something.

191
00:11:16,740 --> 00:11:18,200
So that's my first challenge.

192
00:11:22,220 --> 00:11:24,940
I suppose here I will
write the code that I wish I had.

193
00:11:26,880 --> 00:11:29,653
Although that's not
terribly straight forward.

194
00:11:33,370 --> 00:11:36,080
In order for us to
verify that this code is working.

195
00:11:36,080 --> 00:11:38,080
what I don't want to do is things like

196
00:11:39,200 --> 00:11:41,050
make a random collection of trees,

197
00:11:41,050 --> 00:11:43,680
and then ask the API to sort them.

198
00:11:43,706 --> 00:11:45,650
and then go through
and say, "when I ask each

199
00:11:45,650 --> 00:11:48,570
of those trees what
their total number of ancestors is"

200
00:11:48,570 --> 00:11:50,510
then it's increasing because that would not

201
00:11:50,510 --> 00:11:52,540
tell me that my code is working correctly.

202
00:11:52,540 --> 00:11:54,820
It would just verify that
the code that I've written

203
00:11:54,820 --> 00:11:56,650
did the same as the code that I've written.

204
00:11:56,650 --> 00:11:59,000
I would like you and I to agree on

205
00:11:59,000 --> 00:12:01,020
some representative collection of trees,

206
00:12:01,020 --> 00:12:04,310
which to begin with is in an
arbitrary order that we determine.

207
00:12:04,800 --> 00:12:09,600
And then for us to decide what
order that collection SHOULD be in

208
00:12:09,613 --> 00:12:11,306
after it's been sorted..

209
00:12:11,300 --> 00:12:12,906
DN: Yes, OK.

210
00:12:17,940 --> 00:12:22,000
I would like to initialize
a few representative trees,

211
00:12:22,000 --> 00:12:23,973
and then put them into the collection.

212
00:12:23,986 --> 00:12:28,026
So I would like this to be something like trees equals

213
00:12:28,020 --> 00:12:30,826
small tree, large tree ...

214
00:12:30,826 --> 00:12:32,770
DN:  We could also have a shallow tree,

215
00:12:32,770 --> 00:12:35,226
one that has no terminals or ...

216
00:12:35,310 --> 00:12:38,440
TS: And then with the intention being that

217
00:12:38,710 --> 00:12:41,333
down here, we would say:

218
00:12:41,650 --> 00:12:49,693
"expect trees to be equal to
things that are in a different order".

219
00:12:49,706 --> 00:12:50,280
DN: Yes.

220
00:12:50,280 --> 00:12:54,600
TS: And that will hopefully
verify that things are working.

221
00:12:56,400 --> 00:12:58,200
DN: Three seems like a good number.

222
00:12:58,200 --> 00:12:59,626
TS: Are you sure, OK.

223
00:13:01,250 --> 00:13:03,050
TS: Let's see how many we can think of.

224
00:13:06,450 --> 00:13:10,386
So you want them to be of maximum depth,

225
00:13:10,400 --> 00:13:14,773
and have, at most 5 nodes,
counting from the root node.

226
00:13:14,800 --> 00:13:15,770
DN: Yes that's right.

227
00:13:15,770 --> 00:13:20,760
So that's 4 edges in the path
from the root to the most distant leaf.

228
00:13:25,540 --> 00:13:28,420
So they don't have to go
all the way out to the periphery.

229
00:13:28,420 --> 00:13:29,370
DN: They don't.

230
00:13:29,850 --> 00:13:33,213
Those would be unfinished fences, if you like.

231
00:13:34,333 --> 00:13:38,280
TS: Fences! (laughter)

232
00:13:41,250 --> 00:13:47,200
Let's just say the simplest
possible tree is just one node.

233
00:13:50,910 --> 00:13:52,640
DN: Yes, which would be a root.

234
00:13:58,770 --> 00:14:01,420
TS: I'm trying to speak
through my hesitation here!

235
00:14:02,970 --> 00:14:05,110
I'm going to have to make a decision about ...

236
00:14:05,110 --> 00:14:07,800
what's the class called
and how it's instantiated.

237
00:14:07,826 --> 00:14:11,110
I'm concerned about baking
that into my step definition here

238
00:14:11,110 --> 00:14:15,160
because although I am
prepared to make a decision now,

239
00:14:15,160 --> 00:14:17,620
I don't know if I want
to live with that decision.

240
00:14:19,600 --> 00:14:22,453
I'm going to write a helper
method outside the step definition

241
00:14:22,453 --> 00:14:24,293
which I used to build trees.

242
00:14:24,340 --> 00:14:27,120
So here I can call build tree and give it

243
00:14:27,140 --> 00:14:30,533
something that's a little bit agnostic.

244
00:14:30,533 --> 00:14:31,600
DN: Yes.

245
00:14:31,600 --> 00:14:36,208
That doesn't talk about
the actual name of the class

246
00:14:36,200 --> 00:14:37,493
or how it's instantiated.

247
00:14:37,490 --> 00:14:40,586
Do you pass in an options
hash or positional arguments.

248
00:14:40,586 --> 00:14:43,813
Or do you create an empty
one and mutate it or whatever?

249
00:14:44,120 --> 00:14:46,080
I can try and keep this step definition

250
00:14:46,080 --> 00:14:48,140
to just stuff that we're interested in.

251
00:15:02,510 --> 00:15:09,160
My instinct here is to think of each node
of a tree as being a collection of its children

252
00:15:09,200 --> 00:15:12,586
and a leaf is a node that has no children.

253
00:15:12,770 --> 00:15:13,800
DN: Correct.

254
00:15:17,540 --> 00:15:19,620
I don't know yet if we are going to need to

255
00:15:19,620 --> 00:15:23,146
distinguish between parent nodes and leaves.

256
00:15:23,480 --> 00:15:26,280
Your problem statement
didn't say anything about

257
00:15:26,280 --> 00:15:28,880
storing values on the node.

258
00:15:30,620 --> 00:15:34,240
In a binary tree you might
only store values at the leaves,

259
00:15:34,250 --> 00:15:36,710
and the nodes are just a collection of children.

260
00:15:38,420 --> 00:15:41,386
For now, since you didn't
mention it in the statement.

261
00:15:41,386 --> 00:15:45,293
I'm going to assume that what
we want to represent is the structure

262
00:15:45,293 --> 00:15:48,440
with no values stored within it.

263
00:15:48,480 --> 00:15:53,146
And if we want to add to
it later I want it to be flexible.

264
00:15:54,770 --> 00:15:56,620
If we finish this and then you say

265
00:15:56,620 --> 00:15:59,050
I want you to add up all the numbers in the tree

266
00:15:59,050 --> 00:16:01,250
we will find a way to store them in the tree.

267
00:16:01,250 --> 00:16:05,813
DN:  I don't want to add
requirements at this stage.

268
00:16:06,840 --> 00:16:10,400
TS: OK so what I was saying
was, I think of a node as being

269
00:16:10,400 --> 00:16:12,770
a possible empty collection of children.

270
00:16:12,770 --> 00:16:14,850
So for me, the obvious representation here

271
00:16:14,850 --> 00:16:15,933
is to give it an array.

272
00:16:15,940 --> 00:16:18,000
And say "I want you to build a tree",

273
00:16:18,000 --> 00:16:21,826
and here are the children of the root node

274
00:16:21,826 --> 00:16:23,420
which in that case is nothing.

275
00:16:23,420 --> 00:16:26,773
So if I just want a root, node it will be like that.

276
00:16:26,773 --> 00:16:28,280
What else could we do?

277
00:16:28,310 --> 00:16:35,333
I can think of a 'wide tree'
that would be something like

278
00:16:36,093 --> 00:16:42,173
it's only one deep but
has lots of direct descendants.

279
00:16:42,200 --> 00:16:44,220
That would be a node in the center and

280
00:16:44,220 --> 00:16:46,666
then 5 emanating from it.

281
00:16:46,666 --> 00:16:49,493
DN: So that would have
many descendants but no terminals.

282
00:16:49,490 --> 00:16:51,026
TS: Yes, exactly.

283
00:16:53,600 --> 00:16:56,200
TS: Do you have any other
suggestions, as the owner?

284
00:16:56,200 --> 00:17:00,333
DN: I guess we could do something that is deep.

285
00:17:00,680 --> 00:17:02,773
TS: Would that be deep and narrow?

286
00:17:02,773 --> 00:17:05,080
We could have one that's just got 5 children.

287
00:17:10,050 --> 00:17:11,310
Like this ...

288
00:17:11,310 --> 00:17:13,310
DN: Yes, right.

289
00:17:13,800 --> 00:17:19,426
TS: I'm already liking this because you
can almost see the structure of the tree.

290
00:17:20,280 --> 00:17:22,510
Each set of brackets is one node I think.

291
00:17:23,000 --> 00:17:24,680
This is just one node,

292
00:17:24,710 --> 00:17:26,420
this is one node with 5 children,

293
00:17:26,420 --> 00:17:28,973
and this 12345.

294
00:17:29,020 --> 00:17:31,066
So that's what you meant by a tree?

295
00:17:31,093 --> 00:17:32,226
DN: Yes.

296
00:17:35,820 --> 00:17:38,340
I'm going to write a comment next to each of these

297
00:17:38,340 --> 00:17:41,280
to keep track of what we think
the metric is for each of them.

298
00:17:41,290 --> 00:17:49,480
This one would have no descendants, and no terminals.

299
00:17:49,490 --> 00:17:51,200
DN: Yes.

300
00:17:51,250 --> 00:17:54,200
TS: This one would have 5 descendants.

301
00:17:54,226 --> 00:17:55,280
(I'll write that down).

302
00:17:56,910 --> 00:17:58,386
And no terminals.

303
00:17:59,370 --> 00:18:03,400
This one has I think, 4 descendants.

304
00:18:03,920 --> 00:18:04,820
Is that correct?

305
00:18:04,820 --> 00:18:07,626
DN: Yes it is because we don't count the root.

306
00:18:08,200 --> 00:18:10,466
TS: And one terminal?

307
00:18:10,480 --> 00:18:12,066
DN: Exactly, yes.

308
00:18:12,140 --> 00:18:15,853
TS: It's frustrating that we have two trees

309
00:18:15,866 --> 00:18:19,080
that have no terminals, but that's fine,

310
00:18:19,080 --> 00:18:20,360
we can cope with that.

311
00:18:20,360 --> 00:18:24,760
Thinking ahead, because
the sort in Ruby isn't stable

312
00:18:24,760 --> 00:18:29,266
There's a chance that if two
trees tie on the number of terminals

313
00:18:29,266 --> 00:18:31,220
the sort is going to put
them in an arbitrary order.

314
00:18:31,220 --> 00:18:34,226
But, we'll just have to cross
that bridge when we come to it.

315
00:18:34,226 --> 00:18:36,220
That's absolutely fine.

316
00:18:36,320 --> 00:18:38,360
What other kinds of tree could we have?

317
00:18:38,373 --> 00:18:43,106
DN: We could have a deep wide tree that has ...

318
00:18:43,106 --> 00:18:45,440
perhaps 2 descendants ...

319
00:18:46,890 --> 00:18:50,373
in two entirely different branches,

320
00:18:50,373 --> 00:18:51,910
that go as far as the terminal.

321
00:18:56,080 --> 00:18:57,906
TS: Like this?
DN: That's right.

322
00:18:57,910 --> 00:18:59,480
TS: We can have ....

323
00:19:03,080 --> 00:19:05,333
So I think that's ... I don't know why ....

324
00:19:05,333 --> 00:19:08,493
DN: Your missing the final ....

325
00:19:09,373 --> 00:19:11,120
TS: I don't know why vim isn't ...

326
00:19:11,140 --> 00:19:12,800
That threw me, I was expecting

327
00:19:12,800 --> 00:19:15,786
to see a highlight on the first [bracket]

328
00:19:15,880 --> 00:19:19,306
DN: But if you put your cursor
on the first opening bracket.

329
00:19:19,306 --> 00:19:21,250
TS: Yes it highlights the closing one.

330
00:19:25,970 --> 00:19:28,040
What are our metrics for this?

331
00:19:28,053 --> 00:19:32,680
DN: We have 3 terminals and lots of descendants.

332
00:19:32,960 --> 00:19:34,540
TS: Maybe that doesn't matter.

333
00:19:36,340 --> 00:19:37,693
That's certainly got the most.

334
00:19:37,693 --> 00:19:39,053
DN: It's going to be the winner.

335
00:19:39,050 --> 00:19:42,080
TS: My expectation would be that there are 12,

336
00:19:42,620 --> 00:19:44,310
because there were 4 in this one.

337
00:19:44,310 --> 00:19:46,540
And we have basically tripled that one up.

338
00:19:47,620 --> 00:19:49,226
Just a sanity check this!

339
00:19:49,250 --> 00:19:51,733
Would we expect that these two things would ....

340
00:19:52,110 --> 00:19:55,280
that sorting them by
descendants versus by terminals

341
00:19:55,293 --> 00:19:56,880
is going to produce a different order

342
00:19:56,880 --> 00:19:58,600
otherwise it isn't a useful test case.

343
00:19:58,613 --> 00:20:01,293
If we sort them by the number of descendants

344
00:20:01,306 --> 00:20:05,066
then we have none ... 4,5 many.

345
00:20:05,080 --> 00:20:08,746
So that would be just one
deep tree, wide tree, deep wide tree.

346
00:20:08,746 --> 00:20:09,450
DN: Yes.

347
00:20:11,050 --> 00:20:13,000
Whereas if we sort them by terminals,

348
00:20:13,013 --> 00:20:15,120
we would expect them to be in this order.

349
00:20:15,140 --> 00:20:18,146
Like none, none, one and three.

350
00:20:18,510 --> 00:20:21,426
Bearing that in mind....

351
00:20:21,450 --> 00:20:24,786
I will not put them in in that order.

352
00:20:25,620 --> 00:20:28,986
I'll put them in yet another
order so we can see the sort work.

353
00:20:32,220 --> 00:20:33,293
So let's say ....

354
00:20:36,120 --> 00:20:39,306
Deep tree, just one ....

355
00:20:39,320 --> 00:20:41,720
this is an instance variable.

356
00:20:41,810 --> 00:20:44,170
and the reason why they are
instance variables is so I can

357
00:20:44,170 --> 00:20:47,053
refer to them in there
outside of this lexical scope.

358
00:20:47,053 --> 00:20:49,173
Deep tree, just one node.

359
00:20:51,540 --> 00:20:54,320
Deep wide tree, wide tree.

360
00:20:54,333 --> 00:20:54,970
DN: Yes.

361
00:20:54,970 --> 00:21:00,626
TS: I'm hoping that's enough to get us started.

362
00:21:00,680 --> 00:21:02,640
I'll just check that, by running ....

363
00:21:03,853 --> 00:21:06,986
Oh! Undefined method: build tree. OK, fine.

364
00:21:06,986 --> 00:21:08,940
That's the failure I was expecting.

365
00:21:09,970 --> 00:21:18,413
I will quickly make a features ...

366
00:21:20,880 --> 00:21:23,000
I need to define that method somewhere.

367
00:21:23,000 --> 00:21:27,733
I will make a file and put it in support.

368
00:21:27,880 --> 00:21:32,213
I'll call it trees helper.

369
00:21:41,370 --> 00:21:44,106
And so I don't forget I'm also going to make

370
00:21:44,106 --> 00:21:46,520
that method available to Cucumber,

371
00:21:46,620 --> 00:21:50,786
so I will remember to put a file in features.

372
00:21:54,570 --> 00:21:57,050
The names of these files
are of no consequence,

373
00:21:57,050 --> 00:21:59,020
it's just what I'm used to calling them.

374
00:21:59,200 --> 00:22:01,533
So in here I want to require ....

375
00:22:05,650 --> 00:22:07,760
just trying to think ....

376
00:22:09,140 --> 00:22:13,146
I think I will need to require relative.

377
00:22:13,340 --> 00:22:16,786
I'm trying to work out if this file is
going to run before or after the other one

378
00:22:16,786 --> 00:22:19,733
because cucumber will load
all of the files in the directory.

379
00:22:19,746 --> 00:22:22,493
Just to be safe I will require it.

380
00:22:22,493 --> 00:22:25,066
I will do require relative trees helper

381
00:22:25,110 --> 00:22:27,080
then if it hasn't already been loaded,

382
00:22:27,080 --> 00:22:29,310
it will load it because I want to say world ....

383
00:22:32,050 --> 00:22:38,053
and say make that available
in all of my step definitions.

384
00:22:38,940 --> 00:22:41,026
This needs an argument, children.

385
00:22:43,340 --> 00:22:46,880
It takes an array of children.

386
00:22:48,600 --> 00:22:53,453
Now I have to make a decision
about how to instantiate these things.

387
00:22:54,346 --> 00:22:57,560
For now I'll assume we just have a single class

388
00:22:57,600 --> 00:23:00,680
and I'll call it node because
that's a word we've been using.

389
00:23:01,680 --> 00:23:04,640
I'm assuming this will
ultimately return a new node,

390
00:23:05,170 --> 00:23:07,910
but we need to know
what children it's going to have.

391
00:23:07,910 --> 00:23:09,540
If that children array is empty ....

392
00:23:10,400 --> 00:23:12,973
let me think in code ...

393
00:23:12,973 --> 00:23:18,600
If the children is empty then it's fine to just do ....

394
00:23:20,146 --> 00:23:23,746
We're going to give it an empty load of children.

395
00:23:23,740 --> 00:23:28,040
And I'm prejudging the idea that we're going to

396
00:23:28,053 --> 00:23:30,570
create these by providing an array of children,

397
00:23:30,613 --> 00:23:33,880
rather than creating an empty one
and then mutating it to add them

398
00:23:33,946 --> 00:23:37,720
but we will investigate whether
that's a good idea or not I suppose.

399
00:23:42,770 --> 00:23:46,050
I'll just make it clearer that
that is going to be an empty array.

400
00:23:46,220 --> 00:23:49,586
It may be that is an optional
argument and if we don't provide it

401
00:23:49,586 --> 00:23:51,413
then it creates an empty node.

402
00:23:52,573 --> 00:23:54,573
But this is what would make sense to me

403
00:23:54,573 --> 00:23:58,306
and I'm thinking in terms
of myself being a client now.

404
00:23:58,320 --> 00:24:01,973
If there are no children we make an empty one,

405
00:24:01,970 --> 00:24:04,626
if there are children then ....

406
00:24:04,626 --> 00:24:07,200
each of the children in my representation here

407
00:24:07,680 --> 00:24:11,426
is of the same form as
the list of children i.e. an array.

408
00:24:12,250 --> 00:24:16,573
I need to call build_tree on
each child to turn it into a node,

409
00:24:16,600 --> 00:24:20,640
then I can pass that collection
of nodes to the constructor of node.

410
00:24:20,640 --> 00:24:23,390
So I just need to call
this recursively on the children.

411
00:24:23,400 --> 00:24:26,026
I know, because I've written Ruby before,

412
00:24:26,020 --> 00:24:31,000
that I can do that by doing
children, map, method, build tree.

413
00:24:31,960 --> 00:24:36,973
That's going to call
build_tree on each individual child.

414
00:24:36,970 --> 00:24:44,560
That's the same as no new
children, map, child, build tree, child.

415
00:24:44,573 --> 00:24:47,426
Just slightly more concise.

416
00:24:48,220 --> 00:24:51,613
In fact I prefer that one.

417
00:24:53,560 --> 00:24:55,570
DN:  Yes, it shows the argument better.

418
00:24:55,570 --> 00:24:57,600
TS: Yes, you can see what's going on there.

419
00:24:57,600 --> 00:25:00,370
Then I just have to
remember to close the brackets.

420
00:25:00,370 --> 00:25:05,640
Now I can see that this line here is a special case.

421
00:25:05,650 --> 00:25:09,960
In this one, we're mapping over an
empty array which gives you an empty array.

422
00:25:10,493 --> 00:25:12,026
So I can get rid of that.

423
00:25:15,140 --> 00:25:16,906
So now where are we....

424
00:25:20,220 --> 00:25:24,080
Now it's complaining
that I don't have a Node class.

425
00:25:29,050 --> 00:25:30,213
Let's make one.

426
00:25:30,680 --> 00:25:32,450
I'll put it in a folder called lib.

427
00:25:38,080 --> 00:25:40,140
I'm hesitating because this is the point at which

428
00:25:40,140 --> 00:25:43,613
I would like to start dropping
down to write some unit tests.

429
00:25:43,613 --> 00:25:45,770
Get this to a point where we're comfortable.

430
00:25:45,786 --> 00:25:48,293
Still say uninitialized constant.

431
00:25:50,280 --> 00:25:53,110
I would like to start
dropping down to unit tests now.

432
00:25:55,800 --> 00:25:58,893
We haven't filled this stuff out yet,

433
00:25:59,400 --> 00:26:03,026
but I think I'm happy to just bounce back and forth.

434
00:26:03,710 --> 00:26:06,170
It would be nice to get this first step passing

435
00:26:06,480 --> 00:26:10,000
because it's saying I don't
know what this Node thing is.

436
00:26:10,020 --> 00:26:15,720
so I would be more comfortable to
drive that out with a unit test now.

437
00:26:18,770 --> 00:26:24,560
TS: The main thing I'm
going to do now is install rspec.

438
00:26:25,860 --> 00:26:30,306
At the time of recording the
most recent version of rspec,

439
00:26:30,306 --> 00:26:34,733
is 3.0.0 release candidate 1. (RC1)

440
00:26:34,733 --> 00:26:35,933
DN:  Bleeding edge!

441
00:26:35,946 --> 00:26:39,340
TS. And hopefully the actual
version 3 will be out soon.

442
00:26:42,910 --> 00:26:49,346
DN: Just out of interest, you've
been running Cucumber scenarios.

443
00:26:49,346 --> 00:26:52,240
Are you suspending Vim or .....?

444
00:26:52,280 --> 00:26:54,160
TS:  I will show you.

445
00:26:59,080 --> 00:27:01,140
DN: So you have something in your vimrc?

446
00:27:01,140 --> 00:27:02,770
TS: Yes, that does literally run.

447
00:27:02,770 --> 00:27:04,850
I'm sure there's a cleverer way than that

448
00:27:04,850 --> 00:27:07,413
but I'm just typing leader 'C' to run Cucumber,

449
00:27:07,450 --> 00:27:11,960
and because I've got
cucumber set up to use bin stubs ....

450
00:27:13,480 --> 00:27:15,170
DN: You don't have do bundle exec.

451
00:27:15,173 --> 00:27:16,050
TS: Yes exactly.

452
00:27:18,080 --> 00:27:21,346
TS: It stores all of these
bin stubs in .bundle/bin,

453
00:27:21,346 --> 00:27:23,450
you can see there's a Cucumber binary there.

454
00:27:23,450 --> 00:27:26,413
and I've got my path set up
so bundle bin is on the path, which

455
00:27:26,413 --> 00:27:30,540
people have arguments
about this on the internet.

456
00:27:30,544 --> 00:27:32,820
It does create the opportunity
for someone to get you to

457
00:27:32,820 --> 00:27:37,573
clone a git repository that already has
a .bundle/bin folder with a binary called 'ls' in it

458
00:27:37,630 --> 00:27:40,653
that emails your password to the person.

459
00:27:42,400 --> 00:27:44,340
I prefer convenience over security,

460
00:27:44,340 --> 00:27:46,370
which is why I'm a terrible programmer.

461
00:27:47,420 --> 00:27:48,706
So that's all installed.

462
00:27:48,730 --> 00:27:55,320
Rspec comes with a nice
thingy that will initialize it for me.

463
00:27:55,340 --> 00:27:59,280
That's made a rspec file with some sensible defaults in,

464
00:27:59,280 --> 00:28:01,386
and it's made a spec helper.

465
00:28:01,420 --> 00:28:05,160
I will just check what's in here.

466
00:28:05,370 --> 00:28:09,293
Yes, there's a lot of guff in here which
for the purpose of this, I'll just get rid of.

467
00:28:11,250 --> 00:28:13,340
The only piece of configuration I want

468
00:28:13,340 --> 00:28:19,480
is that rspec 3 has this wonderful feature called disable_monkey_patching

469
00:28:19,680 --> 00:28:23,240
which will turn off all of the stuff
that patches the main object

470
00:28:23,266 --> 00:28:27,893
and extends Object with the 'should' method.

471
00:28:27,890 --> 00:28:31,053
So the only way I'm going to get
any kind of behavior out of rspec now,

472
00:28:31,053 --> 00:28:35,280
is to specifically say I want to
call this method as part of rspec.

473
00:28:37,250 --> 00:28:38,370
That's good.

474
00:28:39,050 --> 00:28:41,560
I will run all of my specs.

475
00:28:42,620 --> 00:28:44,640
Zero example, zero failures.

476
00:28:46,970 --> 00:28:48,820
I better write some examples then.

477
00:28:54,540 --> 00:28:57,400
I've already committed to
the class being called Node

478
00:28:57,400 --> 00:28:59,720
so I will call this node_spec.

479
00:29:01,880 --> 00:29:03,770
So because I turned monkey patching off,

480
00:29:03,770 --> 00:29:06,933
ordinarily the first thing I would
do here is say "describe something"

481
00:29:06,940 --> 00:29:09,426
but in rspec 3 when you turn monkey patching off

482
00:29:09,420 --> 00:29:13,013
you have to refer to the
top level constant RSpec.describe.

483
00:29:15,970 --> 00:29:17,333
Nodes of a tree.

484
00:29:21,820 --> 00:29:24,493
Now I'm ready to start writing examples here.

485
00:29:24,970 --> 00:29:26,773
If I run all of my tests.

486
00:29:31,540 --> 00:29:34,186
DN: How do you run your rspec tests?

487
00:29:34,570 --> 00:29:42,213
TS: I am using the vim-rspec plugin.

488
00:29:42,270 --> 00:29:44,000
So if I grep ...

489
00:29:49,080 --> 00:29:50,340
That's not very helpful.

490
00:29:54,620 --> 00:29:57,493
Maybe what I want to find here is just spec.

491
00:29:58,250 --> 00:30:00,973
There are a few different bindings here.

492
00:30:01,106 --> 00:30:02,800
Leader 'T' runs the current file.

493
00:30:02,800 --> 00:30:09,226
Leader 'S' runs the part of the
spec that is nearest to the person.

494
00:30:09,226 --> 00:30:10,360
So that's really handy,

495
00:30:10,386 --> 00:30:13,480
I can run focused tests by just pressing Leader 'S'.

496
00:30:13,773 --> 00:30:20,440
And Leader 'L' is excellent because every
time I run the test it remembers how it called rspec.

497
00:30:20,440 --> 00:30:22,680
Every time I press Leader 'L' it re-runs it.

498
00:30:22,693 --> 00:30:25,866
This is from thoughtbot I think. It's very nice.

499
00:30:28,120 --> 00:30:29,293
Where was I?

500
00:30:30,280 --> 00:30:31,680
node_spec.

501
00:30:35,110 --> 00:30:39,586
The first thing I want to do
here is verify that I can create one.

502
00:30:40,310 --> 00:30:42,373
So let's say something like:

503
00:30:42,370 --> 00:30:45,853
When the tree is empty.

504
00:30:45,970 --> 00:30:47,186
That will do.

505
00:30:52,000 --> 00:30:54,906
I want to start with something really simple here.

506
00:31:02,140 --> 00:31:05,680
I'm trying to think what I want to do
here to drive out the creation of the class.

507
00:31:13,200 --> 00:31:16,093
I don't really know what
behavior I want yet but let's say:

508
00:31:16,090 --> 00:31:17,453
It has no children.

509
00:31:17,453 --> 00:31:19,450
I'm already jumping slightly ahead but ...

510
00:31:21,420 --> 00:31:26,266
This is going to help me to
think about what I want the API to be.

511
00:31:26,280 --> 00:31:28,893
DN: Do you want to use the word children?

512
00:31:28,890 --> 00:31:32,066
But I guess children means something different.

513
00:31:32,066 --> 00:31:33,140
TS: That's a good point.

514
00:31:33,280 --> 00:31:37,466
I've already introduced the word
children but yes, I mean direct descendants.

515
00:31:37,570 --> 00:31:40,400
That's just my prejudice
about what trees look like

516
00:31:40,400 --> 00:31:43,466
and what the things in them are called.

517
00:31:49,650 --> 00:31:53,040
TS: I'm already having to
think about the API of the thing here.

518
00:31:55,680 --> 00:32:03,040
I'm uncomfortable with that. Let's
say "it can be created without error".

519
00:32:03,110 --> 00:32:05,540
That's really the bare minimum I would expect,

520
00:32:05,540 --> 00:32:07,910
is the ability to create one of these things.

521
00:32:07,910 --> 00:32:10,346
So I'm going to say expect this block.

522
00:32:10,370 --> 00:32:12,666
Make me a new tree with no children.

523
00:32:13,940 --> 00:32:15,746
Not to raise an error.

524
00:32:15,740 --> 00:32:16,546
DN: Ok

525
00:32:17,650 --> 00:32:19,186
TS: So if I run all my tests.

526
00:32:19,620 --> 00:32:23,653
There's the failure I'm
looking for, uninitialized constant Node.

527
00:32:28,050 --> 00:32:29,453
I created the file.

528
00:32:30,250 --> 00:32:34,826
Or maybe I didn't because I
didn't put anything in it and save it.

529
00:32:40,200 --> 00:32:42,066
There's a class.

530
00:32:43,540 --> 00:32:45,301
If I run all my specs.

531
00:32:46,280 --> 00:32:48,710
It's still saying uninitialized constant though

532
00:32:48,710 --> 00:32:51,680
because I haven't made any attempt to load it.

533
00:32:51,720 --> 00:32:54,800
DN: I wondered if that might
be happening by magic somehow.

534
00:32:54,813 --> 00:32:57,250
TS: No it isn't happening by magic and I like that.

535
00:32:57,250 --> 00:33:01,853
With rspec and Cucumber,
you have to explicitly add them in.

536
00:33:01,853 --> 00:33:03,640
I'm a big fan of this.

537
00:33:03,640 --> 00:33:06,666
One of the things that people
criticize both rspec and Cucumber for

538
00:33:06,660 --> 00:33:11,120
was this lack of explicitness and
doing to much stuff automatically.

539
00:33:11,120 --> 00:33:15,066
Both projects at the time have tended towards removing

540
00:33:15,060 --> 00:33:17,426
that stuff and expecting
you to be more explicit.

541
00:33:17,440 --> 00:33:19,413
In fact a lot of the automatic stuff

542
00:33:19,426 --> 00:33:22,306
that people think of rspec
and cucumber as doing now

543
00:33:22,370 --> 00:33:25,510
are actually being done by
rspec rails and cucumber rails,

544
00:33:25,510 --> 00:33:29,440
because they wire cucumber
and rspec into a rails application

545
00:33:29,440 --> 00:33:31,800
and then put stuff in the spec helper

546
00:33:31,800 --> 00:33:34,440
and env files that boot up your application

547
00:33:34,450 --> 00:33:39,853
and then you've got rails
constant auto loading as if  by magic.

548
00:33:39,860 --> 00:33:43,093
but in this kind of setting we have to be explicit and it's nice

549
00:33:43,093 --> 00:33:44,666
because it means that I can ....

550
00:33:44,680 --> 00:33:47,773
I mean whether or not we end up
with more than one class here I don't know.

551
00:33:47,773 --> 00:33:50,650
This might be the only spec file we write today.

552
00:33:51,510 --> 00:33:56,186
In this spec file I can say "I want to load node".

553
00:33:58,600 --> 00:34:03,440
By convention that lib folder that's
in the root rspec will put it on the load path.

554
00:34:03,480 --> 00:34:05,973
so I don't have to fiddle around with the load path,

555
00:34:06,000 --> 00:34:09,520
but I do have to explicitly
say I want to load this class.

556
00:34:14,160 --> 00:34:15,693
'wrong number of arguments', OK

557
00:34:15,690 --> 00:34:19,146
so it has found it and we've got the
wrong number of arguments in the constructor,

558
00:34:19,146 --> 00:34:21,400
so now I can go back and say:

559
00:34:28,710 --> 00:34:31,013
Now I hope to see a green test.

560
00:34:31,013 --> 00:34:32,440
DN: Yeah, great.

561
00:34:34,970 --> 00:34:39,560
TS: I've just realised that I've
powered on through this a long way

562
00:34:39,560 --> 00:34:44,173
and completely forgotten to make any
commits and that's now starting to make me nervous

563
00:34:44,173 --> 00:34:48,080
because I've just written a line
of actual code and I'm nervous about it.

564
00:34:50,310 --> 00:34:54,400
I'm going to deal with
that by opening a new screen.

565
00:34:55,970 --> 00:34:59,066
I'll still have Vim open but
I'm also going to have another terminal

566
00:34:59,066 --> 00:35:01,253
where I'm going to make some commits.

567
00:35:01,250 --> 00:35:07,026
inaudible

568
00:35:07,813 --> 00:35:10,546
I'm not going to waste any time on this.

569
00:35:11,140 --> 00:35:17,533
I'm going to do some slightly more
coarse-grained commits than I'm happy with.

570
00:35:17,533 --> 00:35:19,240
So I'm now clean.

571
00:35:19,280 --> 00:35:23,613
I should have been in that situation
before but I got over excited by the problem!

572
00:35:23,680 --> 00:35:28,813
Let's go back and look at the test we were writing.

573
00:35:30,480 --> 00:35:32,600
I believe that's all fine.

574
00:35:32,620 --> 00:35:34,050
Everything is happy there.

575
00:35:37,480 --> 00:35:40,820
What I'd like to do now is
start building this functionality out.

576
00:35:43,570 --> 00:35:48,613
I can say, context when the tree is not empty.

577
00:35:51,140 --> 00:35:56,960
This is actually when the node has no children.

578
00:35:58,680 --> 00:36:00,370
I think that's more appropriate.

579
00:36:00,370 --> 00:36:01,413
DN: Yes.

580
00:36:02,080 --> 00:36:04,333
TS: And this is when the node has children.

581
00:36:09,420 --> 00:36:11,973
Oh... what a disaster.

582
00:36:21,540 --> 00:36:23,946
What I'd like to do here...

583
00:36:23,946 --> 00:36:26,120
and I don't know if I will stick with this,

584
00:36:26,120 --> 00:36:33,946
is to have a collection of test doubles.

585
00:36:34,786 --> 00:36:37,546
In fact that's not here, this is here.

586
00:36:37,540 --> 00:36:41,720
It is so I can give it an array
of something without having to 

587
00:36:41,720 --> 00:36:43,650
then think about what those are.

588
00:36:43,650 --> 00:36:45,200
Anyway, see how far we can get.

589
00:36:52,880 --> 00:36:55,850
We've still got a very basic
level of functionality here.

590
00:36:57,340 --> 00:37:01,970
DN: Your missing a closing brace.

591
00:37:02,200 --> 00:37:05,650
I'm expecting the evaluation
of that block not to raise an error.

592
00:37:06,280 --> 00:37:06,740
Great, ok.

593
00:37:10,020 --> 00:37:12,280
I've got my Node
class, and I can instantiate

594
00:37:12,820 --> 00:37:13,600
which is great.

595
00:37:14,250 --> 00:37:16,340
I can see here this
is some duplication.

596
00:37:17,280 --> 00:37:19,850
So instead of having
two different things there

597
00:37:19,850 --> 00:37:20,850
I will pull up this.

598
00:37:24,940 --> 00:37:26,940
I'm defining
children in both cases

599
00:37:28,910 --> 00:37:30,420
but in one
context it's empty

600
00:37:30,420 --> 00:37:32,420
and in another
context it's not empty.

601
00:37:32,680 --> 00:37:34,770
That gives me a
nice clean separation.

602
00:37:38,110 --> 00:37:40,200
Those two things
are exactly the same.

603
00:37:42,680 --> 00:37:44,940
Ordinarily I would
refactor this and pull

604
00:37:44,940 --> 00:37:46,970
those out into a
shared example group.

605
00:37:48,000 --> 00:37:50,080
If we duplicate a
lot of examples here,

606
00:37:50,080 --> 00:37:51,020
I'll do that anyway.

607
00:37:53,850 --> 00:37:55,420
Now I want to
think about what

608
00:37:57,000 --> 00:37:58,910
my acceptance
tests are demanding.

609
00:37:58,910 --> 00:38:01,140
I've run these unit
tests a couple of times

610
00:38:01,770 --> 00:38:04,280
The acceptance tests
were complaining about

611
00:38:04,280 --> 00:38:05,880
was, you don't
have a Node class.

612
00:38:05,970 --> 00:38:07,510
Now I have got
the Node class,

613
00:38:08,310 --> 00:38:09,940
it's time for me
to step back up

614
00:38:09,940 --> 00:38:11,940
and run the
cucumber features again

615
00:38:12,510 --> 00:38:15,000
to see if I have finished,
but I don't think I have.

616
00:38:17,110 --> 00:38:18,310
These are failing now.

617
00:38:18,310 --> 00:38:21,110
They are still complaining
that they can't find Node.

618
00:38:21,110 --> 00:38:23,800
and that's because I
need to make sure it's required.

619
00:38:26,770 --> 00:38:27,940
DN: In the environment.

620
00:38:27,940 --> 00:38:28,420
TS: Yes.

621
00:38:28,420 --> 00:38:30,800
So I'll say require
and again I think cucumber

622
00:38:30,800 --> 00:38:32,880
is going to put lib
on the load path again.

623
00:38:40,170 --> 00:38:41,820
I've gone slightly wrong there.

624
00:38:42,650 --> 00:38:44,310
That's not supposed to be green.

625
00:38:46,220 --> 00:38:48,110
These step definitions, tree steps

626
00:38:50,710 --> 00:38:52,600
DN: They don't
actually do anything.

627
00:38:56,970 --> 00:38:58,770
In order to show
what I wanted the

628
00:38:58,770 --> 00:39:01,220
structure to be here,
this needs to be pending.

629
00:39:01,220 --> 00:39:02,880
because I'm not
yet done with it.

630
00:39:07,800 --> 00:39:08,680
That's what I want.

631
00:39:08,880 --> 00:39:10,570
I should not have left these step

632
00:39:12,510 --> 00:39:14,140
definitions that say nothing.

633
00:39:14,850 --> 00:39:15,740
So now it's saying:

634
00:39:16,710 --> 00:39:18,600
You haven't
implemented these steps.

635
00:39:18,620 --> 00:39:20,450
sort by total
number of descendants

636
00:39:20,450 --> 00:39:22,170
or by the total
number of terminals.

637
00:39:22,170 --> 00:39:24,880
Now I can think in terms
of being a client of this API

638
00:39:27,250 --> 00:39:28,880
What do I want
this to look like.

639
00:39:28,880 --> 00:39:30,650
So I've got my
collection of trees,

640
00:39:30,650 --> 00:39:32,450
which I've just
assumed is an array,

641
00:39:32,450 --> 00:39:34,050
but I think
that's reasonable.

642
00:39:36,220 --> 00:39:38,110
If someone gave
me this API and said

643
00:39:38,970 --> 00:39:40,680
You've got a
collection of trees,

644
00:39:41,020 --> 00:39:43,310
and I have
implemented an API, for the trees.

645
00:39:44,450 --> 00:39:46,140
and now I want
you to sort them by

646
00:39:46,620 --> 00:39:48,020
the number of descendants,

647
00:39:48,020 --> 00:39:49,450
or the number of terminals

648
00:39:49,450 --> 00:39:51,310
I would expect
there to be a method

649
00:39:51,310 --> 00:39:52,710
on each tree that I can call

650
00:39:52,710 --> 00:39:54,400
that would give
me a number back,

651
00:39:55,940 --> 00:39:57,140
that would say how many....

652
00:39:57,140 --> 00:39:58,420
trees equals trees sort ....

653
00:40:01,620 --> 00:40:02,310
by something ....

654
00:40:05,570 --> 00:40:06,970
it will either be number of ....

655
00:40:07,710 --> 00:40:10,250
It's tempting to call it
'number of descendants'.

656
00:40:13,680 --> 00:40:16,450
But I'm wondering if it
should be descendants_count.

657
00:40:19,620 --> 00:40:20,940
Maybe that would be nicer.

658
00:40:21,570 --> 00:40:22,880
It's a bit more idiomatic.

659
00:40:25,200 --> 00:40:27,600
But then again, it's at
odds with the language

660
00:40:27,600 --> 00:40:29,800
being used here, so I'm
not sure about that.

661
00:40:29,800 --> 00:40:31,200
I might revisit that later.

662
00:40:37,000 --> 00:40:38,200
I would like it so that ....

663
00:40:40,800 --> 00:40:43,420
I can call descendants_count
or terminals_count

664
00:40:45,970 --> 00:40:48,540
on each node in that
collection, it would give me

665
00:40:48,540 --> 00:40:51,420
a number back and then
it's going to sort the collection

666
00:40:51,710 --> 00:40:53,880
If I run one of my
Cucumber features now.

667
00:40:54,740 --> 00:40:56,820
I would expect to
see actual failures,

668
00:40:56,820 --> 00:40:58,420
which is what
I was hoping for.

669
00:40:58,420 --> 00:40:59,800
This is complaining about

670
00:41:00,650 --> 00:41:02,710
undefined method
descendants_count

671
00:41:02,710 --> 00:41:04,600
undefined method
terminals_count.

672
00:41:07,620 --> 00:41:09,220
Again I've charged ahead here.

673
00:41:11,340 --> 00:41:12,880
Let's be a bit more meticulous.

674
00:41:13,770 --> 00:41:14,680
So this is:

675
00:41:36,940 --> 00:41:39,510
DN: Your commits sometimes
have more text in the

676
00:41:39,510 --> 00:41:41,880
commit message than
what is to be committed.

677
00:41:45,020 --> 00:41:47,510
I find that to be the most
useful way of doing it.

678
00:41:48,540 --> 00:41:50,110
So let's see,
what did I do here?

679
00:41:50,910 --> 00:41:51,970
I want to split that.

680
00:41:52,770 --> 00:41:54,400
I'm going to commit this change:

681
00:42:01,450 --> 00:42:04,370
Which should have been
pending in the first place.

682
00:42:06,650 --> 00:42:07,220
Now this is:

683
00:42:17,020 --> 00:42:18,420
All clean again, I can relax.

684
00:42:19,000 --> 00:42:21,110
All of the stuff in
my gutter goes away.

685
00:42:21,110 --> 00:42:23,250
DN: Yes, I wanted to
draw attention to that.

686
00:42:23,250 --> 00:42:24,480
I think that's fabulous.

687
00:42:24,800 --> 00:42:27,080
TS: I think it's just
called 'git gutter'.

688
00:42:29,910 --> 00:42:31,820
DN: Do you always
have that enabled?

689
00:42:31,820 --> 00:42:32,420
TS: Yes.

690
00:42:32,910 --> 00:42:36,050
DN: I noticed it and I wondered
if it had crept in at some point.

691
00:42:38,170 --> 00:42:40,820
TS: It only creeps in if
there is something to show.

692
00:42:40,820 --> 00:42:43,170
so if I make a change
the gutter will appear.

693
00:42:44,110 --> 00:42:46,986
If I then make a change back so that git says

694
00:42:46,986 --> 00:42:48,413
there's no change it disappears again.

695
00:42:48,653 --> 00:42:50,450
DN:  I think the reason
we didn't see it for so long

696
00:42:50,450 --> 00:42:52,800
is because
you didn't commit anything.

697
00:42:52,820 --> 00:42:54,420
Everything was added, and new.

698
00:42:55,540 --> 00:42:58,080
TS: The reason why I
didn't make those commits is

699
00:42:58,080 --> 00:43:00,540
because I forgot to 'git
init' in the beginning.

700
00:43:02,570 --> 00:43:04,770
Now I find I don't
remember to make commits.

701
00:43:05,650 --> 00:43:07,910
It's the stuff in the
gutter that reminds me

702
00:43:08,400 --> 00:43:10,050
it's starting to get a bit dirty.

703
00:43:16,400 --> 00:43:18,940
DN: How much noise in
the gutter can you tolerate?

704
00:43:18,940 --> 00:43:19,800
TS: Not very much.

705
00:43:22,140 --> 00:43:25,400
Ordinarily I like to make
commits as frequently as possible.

706
00:43:25,940 --> 00:43:28,000
Very small commits
I can get away with.

707
00:43:28,000 --> 00:43:29,880
And as you say
quite often the message

708
00:43:29,880 --> 00:43:32,020
is longer than the
content of the commit.

709
00:43:33,370 --> 00:43:35,450
The problem here is
that we don't have a

710
00:43:35,450 --> 00:43:38,020
terminals_count, or a
descendants_count method.

711
00:43:50,170 --> 00:43:52,110
This makes me
realise that I'm trying

712
00:43:52,110 --> 00:43:54,050
to do two
scenarios at the same time.

713
00:43:54,050 --> 00:43:55,770
I would like to
focus on just one.

714
00:43:55,820 --> 00:43:56,650
DN: Sure, yes.

715
00:43:58,650 --> 00:44:01,340
TS: I don't want to
be simultaneously implementing

716
00:44:01,340 --> 00:44:03,740
number of descendants
and number of terminals.

717
00:44:03,740 --> 00:44:05,340
I'd rather just look at this one.

718
00:44:06,140 --> 00:44:07,450
I'm going to temporarily:

719
00:44:18,510 --> 00:44:20,420
There are better
ways of doing that.

720
00:44:20,420 --> 00:44:22,680
With Cucumber you
can tag scenarios so you

721
00:44:22,710 --> 00:44:24,000
don't have to run them but ....

722
00:44:24,540 --> 00:44:26,200
this is the simplest thing to do.

723
00:44:27,680 --> 00:44:29,110
I mustn't forget about that

724
00:44:30,250 --> 00:44:32,140
but, as long as I
don't forget about it,

725
00:44:32,140 --> 00:44:34,340
it's going to give me
the opportunity to run

726
00:44:34,340 --> 00:44:36,910
through getting the
descendants count to work.

727
00:44:38,740 --> 00:44:40,770
I'm going to switch
back to my node spec

728
00:44:42,850 --> 00:44:44,340
and have a look at doing that.

729
00:44:51,850 --> 00:44:54,680
So now I need to start
making some decisions around ....

730
00:44:56,600 --> 00:44:58,000
how to even set up the test

731
00:44:58,620 --> 00:45:00,940
because what I want
here is something like:

732
00:45:11,340 --> 00:45:13,570
And then I want
something here that's like

733
00:45:14,450 --> 00:45:16,370
the node is
something here and then

734
00:45:17,340 --> 00:45:18,650
it has five descendants.

735
00:45:19,880 --> 00:45:21,110
And then this would say ....

736
00:45:26,170 --> 00:45:28,510
Which is what we
said in the step definition:

737
00:45:28,800 --> 00:45:30,820
node descendant count
to be equal to 5.

738
00:45:32,540 --> 00:45:34,000
So I know what the example is.

739
00:45:36,450 --> 00:45:38,940
I'm not quite sure exactly
what I want to do here....

740
00:45:43,220 --> 00:45:44,800
because I've got doubles here.

741
00:45:47,280 --> 00:45:49,910
If I just make real instances
of node, I could already

742
00:45:50,200 --> 00:45:52,480
build you a tree
that has five descendants

743
00:45:52,480 --> 00:45:55,200
because we had a similar
one in the step definition.

744
00:45:55,200 --> 00:45:55,850
DN: Yes, right.

745
00:45:56,710 --> 00:45:58,400
So I know how
to make <i>real</i> trees

746
00:45:59,420 --> 00:46:00,450
with 5 descendants.

747
00:46:02,910 --> 00:46:05,970
If I want the children of this
node to be the test doubles,

748
00:46:07,140 --> 00:46:08,340
then I need to work out ....

749
00:46:11,400 --> 00:46:14,510
what it is that makes this
fake tree has five descendants.

750
00:46:27,110 --> 00:46:29,710
This feels like it should
be a recursive method.

751
00:46:31,910 --> 00:46:33,820
The number of
descendants of a tree

752
00:46:34,280 --> 00:46:36,540
is the number of
descendants of all of its

753
00:46:36,880 --> 00:46:38,650
subtrees plus
the node at the top.

754
00:46:40,250 --> 00:46:42,710
If I've got three children
and each one of them

755
00:46:42,710 --> 00:46:44,200
has three descendants in it,

756
00:46:45,800 --> 00:46:49,450
then I've got 3 + 3 + 3 = 9
descendants, plus myself is 10.

757
00:46:51,850 --> 00:46:54,940
That's a very obvious
structure for solving the problem.

758
00:47:02,570 --> 00:47:04,600
I'm getting slightly
ahead of myself here.

759
00:47:04,620 --> 00:47:06,970
It would be nice to say
"it has no descendants"

760
00:47:07,600 --> 00:47:08,480
for the empty one.

761
00:47:08,740 --> 00:47:10,540
because I can
avoid that problem.

762
00:47:10,540 --> 00:47:11,250
I can just say:

763
00:47:30,400 --> 00:47:32,420
You can see when
I press leader 'S' there

764
00:47:32,420 --> 00:47:34,420
It's set up RSpec to
only run that line.

765
00:47:34,420 --> 00:47:37,477
So now it's saying 'undefined method:
descendant_count for node'

766
00:47:37,477 --> 00:47:39,978
and then I can easily

767
00:47:40,661 --> 00:47:42,340
go in here and say:

768
00:47:47,340 --> 00:47:49,770
So if I now do leader 'L'
to run my last focus test

769
00:47:51,280 --> 00:47:52,600
It runs just that example.

770
00:47:58,820 --> 00:48:00,910
I can make that
work quite easily here

771
00:48:02,340 --> 00:48:04,370
I can't make it work
so easily down here.

772
00:48:04,910 --> 00:48:07,370
because what does it
mean for the tree to have

773
00:48:07,370 --> 00:48:08,370
five descendants.

774
00:48:14,800 --> 00:48:16,710
This does go slightly counter to the

775
00:48:16,710 --> 00:48:19,110
way I want to write tests
but I think in terms of

776
00:48:19,110 --> 00:48:21,280
expediency it's going
to be quicker for me

777
00:48:21,280 --> 00:48:23,280
to just make a real
tree here because

778
00:48:23,280 --> 00:48:25,510
because I've already
written the tree helper

779
00:48:25,510 --> 00:48:26,850
that knows how to do that.

780
00:48:26,850 --> 00:48:28,570
And I've already
got some examples

781
00:48:28,570 --> 00:48:29,770
from the Cucumber step.

782
00:48:32,050 --> 00:48:34,570
I think that slightly
subverts the notion

783
00:48:34,570 --> 00:48:36,220
of it being a unit
test, because

784
00:48:37,820 --> 00:48:40,020
although I'm only
testing one method here,

785
00:48:41,370 --> 00:48:43,910
I'll end up testing
it against multiple objects.

786
00:48:44,510 --> 00:48:46,710
If I didn't have a time
limit, I would like to

787
00:48:47,000 --> 00:48:48,800
spend some
time investigating

788
00:48:48,800 --> 00:48:51,250
what would be the
consequences of me trying

789
00:48:51,250 --> 00:48:53,020
to do all of this
with test doubles.

790
00:48:54,170 --> 00:48:57,280
But my instinct tells me that
I might get a bit tied in knots.

791
00:49:00,250 --> 00:49:02,710
So for this specific
example, I shall err on the

792
00:49:02,710 --> 00:49:05,620
side of 'quickness' and have
a look at the tree steps here.

793
00:49:09,740 --> 00:49:12,250
I already have a tree
here with 5 descendants

794
00:49:12,740 --> 00:49:13,510
this wide tree.

795
00:49:16,620 --> 00:49:19,020
So I can go here and
say something like this:

796
00:49:24,050 --> 00:49:25,170
What do I want to do?

797
00:49:27,600 --> 00:49:29,540
It's going to be
something like this:

798
00:49:32,850 --> 00:49:33,880
Let's get rid of this.

799
00:49:34,400 --> 00:49:36,570
That's going to give
me a node that really

800
00:49:36,570 --> 00:49:38,400
does have five descendants.
DN: Yes.

801
00:49:38,450 --> 00:49:40,910
And then this is going
to say check that it does.

802
00:49:41,340 --> 00:49:44,510
If I already knew how my
descendant count was going to work

803
00:49:52,680 --> 00:49:54,000
I'm in conflict about this ....

804
00:49:54,000 --> 00:49:55,820
Let's just see what happens if I say:

805
00:50:02,910 --> 00:50:05,110
I would like to get
my head around if this

806
00:50:05,110 --> 00:50:06,600
is the right decision or not.

807
00:50:07,620 --> 00:50:10,480
So, if I run this, firstly the
answer is going to be wrong.

808
00:50:12,370 --> 00:50:14,770
It's going to say,
"expected five and I got none".

809
00:50:16,540 --> 00:50:18,620
DN: Where is
children coming from there?

810
00:50:18,620 --> 00:50:20,310
TS: Children is coming from here

811
00:50:24,570 --> 00:50:26,680
It walks up until
it finds a place where

812
00:50:26,680 --> 00:50:27,880
that has been defined.

813
00:50:27,910 --> 00:50:30,400
So I'm still using this
as several test doubles.

814
00:50:31,310 --> 00:50:32,310
I may decide to put ....

815
00:50:35,110 --> 00:50:37,020
'let children'
inside here and then

816
00:50:37,020 --> 00:50:41,220
it would provide...
DN: ...a locally scoped version?
TS: Yeah, exactly.

817
00:50:43,940 --> 00:50:45,170
That's the wrong answer.

818
00:50:45,170 --> 00:50:46,400
Expected five, got zero.

819
00:50:47,020 --> 00:50:49,800
Now I can start thinking
about how I want this to work

820
00:50:51,310 --> 00:50:53,570
well the most
obvious thing that I need is

821
00:50:55,340 --> 00:50:57,200
to remember
what the children are.

822
00:50:57,800 --> 00:50:59,940
And I guess this
could be something like:

823
00:51:08,420 --> 00:51:09,510
Is that right? Oh well,

824
00:51:11,400 --> 00:51:12,220
Yes .... No.... (laughter).

825
00:51:20,570 --> 00:51:23,340
It's a little difficult
because this method needs to ....

826
00:51:26,800 --> 00:51:28,480
We need to
subtract one from it,

827
00:51:30,080 --> 00:51:31,480
only once,
right at the end.

828
00:51:31,970 --> 00:51:34,050
So if we call it on the
root node of a tree,

829
00:51:34,220 --> 00:51:36,280
it needs to walk
down through the tree

830
00:51:36,280 --> 00:51:37,970
adding up how
many nodes there are.

831
00:51:37,970 --> 00:51:40,480
And then we subtract one
from it right at the end.

832
00:51:40,600 --> 00:51:41,220
DN: Yes.

833
00:51:48,450 --> 00:51:50,310
It now occurs to
me that I'm not sure.

834
00:51:50,540 --> 00:51:53,000
Oh, descendant count of
zero for the empty node

835
00:51:53,000 --> 00:51:55,420
is correct because
there's just the root node.

836
00:52:00,540 --> 00:52:03,200
Let's leave that as it was,
I don't think that's right.

837
00:52:03,480 --> 00:52:05,200
So if it has got several children

838
00:52:05,400 --> 00:52:07,940
in my head, the general
pattern that we want here

839
00:52:07,940 --> 00:52:09,400
is to take all the children

840
00:52:10,170 --> 00:52:11,940
and call descendant_count on them.

841
00:52:14,400 --> 00:52:16,340
And when I know
how many descendants

842
00:52:16,340 --> 00:52:17,620
all of the children have

843
00:52:17,620 --> 00:52:18,880
I want to add one to that.

844
00:52:20,110 --> 00:52:20,800
DN: Right.

845
00:52:22,310 --> 00:52:24,600
The one whose
children you're asking about?

846
00:52:24,850 --> 00:52:26,050
TS: The current node. Yes.

847
00:52:27,170 --> 00:52:30,140
If I collect all the
descendant counts and add them up,

848
00:52:30,770 --> 00:52:32,910
by using inject plus,
and then I have one

849
00:52:34,110 --> 00:52:36,310
and that's kind of
the answer that I want.

850
00:52:36,310 --> 00:52:39,310
Or at least that's the answer
I want in the recursive case.

851
00:52:41,420 --> 00:52:44,710
I haven't been called
recursively as part of this procedure,

852
00:52:44,820 --> 00:52:47,080
the root node, I need
to subtract one from it.

853
00:52:47,080 --> 00:52:49,340
I need to think
more carefully about this.

854
00:52:53,420 --> 00:52:55,970
Hopefully that will be
born out by the fact that

855
00:52:56,340 --> 00:52:58,450
here we would want
all of these to return

856
00:53:00,370 --> 00:53:01,910
that it has five descendants.

857
00:53:02,400 --> 00:53:03,280
Right now it won't.

858
00:53:04,710 --> 00:53:06,420
Because we've
got the wrong code.

859
00:53:07,600 --> 00:53:08,850
Let's run that last test.

860
00:53:20,450 --> 00:53:22,540
There's our first
problem, that because

861
00:53:22,540 --> 00:53:24,620
all the children
are just test doubles

862
00:53:25,880 --> 00:53:27,200
They've all just returned... .

863
00:53:30,250 --> 00:53:32,310
At the moment I've
just got these three

864
00:53:32,910 --> 00:53:34,370
dumb children.
So why don't I

865
00:53:36,650 --> 00:53:38,510
set up a situation that looks like

866
00:53:40,080 --> 00:53:41,110
the tree we had here.

867
00:53:41,450 --> 00:53:43,540
Which was .... there
would be five of these

868
00:53:47,940 --> 00:53:49,570
It would be
quicker to just say:

869
00:53:52,450 --> 00:53:53,650
if I want five children .....

870
00:53:54,970 --> 00:53:56,820
The easiest way to
do that is 5 x map.

871
00:53:59,650 --> 00:54:02,620
Whatever is in this block
will get evaluated five times,

872
00:54:02,620 --> 00:54:03,740
and put into an array.

873
00:54:06,820 --> 00:54:09,250
I can use RSpec 3's
verifying doubles for this.

874
00:54:09,400 --> 00:54:10,740
I can say 'instance double'.

875
00:54:11,850 --> 00:54:13,880
I want to have a
double for an instance

876
00:54:13,880 --> 00:54:14,800
of the node class.

877
00:54:15,250 --> 00:54:17,970
And what this will do is,
if the node class is loaded

878
00:54:17,970 --> 00:54:20,680
it will check whatever
stub methods I put on this

879
00:54:21,850 --> 00:54:24,280
double actually
exist so it's checking that

880
00:54:25,880 --> 00:54:28,280
I'm not stubbing out
methods that don't exist.

881
00:54:30,600 --> 00:54:32,510
I want to stub
out descendant_count.

882
00:54:32,800 --> 00:54:34,370
and I want that
to be .... new style

883
00:54:35,880 --> 00:54:37,540
I can say the descendant count

884
00:54:37,540 --> 00:54:39,200
of each of these,
needs to be one.

885
00:54:41,710 --> 00:54:43,650
I can already see
that is not going to

886
00:54:43,650 --> 00:54:44,910
give me the right answer.

887
00:54:45,310 --> 00:54:46,820
Because it adds one, I get six.

888
00:54:55,710 --> 00:54:56,970
DN: Just so I'm on the same page
as you here

889
00:54:56,970 --> 00:54:58,880
you've created
five instance doubles,

890
00:54:59,620 --> 00:55:00,510
each one is a node.

891
00:55:01,650 --> 00:55:04,110
And it's reporting that
it has one descendant

892
00:55:04,110 --> 00:55:06,310
but actually that
descendant is itself ....

893
00:55:07,850 --> 00:55:10,170
ah yes, of course,
it's reporting to its parent.

894
00:55:10,800 --> 00:55:12,570
TS: Yes, so this is
the problem, that ....

895
00:55:14,770 --> 00:55:16,770
we've already said
that an empty node

896
00:55:16,770 --> 00:55:18,280
should have no descendants.

897
00:55:18,970 --> 00:55:20,170
That's returning zero.

898
00:55:20,170 --> 00:55:22,400
But to even get this
started I'm having to say

899
00:55:22,400 --> 00:55:24,200
that these nodes,
which I'm thinking

900
00:55:24,220 --> 00:55:25,280
of being empty ones,

901
00:55:25,280 --> 00:55:27,220
will have a
descendant count of one.

902
00:55:27,820 --> 00:55:29,480
There's an impedance mismatch.

903
00:55:31,110 --> 00:55:33,910
Effectively you've got
two different methods here

904
00:55:35,110 --> 00:55:37,770
and we're trying to cram
them into the same place.

905
00:55:38,080 --> 00:55:39,020
I'll get rid of this.

906
00:55:39,910 --> 00:55:40,820
I need to fix this.

907
00:55:56,940 --> 00:55:59,310
I already feel
confused by the test doubles.

908
00:55:59,820 --> 00:56:01,680
given that they
weren't helping me

909
00:56:01,680 --> 00:56:03,000
I'll get rid of them for now.

910
00:56:03,480 --> 00:56:05,000
If I can use them later, I will.

911
00:56:06,880 --> 00:56:08,910
This is going to
help me think through

912
00:56:08,910 --> 00:56:10,310
how we want this to behave

913
00:56:10,620 --> 00:56:12,770
because up here
we've got a real instance

914
00:56:12,770 --> 00:56:14,140
of a node with no children

915
00:56:14,140 --> 00:56:15,910
and it's giving
the right answer.

916
00:56:17,510 --> 00:56:19,420
Now we've got a
real instance of node

917
00:56:19,420 --> 00:56:21,310
and we want to
see what the answer is.

918
00:56:25,420 --> 00:56:27,020
So now this is
saying we don't

919
00:56:27,020 --> 00:56:28,510
have that build_tree helper.

920
00:56:30,400 --> 00:56:31,680
So I need to require that.

921
00:56:33,540 --> 00:56:35,420
I think it's up
in features support.

922
00:56:37,710 --> 00:56:38,400
Trees helper.

923
00:56:40,820 --> 00:56:42,650
And then I need
to include a module

924
00:56:44,420 --> 00:56:45,250
in my RSpec file.

925
00:56:47,110 --> 00:56:49,540
I don't have a great
way of having test helpers

926
00:56:50,020 --> 00:56:52,970
that are available in both
RSpec and Cucumber features.

927
00:56:52,970 --> 00:56:55,370
Usually because, when
I'm writing a unit test

928
00:56:55,370 --> 00:56:57,510
I wouldn't want
these helpers that build

929
00:56:59,250 --> 00:57:00,710
huge trees of real objects.

930
00:57:00,710 --> 00:57:02,000
But .... that's
what we've got.

931
00:57:06,600 --> 00:57:07,620
Why has that worked?

932
00:57:08,770 --> 00:57:10,600
Expect descendant count to be five.

933
00:57:10,600 --> 00:57:12,000
Ok, I've done the wrong thing.

934
00:57:13,140 --> 00:57:14,510
expected five and got one,

935
00:57:14,710 --> 00:57:16,740
and I think the
reason why we've got one

936
00:57:16,740 --> 00:57:19,250
is because the subtrees
have all returned zero

937
00:57:19,250 --> 00:57:20,850
DN: And then we've added one to it.

938
00:57:20,850 --> 00:57:21,310
TS: Yes.

939
00:57:21,310 --> 00:57:23,480
So I think that we
need to have one method

940
00:57:25,940 --> 00:57:28,000
that we call from
the outside, which is

941
00:57:28,000 --> 00:57:29,570
going to be descendant_count.

942
00:57:29,970 --> 00:57:31,880
And a different method that is used ....

943
00:57:35,510 --> 00:57:37,910
This code here is going
to be something else.

944
00:57:39,280 --> 00:57:39,850
DN: I see.

945
00:57:41,420 --> 00:57:43,680
And this thing here
can be 'something else'

946
00:57:45,310 --> 00:57:45,850
minus one.

947
00:57:46,770 --> 00:57:47,280
DN: OK.

948
00:57:47,710 --> 00:57:49,740
Because when you
call this you want it

949
00:57:49,740 --> 00:57:51,740
to count all the ....
what did we call them?

950
00:57:56,000 --> 00:57:57,620
This is almost like .... 'node count'.

951
00:57:58,880 --> 00:58:01,710
You want it to count all of
the nodes, including itself

952
00:58:03,250 --> 00:58:04,650
and then disregard itself.

953
00:58:06,020 --> 00:58:06,770
I think!

954
00:58:07,800 --> 00:58:10,140
This may be stupid but
let's see what happens.

955
00:58:13,250 --> 00:58:15,140
This I think, does
the correct thing.

956
00:58:20,170 --> 00:58:21,340
So this needs to be one.

957
00:58:21,910 --> 00:58:24,020
So what we are trying to
ask is how many nodes

958
00:58:24,020 --> 00:58:25,250
in total are in the tree.

959
00:58:25,650 --> 00:58:27,050
If I don't have any children

960
00:58:27,050 --> 00:58:28,540
there's just the one, that's me.

961
00:58:29,200 --> 00:58:30,600
and if I have some children

962
00:58:30,600 --> 00:58:33,000
then I have all my
childrens' nodes and myself.

963
00:58:34,340 --> 00:58:36,280
So I'm always adding
one, and at the end

964
00:58:36,280 --> 00:58:37,200
you subtract one.

965
00:58:40,050 --> 00:58:41,140
If I run my unit tests....

966
00:58:42,250 --> 00:58:43,480
expected five, got zero.

967
00:58:47,200 --> 00:58:48,880
That's not
what I was expecting.

968
00:58:48,880 --> 00:58:50,940
Ah .... it's because I
forgot to change this.

969
00:58:52,220 --> 00:58:55,110
So we have to call that
node_count method recursively

970
00:58:55,250 --> 00:58:57,620
Now, it will correctly
count all of the nodes.

971
00:59:08,080 --> 00:59:10,510
There are other ways
that we can arrange this,

972
00:59:10,510 --> 00:59:11,770
but I think this is fine.

973
00:59:11,770 --> 00:59:13,170
I think this is just as good.

974
00:59:14,250 --> 00:59:16,110
It's slightly awkward that we have

975
00:59:16,110 --> 00:59:17,450
these two ways of doing it.

976
00:59:23,050 --> 00:59:25,280
But I think this is
sort of an inevitable

977
00:59:25,280 --> 00:59:27,850
consequence of saying that
the root node is not ....

978
00:59:27,850 --> 00:59:28,540
Actually ....

979
00:59:33,740 --> 00:59:35,940
Maybe there is a
better way of doing this.

980
00:59:36,910 --> 00:59:38,740
We can do a bit
of refactoring here

981
00:59:38,740 --> 00:59:40,740
and make a commit
because I've definitely

982
00:59:40,910 --> 00:59:41,620
done the work.

983
00:59:46,140 --> 00:59:47,910
I've got
something that works now.

984
00:59:48,200 --> 00:59:49,110
So I will just say:

985
00:59:59,540 --> 01:00:01,740
I think there is a
smarter way of doing it

986
01:00:01,740 --> 01:00:05,000
which is to always think about
the descendant count as being ....

987
01:00:06,740 --> 01:00:08,770
How many nodes are
there apart from me.

988
01:00:09,317 --> 01:00:13,989
For whatever reason, my intuitive idea of
what descendant count was doing

989
01:00:15,189 --> 01:00:18,661
would be including the... It would
be like self AND descendant count

990
01:00:19,510 --> 01:00:20,940
But that's not what you want

991
01:00:20,940 --> 01:00:23,370
you want to know how
many children there are

992
01:00:24,000 --> 01:00:26,370
and how many children
of children there are.

993
01:00:26,370 --> 01:00:27,480
Not counting myself.

994
01:00:31,850 --> 01:00:33,400
if I do this descendant count

995
01:00:34,000 --> 01:00:36,020
Could I say,
'if I don't have any children

996
01:00:36,020 --> 01:00:37,820
then there are
zero descendants".

997
01:00:38,250 --> 01:00:39,650
If I do have some children

998
01:00:40,800 --> 01:00:43,340
I then add up the
descendants each of them have

999
01:00:44,420 --> 01:00:46,250
then I add how
many children I have.

1000
01:00:48,220 --> 01:00:49,050
So this would be:

1001
01:00:54,510 --> 01:00:56,650
And then I think that
does the same thing.

1002
01:00:58,140 --> 01:00:59,340
That's slightly nicer.

1003
01:01:00,080 --> 01:01:01,800
I hadn't thought
of that as being

1004
01:01:02,620 --> 01:01:04,880
a way of adding them
up but I think it works.

1005
01:01:09,620 --> 01:01:11,540
It's a problem
that you have to call

1006
01:01:11,880 --> 01:01:13,800
size on the
collection of children.

1007
01:01:14,140 --> 01:01:16,510
Whereas, previously
we didn't have to do that.

1008
01:01:16,510 --> 01:01:17,600
You got that for free,

1009
01:01:17,600 --> 01:01:19,710
because every child
was returning 'one',

1010
01:01:20,540 --> 01:01:22,480
If they included
themselves anyway ....

1011
01:01:22,850 --> 01:01:24,540
Now we have to
have an awareness

1012
01:01:24,540 --> 01:01:26,000
of how many
children we have.

1013
01:01:26,220 --> 01:01:27,940
I think that's why I avoided that.

1014
01:01:31,400 --> 01:01:33,400
DN; Well there's
only question to ask.

1015
01:01:35,000 --> 01:01:37,820
This is the best way of
representing what you wanted.

1016
01:01:38,370 --> 01:01:39,220
DN: Right.

1017
01:01:41,050 --> 01:01:43,000
TS: The examples
are passing the test.

1018
01:01:51,770 --> 01:01:53,540
I might stick one
more in here.

1019
01:01:54,020 --> 01:01:55,280
Given that we've got them.

1020
01:01:57,280 --> 01:01:59,200
I said I thought
this one had twelve.

1021
01:02:00,310 --> 01:02:02,770
So let's find out if it
does in fact, have twelve.

1022
01:02:03,820 --> 01:02:05,620
DN: It definitely has many.
TS: Yes.

1023
01:02:32,200 --> 01:02:33,480
So this one is going to be:

1024
01:02:48,450 --> 01:02:50,080
I was right, it
does have twelve!

1025
01:02:54,570 --> 01:02:56,650
Although I am
uncomfortable with the

1026
01:02:57,600 --> 01:02:59,250
use of the real
instances here,

1027
01:02:59,310 --> 01:03:00,770
I think I'm going to carry on

1028
01:03:00,770 --> 01:03:03,400
because for the purposes
of what we are doing here,

1029
01:03:03,420 --> 01:03:05,480
I don't think it
would be interesting

1030
01:03:05,480 --> 01:03:06,880
for me to fix that problem.

1031
01:03:08,970 --> 01:03:10,540
Now I've decided how this works

1032
01:03:10,540 --> 01:03:13,540
I could go back and instead
of having real instances here

1033
01:03:13,850 --> 01:03:15,680
I could just
have doubles, so that

1034
01:03:15,740 --> 01:03:18,000
here, I just need
three children that each

1035
01:03:18,000 --> 01:03:19,710
say they have four descendants.

1036
01:03:21,050 --> 01:03:23,080
So I don't need the
real instances here,

1037
01:03:23,970 --> 01:03:26,220
but I've already
'flip flopped' on that a bit

1038
01:03:26,220 --> 01:03:28,340
so I'm just going to
move on with my life.

1039
01:03:29,800 --> 01:03:32,620
I've only tested descendant
count three times there

1040
01:03:32,620 --> 01:03:34,250
but that's giving me confidence,

1041
01:03:34,250 --> 01:03:35,710
that it's not totally wrong.

1042
01:03:36,970 --> 01:03:39,480
All of these trees are
pretty much symmetric.

1043
01:03:42,910 --> 01:03:45,340
All of the children look
the same in each tree.

1044
01:03:45,340 --> 01:03:46,880
This one has got three children

1045
01:03:46,880 --> 01:03:48,140
which are all four deep.

1046
01:03:49,400 --> 01:03:51,080
I think I'm
confident enough that

1047
01:03:51,080 --> 01:03:53,310
that's not a problem,
so I'm going to carry on.

1048
01:03:54,650 --> 01:03:56,770
Let's run the
Cucumber features and see

1049
01:03:56,770 --> 01:03:57,400
where we are.

1050
01:03:58,680 --> 01:04:01,140
Undefined method
descendants count for node.

1051
01:04:01,800 --> 01:04:03,000
Why has that happened?

1052
01:04:03,000 --> 01:04:04,650
Because it's
descendant count.

1053
01:04:11,450 --> 01:04:13,450
I think descendant
count is the name

1054
01:04:13,450 --> 01:04:14,850
I want that
method to have.

1055
01:04:17,340 --> 01:04:19,420
When I was writing
the acceptance test

1056
01:04:19,420 --> 01:04:21,050
I did write
descendants count.

1057
01:04:24,170 --> 01:04:26,250
DN: That's an easy
refactoring to change.

1058
01:04:31,080 --> 01:04:33,450
TS: The reason there
was descendants there

1059
01:04:33,450 --> 01:04:35,650
was because I'd
written descendants here.

1060
01:04:35,650 --> 01:04:38,220
We've got the word
descendants all over the place.

1061
01:04:41,200 --> 01:04:43,650
But this feels more
idiomatically Ruby to me,

1062
01:04:47,000 --> 01:04:48,200
that's just my instinct.

1063
01:04:49,370 --> 01:04:50,080
Let's run them.

1064
01:04:54,110 --> 01:04:55,770
DN: The pending
one is the one we

1065
01:04:56,340 --> 01:04:58,170
don't care about
the moment isn't it?

1066
01:04:58,170 --> 01:04:58,770
TS: Yes, sure.

1067
01:05:00,050 --> 01:05:01,740
I'm going to add
this change and

1068
01:05:01,740 --> 01:05:02,200
just say:

1069
01:05:31,650 --> 01:05:34,080
I think we can power
through the rest of it now.

1070
01:05:34,080 --> 01:05:35,829
So now we say
the collection should

1071
01:05:35,829 --> 01:05:38,272
be ordered by the
total number of descendants.

1072
01:05:38,272 --> 01:05:41,104
That means we are going to
start putting some code in here

1073
01:05:41,104 --> 01:05:42,160
which says:

1074
01:05:49,680 --> 01:05:51,970
So if we've sorted
them by descendant count

1075
01:05:54,970 --> 01:05:56,570
we expect to
see just one node

1076
01:05:58,710 --> 01:06:00,080
which has no descendants.

1077
01:06:01,050 --> 01:06:02,450
A deep tree which has four.

1078
01:06:04,220 --> 01:06:05,600
A wide tree which has five.

1079
01:06:08,250 --> 01:06:10,170
and deep wide
tree which has twelve.

1080
01:06:10,910 --> 01:06:11,770
So let's run that.

1081
01:06:14,540 --> 01:06:17,570
I got that green before but I didn't deserve it.

1082
01:06:17,570 --> 01:06:19,420
In fact because
I didn't deserve it

1083
01:06:19,420 --> 01:06:20,620
I'll put pending in here.

1084
01:06:37,450 --> 01:06:38,910
So, I think we finished that.

1085
01:06:40,710 --> 01:06:42,020
I'll just go back here and ....

1086
01:06:46,080 --> 01:06:46,910
un-comment  that

1087
01:06:48,450 --> 01:06:49,310
and now we've got ....

1088
01:06:50,340 --> 01:06:52,800
sort the collection
by terminals is failing.

1089
01:06:54,080 --> 01:06:56,510
Ok, so I'm hoping we can
pick up the pace a bit now.

1090
01:06:58,740 --> 01:07:00,050
What situation are we in?

1091
01:07:00,770 --> 01:07:02,600
Undefined method
terminal count

1092
01:07:03,540 --> 01:07:05,570
I can start writing
specs around that.

1093
01:07:05,970 --> 01:07:07,570
For the moment
I don't have any.

1094
01:07:11,770 --> 01:07:13,480
So if we've only
got a single node.

1095
01:07:14,620 --> 01:07:15,680
It has no terminals.

1096
01:07:38,940 --> 01:07:41,140
It's complaining
about undefined method.

1097
01:07:42,740 --> 01:07:43,680
I've done with that.

1098
01:07:49,850 --> 01:07:51,570
If we just have
that return zero,

1099
01:07:52,080 --> 01:07:53,770
at least that
example will pass

1100
01:07:53,770 --> 01:07:55,400
and that's not
broken anything.

1101
01:08:05,110 --> 01:08:07,370
Now we have to do
something more difficult.

1102
01:08:07,370 --> 01:08:08,170
Which is:

1103
01:08:08,850 --> 01:08:09,850
How does this work ....

1104
01:08:15,820 --> 01:08:16,910
This is the flat tree.

1105
01:08:21,620 --> 01:08:23,110
That's going
to work as well.

1106
01:08:24,420 --> 01:08:25,510
DN: With no extra work.

1107
01:08:25,510 --> 01:08:27,850
TS: Yes that's great, and
we can just stop there!

1108
01:08:30,020 --> 01:08:31,970
This is going to
be more challenging.

1109
01:08:32,910 --> 01:08:34,910
It has three
terminals, is that right?

1110
01:08:36,020 --> 01:08:36,600
DN: Yes.

1111
01:08:38,250 --> 01:08:40,400
We're expecting the
node terminal count.

1112
01:08:40,420 --> 01:08:41,450
to be equal to three.

1113
01:08:49,970 --> 01:08:50,880
Let's run this one.

1114
01:08:53,570 --> 01:08:54,850
Expected three, got zero.

1115
01:09:03,620 --> 01:09:04,850
What do I want to do here?

1116
01:09:07,970 --> 01:09:10,020
I'm counting how
many leaves there are.

1117
01:09:17,820 --> 01:09:20,820
But I only want the leaves that
are at the maximum depth.

1118
01:09:21,820 --> 01:09:22,800
DN: That's right, yes.

1119
01:09:28,510 --> 01:09:31,220
TS: That gives me the idea
of having another method,

1120
01:09:34,450 --> 01:09:36,050
that can be
called leaf_count,

1121
01:09:39,250 --> 01:09:40,770
that takes a
depth argument.

1122
01:09:47,710 --> 01:09:50,170
We're going to have some
kind of maximum depth.

1123
01:10:03,080 --> 01:10:04,910
I think it would
be easier for me if

1124
01:10:05,310 --> 01:10:08,000
I thought of depth in the
way that I talked about it.

1125
01:10:10,280 --> 01:10:12,280
Let's go with
your method definition.

1126
01:10:13,710 --> 01:10:15,170
We just have
to make it work.

1127
01:10:16,370 --> 01:10:18,540
If we want to refactor
it then we can do so.

1128
01:10:20,110 --> 01:10:21,680
DN: I'm being
an awkward client.

1129
01:10:21,680 --> 01:10:23,250
TS: Yes this
is very realistic.

1130
01:10:23,250 --> 01:10:24,220
DN: Use my language!

1131
01:10:25,940 --> 01:10:28,340
TS: So in that case,
terminal count will just be

1132
01:10:28,820 --> 01:10:32,060
count all of the leaves
that are at depth MAX_DEPTH.

1133
01:10:38,910 --> 01:10:40,556
This just gives me an 'in' because

1134
01:10:40,600 --> 01:10:44,860
terminal count is one of those things

1135
01:10:44,860 --> 01:10:47,616
that we're not going
to be able to call recursively

1136
01:10:47,612 --> 01:10:50,196
we're not going to be able
to say on the child nodes:

1137
01:10:50,540 --> 01:10:55,836
"Tell me how many
terminal nodes are inside you".

1138
01:10:56,250 --> 01:10:58,200
Because the child
doesn't know where

1139
01:10:58,200 --> 01:10:59,050
it is in the tree.

1140
01:11:00,250 --> 01:11:02,080
It doesn't have
a link to its parent.

1141
01:11:02,080 --> 01:11:03,510
It just contains children.

1142
01:11:06,820 --> 01:11:08,710
The reason I'm
doing this is because

1143
01:11:08,710 --> 01:11:10,710
I can define
leaf count recursively.

1144
01:11:28,250 --> 01:11:30,020
If we don't have
any children then ....

1145
01:11:33,940 --> 01:11:35,340
If the depth
argument is 1

1146
01:11:45,650 --> 01:11:47,170
The root node
is at depth one

1147
01:11:47,170 --> 01:11:48,540
In your numbering system.

1148
01:11:48,540 --> 01:11:49,880
so the root is at depth one

1149
01:11:50,450 --> 01:11:51,770
and a child is at depth two

1150
01:11:52,880 --> 01:11:55,480
and another child is at
depth three, four and five.

1151
01:11:55,480 --> 01:11:55,940
DN: Yes.

1152
01:12:01,600 --> 01:12:02,740
If you are at depth one,

1153
01:12:03,420 --> 01:12:04,880
and you're a
leaf then you are

1154
01:12:04,880 --> 01:12:06,080
what we are looking for.

1155
01:12:06,600 --> 01:12:07,080
DN: Yes.

1156
01:12:07,080 --> 01:12:09,280
So you say count
how many leaves there are

1157
01:12:09,280 --> 01:12:10,740
and if you are already a leaf,

1158
01:12:12,050 --> 01:12:14,680
and we're looking for things
that are at depth one,

1159
01:12:14,680 --> 01:12:15,540
then return one.

1160
01:12:15,540 --> 01:12:17,540
Because that's
what you are yourself.

1161
01:12:18,140 --> 01:12:20,050
Otherwise, for
leaves at some other

1162
01:12:20,050 --> 01:12:21,050
depth return zero.

1163
01:12:23,880 --> 01:12:25,220
And in the recursive case,

1164
01:12:26,940 --> 01:12:29,020
I think we want to
do something similar.

1165
01:12:29,020 --> 01:12:29,710
We want to say:

1166
01:12:31,200 --> 01:12:33,140
This is going to
be more complicated.

1167
01:12:42,170 --> 01:12:43,680
As we recursively walk down,

1168
01:12:44,340 --> 01:12:46,140
we say now I
am looking for things

1169
01:12:47,800 --> 01:12:48,740
at one level lower.

1170
01:12:49,880 --> 01:12:52,600
So the root node is
looking for leaves at depth five.

1171
01:12:52,600 --> 01:12:54,850
But when it asks all
of its children it says

1172
01:12:54,850 --> 01:12:57,650
"do you guys have any leaf
descendants at depth four

1173
01:12:57,650 --> 01:13:00,480
because if you do that's
depth five with respect to me".

1174
01:13:06,400 --> 01:13:08,340
So we get all of
the child leaf counts

1175
01:13:09,080 --> 01:13:09,880
and add them up.

1176
01:13:14,450 --> 01:13:16,110
Let's try running that last test.

1177
01:13:16,450 --> 01:13:17,080
That passes.

1178
01:13:17,710 --> 01:13:18,800
If I run all the tests.

1179
01:13:19,820 --> 01:13:20,510
Got a failure:

1180
01:13:20,652 --> 01:13:22,910
"Double received unexpected
message: leaf_count"

1181
01:13:22,916 --> 01:13:25,248
This is the sort of
thing I was talking about.

1182
01:13:26,880 --> 01:13:29,220
The fact that there's
a failure there is fine.

1183
01:13:30,420 --> 01:13:33,110
Because it's what guides
me to stubbing methods out

1184
01:13:33,620 --> 01:13:36,140
of my test doubles and
then gives me feedback

1185
01:13:36,140 --> 01:13:38,280
on what the API of
those objects should be.

1186
01:13:38,280 --> 01:13:40,280
However in this
case those instances

1187
01:13:40,280 --> 01:13:42,280
are all objects of
the same class as me.

1188
01:13:44,540 --> 01:13:46,020
I think it
would be quicker

1189
01:13:48,740 --> 01:13:50,450
to make these
instances of node.

1190
01:13:56,650 --> 01:13:58,650
What was actually
the source of that?

1191
01:14:00,400 --> 01:14:01,170
This is line 38

1192
01:14:05,370 --> 01:14:06,600
Expect no new children.

1193
01:14:07,710 --> 01:14:09,510
I'm asking for
the terminal count.

1194
01:14:10,000 --> 01:14:12,450
And now I realise what
I should  have been doing.

1195
01:14:13,310 --> 01:14:15,000
This should have
just been node.

1196
01:14:15,570 --> 01:14:18,080
I already tried not
to use these test doubles

1197
01:14:19,250 --> 01:14:21,540
in places where I
was calling real methods.

1198
01:14:21,540 --> 01:14:25,770
They were for the purpose of
creating the [inaudible].

1199
01:14:28,910 --> 01:14:30,740
So all of those
tests are passing.

1200
01:14:34,770 --> 01:14:37,450
I feel moderately
confident that that is correct.

1201
01:14:38,770 --> 01:14:41,450
In which case, let's go
back to the Cucumber feature,

1202
01:14:45,450 --> 01:14:47,910
to see if we've done enough
work in the unit test

1203
01:14:47,910 --> 01:14:49,680
to make the
acceptance test pass.

1204
01:14:50,000 --> 01:14:52,000
We just haven't
implemented this yet.

1205
01:14:55,480 --> 01:14:57,620
Perhaps we should
have done that first.

1206
01:15:01,340 --> 01:15:03,200
What order do we
want these to be in?

1207
01:15:05,680 --> 01:15:08,310
DN: Is it sorting from small
to large at the moment?

1208
01:15:08,310 --> 01:15:08,910
TS: Yes.

1209
01:15:09,370 --> 01:15:10,940
DN: So it's not
much different.

1210
01:15:10,940 --> 01:15:12,710
It will be just
one node, wide tree.

1211
01:15:17,050 --> 01:15:17,770
Is that right?

1212
01:15:18,770 --> 01:15:19,600
TS: I think so yes.

1213
01:15:20,170 --> 01:15:21,880
DN: Deep tree
then deep wide tree.

1214
01:15:22,340 --> 01:15:22,940
TS: Yes.

1215
01:15:32,310 --> 01:15:33,250
TS: Oh dear...

1216
01:15:37,620 --> 01:15:39,220
This is very difficult to read.

1217
01:15:39,400 --> 01:15:41,200
My immediate
suspicion here is

1218
01:15:41,800 --> 01:15:43,370
that it is to
do with the sort

1219
01:15:43,370 --> 01:15:45,080
not being stable,
as I mentioned.

1220
01:15:46,650 --> 01:15:48,310
I can't read this
output and see

1221
01:15:48,480 --> 01:15:49,680
what the difference is.

1222
01:15:50,400 --> 01:15:53,310
My intuition is that
when you sort by terminal count

1223
01:16:03,770 --> 01:16:06,280
It's also fine for them
to be the other way round.

1224
01:16:06,850 --> 01:16:09,080
If we wanted them
to stay in the same order

1225
01:16:11,800 --> 01:16:13,740
in the array, we
can't use Ruby's sort_by.

1226
01:16:15,480 --> 01:16:17,220
Well we can, but
not out of the box.

1227
01:16:17,220 --> 01:16:18,820
We have to find
a way to preserve

1228
01:16:18,820 --> 01:16:20,400
the original
order of the list.

1229
01:16:20,400 --> 01:16:22,620
So that we can
associate all of the elements in

1230
01:16:22,620 --> 01:16:24,420
the list with
their original position

1231
01:16:24,420 --> 01:16:26,050
and then sort
by a compound key.

1232
01:16:27,450 --> 01:16:29,940
Firstly sort by how
many terminals they've got

1233
01:16:30,710 --> 01:16:33,220
and then by what
their original position in the

1234
01:16:33,220 --> 01:16:34,800
list was so
that is preserved.

1235
01:16:38,880 --> 01:16:41,140
DN: It's more likely
that I would be ordering

1236
01:16:41,140 --> 01:16:43,740
them by quantity, those
with the greatest number

1237
01:16:48,620 --> 01:16:50,450
and things that
have no terminals

1238
01:16:50,450 --> 01:16:51,620
is of no interest to me.

1239
01:16:52,600 --> 01:16:54,400
They are the
ones I want to ignore.

1240
01:16:54,850 --> 01:16:57,910
You could even throw away
the ones with zero terminals.

1241
01:17:01,940 --> 01:17:04,280
The use I would
have for this tree structure

1242
01:17:06,570 --> 01:17:07,970
it is not interesting to me.

1243
01:17:08,970 --> 01:17:12,170
TS: I will see if I can get
the existing test passing happily.

1244
01:17:12,170 --> 01:17:14,800
Then we can refine the
requirements if we want to.

1245
01:17:15,000 --> 01:17:16,880
It's been too long
since I committed.

1246
01:17:19,740 --> 01:17:20,310
So let's say:

1247
01:17:23,408 --> 01:17:25,970
I should have made
this change first incidentally,

1248
01:17:25,970 --> 01:17:27,850
I just lost track of
what we were doing.

1249
01:17:27,850 --> 01:17:30,896
Before I started
dropping down to RSpec,

1250
01:17:30,892 --> 01:17:33,450
I should have
allowed myself to see this fail,

1251
01:17:33,850 --> 01:17:36,200
and it would have
indicated that I needed to

1252
01:17:36,200 --> 01:17:37,970
go down and
write some unit tests.

1253
01:17:38,400 --> 01:17:38,910
I will say:

1254
01:17:54,220 --> 01:17:55,800
And then what
have I done here?

1255
01:17:55,800 --> 01:17:56,200
This is:

1256
01:18:08,110 --> 01:18:09,680
That's slightly frustrating.

1257
01:18:12,310 --> 01:18:14,740
The best I can do here
is to express our intent.

1258
01:18:15,450 --> 01:18:15,910
I can say:

1259
01:18:35,650 --> 01:18:38,050
That will verify
that this collection here

1260
01:18:39,310 --> 01:18:41,970
is exactly two long, and
has those two things in it

1261
01:18:43,420 --> 01:18:45,480
and we don't really
care about the order.

1262
01:18:45,480 --> 01:18:47,340
Because we do
care about the order

1263
01:18:47,340 --> 01:18:48,170
of the rest of it.

1264
01:18:48,170 --> 01:18:48,620
I can say:

1265
01:18:55,850 --> 01:18:57,740
This is a little
bit clumsy but it is

1266
01:18:59,220 --> 01:19:01,000
at least
expressing what we want.

1267
01:19:01,480 --> 01:19:01,873
DN: Yes.

1268
01:19:01,873 --> 01:19:03,370
You are saying
you don't care

1269
01:19:03,370 --> 01:19:04,540
what order they come in,

1270
01:19:04,540 --> 01:19:06,650
so we will use a
'matcher' to check they are

1271
01:19:06,650 --> 01:19:07,680
in the order we want.

1272
01:19:07,680 --> 01:19:09,340
Whereas we do
want the rest of it

1273
01:19:09,340 --> 01:19:10,710
to look exactly like that.

1274
01:19:12,280 --> 01:19:12,970
So, there we go.

1275
01:19:13,050 --> 01:19:13,710
DN: Very nice.

1276
01:19:15,250 --> 01:19:16,940
TS: We've got
everything passing.

1277
01:19:17,050 --> 01:19:18,820
I want to go back
and look at this.

1278
01:19:23,540 --> 01:19:25,310
We have definitely
done this bit ....

1279
01:19:25,310 --> 01:19:27,080
given a collection
of trees let me

1280
01:19:27,080 --> 01:19:28,400
sort by these properties.

1281
01:19:31,050 --> 01:19:33,050
This max-depth of
5 is implicit in the

1282
01:19:33,050 --> 01:19:34,450
definition of a terminal,

1283
01:19:34,450 --> 01:19:35,850
but we
haven't enforced it.

1284
01:19:39,510 --> 01:19:42,170
You haven't said, when
instantiating these trees,

1285
01:19:44,000 --> 01:19:46,020
enforce that it
isn't deeper than five.

1286
01:19:48,170 --> 01:19:49,650
But there is an implication.

1287
01:19:51,221 --> 01:19:53,310
And you've also
said the total should be

1288
01:19:53,317 --> 01:19:55,600
correct after adding
or removing nodes.

1289
01:19:56,324 --> 01:19:58,669
So there are
two things there.

1290
01:20:01,220 --> 01:20:04,170
What is most interesting
to me is the latter statement.

1291
01:20:09,050 --> 01:20:10,820
Although the enforcement of the

1292
01:20:10,820 --> 01:20:12,480
maximum depth is interesting.

1293
01:20:15,140 --> 01:20:16,800
Let's think
about the other one

1294
01:20:17,310 --> 01:20:18,620
and go back to that later.

1295
01:20:19,310 --> 01:20:21,340
DN: That is more
driving the API isn't it?

1296
01:20:21,340 --> 01:20:22,200
TS: I think so yes.

1297
01:20:25,740 --> 01:20:27,820
If only because, at
the moment we haven't

1298
01:20:27,820 --> 01:20:31,924
looked at what it
means to modify these trees.

1299
01:20:32,054 --> 01:20:35,208
At the moment it if
you look at our node class

1300
01:20:35,820 --> 01:20:38,492
you can't even get the children,

1301
01:20:39,549 --> 01:20:40,940
much less set them.

1302
01:20:41,020 --> 01:20:43,621
We haven't in
any way addressed

1303
01:20:43,621 --> 01:20:46,160
what it means to be able to
mutate these things.

1304
01:20:48,140 --> 01:20:50,420
That's an interesting
thing to think about.

1305
01:20:52,620 --> 01:20:54,280
I'm not sure how
to address that.

1306
01:21:00,280 --> 01:21:02,450
Let me make a
commit before I do anything.

1307
01:21:04,080 --> 01:21:04,600
So this is:

1308
01:21:29,570 --> 01:21:31,650
This is more
difficult to accommodate

1309
01:21:31,650 --> 01:21:33,370
in a cucumber
feature, but I think

1310
01:21:33,370 --> 01:21:35,200
there's probably
a way of doing it.

1311
01:21:42,280 --> 01:21:44,080
This is implicitly a requirement?

1312
01:21:44,910 --> 01:21:45,370
DN: Yes.

1313
01:21:45,740 --> 01:21:47,710
TS: What this
implies is that firstly

1314
01:21:47,710 --> 01:21:49,710
you should be able
to add or remove a node.

1315
01:21:49,710 --> 01:21:51,820
and secondly, when
you do so it shouldn't

1316
01:21:52,140 --> 01:21:53,570
change what's
going on here.

1317
01:21:58,820 --> 01:22:01,250
You should be able to
change one of these trees,

1318
01:22:01,250 --> 01:22:03,340
and then if I order
the collection again,

1319
01:22:03,340 --> 01:22:04,220
it should change.

1320
01:22:04,710 --> 01:22:05,770
DN: Exactly.

1321
01:22:08,400 --> 01:22:10,400
TS: So that
necessitates some kind of

1322
01:22:10,710 --> 01:22:12,420
acceptance test
that tells us

1323
01:22:14,170 --> 01:22:15,080
what it is we want.

1324
01:22:15,420 --> 01:22:17,480
And then some
kind of implementation

1325
01:22:18,480 --> 01:22:20,450
that allows us to
mutate these trees.

1326
01:22:23,420 --> 01:22:25,250
Or add and
remove nodes from them.

1327
01:22:27,910 --> 01:22:29,850
I'm trying to think
of the easiest way

1328
01:22:29,850 --> 01:22:30,480
to test that.

1329
01:22:36,050 --> 01:22:38,000
Maybe we need
a new feature which is

1330
01:22:38,050 --> 01:22:40,020
adding and
removing and updating it.

1331
01:22:47,020 --> 01:22:49,080
It's still part of
the sorting feature.

1332
01:22:51,970 --> 01:22:54,080
Given that I have
a collection of trees,

1333
01:22:56,770 --> 01:22:58,540
when I add a node
to one of them and

1334
01:23:02,400 --> 01:23:03,910
I sort the
collection again

1335
01:23:05,370 --> 01:23:07,200
then it should
still be ordered by

1336
01:23:07,200 --> 01:23:08,800
total number
of descendants.

1337
01:23:10,820 --> 01:23:12,710
DN: I had imagined
you would be doing

1338
01:23:13,340 --> 01:23:14,480
some kind of caching.

1339
01:23:14,880 --> 01:23:16,970
At the moment
you're not doing anything

1340
01:23:16,970 --> 01:23:18,570
with caching, all
you are doing

1341
01:23:18,570 --> 01:23:20,140
is counting
up live objects.

1342
01:23:22,970 --> 01:23:25,000
If you were to
create another feature

1343
01:23:25,000 --> 01:23:27,940
maybe we could call it
'manipulating trees' or something.

1344
01:23:27,940 --> 01:23:31,140
It could justifiably not be
part of the sorted trees story.

1345
01:23:31,910 --> 01:23:32,310
TS: Ok.

1346
01:23:36,400 --> 01:23:37,940
What's the best
way to do that....

1347
01:23:46,280 --> 01:23:48,400
I think what we are
thinking about here

1348
01:23:48,400 --> 01:23:50,170
is coming up with
an API for being

1349
01:23:50,170 --> 01:23:51,570
able to modify these trees.

1350
01:23:51,880 --> 01:23:52,480
DN: Yes.

1351
01:23:57,650 --> 01:23:59,800
TS: Let's say there is
a modifying feature.

1352
01:24:06,650 --> 01:24:07,110
Let's say:

1353
01:24:51,570 --> 01:24:53,340
I'm not sure what
I want to say here.

1354
01:24:53,770 --> 01:24:55,080
But something like that.

1355
01:24:55,080 --> 01:24:57,080
You start out with
one of these things,

1356
01:24:57,080 --> 01:24:59,200
and then you change
it and get a new one.

1357
01:25:07,880 --> 01:25:09,250
We don't need that anymore.

1358
01:25:11,140 --> 01:25:13,080
I think I can keep
putting this stuff

1359
01:25:13,080 --> 01:25:13,800
in tree steps.

1360
01:25:14,540 --> 01:25:17,110
If I run these cucumber
features it's going to say

1361
01:25:17,110 --> 01:25:18,370
you don't have any of this.

1362
01:25:30,020 --> 01:25:30,480
Let's say:

1363
01:25:40,850 --> 01:25:42,140
It doesn't matter really.

1364
01:25:43,050 --> 01:25:44,910
I guess we just
need to think about

1365
01:25:47,200 --> 01:25:48,370
what it is that goes in.

1366
01:25:49,650 --> 01:25:50,910
Now I've built 'some' tree.

1367
01:25:52,600 --> 01:25:54,170
I've got one
pending scenario.

1368
01:25:58,420 --> 01:26:00,080
I need to put
something in here.

1369
01:26:00,600 --> 01:26:02,710
that involves
adding a node to the tree.

1370
01:26:02,710 --> 01:26:05,200
And then I want to do
something that checks it.

1371
01:26:11,800 --> 01:26:14,000
To someone using
this from the outside,

1372
01:26:14,000 --> 01:26:16,000
what does adding a
node to a tree mean?

1373
01:26:18,970 --> 01:26:20,910
I think the
simplest thing is to add

1374
01:26:20,910 --> 01:26:22,250
another child at the root.

1375
01:26:28,700 --> 01:26:31,700
I guess it could be
"I've got a node that is already a tree".

1376
01:26:32,310 --> 01:26:32,910
I could say:

1377
01:26:41,110 --> 01:26:44,170
It could be a node with no
children or something like this:

1378
01:26:48,850 --> 01:26:50,680
and then I want
to somehow add that

1379
01:26:52,770 --> 01:26:53,850
as a child of the tree.

1380
01:26:55,650 --> 01:26:57,600
DN: I don't think
it would be necessary

1381
01:26:57,800 --> 01:26:59,250
to compose trees like that.

1382
01:26:59,540 --> 01:27:02,020
You would only ever be
adding one node at a time.

1383
01:27:02,710 --> 01:27:05,170
For example, when you
leave a comment on a blog,

1384
01:27:09,340 --> 01:27:11,510
they sometimes have
a 'nest it' type thing.

1385
01:27:11,510 --> 01:27:14,510
Imagine each node is
something that one user has added.

1386
01:27:16,770 --> 01:27:17,220
TS: Ok.

1387
01:27:17,450 --> 01:27:18,340
Well in that case ....

1388
01:27:20,450 --> 01:27:22,110
That's just making an empty node.

1389
01:27:24,770 --> 01:27:26,570
So I can add that,
and then I have to

1390
01:27:27,170 --> 01:27:28,880
do something to
my tree to add it.

1391
01:27:30,370 --> 01:27:32,940
So it could be that there's
some kind of add_child.

1392
01:27:34,220 --> 01:27:37,220
You haven't said anything
about the ordering of nodes.

1393
01:27:37,220 --> 01:27:39,480
Your diagram
suggests that you might not

1394
01:27:39,480 --> 01:27:40,800
care about the ordering.

1395
01:27:40,800 --> 01:27:42,170
You haven't drawn this as a

1396
01:27:43,140 --> 01:27:44,880
top to bottom,
left to right tree.

1397
01:27:45,310 --> 01:27:46,820
You just say
there are nodes

1398
01:27:47,200 --> 01:27:48,880
emanating out
from the center.

1399
01:27:51,570 --> 01:27:53,620
You can clarify
whether or not you care

1400
01:27:53,620 --> 01:27:56,080
but for the purpose of
this, we're just going to

1401
01:27:57,770 --> 01:27:59,650
add a child on to
the end of this node.

1402
01:28:05,140 --> 01:28:06,880
And then when
we get to this step

1403
01:28:06,880 --> 01:28:09,050
there is something
that is going to check

1404
01:28:09,050 --> 01:28:11,310
that this node has
been added to the tree.

1405
01:28:19,170 --> 01:28:21,820
We can go ahead and
start writing unit tests here

1406
01:28:22,710 --> 01:28:24,710
but my personal
preference would be

1407
01:28:24,710 --> 01:28:26,540
for making
these trees immutable.

1408
01:28:32,170 --> 01:28:33,800
Having this
return a new tree.

1409
01:28:39,400 --> 01:28:42,340
I don't think this example
is going to illustrate this,

1410
01:28:43,480 --> 01:28:46,050
but making these
structures immutable makes it

1411
01:28:46,770 --> 01:28:48,250
a lot easier to keep track of

1412
01:28:48,480 --> 01:28:49,850
what can possibly happen.

1413
01:29:03,280 --> 01:29:05,400
If I want to
memoize the result of those

1414
01:29:05,400 --> 01:29:07,250
recursive calls
then I could just

1415
01:29:07,250 --> 01:29:09,250
memoize them and
then next time I call them

1416
01:29:09,250 --> 01:29:10,820
you just get the memoized result.

1417
01:29:10,820 --> 01:29:12,740
And if you change
the tree, that just

1418
01:29:12,740 --> 01:29:13,940
means you have a new one.

1419
01:29:14,970 --> 01:29:17,420
And if you had some
kind of structural sharing,

1420
01:29:17,420 --> 01:29:19,250
so that when you
add an extra child,

1421
01:29:19,800 --> 01:29:21,800
you get a new tree
back but all of the

1422
01:29:21,800 --> 01:29:24,600
previous children are
literally the same objects.

1423
01:29:24,600 --> 01:29:25,970
But the parent node is new

1424
01:29:27,400 --> 01:29:29,820
and has a new child
and all of the cached stuff

1425
01:29:30,420 --> 01:29:32,910
would be shared from
the old parts of the tree

1426
01:29:32,910 --> 01:29:34,000
that haven't changed.

1427
01:29:34,000 --> 01:29:35,820
And then you
would have to re-build

1428
01:29:35,820 --> 01:29:37,770
the cache for the
new parts of the tree.

1429
01:29:37,770 --> 01:29:39,770
Driving all of that
stuff out with tests

1430
01:29:39,770 --> 01:29:41,200
is going to
be time consuming.

1431
01:29:41,220 --> 01:29:42,680
In my view,
it's going to make

1432
01:29:42,680 --> 01:29:44,450
for an easier
system to deal with

1433
01:29:47,080 --> 01:29:49,020
without these
things being mutable.

1434
01:29:51,600 --> 01:29:54,000
What I don't want, in
my capacity as a consumer

1435
01:29:54,000 --> 01:29:56,510
of this API, is to be
able to only do tree.children.

1436
01:30:01,340 --> 01:30:02,000
Like do that:

1437
01:30:06,110 --> 01:30:08,340
If there was just
an accessor on tree that

1438
01:30:08,340 --> 01:30:10,080
returned an
array of children and

1439
01:30:10,080 --> 01:30:11,940
I concatenated
that on to the end.

1440
01:30:12,740 --> 01:30:14,080
The root node of that tree

1441
01:30:14,080 --> 01:30:15,680
doesn't even know it's happened.

1442
01:30:25,050 --> 01:30:26,940
Now you have that
array in your hand

1443
01:30:26,940 --> 01:30:28,770
and you can do
whatever you like to it.

1444
01:30:28,770 --> 01:30:30,220
I don't really like the idea

1445
01:30:30,280 --> 01:30:31,570
of exposing it directly.

1446
01:30:32,020 --> 01:30:34,140
For the same reason
I don't like the idea

1447
01:30:35,250 --> 01:30:37,310
of this being
something that mutates

1448
01:30:37,970 --> 01:30:39,050
the underlying tree.

1449
01:30:39,050 --> 01:30:40,940
I would rather
just return a new one.

1450
01:30:41,340 --> 01:30:43,850
Assuming there's a way to
append the child there,

1451
01:30:46,450 --> 01:30:47,400
Which there isn't.

1452
01:30:48,450 --> 01:30:49,850
a failure in our features.

1453
01:30:52,080 --> 01:30:53,970
When I scroll off
the top you can see:

1454
01:30:54,110 --> 01:30:56,910
when I add a node to it
undefined method append_child.

1455
01:30:56,910 --> 01:30:58,370
So let's make
a commit there.

1456
01:31:08,510 --> 01:31:09,820
I'd like to make that work.

1457
01:31:11,910 --> 01:31:14,080
I think this is an
opportunity to do some ....

1458
01:31:15,370 --> 01:31:17,540
tidying up at the
implementation level.

1459
01:31:20,910 --> 01:31:22,970
We've expressed
what we want to happen

1460
01:31:23,540 --> 01:31:25,170
in the feature
here but let's go

1461
01:31:25,170 --> 01:31:26,280
down to the unit test.

1462
01:31:32,880 --> 01:31:34,020
Let's pick one of these.

1463
01:31:36,110 --> 01:31:37,970
This is quite a
nice one, where the

1464
01:31:37,970 --> 01:31:39,370
node has five descendants.

1465
01:31:45,220 --> 01:31:47,140
In this unit test
we have to decide,

1466
01:31:47,140 --> 01:31:48,570
and in the acceptance test,

1467
01:31:49,110 --> 01:31:51,340
how do we know if
it's done the right thing.

1468
01:31:53,800 --> 01:31:56,140
I don't really know how
we are going to do that.

1469
01:31:57,000 --> 01:31:59,450
DN: You could check
the number of descendants.

1470
01:31:59,450 --> 01:32:01,540
TS: At the moment
that's the only visibility

1471
01:32:01,540 --> 01:32:02,620
we have on to the tree.

1472
01:32:04,050 --> 01:32:05,510
Let's think about doing that.

1473
01:32:05,680 --> 01:32:06,140
Let's say:

1474
01:32:23,880 --> 01:32:25,880
So whatever that's
worth, we would say:

1475
01:32:34,310 --> 01:32:35,250
(Let's make a new one).

1476
01:32:39,000 --> 01:32:41,110
And this would be
the descendant count

1477
01:32:43,020 --> 01:32:43,940
to be equal to six.

1478
01:32:45,820 --> 01:32:48,140
I think that would
give us some confidence

1479
01:32:48,250 --> 01:32:50,110
that the right
thing has happened.

1480
01:32:50,310 --> 01:32:52,310
That's the best we
can do at the moment,

1481
01:32:52,310 --> 01:32:54,310
based on the API
that's available to us.

1482
01:32:55,140 --> 01:32:56,740
Let's try running that example.

1483
01:32:57,020 --> 01:32:58,540
undefined method add_child.

1484
01:33:02,970 --> 01:33:04,820
Now we're going to
need a method here

1485
01:33:07,000 --> 01:33:07,910
that adds a child.

1486
01:33:11,280 --> 01:33:13,310
There's a very easy
thing we can do here.

1487
01:33:13,710 --> 01:33:14,480
Which is to say,

1488
01:33:27,020 --> 01:33:29,050
And that's enough
to make the test pass.

1489
01:33:29,050 --> 01:33:31,140
That's moderately
convincing I think.

1490
01:33:35,340 --> 01:33:37,540
I don't think that
spec would have passed

1491
01:33:37,540 --> 01:33:38,480
if that didn't work.

1492
01:33:39,000 --> 01:33:40,620
So I'll make a
commit there and

1493
01:33:41,370 --> 01:33:42,620
I'll say something like:

1494
01:33:50,080 --> 01:33:50,540
Whoops .....

1495
01:33:51,910 --> 01:33:54,310
That's a nice simple
implementation I think.

1496
01:33:56,600 --> 01:33:58,050
How did you feel about that?

1497
01:33:58,650 --> 01:33:59,220
DN: I like it.

1498
01:34:03,140 --> 01:34:05,220
TS: Let's go back
to the step definitions

1499
01:34:06,710 --> 01:34:09,080
and finish off,
because we're still not done.

1500
01:34:13,740 --> 01:34:15,080
That's made that step work.

1501
01:34:15,280 --> 01:34:16,400
And now we have to say:

1502
01:34:32,820 --> 01:34:34,140
Because that one was two.

1503
01:34:36,420 --> 01:34:37,800
DN: Just before
you move on,

1504
01:34:37,800 --> 01:34:39,600
I notice you used
append_child there,

1505
01:34:39,600 --> 01:34:41,600
but it's add_child
in the implementation.

1506
01:34:42,820 --> 01:34:43,450
TS: Thank you.

1507
01:34:44,020 --> 01:34:46,080
Well that's stupid
why didn't that fail?

1508
01:34:47,080 --> 01:34:48,850
Oh it did fail, I
just didn't read it.

1509
01:34:56,450 --> 01:34:58,770
Yes you're right,
append_child is a better name

1510
01:34:59,340 --> 01:35:01,340
DN: For the immutable nature of it?

1511
01:35:01,340 --> 01:35:03,650
TS: Because it tells you
where it's going to go.

1512
01:35:05,020 --> 01:35:06,446
DN: Right: 'Add child below me'.

1513
01:35:07,250 --> 01:35:09,510
TS: Yes, and the fact
that it goes on the end.

1514
01:35:10,330 --> 01:35:12,126
After the existing children.

1515
01:35:12,170 --> 01:35:14,185
At the moment you can't tell.

1516
01:35:16,420 --> 01:35:17,880
So yes, let's call it add_child

1517
01:35:18,280 --> 01:35:20,220
because at the
moment there's no way

1518
01:35:20,220 --> 01:35:21,620
of knowing where it's gone.

1519
01:35:24,170 --> 01:35:26,310
If at some point
we decide we're going to

1520
01:35:26,310 --> 01:35:28,620
be able to expose
the collection of children

1521
01:35:28,620 --> 01:35:30,420
and now we care
about where it comes

1522
01:35:30,420 --> 01:35:31,280
when you have it,

1523
01:35:31,280 --> 01:35:33,420
that would be the
point at which to make it.

1524
01:35:33,420 --> 01:35:35,800
But right now you
can't make that distinction.

1525
01:35:40,280 --> 01:35:41,600
Let's just commit that fix.

1526
01:35:41,940 --> 01:35:43,050
That looks annoying.

1527
01:35:47,620 --> 01:35:48,200
And this is:

1528
01:36:02,680 --> 01:36:03,250
That's fine.

1529
01:36:05,910 --> 01:36:08,080
We are ignoring
the fact that presumably

1530
01:36:08,080 --> 01:36:10,200
the whole point
of all of these trees is

1531
01:36:10,200 --> 01:36:12,420
that you can at some
point get to the nodes.

1532
01:36:13,420 --> 01:36:15,940
At the moment there's
no API for getting to them.

1533
01:36:18,770 --> 01:36:20,540
I would like to
bring that out a bit

1534
01:36:21,770 --> 01:36:23,110
by saying something like:

1535
01:36:34,250 --> 01:36:35,880
I think that to
not do that is to

1536
01:36:37,310 --> 01:36:38,650
slightly dodge the issue.

1537
01:36:41,800 --> 01:36:42,570
DN: Sure

1538
01:36:44,370 --> 01:36:46,340
TS: We don't have a
way of doing this yet.

1539
01:36:46,970 --> 01:36:49,800
DN: So at the moment
children is a private attribute.

1540
01:36:50,420 --> 01:36:52,220
TS: Well it's
an instance variable.

1541
01:36:52,220 --> 01:36:53,250
There is no children.

1542
01:36:53,250 --> 01:36:55,310
Not even a private
method called children.

1543
01:36:55,400 --> 01:36:56,480
so that's going to say

1544
01:36:57,250 --> 01:36:59,140
"I don't know
what you're talking about".

1545
01:37:02,510 --> 01:37:05,050
In the specification,
you didn't say explicitly,

1546
01:37:05,050 --> 01:37:07,450
but I think implicit
in all of this stuff is:

1547
01:37:09,310 --> 01:37:10,680
Where you say model a tree.

1548
01:37:13,620 --> 01:37:15,480
It is implied that
you want access

1549
01:37:17,450 --> 01:37:18,880
to the contents of the tree?

1550
01:37:18,880 --> 01:37:19,600
DN: Sure.

1551
01:37:21,570 --> 01:37:23,540
TS: So this gives us
a way in and verify

1552
01:37:27,020 --> 01:37:29,170
that the children of
the tree are inclusive.

1553
01:37:29,170 --> 01:37:30,200
I want to check this.

1554
01:37:31,050 --> 01:37:32,280
If it was an empty array,

1555
01:37:35,370 --> 01:37:36,570
then that should fail.

1556
01:37:37,420 --> 01:37:39,450
We expected that
to include that node.

1557
01:37:39,910 --> 01:37:42,170
If I just had an
array that had additional

1558
01:37:42,600 --> 01:37:45,570
node in there then I think
that my... Yeah!

1559
01:37:45,800 --> 01:37:48,650
That's to verify that my
rspec expectation is right.

1560
01:37:51,310 --> 01:37:53,650
Because I always
spell include or includes ....

1561
01:37:54,970 --> 01:37:56,680
or does it
have a question mark.

1562
01:37:56,680 --> 01:37:58,310
Every time I type include in Ruby,

1563
01:37:58,310 --> 01:37:59,020
I get it wrong.

1564
01:37:59,450 --> 01:38:01,770
So that has given
me confidence that my test

1565
01:38:01,770 --> 01:38:03,170
is testing the right thing.

1566
01:38:03,200 --> 01:38:05,340
Now, that
introduces a new requirement

1567
01:38:06,020 --> 01:38:07,940
which is how do
we get at the children

1568
01:38:07,940 --> 01:38:08,510
of the tree?

1569
01:38:18,200 --> 01:38:20,650
I guess that means we
need a test here that says ....

1570
01:38:24,110 --> 01:38:25,820
This would be a good place for it.

1571
01:38:33,850 --> 01:38:35,050
Or something like that.

1572
01:38:36,880 --> 01:38:39,650
It exposes that it's
possible to 'get at' the children:

1573
01:38:42,450 --> 01:38:43,050
I would say:

1574
01:38:59,310 --> 01:39:01,770
I can round trip
that collection of children

1575
01:39:02,540 --> 01:39:03,420
through the node.

1576
01:39:07,680 --> 01:39:09,310
There's some duplication here

1577
01:39:09,310 --> 01:39:10,140
but I'll leave  it.

1578
01:39:10,450 --> 01:39:12,340
All over here
we've got places where

1579
01:39:12,340 --> 01:39:13,970
we're making
node.new children.

1580
01:39:13,970 --> 01:39:15,970
There's a temptation
to have one of these

1581
01:39:15,970 --> 01:39:17,050
let things that says:

1582
01:39:18,620 --> 01:39:19,600
Here we could do it.

1583
01:39:22,310 --> 01:39:22,820
That says:

1584
01:39:28,110 --> 01:39:30,020
That means that
all of these places

1585
01:39:30,020 --> 01:39:31,710
where I've got
node.new children,

1586
01:39:32,450 --> 01:39:34,280
I can replace
that with just node.

1587
01:39:36,970 --> 01:39:38,740
And I think
that those tests will.... ,

1588
01:39:39,940 --> 01:39:40,280
Wow!

1589
01:39:41,420 --> 01:39:42,510
completely explode.

1590
01:39:43,770 --> 01:39:44,970
That's not what I wanted.

1591
01:39:45,600 --> 01:39:47,280
Oh, it's because
this is nonsense.

1592
01:39:48,910 --> 01:39:49,570
It should be:

1593
01:40:03,310 --> 01:40:04,770
I was reading the one above.

1594
01:40:07,820 --> 01:40:09,620
This is not
supposed to be a block.

1595
01:40:09,620 --> 01:40:11,140
This is an argument to expect.

1596
01:40:12,710 --> 01:40:14,340
That's the one failure I wanted.

1597
01:40:23,680 --> 01:40:25,000
That is not what I wanted.

1598
01:40:28,310 --> 01:40:29,220
What did I do here?

1599
01:40:30,140 --> 01:40:30,710
Oh this was:

1600
01:40:46,800 --> 01:40:47,820
here I wanted to add ....

1601
01:40:49,220 --> 01:40:51,110
(I've raced ahead
and done two things).

1602
01:40:52,250 --> 01:40:53,400
I just want to add that:

1603
01:40:57,740 --> 01:41:00,570
That is still not added
but all the rest of it which is:

1604
01:41:10,020 --> 01:41:11,710
That has
cleaned up my spec a bit.

1605
01:41:12,400 --> 01:41:13,910
And now I've
just got this new

1606
01:41:15,510 --> 01:41:16,850
example which is failing.

1607
01:41:26,220 --> 01:41:28,080
I'm not going
to spend time writing

1608
01:41:28,080 --> 01:41:30,080
examples around
this, but I don't want

1609
01:41:30,310 --> 01:41:32,200
to expose just
that children array.

1610
01:41:33,400 --> 01:41:34,710
I think that would be bad.

1611
01:41:36,280 --> 01:41:38,540
Because then you
would be able to modify it.

1612
01:41:40,170 --> 01:41:41,740
The simplest
thing I can do to

1613
01:41:41,740 --> 01:41:43,200
make the test pass is to say:

1614
01:41:45,880 --> 01:41:47,650
In fact I don't
even need to do that.

1615
01:41:47,650 --> 01:41:48,370
I can just say:

1616
01:41:53,820 --> 01:41:56,020
I think that will
make all of my tests pass,

1617
01:41:57,300 --> 01:41:58,970
and hopefully
when I run all my

1618
01:41:58,970 --> 01:42:01,420
cucumber features,
it will make them all pass.

1619
01:42:01,420 --> 01:42:02,880
So I will commit that and say:

1620
01:42:10,420 --> 01:42:12,080
But, I'm not really happy about it.

1621
01:42:13,480 --> 01:42:14,940
DN: Even though it's a reader,

1622
01:42:14,940 --> 01:42:16,940
you can take that
object and modify it.

1623
01:42:16,940 --> 01:42:19,170
TS: Exactly.  It doesn't
let you re-assign the

1624
01:42:20,020 --> 01:42:22,570
children collection, but
once you have an array

1625
01:42:23,310 --> 01:42:25,170
you can
remove everything from it

1626
01:42:25,170 --> 01:42:26,170
and re-populate it.

1627
01:42:35,620 --> 01:42:37,020
We could freeze the array.

1628
01:42:38,820 --> 01:42:40,910
We can make
an accessor here that says:

1629
01:42:47,510 --> 01:42:48,600
Can we freeze it here?

1630
01:42:51,650 --> 01:42:53,770
I think if we do
that, it will still work.

1631
01:42:59,050 --> 01:42:59,710
DN: Yes, right.

1632
01:42:59,710 --> 01:43:01,910
TS: Our cucumber
features will still work.

1633
01:43:03,110 --> 01:43:04,970
So that's one
way of dealing with it.

1634
01:43:04,970 --> 01:43:07,170
I think a more
interesting way would be ....

1635
01:43:08,280 --> 01:43:09,600
to expose an enumerator.

1636
01:43:38,650 --> 01:43:40,910
I think that would
feel more natural to me.

1637
01:43:40,910 --> 01:43:43,250
To say "if you want
to iterate over my children".

1638
01:43:43,280 --> 01:43:44,170
"Then you may do so".

1639
01:43:47,322 --> 01:43:50,766
If I just pop open irb:

1640
01:43:51,000 --> 01:43:52,837
"if I have an array".

1641
01:44:00,160 --> 01:44:02,892
There are a variety of
ways to make an enumerator out of that

1642
01:44:02,901 --> 01:44:05,473
you can call to_enum, or
you can just call each

1643
01:44:05,510 --> 01:44:07,340
and that also returns enumerator.

1644
01:44:08,510 --> 01:44:11,000
I think here I would
like to define an iterator.

1645
01:44:12,650 --> 01:44:14,570
So if we can
iterate over each child,

1646
01:44:15,200 --> 01:44:16,480
and I can provide a block.

1647
01:44:17,050 --> 01:44:19,420
Then I will call each
on the children for you.

1648
01:44:23,510 --> 01:44:24,710
And that's nice because ....

1649
01:44:29,170 --> 01:44:30,200
if I have some class,

1650
01:44:35,510 --> 01:44:35,970
If I call:

1651
01:44:42,280 --> 01:44:44,450
If I pass on the block argument like that.

1652
01:44:44,740 --> 01:44:46,110
And make a new one of these.

1653
01:44:52,310 --> 01:44:53,220
Then it will work.

1654
01:44:54,220 --> 01:44:56,000
If I don't pass in
a block, each will

1655
01:44:57,200 --> 01:44:59,200
behave as if I
haven't passed in a block,

1656
01:44:59,200 --> 01:45:00,970
which gives you
an iterator back.

1657
01:45:00,970 --> 01:45:03,140
This gives you the
same as doing 10.times.each:

1658
01:45:10,080 --> 01:45:12,000
Or I've just been
using 10.times and then

1659
01:45:12,680 --> 01:45:14,370
not passing it
a block, and then

1660
01:45:15,820 --> 01:45:18,140
calling something like
map on the end of it.

1661
01:45:18,710 --> 01:45:21,170
The reason that works
is because these methods

1662
01:45:21,170 --> 01:45:23,620
in the standard
library return an enumerator.

1663
01:45:24,540 --> 01:45:27,050
The opportunity to
return an enumerator here

1664
01:45:27,280 --> 01:45:28,400
is a nicer interface.

1665
01:45:29,570 --> 01:45:32,170
It's more constrained,
and gives you what you want.

1666
01:45:35,140 --> 01:45:37,250
And, you don't even
know that it's an array.

1667
01:45:37,250 --> 01:45:39,280
The enumerator
itself doesn't let you

1668
01:45:39,280 --> 01:45:40,480
reach inside it and say

1669
01:45:42,680 --> 01:45:45,000
"what kind of thing
are you iterating over"?

1670
01:45:47,420 --> 01:45:48,620
So that feels quite nice.

1671
01:45:49,820 --> 01:45:53,020
The problem is that that's
going to break all of our examples,

1672
01:45:53,020 --> 01:45:55,280
or just this one
that asks for the children.

1673
01:45:55,310 --> 01:45:57,570
DN: So we still don't
have a children method.

1674
01:45:57,570 --> 01:45:59,450
TS: No. We just have
a way of iterating

1675
01:46:00,220 --> 01:46:01,540
over all of the children.

1676
01:46:03,770 --> 01:46:05,800
So we need to
change our spec slightly.

1677
01:46:08,620 --> 01:46:10,340
So I can't call
children any more,

1678
01:46:10,340 --> 01:46:11,200
I can only call each_child.

1679
01:46:12,420 --> 01:46:14,250
Which gives me
an enumerator back.

1680
01:46:15,570 --> 01:46:17,570
If I want to
check all the things that

1681
01:46:20,370 --> 01:46:22,020
are yielded by that enumerator.

1682
01:46:22,020 --> 01:46:23,680
I could write some code that says:

1683
01:46:26,110 --> 01:46:28,050
I could pass this
a block and then say:

1684
01:46:31,250 --> 01:46:33,740
append_child if I
had already initialized one.

1685
01:46:34,910 --> 01:46:37,310
But fortunately
enumerators include the

1686
01:46:37,310 --> 01:46:39,110
enumerable module which already

1687
01:46:39,110 --> 01:46:40,400
has a method called that.

1688
01:46:40,450 --> 01:46:41,510
It's called entries.

1689
01:46:42,170 --> 01:46:44,200
So I can say "if I get
an enumeration of all

1690
01:46:45,420 --> 01:46:47,600
the children, and
turn that into an array

1691
01:46:48,420 --> 01:46:49,940
by accumulating all of them.

1692
01:46:49,940 --> 01:46:52,450
That should be the
same as the array of children".

1693
01:46:59,940 --> 01:47:01,540
What's that complaining about?

1694
01:47:03,140 --> 01:47:04,970
Node line 9.
Oh it's because I forgot

1695
01:47:07,170 --> 01:47:09,200
to refer to it
as an instance variable.

1696
01:47:14,480 --> 01:47:15,370
So that's all fine.

1697
01:47:17,110 --> 01:47:18,910
If I now run
my cucumber features.

1698
01:47:19,570 --> 01:47:21,280
I've got a
failure because that's

1699
01:47:22,680 --> 01:47:24,050
calling children as well.

1700
01:47:27,200 --> 01:47:29,080
This is all
about designing the API.

1701
01:47:31,000 --> 01:47:33,110
I've got an
opportunity to shape the API,

1702
01:47:37,910 --> 01:47:39,800
and those changes
to the API need to

1703
01:47:41,680 --> 01:47:43,770
propagate out of
the cucumber feature

1704
01:47:43,770 --> 01:47:45,970
because in the
world where the customer

1705
01:47:47,080 --> 01:47:49,050
is the person using
the API, we need to

1706
01:47:49,050 --> 01:47:51,400
make sure that all the
things they want to do

1707
01:47:51,620 --> 01:47:52,850
have been designed out.

1708
01:47:52,850 --> 01:47:54,880
And I think that
exposing an iterator,

1709
01:47:55,220 --> 01:47:58,220
although it's not as nice
as being able to call children.

1710
01:47:58,220 --> 01:48:00,310
In fact, we could
add a children method

1711
01:48:01,050 --> 01:48:02,620
that does each_child.entries

1712
01:48:04,110 --> 01:48:05,740
if we wanted to,
but this is nice.

1713
01:48:06,450 --> 01:48:08,200
It's low level
but it exposes the ....

1714
01:48:09,940 --> 01:48:12,570
This is like the essence
of the interface, is that

1715
01:48:13,740 --> 01:48:15,910
you can iterate
over all of the children.

1716
01:48:19,250 --> 01:48:20,250
I will commit that:

1717
01:48:35,540 --> 01:48:39,684
DN: If you did call each_child.entries
and the array that you get back

1718
01:48:39,680 --> 01:48:42,113
if you then changed
that, it wouldn't affect it.

1719
01:48:42,110 --> 01:48:43,940
TS: Right. Because that's your array

1720
01:48:43,940 --> 01:48:44,570
DN: It's a copy.

1721
01:48:45,710 --> 01:48:47,620
TS: The tree doesn't
even know that you

1722
01:48:47,620 --> 01:48:49,600
have called entries
on that enumerator.

1723
01:48:49,600 --> 01:48:50,540
You've just got one.

1724
01:48:53,220 --> 01:48:54,420
In fact, that reminds me.

1725
01:48:56,820 --> 01:48:58,620
In terms of
designing the API of

1726
01:48:58,620 --> 01:49:00,420
this thing or
doing some re-factoring.

1727
01:49:00,420 --> 01:49:02,450
You can see there
are a few places where

1728
01:49:02,450 --> 01:49:04,110
we want to
know if this is empty.

1729
01:49:06,420 --> 01:49:07,820
Here's the clearest point.

1730
01:49:07,820 --> 01:49:09,200
What we are asking here is

1731
01:49:09,200 --> 01:49:10,310
whether we are a leaf.

1732
01:49:10,710 --> 01:49:11,220
"Am I a leaf?"

1733
01:49:12,140 --> 01:49:13,570
That's what it really means.

1734
01:49:15,800 --> 01:49:17,510
If we're a leaf
do this otherwise

1735
01:49:17,510 --> 01:49:18,570
do this other thing.

1736
01:49:20,820 --> 01:49:22,140
We can have a method here.

1737
01:49:22,910 --> 01:49:24,110
Which is "are you a leaf"?

1738
01:49:26,650 --> 01:49:28,140
Because I've got access to it

1739
01:49:28,140 --> 01:49:29,650
I can just say children.empty?

1740
01:49:31,970 --> 01:49:34,110
But I'm nervous
about all of these places

1741
01:49:34,480 --> 01:49:37,050
where we're referring
to the instance variable.

1742
01:49:38,220 --> 01:49:40,740
I would much rather
have the instance variable

1743
01:49:41,140 --> 01:49:42,600
in as few places as possible.

1744
01:49:50,340 --> 01:49:52,250
Instead of all
these places where

1745
01:49:52,880 --> 01:49:54,310
I'm accessing the children

1746
01:49:54,570 --> 01:49:56,280
For example, in
this leaf method,

1747
01:49:56,280 --> 01:49:58,680
instead of saying
children.empty?, I could say:

1748
01:50:01,770 --> 01:50:03,310
So build me an
array, and then

1749
01:50:04,140 --> 01:50:05,540
tell me whether it's empty.

1750
01:50:05,540 --> 01:50:07,540
But there's an even
better way of doing that.

1751
01:50:07,540 --> 01:50:09,540
Enumerable has
a method called 'none?'.

1752
01:50:11,540 --> 01:50:13,910
So if I call each_child
to get the enumerator ....

1753
01:50:13,910 --> 01:50:14,370
I can say:

1754
01:50:15,080 --> 01:50:17,020
That is saying
"are there no children?".

1755
01:50:18,510 --> 01:50:21,020
In fact it will tell me if there
are any children that are nil or false,

1756
01:50:22,140 --> 01:50:24,000
but in this case,
none takes a block

1757
01:50:25,480 --> 01:50:27,740
and you can say
"are there no children that

1758
01:50:27,740 --> 01:50:28,913
satisfy this condition?"

1759
01:50:28,910 --> 01:50:30,650
If you don't provide the block, it says:

1760
01:50:30,650 --> 01:50:32,600
"are there no children that are truthy?",

1761
01:50:33,620 --> 01:50:36,200
which in our case is the
same as there being none.

1762
01:50:36,200 --> 01:50:38,480
If I run all of the unit
tests, that still works.

1763
01:50:39,250 --> 01:50:41,480
And all the
cucumber features still work.

1764
01:50:42,540 --> 01:50:44,420
That gives me
an opportunity to say:

1765
01:50:55,510 --> 01:50:57,370
And there are
several other places

1766
01:50:57,370 --> 01:50:58,400
where I could do this.

1767
01:50:58,400 --> 01:51:00,170
I'm only using
children here  to map

1768
01:51:00,170 --> 01:51:03,140
over something, which
each_child will do quite nicely.

1769
01:51:06,420 --> 01:51:07,110
And same here.

1770
01:51:12,480 --> 01:51:14,800
All I am doing with
this instance variable

1771
01:51:14,820 --> 01:51:16,770
using it to remember the
value that was passed

1772
01:51:16,770 --> 01:51:18,480
into the constructor,
and then I am

1773
01:51:18,480 --> 01:51:20,050
exposing a way of iterating over it.

1774
01:51:21,280 --> 01:51:23,370
So the only state
that is stored in here,

1775
01:51:25,770 --> 01:51:27,710
allows you to
expose it in iteration,

1776
01:51:27,710 --> 01:51:30,420
and some of the work is
done by doing that iteration.

1777
01:51:31,540 --> 01:51:32,820
So if I run all of my tests.

1778
01:51:33,600 --> 01:51:34,250
They're fine.

1779
01:51:34,250 --> 01:51:36,170
And the cucumber features are fine.

1780
01:51:37,570 --> 01:51:38,620
I can change this to:

1781
01:51:46,370 --> 01:51:48,080
The only frustrating thing is

1782
01:51:48,080 --> 01:51:49,140
because we did this children.size ....

1783
01:51:54,800 --> 01:51:56,680
When you create
an enumerator, it is

1784
01:51:56,680 --> 01:51:58,770
possible to tell it
how to find the size

1785
01:51:58,940 --> 01:52:00,540
of the underlying collection.

1786
01:52:00,540 --> 01:52:01,710
Some enumerators can.

1787
01:52:02,800 --> 01:52:04,450
It has always
got a size method,

1788
01:52:04,450 --> 01:52:06,450
but sometimes it returns nil if the

1789
01:52:06,450 --> 01:52:09,080
enumerator has been
created without providing

1790
01:52:09,080 --> 01:52:11,680
what the size of the
underlying enumeration is.

1791
01:52:14,910 --> 01:52:17,170
If I say each and
then ask that for its size.

1792
01:52:18,570 --> 01:52:20,970
In the case where
the underlying collection

1793
01:52:20,970 --> 01:52:23,250
that you've provided,
does report the size,

1794
01:52:24,880 --> 01:52:26,400
you can get the size back out.

1795
01:52:28,420 --> 01:52:30,310
I feel slightly nervous about that.

1796
01:52:31,620 --> 01:52:33,020
Oh! But, I've just remembered!

1797
01:52:35,540 --> 01:52:37,940
I think enumerable
has a method called count.

1798
01:52:41,650 --> 01:52:43,700
Which does
something like 'all' or 'none'.

1799
01:52:45,220 --> 01:52:47,740
You can give it a block
and it will tell you for

1800
01:52:47,740 --> 01:52:49,370
how many
items in the enumeration,

1801
01:52:49,370 --> 01:52:50,310
that block is true.

1802
01:52:53,170 --> 01:52:55,200
But I'm not sure
if this is going to work.

1803
01:52:56,310 --> 01:52:56,940
It does, good.

1804
01:53:01,650 --> 01:53:03,970
In all these cases
I have avoided building

1805
01:53:04,570 --> 01:53:06,080
an array of all the children.

1806
01:53:11,480 --> 01:53:13,400
Now that we
are only accessing that

1807
01:53:14,080 --> 01:53:16,400
children collection....
(we have got to do this).

1808
01:53:16,940 --> 01:53:19,250
Apart from that we
are only accessing that

1809
01:53:19,250 --> 01:53:21,340
children collection
through the iterator,

1810
01:53:21,340 --> 01:53:22,880
which means
that children can be

1811
01:53:22,910 --> 01:53:24,250
anything that's enumerable,

1812
01:53:24,250 --> 01:53:25,949
anything that
responds to each.

1813
01:53:25,957 --> 01:53:27,397
It doesn't have to be an array.

1814
01:53:27,630 --> 01:53:30,450
It could be some
sort of 'lazy collection',

1815
01:53:31,510 --> 01:53:32,970
which you haven't specified.

1816
01:53:33,280 --> 01:53:34,970
But designing it
this way means

1817
01:53:35,370 --> 01:53:37,770
we are gradually
reducing the surface area

1818
01:53:37,770 --> 01:53:39,450
of what we expect from children.

1819
01:53:39,450 --> 01:53:41,450
All we require
from children is that

1820
01:53:41,450 --> 01:53:43,000
we can call each
on it, to get an

1821
01:53:43,000 --> 01:53:44,880
enumerator back,
and the rest of the

1822
01:53:44,880 --> 01:53:46,880
functionality sits
on top of that single

1823
01:53:46,880 --> 01:53:49,510
assumption about what
we can do with  the children.

1824
01:53:52,340 --> 01:53:54,310
I'm not changing
the tests at all here.

1825
01:53:54,680 --> 01:53:56,680
I'm just getting a
chance to re-factor:

1826
01:54:08,450 --> 01:54:10,170
And then,
(this one is a bit tricky).

1827
01:54:10,540 --> 01:54:12,200
There are two ways of doing this.

1828
01:54:13,420 --> 01:54:14,880
I'll show you the stupid way.

1829
01:54:14,880 --> 01:54:17,200
Well, you don't need me
to show you stupid way.

1830
01:54:18,140 --> 01:54:19,000
It's just:

1831
01:54:27,480 --> 01:54:28,400
Run all the tests.

1832
01:54:29,370 --> 01:54:30,510
Run all the cucumbers.

1833
01:54:31,110 --> 01:54:31,710
That's fine.

1834
01:54:32,110 --> 01:54:32,770
DN: Yes.

1835
01:54:34,570 --> 01:54:36,370
TS: I think a better way is to build

1836
01:54:36,370 --> 01:54:38,250
an enumeration of the new children

1837
01:54:40,910 --> 01:54:42,650
by adapting the old enumeration.

1838
01:54:44,020 --> 01:54:44,740
I can say here:

1839
01:54:51,280 --> 01:54:53,280
An enumerator
works by providing an

1840
01:54:56,140 --> 01:54:57,800
object called a yielder to this

1841
01:54:57,800 --> 01:54:59,800
block that you
pass in the constructor.

1842
01:54:59,800 --> 01:55:01,770
and every time you call yielder.yield

1843
01:55:03,110 --> 01:55:04,400
It will yield that value.

1844
01:55:08,400 --> 01:55:09,710
Let's look at it on irb:

1845
01:55:11,170 --> 01:55:11,570
If I say:

1846
01:55:29,200 --> 01:55:30,910
First you can step through them

1847
01:55:31,020 --> 01:55:31,680
one at a time.

1848
01:55:31,800 --> 01:55:34,220
You can say give me the
next value, and the next .....

1849
01:55:34,220 --> 01:55:36,850
It's using fibers to suspend
execution of that block

1850
01:55:37,710 --> 01:55:39,800
after every yield
until I say I'm ready.

1851
01:55:40,650 --> 01:55:42,450
If I enumerate
off the end it says ....

1852
01:55:43,650 --> 01:55:44,680
I think I can re-wind.

1853
01:55:46,680 --> 01:55:47,020
Yes.

1854
01:55:48,910 --> 01:55:50,650
It's enumerable
so I can also say:

1855
01:55:54,140 --> 01:55:54,540
I can do:

1856
01:55:59,680 --> 01:56:01,850
It works like a
normal enumerable 'thing'

1857
01:56:01,880 --> 01:56:03,880
but you've
built it programmatically.

1858
01:56:04,340 --> 01:56:06,370
I can take
advantage of that by saying:

1859
01:56:15,850 --> 01:56:17,850
So yield all of the existing children

1860
01:56:17,850 --> 01:56:19,740
to the yielder,
and then afterwards,

1861
01:56:21,540 --> 01:56:22,310
Yield a new one.

1862
01:56:25,970 --> 01:56:27,800
I need to do
some variable re-names.

1863
01:56:29,740 --> 01:56:31,570
It's fine but
I think it's confusing.

1864
01:56:32,970 --> 01:56:33,880
So add a new child.

1865
01:56:34,740 --> 01:56:36,800
And then I'll say,
make a new enumerator.

1866
01:56:38,600 --> 01:56:40,050
It will not create an array.

1867
01:56:40,540 --> 01:56:42,740
This piece of code
will just spin over the

1868
01:56:42,740 --> 01:56:44,220
old children and yield them.

1869
01:56:44,740 --> 01:56:46,540
And then will
yield the new child.

1870
01:56:46,540 --> 01:56:48,570
Rather than
building a new array here.

1871
01:56:49,220 --> 01:56:51,020
I can pass in
my new enumeration

1872
01:56:54,450 --> 01:56:55,310
of the children.

1873
01:56:56,880 --> 01:56:57,650
And that works.

1874
01:56:59,510 --> 01:57:01,170
I think that's
an efficient way

1875
01:57:01,170 --> 01:57:02,450
of mutating these trees.

1876
01:57:03,540 --> 01:57:05,450
To think of the
children as being

1877
01:57:05,450 --> 01:57:06,880
enumerations of children.

1878
01:57:09,850 --> 01:57:11,880
If we had some
kind of 'insert before'

1879
01:57:13,170 --> 01:57:15,020
You could do a
thing here that says

1880
01:57:17,510 --> 01:57:19,420
"if child equals
the one I'm supposed

1881
01:57:19,650 --> 01:57:20,910
to be inserting before,

1882
01:57:21,420 --> 01:57:22,480
then yield the new one.

1883
01:57:23,200 --> 01:57:25,220
And after that
yield the existing one."

1884
01:57:26,400 --> 01:57:28,200
If it's 'insert after' you can
yield the old child

1885
01:57:28,200 --> 01:57:30,020
and then immediately
yield the new one.

1886
01:57:30,450 --> 01:57:32,340
Adding it on to the
end is the easiest

1887
01:57:32,340 --> 01:57:33,800
because we
know where it goes.

1888
01:57:33,820 --> 01:57:35,800
But enumerating
over the old collection

1889
01:57:36,510 --> 01:57:38,680
and inserting the new
one at the right time

1890
01:57:40,280 --> 01:57:42,800
allows us to ....

1891
01:57:44,650 --> 01:57:47,250
If we wanted to insert a copy of this
after every existing child.

1892
01:57:47,250 --> 01:57:48,800
We can say
"yield the old child

1893
01:57:48,800 --> 01:57:50,140
and then yield the new one",

1894
01:57:50,140 --> 01:57:51,480
each time around the loop.

1895
01:57:52,970 --> 01:57:54,970
We can do any modification

1896
01:57:55,000 --> 01:57:56,510
to the tree
that we want here.

1897
01:57:56,510 --> 01:57:58,740
But we're not
actually modifying anything.

1898
01:57:59,280 --> 01:58:01,710
This has the nice
structural sharing property

1899
01:58:01,710 --> 01:58:03,800
where this new
new node that we are getting

1900
01:58:05,570 --> 01:58:07,680
is re-using the
collection of children

1901
01:58:08,170 --> 01:58:09,280
that the old node had.

1902
01:58:09,710 --> 01:58:12,020
It isn't copying that
array and adding to it.

1903
01:58:12,020 --> 01:58:14,140
It's holding on to
it through each_child.

1904
01:58:16,200 --> 01:58:18,770
The new node has a
child enumerator that calls

1905
01:58:20,140 --> 01:58:21,480
each_child on the old node,

1906
01:58:21,800 --> 01:58:23,680
and when it's
finished enumerating all

1907
01:58:23,680 --> 01:58:25,680
of its children, it
yields the new one.

1908
01:58:25,680 --> 01:58:27,420
That feels close to optimal to me.

1909
01:58:32,020 --> 01:58:33,710
It's not super efficient because

1910
01:58:34,140 --> 01:58:36,540
when you are doing
things non-destructively,

1911
01:58:36,540 --> 01:58:38,480
you're expecting
the garbage collector

1912
01:58:38,480 --> 01:58:41,280
to do the work of cleaning
up all the old stuff for you.

1913
01:58:42,400 --> 01:58:44,540
But after the
garbage collector has run,

1914
01:58:44,540 --> 01:58:46,800
we're not going to be
using lots more memory.

1915
01:58:50,850 --> 01:58:53,340
If you want to
compose a lot of trees together,

1916
01:58:53,620 --> 01:58:55,310
which this API
allows you to do.

1917
01:58:55,570 --> 01:58:57,880
Every time you compose
a tree into a new one,

1918
01:58:57,880 --> 01:58:59,480
you are not taking a copy of it.

1919
01:59:01,340 --> 01:59:03,400
You are holding on
to a reference to it.

1920
01:59:03,400 --> 01:59:05,680
Which you would do
anyway if it was mutable

1921
01:59:08,370 --> 01:59:10,800
And every time you
make a change it's creating

1922
01:59:10,820 --> 01:59:13,020
just enough new stuff
and holding on to as

1923
01:59:13,020 --> 01:59:15,820
much of the old stuff as is
necessary to make use of it.

1924
01:59:17,740 --> 01:59:20,370
I feel good that we have
been able to do that there.

1925
01:59:21,800 --> 01:59:22,510
So I shall say:

1926
01:59:32,770 --> 01:59:33,620
How are we doing?

1927
01:59:33,620 --> 01:59:35,680
DN: I think that's a
good place to wrap up.

1928
01:59:36,280 --> 01:59:39,310
Thanks Tom, it's been very
interesting watching you work.

1929
01:59:41,020 --> 01:59:43,800
TS: Thanks for having me,
it has been really good fun.

