1
00:00:01,400 --> 00:00:02,777
Welcome to Peer to Peer.

2
00:00:03,337 --> 00:00:08,171
Where you can hone your
skills by watching live coding videos.

3
00:00:08,200 --> 00:00:10,720
Our guest today is John Wiegley,

4
00:00:10,720 --> 00:00:16,742
who's a researcher at BAE,
and author of many useful Haskell libraries.

5
00:00:16,900 --> 00:00:19,268
Our host is Ollie Charles.

6
00:00:19,320 --> 00:00:26,194
And the challenge that he set for John
is called Building a Basic Calculator Language.

7
00:00:26,300 --> 00:00:28,948
OC: OK John, would you like
to start by reading the problem out?

8
00:00:28,948 --> 00:00:33,965
JW: Sure, we have implement a system
that parses BC expressions and evaluates them.

9
00:00:33,960 --> 00:00:39,074
Basic Calculator (which we're calling BC)
is a calculator language, used for scripting

10
00:00:39,074 --> 00:00:41,737
and as an interactive mathematical shell.

11
00:00:41,737 --> 00:00:48,857
Here is an example expression:
we've got 1 + 9 x 20 divided by 5, should equal 40.

12
00:00:48,850 --> 00:00:52,342
The program should parse a
file, evaluate all expressions,

13
00:00:52,340 --> 00:00:55,348
and print the results to standard output.

14
00:00:55,400 --> 00:01:00,571
OC: And you should have a couple of example files
which we're going to aim to parse in this session.

15
00:01:00,605 --> 00:01:02,342
Yes, those are the ones.

16
00:01:02,800 --> 00:01:07,668
Would you like to open those up
and see if it all looks clear enough.

17
00:01:07,680 --> 00:01:10,100
See if you have any questions on the syntax.

18
00:01:13,485 --> 00:01:17,565
JW: It looks pretty straightforward to me.

19
00:01:17,560 --> 00:01:18,194
OC: OK.

20
00:01:18,190 --> 00:01:22,685
(John contemplates the problem)

21
00:01:22,680 --> 00:01:25,897
Chapter 2: Handling Primitive Operations.

22
00:01:25,900 --> 00:01:30,788
JW: Alright, the first thing I'm going
to do is keep these files in this directory

23
00:01:30,780 --> 00:01:34,217
and I'm going to turn this
into a git repository in here.

24
00:01:35,400 --> 00:01:38,754
We'll make a file and call it Parser.hs.

25
00:01:43,800 --> 00:01:49,005
And look to see if the first expression
we want to parse is an addition operation.

26
00:01:49,900 --> 00:01:56,685
I want to model this after I parse it into a
data type that I will run the evaluator against.

27
00:01:56,900 --> 00:02:01,302
So my expressions are going
to have to include an add operation.

28
00:02:01,400 --> 00:02:09,600
And that will need two numbers.
Which I think will be sub expressions in the future.

29
00:02:09,702 --> 00:02:13,965
So I will say: the addition
operation takes two expressions.

30
00:02:14,000 --> 00:02:18,468
Which means I will need a number...

31
00:02:18,468 --> 00:02:20,460
(Silence)

32
00:02:20,750 --> 00:02:30,754
To parse that I'm going to use Parsec.
Which is a library designed for parsing in Haskell.

33
00:02:31,900 --> 00:02:36,468
When I want to parse something,
I have a Parser that will return an integer.

34
00:02:36,700 --> 00:02:38,674
We'll call this num.

35
00:02:39,680 --> 00:02:42,100
And the number a Parser will take...

36
00:02:43,931 --> 00:02:45,440
Let's see...

37
00:02:45,500 --> 00:02:49,474
Many instances of some number.

38
00:02:50,100 --> 00:02:52,708
I'll do it the dumb way first.

39
00:02:52,800 --> 00:02:56,857
I often forget what the whole Parsec interface is.

40
00:02:56,900 --> 00:03:02,902
It's telling me oneOf is not in
scope, so I'm going to hit [inaudible].

41
00:03:05,700 --> 00:03:09,485
You can see I have the syntax
checking happening behind the scenes.

42
00:03:09,500 --> 00:03:15,805
If I press Control C Control H it will do a Hoogle
query, on whatever keyword is under my cursor.

43
00:03:16,100 --> 00:03:20,502
I have Hoogle running locally so that
it works whether I have internet access or not.

44
00:03:20,600 --> 00:03:23,577
I see right away that's in the Char sub module,

45
00:03:23,600 --> 00:03:27,840
so if I go up here and add Char,
then oneOf should be fine.

46
00:03:27,900 --> 00:03:31,348
Same with many, many is in...

47
00:03:31,931 --> 00:03:35,382
looks like Parsec.Prim.

48
00:03:42,960 --> 00:03:47,474
I've said I want a Parser that returns
an integer. This Parser will return characters.

49
00:03:47,500 --> 00:03:50,571
So I need a way to turn that into an integer.

50
00:03:50,800 --> 00:03:59,314
Which I can do using an applicative form of fmap

51
00:03:59,805 --> 00:04:05,200
Actually, I can use the
applicative definition, it will be fine.

52
00:04:06,125 --> 00:04:08,514
There we are... everything parses.

53
00:04:08,548 --> 00:04:12,800
Let me see if I can load this in...

54
00:04:12,982 --> 00:04:16,000
GHCi REPL

55
00:04:16,000 --> 00:04:18,300
I want to run this Parser on sample input.

56
00:04:18,300 --> 00:04:24,822
I need to go into Parsec to find out how to do that.

57
00:04:24,900 --> 00:04:31,405
There is one that will let you do a test parse.

58
00:04:31,800 --> 00:04:41,268
OC: I believe it's in the index,
that may be easier to find.

59
00:04:41,700 --> 00:04:43,100
JW: It's in the Prim module

60
00:04:43,291 --> 00:04:45,700
Yes, that's the one I was thinking of.

61
00:04:45,700 --> 00:04:49,120
It takes a Parser and an input string.

62
00:04:49,300 --> 00:04:54,034
So if I say parse test. I may
have to import the Prim module.

63
00:04:54,400 --> 00:05:01,851
If I say parseTest, then I should get my integer.

64
00:05:02,100 --> 00:05:04,720
Next, I want to parse the add operation.

65
00:05:05,000 --> 00:05:11,371
And that will yield an expression.

66
00:05:11,700 --> 00:05:18,994
Again, I'm using the applicative style to call...

67
00:05:19,400 --> 00:05:23,782
Well, I only have 'add' expressions.

68
00:05:23,900 --> 00:05:27,400
But I need something that's
going to branch based on what it finds.

69
00:05:27,622 --> 00:05:29,400
So I need something higher level.

70
00:05:30,500 --> 00:05:34,651
We need something that says, I'm going to do a choice...

71
00:05:34,650 --> 00:05:39,040
one of the num parser or the add parser

72
00:05:39,040 --> 00:05:43,234
And the add parser is going to inaudible call the expression parser.

73
00:05:43,554 --> 00:05:47,657
And GCHi does not know, so let's see what it's called.

74
00:05:50,320 --> 00:05:53,040
Choice, as in combinator.

75
00:05:53,100 --> 00:05:57,794
You always have a long
setup of imports with Parsec.

76
00:05:57,920 --> 00:06:02,228
OK, so num says "I don't want to return an integer".

77
00:06:02,500 --> 00:06:05,337
I don't want to 'read' here, I don't want to 'just read'.

78
00:06:05,400 --> 00:06:09,325
I need to wrap that up in my constructor.

79
00:06:09,337 --> 00:06:12,200
And then that means
this returns expression as well.

80
00:06:12,200 --> 00:06:13,800
OC: So what we're saying here is

81
00:06:13,805 --> 00:06:18,617
expr is a Parser that can either
parse addition or a single number.

82
00:06:18,700 --> 00:06:19,600
JW: Correct.

83
00:06:19,874 --> 00:06:28,685
I've forgotten the plus symbol here... so I need to have...

84
00:06:29,200 --> 00:06:33,097
The 'add' is going to read in an expression.

85
00:06:33,100 --> 00:06:36,708
Then it wants to read a plus,
and then another expression.

86
00:06:36,900 --> 00:06:43,108
So in front of the second expression,
I'm going to say that I'm looking for the string plus.

87
00:06:43,300 --> 00:06:45,920
And I'm going to use an
applicative operator that says

88
00:06:45,954 --> 00:06:50,571
"throw whatever you found away and keep reading".

89
00:06:50,600 --> 00:07:00,377
Now if I do 1 plus 2, (I need to make my thing show-able).

90
00:07:00,400 --> 00:07:03,588
The Parser is aborting, it's not recursing.

91
00:07:06,297 --> 00:07:12,514
OC: Is that because it's hitting white space in here?

92
00:07:12,610 --> 00:07:16,354
JW: It's hitting the white space but
if I look at my Parser for expression,

93
00:07:16,560 --> 00:07:22,125
I see that I've said the num Parser should
be first, and then choice only parses once.

94
00:07:22,400 --> 00:07:26,925
So I could say "many choice" to get a list
of expressions, but that's not quite what I want.

95
00:07:27,000 --> 00:07:31,931
I want a chance to parse add
first, but it's still not accepting it.

96
00:07:31,950 --> 00:07:36,880
Because it's trying to go into
add and it's failing to parse it.

97
00:07:36,880 --> 00:07:38,845
I think your right, its the white space.

98
00:07:38,857 --> 00:07:42,342
OC: let's try GCHi without the white space.

99
00:07:49,840 --> 00:07:54,582
JW: Oh! I'm still passing the
num Parser to parseTest (laughter).

100
00:07:54,600 --> 00:07:59,748
Here I have an infinite loop,
because I have no termination condition.

101
00:07:59,800 --> 00:08:03,200
Let's see if the add
expression is also an infinite loop.

102
00:08:04,300 --> 00:08:07,565
OC: What if we change the expr
that you have in add to num?

103
00:08:07,800 --> 00:08:11,700
So we don't have any kind of possibility.

104
00:08:12,600 --> 00:08:15,417
I imagine you're right and
we are going to need two expr.

105
00:08:15,420 --> 00:08:20,148
JW: We have the correct parsing
there, but we want our recursion.

106
00:08:20,200 --> 00:08:24,205
Let me think about why
this is infinitely recursing here.

107
00:08:24,200 --> 00:08:29,520
(John thinks).

108
00:08:29,700 --> 00:08:33,300
Ah! because the very first
thing that add does is call expression

109
00:08:33,300 --> 00:08:36,685
and the first thing that expression does
is call add which then calls expression.

110
00:08:36,720 --> 00:08:39,500
So it's never consuming anything.

111
00:08:39,500 --> 00:08:47,817
I need to have some way of knowing
in expression what the next step will be.

112
00:08:48,400 --> 00:08:51,200
OC: I think you were right by doing num first before,

113
00:08:51,200 --> 00:08:54,400
but we were simply calling
parseTest with the wrong Parser.

114
00:08:56,845 --> 00:08:59,851
So now we're seeing parse
errors that you would expect.

115
00:08:59,851 --> 00:09:01,850
Right, so now the...

116
00:09:04,100 --> 00:09:08,045
JW: If I call add without white space, I get what I want.

117
00:09:08,100 --> 00:09:11,360
Let's first add the notion of white space.

118
00:09:11,400 --> 00:09:16,422
So I want to have a Parser that says white space,

119
00:09:16,445 --> 00:09:20,080
(It's not going to return a value,
we're just going to throw it away).

120
00:09:20,100 --> 00:09:30,960
And we're going to say "many which says
zero or more", and then I'm going to throw it away.

121
00:09:31,400 --> 00:09:39,154
And then I'm going to say, after
the first expression I will accept white space.

122
00:09:39,542 --> 00:09:41,497
I need to flip this around.

123
00:09:41,700 --> 00:09:49,394
I want that after the operator.

124
00:09:49,700 --> 00:09:54,811
Now I can accept white space whether or not I have it.

125
00:09:54,900 --> 00:09:57,800
We still have the problem
that the choice is not correct.

126
00:09:58,331 --> 00:10:02,685
But if I remove them I have an infinite loop.

127
00:10:03,200 --> 00:10:09,257
We need to have a proper
top level expression Parser.

128
00:10:11,800 --> 00:10:13,840
OC: So it did recurse again, I take it?

129
00:10:13,851 --> 00:10:14,617
JW: Right.

130
00:10:14,640 --> 00:10:20,742
There is an eof Parser which
tells me when I'm at the end.

131
00:10:20,900 --> 00:10:26,708
So we're going to have a requirement be
that our string has to go to the end of the file.

132
00:10:26,720 --> 00:10:27,314
OC: OK.

133
00:10:27,325 --> 00:10:31,177
JW: And there can be white space at the end of the file.

134
00:10:31,300 --> 00:10:34,720
Now when I do parse I get that plus is not expected.

135
00:10:34,900 --> 00:10:43,988
The reason was because we parsed a
number and it thought it should be at space.

136
00:10:44,400 --> 00:10:48,914
Because we wanted to have
space or the end of the input.

137
00:10:48,914 --> 00:10:50,910
OC: Oh, yes OK.

138
00:10:50,910 --> 00:10:54,457
(John thinks).

139
00:10:54,617 --> 00:10:58,685
JW: Why is this happening?

140
00:10:58,720 --> 00:11:02,457
OC: What does parseTest with just add
do now? Now that we've got the white space in there?

141
00:11:02,468 --> 00:11:06,274
JW: It is not parsing correctly.

142
00:11:06,285 --> 00:11:10,400
It did call expr.

143
00:11:19,400 --> 00:11:23,382
OC: Usually when I'm parsing
grammars like this, I use something like chainl

144
00:11:23,500 --> 00:11:26,500
which factors out the
left recursion automatically.

145
00:11:26,500 --> 00:11:31,302
So we might be getting
problems with left recursion here.

146
00:11:31,400 --> 00:11:37,394
Maybe if we change add for
now to take just two numbers.

147
00:11:37,700 --> 00:11:42,491
And we can move on and see if
we can write an evaluator for addition.

148
00:11:42,570 --> 00:11:48,354
Keep the Parser simple for now and
we'll come back and add a bit more logic to it later.

149
00:11:48,500 --> 00:11:50,685
JW: That's working correctly.

150
00:11:50,700 --> 00:11:53,017
Let's write our first evaluator.

151
00:11:53,100 --> 00:11:58,445
Which is going to take an
expression and reduce it to a number.

152
00:11:58,440 --> 00:12:03,520
It's a requirement of our calculator that
it's going to produce numbers in the end.

153
00:12:03,800 --> 00:12:06,857
When we have a number, that's easy, we can get a number.

154
00:12:07,100 --> 00:12:09,700
And when we have an addition between two things,

155
00:12:09,700 --> 00:12:15,291
we have to recursively evaluate
those expressions and add them.

156
00:12:18,697 --> 00:12:20,022
OC: Yes.

157
00:12:20,560 --> 00:12:26,400
JW: And now in GHCi if I eval expression.

158
00:12:27,085 --> 00:12:30,628
Could not match.

159
00:12:30,720 --> 00:12:33,988
Oh! because parseTest is not in IO.

160
00:12:34,205 --> 00:12:36,651
So if I go over here to...

161
00:12:36,650 --> 00:12:42,994
(Silence)

162
00:12:43,600 --> 00:12:47,497
So parse will say "take a Parser".

163
00:12:49,874 --> 00:12:53,257
And it returns...

164
00:12:53,280 --> 00:12:57,017
And source name, let's see what that is.

165
00:13:01,200 --> 00:13:05,234
If I have an error it will just yield the error.

166
00:13:05,300 --> 00:13:16,057
And if I have a value, then I will
print the result of evaluating that.

167
00:13:16,050 --> 00:13:18,434
And I will do a show here.

168
00:13:18,430 --> 00:13:20,491
There we go, I get three.

169
00:13:20,500 --> 00:13:25,702
This is a lot of code to retype all
the time so we're going to call this test.

170
00:13:25,800 --> 00:13:29,977
OC: We are probably going to need the
exact same code when we read from the file.

171
00:13:29,970 --> 00:13:35,954
JW: So for now our test is just going
to take a String, and it's going to parse it.

172
00:13:36,000 --> 00:14:01,234
(Silence)

173
00:14:01,497 --> 00:14:02,640
Oh! it wanted Text.

174
00:14:07,300 --> 00:14:19,200
[inaudible]

175
00:14:21,600 --> 00:14:26,937
Ah! I don't have recursive parsing yet.

176
00:14:29,417 --> 00:14:31,691
Let's just do right recursion.

177
00:14:31,690 --> 00:14:37,942
(Silence).

178
00:14:38,537 --> 00:14:42,560
It's not liking that at all.

179
00:14:44,300 --> 00:14:46,537
It's not the white space.

180
00:14:46,530 --> 00:14:51,702
(Silence)

181
00:14:51,931 --> 00:14:56,342
OK so mark right recursion on add.

182
00:14:57,100 --> 00:15:00,674
We're going to need recursion
on those steps at some point.

183
00:15:00,720 --> 00:15:04,125
We really need to figure out what's going on here.

184
00:15:04,900 --> 00:15:11,360
OC: I wonder if that trailing white space
might cause us some problems on the expr Parser.

185
00:15:12,548 --> 00:15:14,800
That might be introducing the ambiguity.

186
00:15:15,600 --> 00:15:19,360
JW: It's possible.  We can certainly remove it for now.

187
00:15:19,400 --> 00:15:22,434
But I have a feeling that's not the problem.

188
00:15:22,500 --> 00:15:26,148
The problem is the left recursion here.

189
00:15:27,131 --> 00:15:31,177
Let me think.

190
00:15:31,300 --> 00:15:36,148
It needs a way of knowing if it
should descend into this add branch.

191
00:15:36,160 --> 00:15:41,691
Which means it needs to know
if there's going to be a plus there.

192
00:15:43,702 --> 00:15:46,605
Another thing I could do is go ask the Internet.

193
00:15:46,600 --> 00:15:50,480
Although I don't know if I have internet access here.

194
00:15:50,491 --> 00:15:52,100
Let me check, let's see:

195
00:15:52,822 --> 00:16:00,022
How to rate recursive math expression parcer.

196
00:16:00,020 --> 00:16:03,977
Parsing expressions by recursive
decent... the classic solution.

197
00:16:03,970 --> 00:16:19,291
So E is T and a plus and a minus
are a T. T and F. F is a P. P is a B and a T.

198
00:16:19,371 --> 00:16:23,005
The top level only recurs within parens here.

199
00:16:23,000 --> 00:16:30,628
(Silence)

200
00:16:30,651 --> 00:16:36,422
OC: Maybe look up chainl and see what that's doing?

201
00:16:36,420 --> 00:16:45,520
(Silence).

202
00:16:45,520 --> 00:16:49,542
JW: So, parse one or more
occurrences of P separated by op.

203
00:16:50,180 --> 00:16:56,708
Return the value obtained by left associate
application of all functions returned by op.

204
00:16:57,451 --> 00:17:00,102
(Inaudible).

205
00:17:00,100 --> 00:17:05,714
This can be used to eliminate left recursion
which typically occurs in expression grammars.

206
00:17:05,710 --> 00:17:08,788
That is exactly what we need to use.

207
00:17:09,337 --> 00:17:11,885
So why don't we try that.

208
00:17:12,100 --> 00:17:19,588
I also want to find out what the non-chainl
solution is, because I've never had this problem.

209
00:17:19,800 --> 00:17:25,302
OC: Surely you normally have parenthesis,
and it's they that break up the recursion.

210
00:17:25,531 --> 00:17:29,497
JW: But it's perfectly legitimate
to have one or one plus one.

211
00:17:29,542 --> 00:17:32,697
Without having parenthesis
to have that make sense.

212
00:17:32,708 --> 00:17:33,840
OC: Right.

213
00:17:33,840 --> 00:17:40,285
(Silence).

214
00:17:41,085 --> 00:17:45,851
OC: Because ultimately we're going
to be removing this thing anyway.

215
00:17:45,874 --> 00:17:46,700
JW: Right.

216
00:17:50,102 --> 00:17:53,885
Clearly we cant re-curse all the way back to the top.

217
00:17:53,880 --> 00:17:58,125
(Silence).

218
00:17:58,548 --> 00:18:01,977
This is the problem we're
running into, as you indicated.

219
00:18:01,970 --> 00:18:04,148
So left (inaudible) removal.

220
00:18:04,160 --> 00:18:08,057
OC: You have to explicitly do left factoring.

221
00:18:09,988 --> 00:18:16,902
You have that X Prime thing which starts
with addition. And that again is breaking it for you.

222
00:18:16,902 --> 00:18:19,234
JW: Ah, that's what it is.

223
00:18:19,230 --> 00:18:21,702
Bookmark: Introducing a term parser.

224
00:18:21,800 --> 00:18:26,971
JW: We left off here trying to
break the infinite recursion we have.

225
00:18:27,000 --> 00:18:29,840
We have a left recursion in  a top down Parser.

226
00:18:29,900 --> 00:18:33,851
Which is going to infinitely
re curse without parsing any input.

227
00:18:33,900 --> 00:18:40,811
We solve it by having a term Parser which
knows how to parse numbers, for example.

228
00:18:43,100 --> 00:18:45,771
OC: So what we're trying to
do is break that ambiguity.

229
00:18:45,800 --> 00:18:47,017
JW: Right.

230
00:18:47,017 --> 00:18:52,320
Our main expression Parser is
going to call the term Parser first.

231
00:18:52,902 --> 00:18:55,097
We'll do it in monadic style here.

232
00:18:55,165 --> 00:18:59,245
Now we have the term we can
look at what the next thing will be.

233
00:18:59,257 --> 00:19:04,274
And for example, if it's a plus,
we know it's a descendant to addition.

234
00:19:04,308 --> 00:19:10,388
So if that's the case we have to put a branch on this.

235
00:19:11,300 --> 00:19:14,262
So we will take a look at what the next token is.

236
00:19:16,228 --> 00:19:20,400
We know that it could be, say, a plus.

237
00:19:20,400 --> 00:19:25,874
(Silence).

238
00:19:25,870 --> 00:19:46,834
And then if Y is that, then we are going to return
Eadd X and then call inaudible expression parser.

239
00:19:48,000 --> 00:19:54,845
Otherwise if it's not plus, then at the
moment we just have an unrecognized operator.

240
00:19:54,914 --> 00:20:00,514
Over here again, we have the white space problem.

241
00:20:00,670 --> 00:20:05,428
We'll allow white space to be
thrown away here... and here.

242
00:20:05,420 --> 00:20:12,834
(Silence).

243
00:20:12,830 --> 00:20:16,057
Without white space.
Oh, we're still having a problem.

244
00:20:16,617 --> 00:20:20,502
OC: There's no termination condition here.

245
00:20:20,600 --> 00:20:24,377
So even when we see an addition sign we expect another one.

246
00:20:24,422 --> 00:20:26,548
JW: That's true.

247
00:20:28,540 --> 00:20:35,508
So we can have plus or we can have
eof, but eof is going to return nothing.

248
00:20:36,057 --> 00:20:41,565
So in that case, we're going to return the String.

249
00:20:43,382 --> 00:20:46,571
At the moment... to work around that.

250
00:20:46,600 --> 00:20:51,908
Unrecognised operator...

251
00:20:54,754 --> 00:21:01,062
OC: Maybe use Just for the operator
and use Nothing for end-of-file.

252
00:21:01,100 --> 00:21:02,468
JW: Excellent.

253
00:21:02,460 --> 00:21:34,262
Inaudible then we'll return just
our X and Y and we'll say is Y a plus.

254
00:21:35,931 --> 00:21:40,662
Now we've got rid of our
infinite left recursion problem.

255
00:21:40,700 --> 00:21:45,942
Now you were telling me about a
function called chainl, which I have not used yet.

256
00:21:45,942 --> 00:21:49,771
But in Parsec is designed to solve this problem.

257
00:21:49,800 --> 00:21:51,508
OC: That's what I'm telling you.

258
00:21:51,600 --> 00:22:04,068
JW: That's right, but we will say we want term, chainl1 and...

259
00:22:04,350 --> 00:22:06,365
which in this case... let's see...

260
00:22:06,445 --> 00:22:10,902
The addop is going to be...

261
00:22:10,948 --> 00:22:15,988
Oh! I see that's the
symbols that it's expecting to see.

262
00:22:16,000 --> 00:22:19,485
Let's do this, just like they have here: 

263
00:22:19,497 --> 00:22:29,645
we'll say the add operation, and now if
we see add we're going to return the function plus.

264
00:22:29,657 --> 00:22:35,257
OC: I think you want EAdd there rather than addition.

265
00:22:35,300 --> 00:22:39,908
JW: That's right because I'm
not doing evaluation in the Parser.

266
00:22:41,565 --> 00:22:44,331
So I have term chain addop.

267
00:22:46,400 --> 00:22:49,600
I  will still need to deal with white space.

268
00:22:55,230 --> 00:23:05,085
I believe that symbol skips trailing white space,
so I don't need to worry about leaving white space.

269
00:23:05,451 --> 00:23:09,931
OC: Do you need to worry about
that if you're using symbol everywhere?

270
00:23:10,000 --> 00:23:11,245
JW: Perhaps not.

271
00:23:11,240 --> 00:23:13,725
OC: (Inaudible).

272
00:23:13,725 --> 00:23:18,342
Let's say that there can be white
space after terminals, for the moment.

273
00:23:18,340 --> 00:23:22,960
(Silence).

274
00:23:23,200 --> 00:23:26,731
Now the add Parser is going to go away.

275
00:23:27,000 --> 00:23:31,520
And we're going to have a new Parser for expressions.

276
00:23:31,954 --> 00:23:34,600
And now all this gets to go away.

277
00:23:34,600 --> 00:23:41,782
OC: It might be a Parser as a function to
expression to expression to expression, in addop...

278
00:23:41,794 --> 00:23:46,880
because you have EAdd as your return type.

279
00:23:46,880 --> 00:23:56,297
(Silence).

280
00:23:59,300 --> 00:24:07,657
JW: Their version of white space
here is too fancy for what I want just yet.

281
00:24:08,480 --> 00:24:14,594
Parsec allows you to describe what tokens look
like and what the white spacing comments are.

282
00:24:14,605 --> 00:24:18,994
I may use that a little bit but not at the moment.

283
00:24:20,480 --> 00:24:22,411
Symbol is applied to too few arguments...

284
00:24:22,434 --> 00:24:28,262
Ah! This symbol is coming from that fancy library.

285
00:24:28,400 --> 00:24:35,540
I don't want symbol. I want string and
I have to build in my own terminating white space.

286
00:24:35,540 --> 00:24:41,360
(Silence).

287
00:24:42,022 --> 00:24:43,302
OC: That's a lot simpler.

288
00:24:43,314 --> 00:24:44,300
JW: Much cleaner.

289
00:24:44,890 --> 00:24:51,348
Based on the example that they gave,
we want to extend this to more operations.

290
00:24:51,340 --> 00:24:57,668
So we will go ahead and add those,
because Math operations tend to be easy to put in.

291
00:24:57,800 --> 00:25:07,611
We're going to say we want
subtraction, multiplication and division.

292
00:25:08,200 --> 00:25:14,560
It's all still going to be on numbers.
Now we have to make three more versions of addop.

293
00:25:15,977 --> 00:25:19,268
We have inaudible.

294
00:25:20,000 --> 00:25:29,200
We only have to worry about precedence
because, what would it mean if we said this:

295
00:25:30,674 --> 00:25:32,400
In what order do we evaluate?

296
00:25:32,400 --> 00:25:37,245
We know we want the division to happen first.
How do we make sure the Parser enforces that.

297
00:25:37,400 --> 00:25:42,320
The way to do that is to
structure how we do our traversal.

298
00:25:42,354 --> 00:25:44,770
OC: Because now the Parser is just running from left to right,

299
00:25:44,788 --> 00:25:48,200
and basically just standing on the left.

300
00:25:48,200 --> 00:25:52,571
JW: The expression evaluator
is going to be equally trivial.

301
00:25:55,500 --> 00:25:57,700
OC: Can we not just work with 'int' anymore?

302
00:25:58,300 --> 00:26:05,051
JW: Ah true... 

303
00:26:05,794 --> 00:26:11,017
we want the fractional numbers...

304
00:26:11,500 --> 00:26:18,674
And now our num will have to say... I always
forget what the conversion operations are called...

305
00:26:18,900 --> 00:26:21,600
OC: I wonder if it's easier to use doubles everywhere.

306
00:26:21,600 --> 00:26:31,680
In some of the later codes it assumes
you can assign to floating point numbers.

307
00:26:32,100 --> 00:26:36,662
We want a number... followed by...

308
00:26:37,500 --> 00:26:41,405
(we're going to have to do
this in a different style here).

309
00:26:41,530 --> 00:26:47,005
OC: I feel  that Parsec may already
have a pre-built Parser for doubles.

310
00:26:47,074 --> 00:26:50,200
JW: True, but I want us to write our own!

311
00:26:50,200 --> 00:26:55,028
So we want the part before and
after to be numerical parsing.

312
00:26:55,120 --> 00:26:56,834
So this is our numerical parser.

313
00:26:57,280 --> 00:27:04,297
We're going to say a numerical Parser is some number.

314
00:27:04,720 --> 00:27:10,411
And then we want an optional period character.

315
00:27:10,900 --> 00:27:15,097
And it's optional, so we will
get a maybe value out of it.

316
00:27:15,090 --> 00:27:20,685
(John thinks).

317
00:27:21,000 --> 00:27:29,268
Then we will take our X and
append it with yet another number.

318
00:27:29,440 --> 00:27:33,108
Otherwise, just return a number.

319
00:27:33,177 --> 00:27:37,302
It's complaining because there
are two definitions of optional.

320
00:27:37,634 --> 00:27:42,400
(John thinks).

321
00:27:42,500 --> 00:27:46,377
OC: The definitions are completely equivalent...

322
00:27:46,400 --> 00:27:49,120
we aren't making a choice about which ones we hide.

323
00:27:49,131 --> 00:27:51,908
Fairly arbitrary, right?
JW: Right.

324
00:28:03,900 --> 00:28:07,691
I think it may be re-exported nowadays.

325
00:28:07,794 --> 00:28:09,500
They have the same definition.

326
00:28:30,300 --> 00:28:36,948
OC: I believe we need to use that dot
character between the two num Parsers.

327
00:28:37,100 --> 00:28:38,274
JW: Yes.

328
00:28:39,531 --> 00:28:44,690
OC: Now we are consuming a dot
but we're ignoring it when we emit a string.

329
00:28:44,830 --> 00:28:48,491
JW: Oh yes, we have to add
it back in. Very good point.

330
00:28:48,490 --> 00:28:55,165
(John types).

331
00:28:55,234 --> 00:28:57,908
I can't do sections like that.

332
00:28:57,900 --> 00:29:01,885
(Ollie mumbles in agreement).

333
00:29:02,000 --> 00:29:05,211
JW: So now cannot deduce this being double.

334
00:29:05,660 --> 00:29:11,920
So we will say if double... there we go...
and now we get ... inaudible zero

335
00:29:11,970 --> 00:29:15,211
OC: Can we try to parse 1.5, something like that?

336
00:29:15,210 --> 00:29:18,720
(John trys this).

337
00:29:18,800 --> 00:29:20,900
JW: We can even multiply something in here.

338
00:29:23,220 --> 00:29:26,525
That did not work. Because
we haven't tied in the Parser.

339
00:29:28,137 --> 00:29:30,480
OC: These are all doing EAdd as well.

340
00:29:30,480 --> 00:29:33,588
JW: True, they're not plugged in.

341
00:29:37,700 --> 00:29:42,880
Now we want to extend our
parsing chain the way that they did.

342
00:29:43,890 --> 00:29:49,554
He did precedence by having it be at the same level. 

343
00:29:50,331 --> 00:29:53,874
(John mumbles as he types).

344
00:29:53,890 --> 00:29:56,171
We're going to follow suit.

345
00:29:56,170 --> 00:30:08,662
(Silence).

346
00:30:09,485 --> 00:30:12,240
Now we want chain in the addop...

347
00:30:12,240 --> 00:30:17,565
And then we'll say...  a little snipped...

348
00:30:18,388 --> 00:30:22,137
A lot of good coding can come
from just copying. (laughter)

349
00:30:25,600 --> 00:30:28,845
We don't have parens yet...

350
00:30:28,900 --> 00:30:32,080
So instead we will call...

351
00:30:32,080 --> 00:30:35,965
(John thinks)

352
00:30:35,960 --> 00:30:41,417
We will just say... our own term...

353
00:30:43,394 --> 00:30:48,742
What am I going to call this for
now now... I'm going to call it sub expression.

354
00:30:48,740 --> 00:30:55,977
(inaudible mumbling).

355
00:30:56,400 --> 00:30:59,000
If I say that I get
correct multiplication.

356
00:30:59,000 --> 00:31:03,142
If I add the 5 to the back it works as we'd thought.

357
00:31:03,154 --> 00:31:06,100
But it also works the same if we add it to the front.

358
00:31:09,500 --> 00:31:13,017
I would like to have parenthesis so that we can do this...

359
00:31:13,020 --> 00:31:18,925
And if we add them, we will have
satisfied the first three lines of our file.

360
00:31:18,940 --> 00:31:22,720
OC: I wonder now if we could
try to hook this in to read from a file.

361
00:31:23,120 --> 00:31:27,965
and maybe try to parse the entire
file and watch the Parser eventually fail.

362
00:31:27,965 --> 00:31:29,960
JW: OK.

363
00:31:30,600 --> 00:31:33,794
OC: We should be ready to 
parse the first two lines I think.

364
00:31:33,805 --> 00:31:37,211
It might eventually
start emitting some evaluation.

365
00:31:37,240 --> 00:31:42,480
JW: So let's write a function that we
can call from the REPL... called testFile...

366
00:31:42,502 --> 00:31:46,880
and that will take a FilePath,
instead of just a string.

367
00:31:47,600 --> 00:31:52,891
And then we want to get the contents of the path.

368
00:31:55,500 --> 00:32:02,617
We're going to parse the same
expression but we're going to do many of them.

369
00:32:05,000 --> 00:32:07,268
We could also cut the file up.

370
00:32:07,337 --> 00:32:11,268
But I want this expression
Parser to take in the whole thing.

371
00:32:11,300 --> 00:32:14,914
OC: Yes, We can give it the whole
file and it will evaluate it line by line.

372
00:32:15,291 --> 00:32:16,651
JW: Right.

373
00:32:16,685 --> 00:32:20,742
So... this will be a series of xs.

374
00:32:23,200 --> 00:32:26,514
Again we need this case here.

375
00:32:27,700 --> 00:32:30,811
So we're going to say for every x that we have...

376
00:32:30,810 --> 00:32:34,491
(Silence).

377
00:32:34,490 --> 00:32:37,371
I'm going to call it (inaudible).

378
00:32:38,274 --> 00:32:42,125
forM_ is not in scope, this comes from Control.Monad.

379
00:32:46,100 --> 00:32:49,405
If I didn't do this, if I said Control-c and Control-m...

380
00:32:49,410 --> 00:32:54,217
it would suggest to me all
the modules that it knows about.

381
00:32:54,270 --> 00:32:58,994
If I select Control.Monad
it will put it with the explicit.

382
00:33:01,200 --> 00:33:04,285
OC: Is that coming from
the normal Haskell mode for Emacs

383
00:33:04,290 --> 00:33:06,971
or is it an extra extension you have?

384
00:33:07,000 --> 00:33:08,925
JW: Let's see...

385
00:33:10,388 --> 00:33:16,491
ghc-ins-mod is providing that feature.

386
00:33:17,100 --> 00:33:22,000
I use Haskell mode and I use ghc-mod and hdevtools.

387
00:33:22,297 --> 00:33:28,902
And the code that jumps to the local
Hoogle is a patch that I did on ghc-mod's code,

388
00:33:29,300 --> 00:33:34,045
to jump over to the Hoogle
I have running on my local machine.

389
00:33:34,320 --> 00:33:36,502
So parser providing too few arguments.

390
00:33:36,500 --> 00:33:40,331
I definitely want to pass the
name of the file to the Parser.

391
00:33:40,937 --> 00:33:46,811
getContents... Ahh, I want readFile.

392
00:33:46,810 --> 00:33:56,308
(Silence).

393
00:33:56,600 --> 00:34:00,685
I did the case one level too far.

394
00:34:00,680 --> 00:34:08,754
(Silence)

395
00:34:08,750 --> 00:34:11,040
So let's say here...

396
00:34:11,500 --> 00:34:15,800
I'll do it in point free
just because I know you (laughter).

397
00:34:17,000 --> 00:34:20,251
I need to pack the string.

398
00:34:20,250 --> 00:34:23,222
(Silence).

399
00:34:23,220 --> 00:34:25,600
So, the actual type...

400
00:34:25,840 --> 00:34:28,320
OC: So I guess parse is a pure function?

401
00:34:28,354 --> 00:34:32,605
JW: Yes, we're working with
pure functions here. Good thing!

402
00:34:33,257 --> 00:34:38,022
And then this is a right value, not just value.

403
00:34:38,200 --> 00:34:40,800
I have no idea what this is going to do (laughter).

404
00:34:40,800 --> 00:34:47,988
Not all of this file will parse so we
will take a cut out of it and call it test.bc.

405
00:34:48,205 --> 00:34:51,108
Then I'm going to run this on test.bc

406
00:34:51,611 --> 00:34:55,954
And we go into an infinite loop (laughter).

407
00:34:56,308 --> 00:35:00,525
It would be nice to know why, so let's add some tracing.

408
00:35:00,600 --> 00:35:05,268
I tend to add a lot of tracing
when I'm initially developing.

409
00:35:05,260 --> 00:35:09,188
(Inaudible)

410
00:35:09,200 --> 00:35:14,251
I want to know when expr is being called.

411
00:35:17,000 --> 00:35:22,857
The tricky thing about doing traces is
that it's not like 'print' in an imperative language.

412
00:35:22,900 --> 00:35:27,028
It's not going to print a
statement as soon as it enters expr.

413
00:35:28,194 --> 00:35:33,417
It will cause that string to be
printed when expr's result gets evaluated.

414
00:35:33,500 --> 00:35:37,268
Which sometimes can be rather distant.

415
00:35:37,268 --> 00:35:40,274
Action of debugging at a distance.

416
00:35:40,290 --> 00:35:44,731
OC: So this is where Haskell's laziness
is more of a pain point than a benefit.

417
00:35:44,742 --> 00:35:48,068
JW: Right, it makes it harder to
find out when things are happening.

418
00:35:48,068 --> 00:35:51,017
So we are seeing that the
expression is only being called once.

419
00:35:51,051 --> 00:35:54,514
Our infinite recursion is happening elsewhere.

420
00:35:58,500 --> 00:36:02,891
My first version of many parsers will
have tracers on every function (laughter).

421
00:36:02,900 --> 00:36:07,188
So I can watch what's happening as it's going.

422
00:36:07,222 --> 00:36:10,560
So I will go ahead and put this in.

423
00:36:13,000 --> 00:36:19,588
After a certain point I have a keyboard macro.

424
00:36:20,068 --> 00:36:25,417
Now I can say control E and control... alright.

425
00:36:26,100 --> 00:36:28,171
So we get to addop and we stop.

426
00:36:29,817 --> 00:36:32,034
So addop...

427
00:36:32,125 --> 00:36:39,165
(Silence).

428
00:36:39,160 --> 00:36:43,211
Let me add traces, inaudible.

429
00:36:43,210 --> 00:36:50,297
(John mumbles to himself).

430
00:36:51,410 --> 00:36:56,720
Ah! the minus symbol. We don't have a minus symbol.

431
00:36:59,188 --> 00:37:03,645
OC: What happens if we just
shorten this file even more... yeah.

432
00:37:06,091 --> 00:37:08,674
JW: We're getting no output whatsoever.

433
00:37:08,700 --> 00:37:12,011
Oh! there we go, same place.

434
00:37:12,800 --> 00:37:18,400
OC: And if we run our test again?

435
00:37:21,400 --> 00:37:22,300
JW: Interesting.

436
00:37:26,300 --> 00:37:27,900
I don't have support for parens.

437
00:37:29,300 --> 00:37:31,200
But there are no parens in this line

438
00:37:32,000 --> 00:37:34,300
OC: Maybe it's the
new line that's the problem,

439
00:37:35,900 --> 00:37:37,000
at the end of the file.

440
00:37:38,200 --> 00:37:39,900
Let's say that we want there to be

441
00:37:39,900 --> 00:37:41,300
an eof at the end of the file.

442
00:37:47,400 --> 00:37:49,200
We don't even get there which means

443
00:37:49,200 --> 00:37:52,000
we have infinite
recursion happening somewhere.

444
00:37:58,000 --> 00:38:03,600
Let's split the file up into lines
and do this differently:

445
00:38:20,100 --> 00:38:22,500
Now we would expect
that we would get the 2.0

446
00:38:23,100 --> 00:38:24,000
as a result.

447
00:38:27,000 --> 00:38:28,700
If we go back to what we had before

448
00:38:29,500 --> 00:38:32,700
It's failing parse these comments.

449
00:38:34,400 --> 00:38:36,200
OC: Maybe the empty strings as well.

450
00:38:36,200 --> 00:38:36,700
JW: Yes.

451
00:38:39,100 --> 00:38:41,600
OC: Cool, we don't have parentheses.

452
00:38:43,600 --> 00:38:45,920
We definitely want to strip out the comments.

453
00:38:50,200 --> 00:38:52,200
Let's write a function called massage.

454
00:38:54,200 --> 00:38:55,800
That will take some input text

455
00:38:57,800 --> 00:39:00,400
and strip out anything
that looks like a comment.

456
00:39:02,400 --> 00:39:03,200
First we'll say:

457
00:39:38,320 --> 00:39:39,760
I'll go to Data.Text library

458
00:39:39,760 --> 00:39:41,680
to find out how to partition a string.

459
00:39:49,900 --> 00:39:52,500
partition is not what I
want, I want break or split.

460
00:40:15,400 --> 00:40:18,160
We're never going to have
the hash be a valid character.

461
00:40:19,600 --> 00:40:20,640
So we're going to say:

462
00:41:32,000 --> 00:41:33,600
OC: That's the parentheses again.

463
00:41:35,300 --> 00:41:37,300
I think we're skipping over comments

464
00:41:37,300 --> 00:41:39,500
successfully now,
and those two outputs

465
00:41:39,500 --> 00:41:42,160
do match what we
would expect from the input file.

466
00:41:45,900 --> 00:41:48,600
JW: We have now got
parsing of expressions and files.

467
00:41:50,200 --> 00:41:51,600
We know we have to do parens

468
00:41:51,600 --> 00:41:52,960
and a couple of other things.

469
00:41:53,600 --> 00:41:55,000
What I would like to do next

470
00:41:57,000 --> 00:41:58,160
is do it in a REPL style.

471
00:41:59,100 --> 00:42:03,000
So that I could use this on
the command line for example.

472
00:42:03,000 --> 00:42:05,100
We want to have a function called REPL.

473
00:42:05,100 --> 00:42:06,800
And this will just loop forever.

474
00:42:14,900 --> 00:42:16,800
I can't remember what the function is

475
00:42:16,800 --> 00:42:18,600
to get input from the command line

476
00:42:18,600 --> 00:42:19,300
Is it getLine?

477
00:42:22,300 --> 00:42:23,500
It's not something I use.

478
00:42:23,500 --> 00:42:25,000
OC: You can also use interact.

479
00:42:25,000 --> 00:42:27,000
That would be interesting to look at.

480
00:42:27,700 --> 00:42:29,700
Let's hop over to interact:

481
00:42:32,200 --> 00:42:34,700
The output string is
going to be what it prints.

482
00:42:36,000 --> 00:42:37,900
So we're going to get an input string,

483
00:42:38,900 --> 00:42:40,300
and run it against our test.

484
00:42:45,100 --> 00:42:47,100
This one is in IO, which is unfortunate.

485
00:42:51,000 --> 00:42:53,200
There's no reason this
function should be in IO

486
00:42:53,200 --> 00:42:54,600
except when we're printing.

487
00:42:54,600 --> 00:42:56,000
So let's break this into two.

488
00:42:58,000 --> 00:42:58,600
Let this be:

489
00:43:23,000 --> 00:43:25,300
I guess it would be more appropriate
to call it evalText.

490
00:43:25,600 --> 00:43:26,800
And our test is going to...

491
00:43:38,400 --> 00:43:40,900
That's not really a unicode character.

492
00:43:40,900 --> 00:43:42,400
OC: That's actually the ASCII 'dot'.

493
00:43:42,400 --> 00:43:44,100
JW: Yes but Emacs has this way to say

494
00:43:45,500 --> 00:43:48,300
'when you see this type
of character in this context,'

495
00:43:48,800 --> 00:43:51,000
then, 'show me
this other character instead.'

496
00:43:52,700 --> 00:43:53,300
When I type:

497
00:43:57,900 --> 00:44:00,100
I'd like to see the
mathematical notations

498
00:44:01,100 --> 00:44:03,280
OC: And you're doing
the same with the arrow

499
00:44:03,280 --> 00:44:04,560
and the double colon above.

500
00:44:04,600 --> 00:44:05,500
JW: And this arrow and a
few other things.

501
00:44:07,500 --> 00:44:12,000
I have one for the proc incoming arrow.

502
00:44:14,800 --> 00:44:16,200
I interact with evalText,

503
00:44:17,500 --> 00:44:21,500
which simply needs to pack and unpack.

504
00:44:22,500 --> 00:44:25,100
There's no particular
reason I'm using Data.Text.

505
00:44:28,900 --> 00:44:30,900
OC: I think interact already runs forever.

506
00:44:32,900 --> 00:44:35,500
The idea of interact
is you get a lazy string

507
00:44:35,500 --> 00:44:36,800
of all of standard input.

508
00:44:37,700 --> 00:44:39,800
And you deliver a lazy string of output.

509
00:44:40,200 --> 00:44:42,800
So you might want to
split that into lines again

510
00:44:44,300 --> 00:44:45,600
then evalText over each line.

511
00:44:47,400 --> 00:44:48,000
JW: Right.

512
00:44:49,300 --> 00:44:50,900
Well if I'm going to be on a REPL...

513
00:44:51,400 --> 00:44:52,300
Lets take a look...

514
00:44:56,500 --> 00:44:57,400
Oh yes you're right.

515
00:44:58,000 --> 00:44:59,400
It takes the entire input.

516
00:45:02,800 --> 00:45:04,300
That's not really what I want.

517
00:45:07,300 --> 00:45:09,800
I want to have my own forever because I
want to see the result of every line as I
type.

518
00:45:13,040 --> 00:45:14,640
So we want our input to come from getLine.

519
00:45:22,000 --> 00:45:24,640
Now that we're in IO
we can just run test on the input.

520
00:45:33,360 --> 00:45:35,120
We can be a little bit fancier now.

521
00:46:13,520 --> 00:46:16,640
I have to add in an
extension called OverloadedStrings.

522
00:46:19,520 --> 00:46:20,800
OC: And when you type that

523
00:46:20,800 --> 00:46:22,480
have you got a templating thing for Emacs?

524
00:46:26,800 --> 00:46:28,960
JW: There is a module called YASnippet

525
00:46:30,880 --> 00:46:32,560
And I have a snippet called 'lang'.

526
00:46:35,440 --> 00:46:36,320
So if I type 'lang' and hit tab

527
00:46:37,760 --> 00:46:39,200
It will expand and then ask...

528
00:46:39,680 --> 00:46:41,680
It actually has gone to GHC and asked it.

529
00:46:44,080 --> 00:46:45,440
I can show you the snippet

530
00:46:57,360 --> 00:46:58,160
Here it is.

531
00:47:00,160 --> 00:47:03,600
It inserts language, it requires and then
it says haskell-yas-ghc-language-pragmas

532
00:47:05,760 --> 00:47:08,400
That is a function that will go out to GHC,

533
00:47:14,400 --> 00:47:16,960
and ask "what are all your extensions?"
Actually I think the command was

534
00:47:18,240 --> 00:47:20,160
Right there: ghc --supported-extensions.

535
00:47:22,160 --> 00:47:26,720
And that will tell you what you can use.

536
00:47:31,760 --> 00:47:33,040
Back to our example code.

537
00:47:38,400 --> 00:47:39,760
This is not compiling yet.

538
00:47:40,160 --> 00:47:41,440
It still didn't like that.

539
00:47:49,360 --> 00:47:50,480
It wants a character!

540
00:48:04,320 --> 00:48:05,760
Oh! I don't want to use return.

541
00:48:07,760 --> 00:48:09,840
It was interpreting it in the List monad

542
00:48:11,840 --> 00:48:13,760
Right, so now if we have a REPL I can say:

543
00:48:17,760 --> 00:48:20,880
This makes it a little easier for me to do
little tests.

544
00:48:22,240 --> 00:48:23,120
So let's do parens.

545
00:48:29,680 --> 00:48:31,680
For this one I can use a Parsec feature.

546
00:48:41,200 --> 00:48:42,880
It's in the combinators library.

547
00:48:43,760 --> 00:48:45,200
It's called 'between' I think.

548
00:48:46,720 --> 00:48:46,960
Yes.

549
00:48:52,000 --> 00:48:53,520
I like this notion of symbol.

550
00:48:56,160 --> 00:48:58,480
A symbol can have
white space on either side.

551
00:49:05,760 --> 00:49:07,200
OC: Maybe it would be better

552
00:49:07,200 --> 00:49:08,960
if we passed a Parser in as well.

553
00:49:09,680 --> 00:49:12,320
so symbol is a kind of Parser transformer
that takes a Parser

554
00:49:13,760 --> 00:49:15,360
and gives you...

555
00:49:15,600 --> 00:49:18,880
JW: Then I would find myself
constantly doing things like that.

556
00:49:20,240 --> 00:49:21,760
I would rather just say this:

557
00:49:22,640 --> 00:49:25,280
Now I will go to all the
places where I've done this.

558
00:49:25,280 --> 00:49:28,400
I can say symbol without
having to have this nonsense here.

559
00:49:31,680 --> 00:49:34,080
The symbol function that comes with Parsec,

560
00:49:41,680 --> 00:49:43,440
the one that is in the token module,

561
00:49:43,440 --> 00:49:45,200
relies upon a definition of what

562
00:49:46,560 --> 00:49:48,240
the tokens of your language are

563
00:49:48,240 --> 00:49:49,680
including the commenting.

564
00:49:50,400 --> 00:49:53,120
We've handled commenting,
pre - input to the Parser.

565
00:49:54,400 --> 00:49:56,960
Parsec does have the
ability to say this is what...

566
00:49:59,600 --> 00:50:01,680
OC: So rather than sanitizing the input,

567
00:50:01,680 --> 00:50:04,880
you could have dealt with
comments as syntax themselves.

568
00:50:04,880 --> 00:50:05,440
JW: Right.

569
00:50:05,440 --> 00:50:07,760
If I go to the contents of the Parsec module.

570
00:50:16,880 --> 00:50:18,480
We have a module called token.

571
00:50:19,360 --> 00:50:20,960
In token there is this notion

572
00:50:20,960 --> 00:50:22,320
of a language definition.

573
00:50:22,720 --> 00:50:24,560
Which you call makeTokenParser

574
00:50:26,560 --> 00:50:28,960
and you pass in a
definition of your language.

575
00:50:29,600 --> 00:50:31,840
And that definition defines these things.

576
00:50:33,840 --> 00:50:35,120
How do comments begin and end.

577
00:50:35,120 --> 00:50:37,360
What does a single
line comment look like.

578
00:50:38,320 --> 00:50:39,680
Can they be nested etc. etc.

579
00:50:41,200 --> 00:50:43,040
And finally you have reservedNames

580
00:50:43,040 --> 00:50:44,800
and reservedOpNames.

581
00:50:44,800 --> 00:50:46,880
That way, when you
say symbol it has to be,

582
00:50:47,200 --> 00:50:48,080
something from...

583
00:50:48,960 --> 00:50:51,840
I don't think it has to be
from your reservedNames list,

584
00:50:51,840 --> 00:50:54,480
but it won't confuse
that as an identifier name.

585
00:50:56,800 --> 00:50:57,760
it's been reserved.

586
00:50:58,560 --> 00:51:00,240
This is a very handy thing to use

587
00:51:02,880 --> 00:51:04,720
but we're not going to be using it right
now because

588
00:51:05,200 --> 00:51:06,400
Our language is so simple.

589
00:51:22,320 --> 00:51:24,960
OC: I think between
still needs a third argument

590
00:51:24,960 --> 00:51:26,320
which is the Parser to run.

591
00:52:22,240 --> 00:52:23,840
OC: So we should be able to call

592
00:52:24,080 --> 00:52:26,000
the function that's reading the file

593
00:52:27,440 --> 00:52:29,200
And get a little further this time.

594
00:52:30,160 --> 00:52:32,640
Previously we were
using testFile on test.bc

595
00:52:35,760 --> 00:52:36,960
which is a shorter file.

596
00:52:37,520 --> 00:52:38,160
There we go.

597
00:52:38,160 --> 00:52:40,160
OC: It looks like it gets all the way to
the end there.

598
00:52:40,160 --> 00:52:42,160
JW: Right. Now we're
going to test.bc

599
00:52:42,160 --> 00:52:43,440
and add in the next thing.

600
00:52:48,960 --> 00:52:50,560
As we're in a working state here,

601
00:52:50,880 --> 00:52:52,800
I'm going to go ahead and commit this.

602
00:53:05,520 --> 00:53:07,360
JW: How are we going to handle let
binding?

603
00:53:07,360 --> 00:53:10,080
We will start by writing
a parser for let bindings.

604
00:53:13,360 --> 00:53:14,960
It's going to be an expression.

605
00:53:14,960 --> 00:53:16,000
I don't know what yet.

606
00:53:20,080 --> 00:53:22,320
We want to
represent this in our language.

607
00:53:24,320 --> 00:53:25,200
We're going to say:

608
00:53:25,200 --> 00:53:27,920
A let binding has a
variable name and an expression.

609
00:53:34,640 --> 00:53:37,280
We know that we will
have let in our constructor.

610
00:53:52,960 --> 00:53:53,760
I want letter.

611
00:53:59,200 --> 00:54:02,880
OC: So some is like many but it requires
one or more

612
00:54:03,840 --> 00:54:04,960
And we want, of course...

613
00:54:10,640 --> 00:54:12,560
We're going to get some conflict here.

614
00:54:12,800 --> 00:54:15,280
Oh! that's because
letter returns a character,

615
00:54:18,160 --> 00:54:20,560
the aggregate raises a string and then
pack it

616
00:54:20,560 --> 00:54:21,760
because we want to test.

617
00:54:21,760 --> 00:54:24,160
We want to tie the let
binding in to our Parser.

618
00:54:26,800 --> 00:54:29,760
OC: Do you need to introduce
the let keyword there at all.

619
00:54:31,600 --> 00:54:32,880
JW: Excellent point.

620
00:54:39,600 --> 00:54:41,440
OC: Is there an equals between the keyword...

621
00:54:42,080 --> 00:54:44,720
JW: Let's see what
your specification said

622
00:54:56,320 --> 00:54:58,800
It's starting to go a little out in to
space here so let's write it more
monadically

623
00:55:34,640 --> 00:55:35,840
What is going on there?

624
00:55:40,400 --> 00:55:42,480
Why would it think
that the type of body...

625
00:55:43,760 --> 00:55:45,360
OC: Is that error out of date

626
00:55:46,400 --> 00:55:47,600
because you don't have

627
00:55:47,600 --> 00:55:49,200
that last line of code any more.

628
00:55:52,160 --> 00:55:55,280
JW: That's true. Sometimes
the background syntax checker

629
00:55:55,280 --> 00:55:56,240
Ah

630
00:55:57,200 --> 00:55:58,800
I'm getting a little ahead of it

631
00:55:58,800 --> 00:56:00,880
so it's showing a result from a while ago.

632
00:56:02,000 --> 00:56:04,880
In the evaluator, we need
to do something with this let.

633
00:56:09,440 --> 00:56:11,200
We need to take in an environment.

634
00:56:13,760 --> 00:56:15,200
And that is going to be a map.

635
00:56:19,040 --> 00:56:20,320
of names to expressions.

636
00:56:22,320 --> 00:56:24,640
We want the let to
add an entry into that map.

637
00:56:25,120 --> 00:56:26,560
That we can later evaluate,

638
00:56:26,880 --> 00:56:28,640
if anyone makes a reference to it.

639
00:56:29,280 --> 00:56:30,960
We want to have Data.Map in scope.

640
00:56:38,160 --> 00:56:40,560
We don't JUST want a
map of text to expressions

641
00:56:40,880 --> 00:56:42,800
because that would mean every time

642
00:56:42,800 --> 00:56:44,320
the variable was referred to

643
00:56:44,320 --> 00:56:45,600
it would be re-evaluated.

644
00:56:48,240 --> 00:56:49,680
We want a function in there.

645
00:56:54,880 --> 00:56:56,880
We want our evaluator to be recursive.

646
00:56:59,680 --> 00:57:02,240
I will need to have
this be a little trickier.

647
00:57:07,280 --> 00:57:08,880
Let's go with the dumb way first

648
00:57:11,600 --> 00:57:13,360
and build this up incrementally.

649
00:57:14,400 --> 00:57:16,800
It never pays to be
too fancy in the beginning.

650
00:57:22,160 --> 00:57:24,000
We need to pass in the environment

651
00:57:24,000 --> 00:57:26,000
and return the mutated environment.

652
00:57:26,000 --> 00:57:28,400
Which is the perfect job for state.

653
00:57:28,400 --> 00:57:30,400
Which means we need to bring in State.

654
00:57:35,920 --> 00:57:37,520
Which means now we are monadic.

655
00:57:39,520 --> 00:57:41,120
So all these have to do returns.

656
00:57:47,040 --> 00:57:48,240
Now we are going to say:

657
00:57:53,520 --> 00:57:55,200
OC: modify is from Control.Monad.State.

658
00:57:57,600 --> 00:57:59,920
env is going to be
the modified environment.

659
00:58:00,560 --> 00:58:01,680
I'm going to say:

660
00:58:11,840 --> 00:58:16,080
Parsec again has its own keyword named
State

661
00:58:23,280 --> 00:58:24,160
I need to getEnv.

662
00:58:29,680 --> 00:58:31,280
OC: Because Env is a new type.

663
00:58:31,520 --> 00:58:32,160
JW: Right

664
00:58:32,560 --> 00:58:33,440
OC: We need to wrap it back up.

665
00:58:38,800 --> 00:58:40,080
modify returns no value,

666
00:58:40,480 --> 00:58:42,080
yet we have been saying things

667
00:58:42,080 --> 00:58:43,520
return as Double all the time.

668
00:58:49,200 --> 00:58:49,840
Let's say:

669
00:58:55,920 --> 00:58:57,920
Let has one more
component doesn't it?

670
00:58:59,840 --> 00:59:02,000
It has the body
over which the let ranges.

671
00:59:05,440 --> 00:59:07,040
OC: Which in this simple syntax,

672
00:59:08,320 --> 00:59:09,840
is just to the end of the file.

673
00:59:11,200 --> 00:59:13,600
JW: This is actually an
imperative notion now.

674
00:59:13,600 --> 00:59:15,360
This is a statement with no result.

675
00:59:15,920 --> 00:59:18,000
That has an
effect on the environment.

676
00:59:18,800 --> 00:59:20,560
Which is not part of our evaluator.

677
00:59:23,440 --> 00:59:25,120
OC: Well, you could still put this

678
00:59:25,600 --> 00:59:29,200
in the evaluator but then the evaluator
could return Maybe Double

679
00:59:29,200 --> 00:59:30,800
Maybe running an expression

680
00:59:31,040 --> 00:59:32,480
doesn't give you any output.

681
00:59:34,000 --> 00:59:35,600
JW: That's one way we could do it.

682
00:59:36,240 --> 00:59:36,880
Let me think.

683
00:59:40,320 --> 00:59:42,800
OC: We could take
the more functional approach

684
00:59:43,920 --> 00:59:46,960
and have the let binding
scope over the rest of the file.

685
00:59:48,000 --> 00:59:50,240
And every time
you're introducing a new let

686
00:59:50,240 --> 00:59:52,000
you're introducing some more scope

687
00:59:52,000 --> 00:59:53,840
that extends to the end of the file.

688
00:59:53,840 --> 00:59:55,040
JW: I like that idea more,

689
00:59:56,400 --> 00:59:58,480
but for now let's
go with the Maybe idea.

690
01:00:01,410 --> 01:00:02,820
So in this case we have this.

691
01:00:04,700 --> 01:00:05,640
And here we'll have...

692
01:00:09,170 --> 01:00:10,700
These guys all become 'Justs'.

693
01:00:27,880 --> 01:00:28,940
We're in the monad now.

694
01:00:35,520 --> 01:00:37,640
So for example if
we were to say 1 plus

695
01:00:37,640 --> 01:00:38,941
let phi equal 10...

696
01:00:43,290 --> 01:00:44,700
Let's have a let be it's body.

697
01:00:44,820 --> 01:00:45,410
OC: Sure.

698
01:00:46,700 --> 01:00:48,000
JW: That makes more sense.

699
01:00:48,000 --> 01:00:48,470
OC: Yes.

700
01:00:49,170 --> 01:00:51,410
JW: We're still monadic
here so I'm going to

701
01:00:51,410 --> 01:00:53,050
rewrite this into monadic form.

702
01:00:54,230 --> 01:00:56,588
In another language
we would not name names.

703
01:00:57,050 --> 01:00:58,705
I could have said this couldn't I?

704
01:00:59,520 --> 01:01:01,290
It would have meant the same thing.

705
01:01:02,350 --> 01:01:03,760
Can't do that in Haskell yet.

706
01:01:04,470 --> 01:01:07,410
OC: So that's the style of banana brackets
that you were referring to

707
01:01:08,580 --> 01:01:10,700
Which is still somewhat controversial

708
01:01:10,700 --> 01:01:12,110
in the Haskell community.

709
01:01:18,350 --> 01:01:19,290
Now I want to:

710
01:01:32,110 --> 01:01:35,760
I do not need to return because that is
itself monadic.

711
01:01:36,580 --> 01:01:38,580
Now we need to pass in an environment

712
01:01:39,170 --> 01:01:41,050
to our evaluator wherever we use it.

713
01:01:42,350 --> 01:01:44,940
So let's have a way of
creating a new environment...

714
01:02:55,170 --> 01:02:56,470
OC: Do we really want that

715
01:02:57,170 --> 01:02:58,820
because you want to pass on this

716
01:02:59,880 --> 01:03:02,470
mutated environment
for every step of the REPL.

717
01:03:03,640 --> 01:03:05,520
JW: This will be a top level function.

718
01:03:06,110 --> 01:03:06,470
OC: OK.

719
01:03:09,640 --> 01:03:11,880
JW: This is for people
who are further down

720
01:03:11,880 --> 01:03:13,520
and don't have to worry like this.

721
01:03:14,350 --> 01:03:15,411
So we're going to say...

722
01:03:21,058 --> 01:03:27,411
We're going to have a new function called
eval.

723
01:03:33,760 --> 01:03:35,410
It underlines warnings in blue.

724
01:03:37,170 --> 01:03:39,410
I generally tend to
pay attention to them,

725
01:03:39,410 --> 01:03:40,940
I'm getting rid of redundancy.

726
01:03:42,000 --> 01:03:43,410
I don't need so much tracing.

727
01:03:43,882 --> 01:03:46,588
This seems like a good
opportunity to delete some.

728
01:03:48,110 --> 01:03:51,764
OC: Those warnings about
redundant brackets are coming from hlint?

729
01:03:53,050 --> 01:03:53,880
JW: Correct.

730
01:03:55,880 --> 01:03:57,290
I'm using flycheck which is

731
01:03:57,290 --> 01:04:00,580
talking to both GHC and hlint.

732
01:04:03,050 --> 01:04:05,640
That will give me a
more comprehensive picture.

733
01:04:06,350 --> 01:04:08,000
I have one warning left which is

734
01:04:08,000 --> 01:04:09,640
the import of token is redundant.

735
01:04:10,820 --> 01:04:11,640
So I will drop it.

736
01:04:15,050 --> 01:04:16,580
We did this to do let bindings.

737
01:04:17,176 --> 01:04:18,941
We still can't refer our variables.

738
01:04:20,117 --> 01:04:22,352
OC: Because we're
using a new environment.

739
01:04:22,705 --> 01:04:25,058
JW: So I need a new
thing which we'll call EVar,

740
01:04:26,700 --> 01:04:28,580
which will be a variable reference.

741
01:04:29,640 --> 01:04:31,640
I know how I want eval to be evaluated.

742
01:04:34,230 --> 01:04:36,350
I don't yet know how
I want it to be parsed.

743
01:04:40,230 --> 01:04:42,230
I'm going to get my environment and do:

744
01:05:03,640 --> 01:05:05,520
This is where I said we we're going to

745
01:05:05,520 --> 01:05:06,820
re-evaluate all the time.

746
01:05:12,230 --> 01:05:15,410
OC: This is because the look up has
returned an Expr.

747
01:05:15,410 --> 01:05:15,880
JW: Yes.

748
01:05:15,880 --> 01:05:18,000
And we're storing
expressions in our map.

749
01:05:20,110 --> 01:05:22,000
Because Haskell is a lazy language

750
01:05:22,940 --> 01:05:25,520
we want to get the map to have thunks in
it.

751
01:05:26,000 --> 01:05:28,230
So that the first time you touch the
thunk,

752
01:05:28,940 --> 01:05:31,410
only then will it do
the work of evaluating it.

753
01:05:32,000 --> 01:05:34,000
From then on it
will have that value.

754
01:05:34,350 --> 01:05:34,700
OC: OK.

755
01:05:35,290 --> 01:05:36,820
JW: we'll do that next.  Let's see.

756
01:05:39,050 --> 01:05:39,640
I need to:

757
01:05:43,170 --> 01:05:46,000
Now we have a way to
define and reference variables.

758
01:05:48,000 --> 01:05:49,640
We just need a way to parse them.

759
01:05:50,820 --> 01:05:53,410
Variable's going to be
a fundamental term again

760
01:05:56,110 --> 01:05:57,764
in addition to our let bindings.

761
01:05:58,705 --> 01:06:00,117
So we're going to have terms,

762
01:06:02,110 --> 01:06:03,058
and we'll call them:

763
01:06:10,470 --> 01:06:11,410
What is a variable?

764
01:06:16,470 --> 01:06:19,640
variable has the same definition as a
name.

765
01:06:30,940 --> 01:06:32,820
OC: So this is the same parser we used

766
01:06:32,820 --> 01:06:34,820
when we introduced a name in the let
binding.

767
01:06:35,290 --> 01:06:35,764
JW: Yes.

768
01:06:41,176 --> 01:06:42,117
Let's have our name...

769
01:06:52,230 --> 01:06:54,700
That way if we want
to update to alphanumerics

770
01:06:56,000 --> 01:06:57,882
we only have to change it in one place.

771
01:06:59,760 --> 01:07:00,470
Let's say:

772
01:07:15,050 --> 01:07:17,640
OC: So that no parse is
not coming from our parser.

773
01:07:17,640 --> 01:07:19,170
it's coming from our use of the

774
01:07:19,170 --> 01:07:20,580
read function somewhere.

775
01:07:21,410 --> 01:07:21,880
JW: Yes.

776
01:07:30,470 --> 01:07:31,640
We can use trace here.

777
01:07:34,580 --> 01:07:36,230
Actually, I don't need to do that

778
01:07:36,230 --> 01:07:37,760
because I have a key binding

779
01:07:39,760 --> 01:07:42,820
I use that auto inserts.

780
01:07:43,760 --> 01:07:45,050
I change it to be traces.

781
01:07:48,580 --> 01:07:50,470
I'm going to do this return at the end

782
01:07:50,470 --> 01:07:52,230
because trace has to yield a value.

783
01:07:56,350 --> 01:07:58,000
Sometimes I use printf more

784
01:07:58,000 --> 01:07:59,640
and sometimes I use trace more.

785
01:07:59,640 --> 01:08:01,290
I should have two variants of it.

786
01:08:05,050 --> 01:08:06,470
We never even get to our let.

787
01:08:08,820 --> 01:08:09,880
It's trying to parse...

788
01:08:17,880 --> 01:08:19,170
We get the same problem

789
01:08:19,170 --> 01:08:20,820
even if we just use the word let.

790
01:08:22,235 --> 01:08:23,176
(Big sigh from John)

791
01:08:27,520 --> 01:08:29,520
OC: We do have trace lines above which

792
01:08:29,520 --> 01:08:32,110
seem to indicate we
have gone into addop

793
01:08:32,110 --> 01:08:34,110
and mulop.

794
01:08:35,410 --> 01:08:37,640
JW: I just have to
prioritize let binding.

795
01:08:40,823 --> 01:08:42,117
This is what parsec does.

796
01:08:48,230 --> 01:08:50,470
It read in the first
letter of the word let.

797
01:08:51,520 --> 01:08:54,000
Found that it wasn't
a number in the num parser

798
01:08:54,580 --> 01:08:55,760
and said "this isn't me".

799
01:08:56,820 --> 01:08:58,820
Choice said, "OK whats the next parser,"

800
01:08:59,290 --> 01:09:00,700
but it didn't give back the L.

801
01:09:01,640 --> 01:09:02,820
So you have to use try

802
01:09:03,290 --> 01:09:04,940
as a wrapper around your parser

803
01:09:04,940 --> 01:09:06,700
if you want the input to be re wound

804
01:09:07,520 --> 01:09:10,110
to the beginning of
where your last parse failed.

805
01:09:10,110 --> 01:09:12,580
But since let begins
with a concrete key word

806
01:09:12,580 --> 01:09:14,350
that we're not going to be re-using

807
01:09:14,350 --> 01:09:15,290
as a variable name,

808
01:09:15,290 --> 01:09:17,411
it's safe for us to
promote that higher

809
01:09:17,410 --> 01:09:19,170
OC: Because no other expressions

810
01:09:19,170 --> 01:09:20,580
are going to use that word.

811
01:09:20,820 --> 01:09:21,520
JW: Right.

812
01:09:24,940 --> 01:09:27,880
because variable is going
to be a similar type of parser,

813
01:09:27,880 --> 01:09:29,050
let's wrap that as well.

814
01:09:40,700 --> 01:09:42,700
The REPL creates a new environment.

815
01:09:44,350 --> 01:09:46,940
So we want a different
type of test for this to use.

816
01:09:48,940 --> 01:09:50,110
Let me expand this out.

817
01:09:52,940 --> 01:09:55,410
We want to run this
forever loop within State.

818
01:10:01,647 --> 01:10:03,882
We're going to do
execStateT on this one.

819
01:10:04,580 --> 01:10:05,880
And we're going to flip it

820
01:10:06,350 --> 01:10:08,000
and do it with a new environment.

821
01:10:11,760 --> 01:10:12,700
Forever runs an IO,

822
01:10:15,640 --> 01:10:16,700
so we want to go here.

823
01:10:20,000 --> 01:10:21,764
OC: Forever should work on any monad.

824
01:10:22,000 --> 01:10:24,580
I think your problem
there was was the getLine

825
01:10:24,580 --> 01:10:26,350
is forcing you to be in the IO monad.

826
01:10:33,880 --> 01:10:34,820
So we get our input

827
01:10:36,000 --> 01:10:37,640
and we want to run our evaluator

828
01:10:40,580 --> 01:10:42,700
For that we're going
to have to parse it.

829
01:10:43,520 --> 01:10:45,520
I'm getting a lot
of duplication here.

830
01:10:47,050 --> 01:10:49,410
But for the time
being we'll just let it slide.

831
01:11:00,580 --> 01:11:02,110
We need to have our evaluator.

832
01:11:07,880 --> 01:11:09,640
We're going to get the environment

833
01:11:09,640 --> 01:11:10,940
and do a sub evaluation.

834
01:11:35,410 --> 01:11:37,290
OC: Sounds like it should be possible

835
01:11:37,640 --> 01:11:39,760
to do that without
having to runState.

836
01:11:41,760 --> 01:11:43,050
JW: This StateT is over IO,

837
01:11:44,350 --> 01:11:45,880
and our function is a StateT

838
01:11:45,880 --> 01:11:47,050
that's over Identity.

839
01:11:48,350 --> 01:11:52,000
We could use the mmorph library's hoist
routine.

840
01:11:52,940 --> 01:11:54,350
To swap out between the two.

841
01:12:01,640 --> 01:12:02,940
We're going to say:

842
01:12:26,580 --> 01:12:28,470
We're going to go from Identity to IO.

843
01:12:33,880 --> 01:12:35,760
It should be just a matter of return.

844
01:12:52,110 --> 01:12:54,230
getLine is still will forcing us into the
wrong monad.

845
01:13:02,820 --> 01:13:05,050
OC: You might have
Data.Text.IO.getLine

846
01:13:07,050 --> 01:13:08,352
that you avoid packing.

847
01:13:19,290 --> 01:13:21,294
OC: And you have got T.readFile here.

848
01:13:41,050 --> 01:13:42,941
OC: Another problem is execState is

849
01:13:43,170 --> 01:13:45,411
apparently going to give you back the
file.

850
01:14:00,580 --> 01:14:03,170
JW: execState is giving us back a...

851
01:14:17,640 --> 01:14:20,000
It's losing the sense
of what monad we're in.

852
01:14:42,580 --> 01:14:44,940
Oh I always get a
surprise when that type checks!

853
01:14:44,940 --> 01:14:47,050
I didn't think that
hoist line was right

854
01:14:47,760 --> 01:14:48,700
but I guess it was.

855
01:14:49,290 --> 01:14:51,050
OC: You were pretty quick so maybe

856
01:14:51,050 --> 01:14:53,764
you were running ahead
of your flycheck again!

857
01:14:54,000 --> 01:14:55,170
JW: So we have 1 plus 4.

858
01:14:56,117 --> 01:14:57,529
We have let phi equals 20.

859
01:14:58,110 --> 01:14:59,529
Now I should be able to say

860
01:14:59,647 --> 01:15:00,941
phi plus 5 and I get no parse.

861
01:15:03,760 --> 01:15:06,000
we have been
stricken by this num parser

862
01:15:06,940 --> 01:15:09,058
OC: So maybe we can just do the same
trick twice

863
01:15:11,290 --> 01:15:12,588
JW: Well it's worth trying,

864
01:15:14,230 --> 01:15:16,470
So we can define
and reference variables.

865
01:15:20,230 --> 01:15:22,000
Now we want the ability to define

866
01:15:22,110 --> 01:15:24,350
not just sub
expressions, but functions.

867
01:15:25,170 --> 01:15:26,110
Before we do that

868
01:15:26,230 --> 01:15:27,410
I want to do this trick

869
01:15:27,410 --> 01:15:29,520
where we do not
re-evaluate expressions.

870
01:15:32,470 --> 01:15:33,760
We want our map to be a map

871
01:15:35,760 --> 01:15:36,820
of names to doubles.

872
01:15:38,820 --> 01:15:40,350
And the reason we can do that

873
01:15:40,352 --> 01:15:42,000
is because they are constants.

874
01:15:42,580 --> 01:15:44,700
They can only
ever refer other things

875
01:15:44,820 --> 01:15:46,110
inside the environment.

876
01:15:46,110 --> 01:15:48,580
So here, instead of
inserting our expression,

877
01:15:49,410 --> 01:15:51,410
into the map we we are going to insert...

878
01:15:56,700 --> 01:15:58,580
Oh I have to evaluate that outside.

879
01:16:00,352 --> 01:16:02,000
OC: Because that might refer to

880
01:16:02,000 --> 01:16:04,000
previously bound variables.

881
01:16:06,820 --> 01:16:09,290
This is not using any kind of laziness type trick

882
01:16:10,350 --> 01:16:12,230
it's just evaluating at that moment.

883
01:16:13,290 --> 01:16:15,640
OC: Should we change that last evalExpr b
as well

884
01:16:15,640 --> 01:16:16,820
to just return B prime.

885
01:16:21,880 --> 01:16:23,050
JW: Let's check this in.

886
01:16:25,640 --> 01:16:27,290
We can now define and reference.

887
01:16:31,520 --> 01:16:33,880
Now let's see if we can
parse this in our test.

888
01:16:37,520 --> 01:16:39,640
OC: I imagine we're
going to get a problem

889
01:16:39,640 --> 01:16:40,940
looking up square root.

890
01:16:43,410 --> 01:16:44,230
That's my guess.

891
01:16:45,640 --> 01:16:47,410
JW: Unknown variable square root.

892
01:16:49,760 --> 01:16:51,410
We have no way of defining functions yet.

893
01:16:52,000 --> 01:16:54,700
OC: We do seem to have
a couple of loop regressions.

894
01:16:55,170 --> 01:16:56,000
Oh, look at that...

895
01:16:59,520 --> 01:17:01,176
we're losing the sense of lines

896
01:17:01,290 --> 01:17:03,050
because we're chopping things up.

897
01:17:05,050 --> 01:17:06,700
So we got two but we didn't get 30

898
01:17:07,170 --> 01:17:09,294
Let's do this now
ourselves, at the REPL.

899
01:17:12,110 --> 01:17:14,230
We definitely have a regression there.

900
01:17:19,290 --> 01:17:22,110
I don't think division
is being handled correctly.

901
01:17:26,940 --> 01:17:29,411
I have a feeling that
if it's any other operator

902
01:17:29,640 --> 01:17:30,470
it will be fine.

903
01:17:30,470 --> 01:17:31,760
Yes, so it's just division.

904
01:17:35,760 --> 01:17:38,230
OC: We maybe forgot
to put a line in our parser.

905
01:18:06,000 --> 01:18:07,520
OC: Is it because we should be using

906
01:18:07,520 --> 01:18:08,940
symbol rather than string.

907
01:18:08,940 --> 01:18:10,110
JW: Of course that's why.

908
01:18:10,470 --> 01:18:11,050
Thank you.

909
01:18:13,050 --> 01:18:14,110
Yes now we have it.

910
01:18:18,110 --> 01:18:20,230
OC: So I  guess we
go back to that read file.

911
01:18:23,640 --> 01:18:26,820
we have all of our current lines
no square root

912
01:18:28,000 --> 01:18:29,520
JW: I guess you we're expecting

913
01:18:29,520 --> 01:18:30,820
that to be from a library?

914
01:18:34,110 --> 01:18:36,230
There's a prelude in
scope and I assumed...

915
01:18:36,580 --> 01:18:38,230
JW: Let's call it double instead,

916
01:18:39,170 --> 01:18:40,588
and let's say that double...

917
01:18:41,640 --> 01:18:44,000
Let's see what the
syntax for functions was.

918
01:18:52,230 --> 01:18:53,640
Now we need to define that.

919
01:18:54,580 --> 01:18:56,350
As usual I like to start by looking

920
01:18:56,350 --> 01:18:57,520
at my expression tree.

921
01:19:01,410 --> 01:19:02,940
This is a lot like a let binding,

922
01:19:04,470 --> 01:19:06,700
it's just one that
needs input parameters.

923
01:19:09,880 --> 01:19:11,170
This is like saying this:

924
01:19:17,290 --> 01:19:20,000
We have an expression
that's a lambda abstraction

925
01:19:21,410 --> 01:19:22,940
and we want to define double

926
01:19:22,940 --> 01:19:24,470
to be that lambda abstraction.

927
01:19:25,880 --> 01:19:27,640
So we'll call that ELam.

928
01:19:28,470 --> 01:19:30,230
At the moment we're going to allow

929
01:19:30,230 --> 01:19:32,350
that lambda to
take just one variable.

930
01:19:34,230 --> 01:19:35,760
OC: Yes, that's all that happens

931
01:19:35,760 --> 01:19:37,050
in these little example scripts.

932
01:19:37,050 --> 01:19:38,820
You can assume that these are all

933
01:19:38,820 --> 01:19:40,350
functions over one variable.

934
01:19:40,700 --> 01:19:41,290
JW: Right.

935
01:19:41,640 --> 01:19:43,520
So that variable is going to itself

936
01:19:46,700 --> 01:19:48,000
evaluate down to a value.

937
01:19:49,760 --> 01:19:50,230
OC: Yes,

938
01:19:50,230 --> 01:19:51,520
JW: So we can have our lambda

939
01:19:53,520 --> 01:19:54,940
be a host language lambda.

940
01:19:59,410 --> 01:20:00,940
Of expression to expression.

941
01:20:00,940 --> 01:20:02,700
OC: Why expression to expression

942
01:20:02,700 --> 01:20:04,230
and not double to expression?

943
01:20:06,940 --> 01:20:08,580
JW: Because it's a lambda in there

944
01:20:08,580 --> 01:20:10,820
and this would be
the higher order abstract syntax

945
01:20:11,520 --> 01:20:13,520
where we're using
the host language's

946
01:20:14,940 --> 01:20:17,290
ability to represent
functions as values..

947
01:20:18,470 --> 01:20:20,230
In order for our target language

948
01:20:22,000 --> 01:20:23,764
to represent functions as values.

949
01:20:24,110 --> 01:20:25,640
That's the higher order nature.

950
01:20:26,470 --> 01:20:28,110
There can be no automatically

951
01:20:28,110 --> 01:20:29,880
derived Show instance for these.

952
01:20:30,110 --> 01:20:31,410
This is the tedious part

953
01:20:31,410 --> 01:20:33,410
where we have to do a lot of boilerplate.

954
01:20:36,470 --> 01:20:37,880
We have to say for every one

955
01:20:38,940 --> 01:20:39,760
of these things...

956
01:20:43,880 --> 01:20:45,290
I need to say what it means

957
01:20:45,290 --> 01:20:46,230
to print that out.

958
01:20:48,230 --> 01:20:50,000
So I'm going to say what that means.

959
01:20:50,820 --> 01:20:52,580
OC: Do we still need Show instance?

960
01:20:53,410 --> 01:20:55,170
We could just drop that I suppose.

961
01:20:58,000 --> 01:21:00,350
JW: True, but it comes
in handy for debugging

962
01:21:10,700 --> 01:21:12,350
Lambda is not going to be there.

963
01:21:58,110 --> 01:22:01,760
It's not the show it's complaining about
it's the fact that this has to be monoid.

964
01:22:08,580 --> 01:22:10,700
Pretty soon this is going to be 300 lines

965
01:22:11,640 --> 01:22:13,290
as usually happens in Haskell!

966
01:22:13,290 --> 01:22:15,290
OC: but we do want to be working
with strings here right?

967
01:22:15,290 --> 01:22:17,410
because show is
defined as a function

968
01:22:17,520 --> 01:22:18,940
from something to string.

969
01:22:18,940 --> 01:22:20,000
JW: You're right.

970
01:22:31,760 --> 01:22:33,520
OC: I think we're OK using show.

971
01:22:34,941 --> 01:22:37,529
Oh yes! because we're
defining a Show instance.

972
01:22:38,000 --> 01:22:40,235
Yes, so we want
unpack in these two places.

973
01:22:45,050 --> 01:22:46,230
JW: Now I have my lambda.

974
01:22:48,230 --> 01:22:49,760
The first thing is to decide

975
01:22:49,760 --> 01:22:51,170
how I'm going to evaluate it.

976
01:22:52,230 --> 01:22:54,350
Before I go on to how
I'm going to parse it.

977
01:22:56,350 --> 01:22:58,000
So I get my lambda, and I have an F

978
01:22:59,410 --> 01:23:00,580
and now I'm going to say:

979
01:23:12,700 --> 01:23:13,760
I need a double.

980
01:23:14,940 --> 01:23:18,820
I need a body for my lambda

981
01:23:22,000 --> 01:23:24,235
I need to define
what application means.

982
01:23:24,230 --> 01:23:25,882
What it means to call a function.

983
01:23:26,000 --> 01:23:27,640
That's how it gets its argument.

984
01:23:29,170 --> 01:23:31,410
Application takes a
form and an argument.

985
01:23:36,700 --> 01:23:38,230
And we're going to show that as...

986
01:23:46,230 --> 01:23:47,880
OC: Is F here going to be the name

987
01:23:48,940 --> 01:23:50,350
of the lambda abstraction?

988
01:23:51,410 --> 01:23:51,880
JW: Yes

989
01:23:54,820 --> 01:23:56,941
We'll restrict it to
being nothing fancy

990
01:23:57,410 --> 01:23:59,290
like an expression that evaluates

991
01:24:01,290 --> 01:24:03,647
to a lambda that can
be passed as an argument.

992
01:24:03,880 --> 01:24:05,410
That would be cool but for now

993
01:24:05,760 --> 01:24:08,000
we'll have functions be only
referenceable by name.

994
01:24:11,520 --> 01:24:12,941
So we have EApp be a name

995
01:24:14,823 --> 01:24:17,411
and the argument is
going to be the expression.

996
01:24:17,411 --> 01:24:18,823
So we only allow one argument.

997
01:24:19,880 --> 01:24:20,820
We want unpack n.

998
01:24:29,170 --> 01:24:30,110
We'll say:

999
01:24:43,290 --> 01:24:44,470
Then look up in the map...

1000
01:24:58,470 --> 01:25:00,470
We can't store just doubles in our map.

1001
01:26:12,820 --> 01:26:14,000
Evaluating a lambda.

1002
01:26:20,230 --> 01:26:23,050
There should be no
context in which it's evaluating.

1003
01:26:25,050 --> 01:26:26,580
OC: That's basically a type error.

1004
01:26:26,580 --> 01:26:28,580
in our little language

1005
01:27:04,470 --> 01:27:06,470
Now we need a way to define these two things

1006
01:27:07,170 --> 01:27:09,647
OC: There's a little
more syntax to bring in here

1007
01:27:10,350 --> 01:27:11,760
We had that binding before,

1008
01:27:11,760 --> 01:27:13,520
now we're going to have fun binding.

1009
01:27:17,410 --> 01:27:19,880
OC: We're already having
fun binding. (laughter).

1010
01:27:26,580 --> 01:27:28,110
So we want the symbol define.

1011
01:27:30,110 --> 01:27:32,000
We want the name and the open parens

1012
01:27:35,050 --> 01:27:36,941
We want also, the argument to be a name.

1013
01:27:43,640 --> 01:27:45,170
Then we want closing parens,

1014
01:27:46,350 --> 01:27:47,880
and then open curly (laughter).

1015
01:27:51,050 --> 01:27:53,410
And then we can
have up to many expressions

1016
01:27:57,520 --> 01:27:58,940
in the body of the function.

1017
01:28:01,640 --> 01:28:03,290
Now, expressions that could end

1018
01:28:05,880 --> 01:28:06,580
in newlines.

1019
01:28:11,290 --> 01:28:13,050
And there is a thing we can use from

1020
01:28:15,050 --> 01:28:16,470
parser called text sepBy.

1021
01:28:20,580 --> 01:28:21,640
So we want sepBy1.

1022
01:28:24,350 --> 01:28:25,760
OC: So that parses at least one expression

1023
01:28:27,760 --> 01:28:29,170
that is separated by new lines.

1024
01:28:29,170 --> 01:28:30,000
JW: Right.

1025
01:28:32,000 --> 01:28:32,820
This is our body.

1026
01:28:34,820 --> 01:28:35,760
And now we're going to return ELam

1027
01:28:38,230 --> 01:28:40,000
We want a function that's going to

1028
01:28:40,000 --> 01:28:41,640
take in some number and return...

1029
01:28:47,050 --> 01:28:48,580
Let me ask you this question:

1030
01:28:50,110 --> 01:28:51,760
What if we evaluate a function

1031
01:28:52,940 --> 01:28:54,350
that has let bindings in it?

1032
01:28:54,350 --> 01:28:56,580
Those let bindings should
probably not escape

1033
01:28:56,940 --> 01:28:58,580
outside of the function should they?

1034
01:28:58,580 --> 01:29:00,470
And every time you run the function,

1035
01:29:01,050 --> 01:29:03,050
it should renew the let bindings.

1036
01:29:05,760 --> 01:29:08,580
JW: So a function is not
going to return an expression.

1037
01:29:09,880 --> 01:29:11,760
An expression is going to be a mutator

1038
01:29:11,760 --> 01:29:13,050
from doubles to doubles.

1039
01:29:16,350 --> 01:29:18,580
But, we want it to
inherit the environment.

1040
01:29:22,000 --> 01:29:23,760
that it was executed in each time.

1041
01:29:23,760 --> 01:29:26,820
OC: So we can refer to let bindings
outside the function definition.

1042
01:29:31,170 --> 01:29:33,760
So instead of using
something as fancy as reader,

1043
01:29:34,470 --> 01:29:37,050
we're going to take in
environment as an argument.

1044
01:29:37,050 --> 01:29:37,640
OC: Sure.

1045
01:29:40,700 --> 01:29:43,290
JW: We have our env

1046
01:29:44,230 --> 01:29:45,290
JW: We're going to say:

1047
01:30:00,110 --> 01:30:01,410
Oh, we can bind our name to...

1048
01:30:04,000 --> 01:30:06,470
OC: So we put that
double into the environment.

1049
01:30:06,470 --> 01:30:07,170
JW: Right.

1050
01:30:08,230 --> 01:30:09,170
We have to say:
"insert at arg"

1051
01:30:27,880 --> 01:30:28,940
It can't just be that.

1052
01:30:29,760 --> 01:30:31,880
OC: We need to wrap
it up as an expression.

1053
01:30:40,940 --> 01:30:44,000
And then this has to be getEnv
and then rewrapped.
Because type-wrapping is just as much
fun as you expect it to be.

1054
01:30:51,176 --> 01:30:53,411
Eval state T
returns an identity double.

1055
01:30:55,290 --> 01:30:56,705
Then arg is the wrong thing.

1056
01:30:59,880 --> 01:31:01,410
It is not the body expression.

1057
01:31:02,940 --> 01:31:04,580
Now we want to sequence through.

1058
01:31:08,000 --> 01:31:09,520
We want to fold down the body.

1059
01:31:11,520 --> 01:31:13,290
OC: You would probably be alright

1060
01:31:16,235 --> 01:31:18,823
taking the last value
of the expression for now.

1061
01:31:19,520 --> 01:31:21,170
JW: I need to evaluate every one

1062
01:31:22,470 --> 01:31:25,170
so that any internal
let bindings get established.

1063
01:31:25,170 --> 01:31:25,880
OC: Right, OK.

1064
01:31:31,880 --> 01:31:33,290
We're going to bind this in.

1065
01:31:35,170 --> 01:31:36,940
I'm going to do a flip binding here.

1066
01:31:40,470 --> 01:31:41,880
And then fold M inside here.

1067
01:31:45,640 --> 01:31:48,230
It's going to go from
environment to environment.

1068
01:31:49,520 --> 01:31:50,940
For every body expression.

1069
01:31:52,940 --> 01:31:54,820
Folding down from the environment

1070
01:31:54,820 --> 01:31:55,640
over the body.

1071
01:32:00,700 --> 01:32:02,000
So Env, expected type Double.

1072
01:32:13,640 --> 01:32:15,880
And fold M has the
accumulator on the left.

1073
01:32:23,640 --> 01:32:25,170
I don't need to fold M that way.

1074
01:32:32,350 --> 01:32:33,170
We're going to pass in a double

1075
01:32:34,470 --> 01:32:35,410
As it thinks I need.

1076
01:32:38,110 --> 01:32:40,230
And we're going to
ignore it in each step.

1077
01:32:41,640 --> 01:32:44,588
OC: So we're just taking
the last double that's produced.

1078
01:32:44,588 --> 01:32:45,882
JW: Right, and then we need

1079
01:32:45,882 --> 01:32:47,176
the right identity here.

1080
01:32:49,760 --> 01:32:51,050
OC: Cool, everything typechecks?

1081
01:32:54,580 --> 01:32:57,290
JW: No! Now the functions
are differently expressed.

1082
01:32:59,290 --> 01:33:01,520
Function application
now has to hand in

1083
01:33:01,520 --> 01:33:02,940
the current environment.

1084
01:33:04,000 --> 01:33:04,940
Which makes sense.

1085
01:33:08,940 --> 01:33:13,050
Couldn't match expected type
first argument.

1086
01:33:14,580 --> 01:33:16,580
This is now just going to be the value
we wanted, so we can just return it.

1087
01:33:22,820 --> 01:33:23,640
It type checked!
OC: [Laughs]
JC: I continue to be
perhaps incorrectly amazed.

1088
01:33:36,350 --> 01:33:38,230
I don't like excessively long lines.

1089
01:33:43,520 --> 01:33:45,290
OK, let's try this out with test file.

1090
01:33:46,820 --> 01:33:48,110
Unknown variable, fine.

1091
01:33:50,580 --> 01:33:52,230
We haven't tied it in yet so we need:
letBinding followed by funBinding.

1092
01:33:56,000 --> 01:33:57,290
What else did we define?

1093
01:33:57,290 --> 01:33:58,700
We need to do application.

1094
01:34:01,290 --> 01:34:02,820
A naked variable reference

1095
01:34:03,170 --> 01:34:04,940
could be a variable reference or

1096
01:34:04,940 --> 01:34:06,350
it could be a function call.

1097
01:34:09,640 --> 01:34:11,170
OC: I think all function calls

1098
01:34:11,170 --> 01:34:13,410
are a variable name immediately
followed by parentheses

1099
01:34:14,470 --> 01:34:16,230
with no white space between them.

1100
01:34:16,230 --> 01:34:16,820
JW:  Right.

1101
01:34:17,760 --> 01:34:19,760
So we're going to try to parse a funCall.

1102
01:34:27,880 --> 01:34:30,000
Because if there is
no paren after that,

1103
01:34:32,000 --> 01:34:33,520
we'll back track all the way up.

1104
01:34:42,110 --> 01:34:44,350
We want the name of
the function to come in.

1105
01:34:48,820 --> 01:34:51,290
And then we're going to look for this guy
except instead of parsing a varname,

1106
01:34:51,290 --> 01:34:53,290
we're going to parse a sub-expression.

1107
01:34:53,290 --> 01:34:54,470
Then we're going to say: return that
as an application of name to arg.

1108
01:35:07,640 --> 01:35:11,760
"Type error says Ollie!"
OC: [Laughs] Well I didn't say it but...

1109
01:35:11,760 --> 01:35:13,410
So we tried to evaluate a lambda

1110
01:35:13,880 --> 01:35:16,110
because we put a
lambda in our syntax tree

1111
01:35:18,940 --> 01:35:19,880
Why did we do that?

1112
01:35:24,110 --> 01:35:26,470
Oh that's right, what
does define evaluate to.

1113
01:35:27,760 --> 01:35:30,000
It evaluates to the
body of the function.

1114
01:35:30,820 --> 01:35:31,760
Which is a lambda.

1115
01:35:32,470 --> 01:35:34,000
In that case we're going to say

1116
01:35:34,820 --> 01:35:36,580
that functions evaluate to zero.

1117
01:35:44,940 --> 01:35:46,470
That just did not work at all.

1118
01:35:51,290 --> 01:35:52,940
OC: We have a zero from our define.

1119
01:35:53,520 --> 01:35:55,050
I guess the error is on the let.

1120
01:35:55,640 --> 01:35:57,520
JW: Yes, let me put some
boundary on there.

1121
01:35:59,170 --> 01:36:00,700
OC: so you're now tracing
in our language!

1122
01:36:01,520 --> 01:36:03,294
JW: Yes! I see the two, three and zero.

1123
01:36:04,940 --> 01:36:05,640
We defined it.

1124
01:36:07,170 --> 01:36:09,640
So it's the call that
we're having a problem with.

1125
01:36:11,640 --> 01:36:12,820
expecting define...

1126
01:36:12,820 --> 01:36:15,050
OC: Ah, so I think the problem here
is our function name

1127
01:36:16,110 --> 01:36:16,940
starts with a D.

1128
01:36:17,880 --> 01:36:19,640
And when it sees D it assumes
that it must be going to...
JW: Oh right!

1129
01:36:24,700 --> 01:36:26,700
OC: We'll probably have to try unbinding.

1130
01:36:32,110 --> 01:36:33,640
JW: Unknown function double.

1131
01:36:34,940 --> 01:36:37,170
OC: But we did just
define a function double.

1132
01:36:37,170 --> 01:36:38,000
JW: Yes, right.

1133
01:36:41,520 --> 01:36:43,290
We need to go to define and find out

1134
01:36:46,230 --> 01:36:48,110
why it did not get
inserted into the environment

1135
01:36:52,820 --> 01:36:53,760
Ah, that's what it is.

1136
01:36:54,820 --> 01:36:56,000
OC: Define gave us Elam...

1137
01:36:56,820 --> 01:36:58,580
JW: And the blue line is telling us

1138
01:36:58,580 --> 01:37:00,230
"your not doing anything with name".

1139
01:37:03,764 --> 01:37:04,700
Elam needs to have:

1140
01:37:07,640 --> 01:37:09,294
Just as let did, Elam needs a name.

1141
01:37:14,470 --> 01:37:16,941
Now when we go, we won't just
have Ollie's type error

1142
01:37:24,470 --> 01:37:27,050
Now we need something
new to go into our map, right?

1143
01:37:27,880 --> 01:37:29,410
We can just put ELam in there.

1144
01:37:30,580 --> 01:37:31,640
So we're going to say:

1145
01:37:33,640 --> 01:37:35,290
OC: It's exactly the same as ELet

1146
01:37:35,880 --> 01:37:37,760
but without the evaluation I guess.
JC: Right. It's just going to return 0.
OC: Bit of a hack, but oh well!

1147
01:38:01,170 --> 01:38:02,820
Elam should have two arguments.

1148
01:38:03,170 --> 01:38:05,760
Oh! The Show-er

1149
01:38:06,700 --> 01:38:07,640
We're going to say:
I like the way Lisp does it.

1150
01:38:24,350 --> 01:38:26,000
Yehey! Unknown function double.

1151
01:38:26,820 --> 01:38:29,410
This is where we put in
a little bit of our tracing.

1152
01:38:50,940 --> 01:38:52,820
It never showed it, so we get to there...

1153
01:38:55,290 --> 01:38:56,230
We must have done...

1154
01:38:58,230 --> 01:38:59,520
Oh, nobody used the value,

1155
01:39:00,000 --> 01:39:01,520
that's why the trace didn't get...

1156
01:39:02,700 --> 01:39:04,470
Since no one is forcing the value

1157
01:39:04,580 --> 01:39:07,050
that means the insert
is not happening either.

1158
01:39:10,470 --> 01:39:11,880
If it's just returning zero

1159
01:39:12,820 --> 01:39:15,410
it can elide out the rest.

1160
01:39:16,350 --> 01:39:18,000
OC: But we're in a monad, so it
should be forcing us to be [inaudible].

1161
01:39:18,000 --> 01:39:19,050
JW:  Your right.

1162
01:39:22,110 --> 01:39:25,050
OC: Maybe in our function
that reads from the file

1163
01:39:26,820 --> 01:39:28,940
we could print the environment
after every step.

1164
01:39:28,940 --> 01:39:30,235
JW: Oh! Is that our problem?

1165
01:39:32,705 --> 01:39:35,058
OC: Yes, the file doesn't
do what the REPL does.

1166
01:39:36,470 --> 01:39:37,290
JW: Ah, thank you.

1167
01:39:40,470 --> 01:39:42,110
In the file parser we need to do

1168
01:39:42,580 --> 01:39:44,820
the exact same thing
we we're doing before

1169
01:39:46,110 --> 01:39:46,700
Which is: to call...
Let's just copy and paste.

1170
01:40:06,588 --> 01:40:07,529
That did not work.

1171
01:40:19,290 --> 01:40:20,700
For every line in the input,

1172
01:40:20,700 --> 01:40:21,640
we parse the line,

1173
01:40:24,110 --> 01:40:25,760
and execute it within our state.

1174
01:40:26,820 --> 01:40:28,000
and print the result.

1175
01:40:33,880 --> 01:40:36,470
OC: Can we just flip back
to the error we had again.

1176
01:40:36,470 --> 01:40:38,470
JW: Now we have a much different error.

1177
01:40:40,470 --> 01:40:41,410
we have regressed.

1178
01:40:44,110 --> 01:40:45,529
Let me see what version of

1179
01:40:45,520 --> 01:40:47,294
the code we were using previously.

1180
01:41:17,760 --> 01:41:20,350
Oh, the massager!
We're not using the massager.

1181
01:41:21,640 --> 01:41:24,230
So I'm going to go
ahead and use the view patterns.

1182
01:41:26,820 --> 01:41:29,410
OC: So view patterns
here let us call a function

1183
01:41:29,410 --> 01:41:30,820
before binding a variable.

1184
01:41:31,170 --> 01:41:31,640
JW: Yes.

1185
01:41:31,640 --> 01:41:35,170
I could just do this. That's actually
a silly use of view patterns.

1186
01:41:40,000 --> 01:41:41,760
Except that it's going to be a Maybe.

1187
01:41:45,290 --> 01:41:47,410
So we have to lift one level out and say:
if it's Nothing, do nothing
otherwise we have some String.

1188
01:41:56,470 --> 01:41:58,000
OC: We could use forM_ again there.

1189
01:41:59,050 --> 01:42:00,470
You can use forM_ over a maybe.

1190
01:42:01,290 --> 01:42:03,170
I think we have to use data.foldable

1191
01:42:09,640 --> 01:42:12,000
which in real world projects
that's exactly what I do.

1192
01:42:15,410 --> 01:42:18,230
Look at that! We evaled it.
OC: Wonderful.

1193
01:42:20,110 --> 01:42:21,529
JC: So we have Phi equaling
1 plus double...

1194
01:42:24,470 --> 01:42:25,640
We even have an error.

1195
01:42:26,820 --> 01:42:28,350
We are missing a parenthesis

1196
01:42:28,350 --> 01:42:30,110
and yet we didn't get a syntax there.
OC: [Laughs]

1197
01:42:31,410 --> 01:42:33,760
JC: Let me see what
happens if I do that directly.

1198
01:42:38,820 --> 01:42:40,230
Might as well do it this way.

1199
01:42:41,640 --> 01:42:42,580
Ah! the parse stops.

1200
01:42:46,820 --> 01:42:48,470
Because it has reached a token

1201
01:42:48,470 --> 01:42:50,000
it doesn't recognise, it ends.

1202
01:42:50,700 --> 01:42:53,520
Other parsers like Trifecta,

1203
01:42:54,230 --> 01:42:55,520
I could coax it to tell me

1204
01:42:55,520 --> 01:42:57,410
what the remainder of the input was.

1205
01:42:57,410 --> 01:42:59,290
I don't know how that's done in parsec

1206
01:42:59,760 --> 01:43:02,350
and I don't think we
should worry about it just now.

1207
01:43:11,760 --> 01:43:13,170
We can restrict our parser

1208
01:43:13,170 --> 01:43:14,940
on the line by line parser and say

1209
01:43:14,940 --> 01:43:16,470
we want it to terminate at EOF.

1210
01:43:21,050 --> 01:43:23,410
OC: So that requires that we
successfully parse a line?

1211
01:43:25,410 --> 01:43:27,050
JW:  Right, so now I get unexpected.

1212
01:43:27,640 --> 01:43:29,640
Of course the line numbers are all off,

1213
01:43:29,640 --> 01:43:31,290
because we do this line by line.

1214
01:43:34,820 --> 01:43:35,640
There we go!

1215
01:43:40,000 --> 01:43:41,290
5 times 5 is 25 OK,

1216
01:43:42,000 --> 01:43:43,640
So 26 divided by 2 should be 13.
Alright!

1217
01:43:46,350 --> 01:43:48,940
I would say that's a
good place for us to check in.
Function definitions and calling now work.

1218
01:44:00,230 --> 01:44:00,940
OC: Awesome!

1219
01:44:07,410 --> 01:44:10,000
OC: Now we're getting
near the end of the session,

1220
01:44:10,000 --> 01:44:11,290
I wonder if we might try

1221
01:44:11,290 --> 01:44:13,410
to implement that Fibonacci function.

1222
01:44:13,760 --> 01:44:15,520
It's in one of these example files.

1223
01:44:17,050 --> 01:44:19,050
We should only need to redefine phi,

1224
01:44:21,640 --> 01:44:23,760
but we do need
a square root operation.

1225
01:44:23,760 --> 01:44:25,410
Maybe we could introduce that

1226
01:44:25,410 --> 01:44:27,050
as a primitive in the language.

1227
01:44:27,520 --> 01:44:29,640
That should allow
us to get all the way

1228
01:44:29,640 --> 01:44:31,050
to the bottom of this file.

1229
01:44:32,000 --> 01:44:33,880
JW: We should be able to do that easily.

1230
01:44:34,352 --> 01:44:36,340
Because we chose the higher order

1231
01:44:36,350 --> 01:44:37,764
abstract syntax notation.

1232
01:44:38,350 --> 01:44:40,350
That makes it easier for us to inject

1233
01:44:44,940 --> 01:44:47,290
what we would call built-ins
into our language.

1234
01:44:47,880 --> 01:44:49,050
All we need then is a parser

1235
01:44:51,520 --> 01:44:52,470
and we're going to have an option...

1236
01:44:53,050 --> 01:44:54,230
Let's extend funCall.

1237
01:44:55,290 --> 01:44:56,235
FunCall will say:
if name is 'sqrt'...

1238
01:45:08,230 --> 01:45:10,350
I don't want to
do it at call point, sorry.

1239
01:45:13,050 --> 01:45:15,520
I want to do it when
we define the environment.

1240
01:45:16,700 --> 01:45:17,760
So new environment.

1241
01:45:19,290 --> 01:45:20,940
Instead of having an empty map

1242
01:45:20,940 --> 01:45:22,230
we want a map where we can

1243
01:45:23,410 --> 01:45:24,700
insert into square root.

1244
01:45:40,700 --> 01:45:42,940
And we need to do this on an empty map.

1245
01:45:43,760 --> 01:45:45,290
We can call this a singleton.

1246
01:45:45,290 --> 01:45:55,882
See I have hlint down here suggesting
that I could say const sqrt because

1247
01:45:56,470 --> 01:45:58,000
I'm ignoring that parameter.

1248
01:45:58,000 --> 01:46:00,000
I still have an error, saying
I'm not using that language pragma.

1249
01:46:04,470 --> 01:46:05,170
Now we can say:

1250
01:46:10,350 --> 01:46:11,410
OC: Excellent.

1251
01:46:11,647 --> 01:46:13,058
JW: If we go over to our file,

1252
01:46:13,764 --> 01:46:15,176
and we see now that we have,

1253
01:46:16,470 --> 01:46:19,176
(I was doing a lot of
work in this little scratch file)

1254
01:46:19,176 --> 01:46:20,235
Phi should be fine.

1255
01:46:20,700 --> 01:46:22,350
Oh! we have a power operator here,

1256
01:46:24,350 --> 01:46:26,110
raising something to an exponent.

1257
01:46:26,110 --> 01:46:27,640
We need to quickly add that in.

1258
01:46:29,050 --> 01:46:30,820
It's rather like a multiplication.

1259
01:46:30,820 --> 01:46:33,050
OC: You can have
the same precedence there.

1260
01:46:33,050 --> 01:46:34,117
JW: We're going to say:

1261
01:46:39,050 --> 01:46:40,940
We'll use that as the same precedence.

1262
01:46:48,230 --> 01:46:50,820
We have now reached
a certain level of maturity

1263
01:46:50,820 --> 01:46:53,050
where we can drop
tracing from our parser

1264
01:47:07,640 --> 01:47:10,350
wherever EMul was

1265
01:47:21,520 --> 01:47:23,290
Is that appropriate for doubles?

1266
01:47:23,760 --> 01:47:24,700
I'll just check.

1267
01:47:33,760 --> 01:47:35,640
I will take a look at this file again.

1268
01:47:40,940 --> 01:47:42,700
Do you really want the return keyword?

1269
01:47:42,700 --> 01:47:44,820
Since the last
expression of the function

1270
01:47:44,820 --> 01:47:46,820
is defined to be the value of the call.

1271
01:47:46,820 --> 01:47:48,700
OC: Yes, I think we're OK dropping that.

1272
01:47:50,470 --> 01:47:52,700
JW: We've  got parens,
and we've got division.

1273
01:47:52,700 --> 01:47:53,410
we've got phi and psi...

1274
01:47:54,580 --> 01:47:57,520
A global phi and a local psi.

1275
01:47:57,520 --> 01:47:58,470
Let's give it a try...

1276
01:47:58,470 --> 01:48:00,000
Do you think it's going to work?

1277
01:48:02,820 --> 01:48:03,880
OC: I'm going to say no,

1278
01:48:03,880 --> 01:48:05,880
I don't think it will work (laughter).

1279
01:48:06,580 --> 01:48:07,880
JW:  So unknown variable N...

1280
01:48:09,880 --> 01:48:12,470
We're now making
reference to a local variable.

1281
01:48:13,050 --> 01:48:15,880
That's a good thing, to
check why isn't that happening.

1282
01:48:17,290 --> 01:48:18,110
When we defined...

1283
01:48:19,520 --> 01:48:22,000
OC: When we went into the lambda we
don't seem to be extending the environment.

1284
01:48:22,000 --> 01:48:23,760
we are extending the environment.

1285
01:48:24,230 --> 01:48:25,640
So we got the arg, as the name,

1286
01:48:26,700 --> 01:48:28,230
we extended the environment.

1287
01:48:30,230 --> 01:48:32,820
We evaluate within
that extended environment...

1288
01:48:34,820 --> 01:48:36,470
OC: Are we able to see which line

1289
01:48:36,470 --> 01:48:38,000
it's having this trouble with?

1290
01:48:41,880 --> 01:48:43,640
we've got quite a few unexpecteds.

1291
01:48:50,352 --> 01:48:51,882
JW:  It's the definition of fib

1292
01:48:53,410 --> 01:48:55,294
that seems to be having the problem.

1293
01:48:55,410 --> 01:48:56,588
Column 3 or column 8.

1294
01:48:59,290 --> 01:49:00,941
It wasn't expecting the word fib.

1295
01:49:12,580 --> 01:49:13,520
See that works.

1296
01:49:17,290 --> 01:49:18,820
Let's reduce the problem here,

1297
01:49:19,880 --> 01:49:22,580
get rid of these ones that are before it.

1298
01:49:27,050 --> 01:49:31,520
OC: The let binding is definitely working
because we're seeing that

1299
01:49:38,580 --> 01:49:41,410
OC: This isn't a problem
with the comment dropping those?...

1300
01:49:53,880 --> 01:49:55,760
Let's see if whitespace is consuming.

1301
01:49:57,760 --> 01:50:00,230
Oh! Whitespace only
takes space into account.

1302
01:50:01,050 --> 01:50:02,470
We want it to be space or tab,

1303
01:50:06,000 --> 01:50:07,764
or return or newline..

1304
01:50:12,000 --> 01:50:14,820
OC: Is it the leading
whitespace causing the problem?

1305
01:50:16,230 --> 01:50:18,350
or are we stripping the leading whitespace
out as well.

1306
01:50:18,350 --> 01:50:20,580
JW: We should be
stripping any whitespace

1307
01:50:20,580 --> 01:50:22,110
that occurs before the brace

1308
01:50:22,110 --> 01:50:23,050
and after the brace.

1309
01:50:33,290 --> 01:50:34,940
Let's see if it would help to have

1310
01:50:36,110 --> 01:50:38,000
a semi colon in our function bodies.

1311
01:50:44,470 --> 01:50:45,640
And that does not help.

1312
01:50:45,640 --> 01:50:47,290
I think the problem is outside.

1313
01:50:49,880 --> 01:50:51,760
We need to bring some tracing back in:

1314
01:51:13,050 --> 01:51:15,050
We're getting as far as parsing
funBinding seven

1315
01:51:15,050 --> 01:51:22,117
so it's not liking the closing brace.

1316
01:51:27,050 --> 01:51:29,880
OC: That expected F
assumes that the define is a variable
name

1317
01:51:31,290 --> 01:51:33,529
and it's trying to
do addition on that variable.

1318
01:51:41,170 --> 01:51:42,470
Maybe if we just try to do

1319
01:51:42,470 --> 01:51:44,235
one expression in the definition

1320
01:51:45,170 --> 01:51:47,290
see if that gives
us any more progress.

1321
01:51:58,000 --> 01:51:59,640
JW: We're getting as far as seven.

1322
01:52:25,170 --> 01:52:26,230
OC: Or maybe trace it?

1323
01:53:05,050 --> 01:53:07,170
JW: Let's try parsing the single expression.

1324
01:53:39,410 --> 01:53:42,110
JW: It's trying to parse
the funBinding and failing.

1325
01:53:44,110 --> 01:53:46,117
So it's trying to parse it as a funCall.

1326
01:53:48,820 --> 01:53:51,170
OC: But that's failing
because it doesn't see

1327
01:53:51,170 --> 01:53:53,290
an open parenthesis right after define.

1328
01:53:54,470 --> 01:53:57,170
JW: Exactly and then
it tries to do it as a variable

1329
01:53:58,110 --> 01:53:59,760
I'm surprised it's not telling us...

1330
01:54:01,760 --> 01:54:02,700
"unknown variable".

1331
01:54:05,050 --> 01:54:07,520
OC: It's still trying
to evaluate at that point.

1332
01:54:10,700 --> 01:54:12,230
we're failing in the parsing.

1333
01:54:21,640 --> 01:54:24,110
JW: It should read it
as a variable shouldn't it?

1334
01:54:25,760 --> 01:54:28,000
OC: It is giving a
variable called define.

1335
01:54:28,350 --> 01:54:29,640
And the next thing to do

1336
01:54:30,230 --> 01:54:32,580
is to look for a math operator.

1337
01:54:36,940 --> 01:54:38,820
JW: That's right. That's what it's saying

1338
01:54:38,823 --> 01:54:40,000
it's expecting to see

1339
01:54:40,000 --> 01:54:41,882
unexpected F wanted a math operator.

1340
01:54:44,580 --> 01:54:46,940
Because the define
expression is failing,

1341
01:54:51,410 --> 01:54:53,520
because of a failure to parse "d".

1342
01:54:59,520 --> 01:55:00,470
Ah, you know what...

1343
01:55:02,230 --> 01:55:04,000
We don't do multi line parsing yet.

1344
01:55:04,940 --> 01:55:07,410
We're handing these
to the parser line by line.

1345
01:55:09,410 --> 01:55:11,760
OC: We should be able
to put it all in one line

1346
01:55:11,760 --> 01:55:13,410
and then our test will be simple.

1347
01:55:13,410 --> 01:55:14,470
JW:  You would think.

1348
01:55:14,470 --> 01:55:15,640
OC: Let's try that first.

1349
01:55:19,050 --> 01:55:21,410
JW: So we're going to
have to break into lines,

1350
01:55:21,410 --> 01:55:22,700
strip out the comments,

1351
01:55:23,640 --> 01:55:25,520
and then put the lines back together.

1352
01:55:25,520 --> 01:55:27,880
OC:  If we just modify
our test bc file for now

1353
01:55:27,880 --> 01:55:30,230
we should be able to
join four lines into one.

1354
01:55:30,700 --> 01:55:31,640
JW: You mean in here?

1355
01:55:31,640 --> 01:55:32,110
OC: Yes.

1356
01:55:35,880 --> 01:55:37,411
Because we have a semi colon

1357
01:55:37,410 --> 01:55:38,941
between them we might be OK.

1358
01:55:39,050 --> 01:55:40,940
JW: I don't know if I kept the semi colon.

1359
01:55:43,290 --> 01:55:44,110
Oh I did keep it.

1360
01:55:48,700 --> 01:55:49,290
Very good!

1361
01:55:50,580 --> 01:55:51,880
So it's 1,2 and 55, correct.

1362
01:55:53,170 --> 01:55:54,580
OC: Yes, almost 55 anyway.

1363
01:56:01,050 --> 01:56:03,410
JW: We don't have
multi line working just yet

1364
01:56:03,410 --> 01:56:05,290
but we do have a way to do separators.

1365
01:56:05,880 --> 01:56:07,760
And since you're probably going to be

1366
01:56:07,760 --> 01:56:09,760
typing these at a REPL anyway

1367
01:56:09,760 --> 01:56:12,940
This probably makes more
sense for things to fit on one line.

1368
01:56:14,940 --> 01:56:16,580
Here's our file, we can show that...

1369
01:56:17,640 --> 01:56:20,352
(I can get rid of that
little devil at the beginning)

1370
01:56:22,110 --> 01:56:24,352
we do get a close
approximation (laughter).

1371
01:56:27,290 --> 01:56:28,823
It's just one of those things.

1372
01:56:30,470 --> 01:56:32,820
To wrap this up we
need a way to execute this

1373
01:56:32,820 --> 01:56:34,000
from the command line.

1374
01:56:34,820 --> 01:56:36,470
If I go into my parser and look at

1375
01:56:36,470 --> 01:56:38,700
this REPL function
we have been calling.

1376
01:56:38,700 --> 01:56:39,880
Really that IS our main.

1377
01:56:40,820 --> 01:56:41,290
If I now:

1378
01:57:09,050 --> 01:57:11,640
OC: This is also reading
from standard input then?

1379
01:57:11,640 --> 01:57:14,823
JW: Yes, in theory, we can pipe
that file we have been working on into it.

1380
01:57:16,580 --> 01:57:18,470
Maybe let's see what we get with that?

1381
01:57:24,000 --> 01:57:24,941
JW: Not quite!

1382
01:57:25,880 --> 01:57:28,940
OC: I guess our REPL
doesn't deal with comments like that

1383
01:57:28,940 --> 01:57:31,411
Let's try this outside
of Emacs, you never know.

1384
01:57:36,700 --> 01:57:37,050
JW:  No.

1385
01:57:37,760 --> 01:57:40,470
OC: I think our REPL isn't
dealing with the comments

1386
01:57:40,470 --> 01:57:42,470
within the file, and that kind of stuff.

1387
01:57:46,820 --> 01:57:49,170
OC: That's cool, I guess
we should wrap up then.

1388
01:57:50,580 --> 01:57:52,110
OC: What are the kind of things

1389
01:57:52,110 --> 01:57:54,230
that stand out to you: the itches
you want to scratch?

1390
01:57:55,410 --> 01:57:58,230
JW: If I wanted to build
this into a nice toy calculator

1391
01:57:59,290 --> 01:58:02,000
I would first want to
get rid of all the repetition

1392
01:58:02,580 --> 01:58:04,470
in dealing with calling of parsec.

1393
01:58:05,050 --> 01:58:07,640
I would factor that out
with some other function

1394
01:58:07,640 --> 01:58:09,520
and all these would call as helpers.

1395
01:58:11,050 --> 01:58:13,170
There are some inefficiencies in here.

1396
01:58:13,170 --> 01:58:14,700
The fact that in our map type,

1397
01:58:15,880 --> 01:58:17,880
we have a map from text to expression.

1398
01:58:17,880 --> 01:58:19,294
So as I mentioned earlier,

1399
01:58:19,410 --> 01:58:21,640
we would always
be re-evaluating variables.

1400
01:58:24,820 --> 01:58:26,820
I would rather have them as constants

1401
01:58:26,820 --> 01:58:28,820
that immediately reduce to doubles.

1402
01:58:34,940 --> 01:58:37,880
At the point where we're evaluating our
when we see an EVar.

1403
01:58:42,350 --> 01:58:45,290
When we see a let, instead
of putting the body of the let

1404
01:58:45,290 --> 01:58:47,050
into the map, we could evaluate it

1405
01:58:47,050 --> 01:58:48,470
stick it in an ENum.

1406
01:58:48,940 --> 01:58:50,350
and then put that in the map

1407
01:58:50,350 --> 01:58:52,110
and that would achieve what I want.

1408
01:58:52,110 --> 01:58:54,820
OC: You would basically be doing a kind of
memoization then?

1409
01:58:54,820 --> 01:58:57,290
JW:  Yes, something like
that, it hurts not to do it.

1410
01:58:59,290 --> 01:59:00,580
So we will just say this:

1411
01:59:10,110 --> 01:59:12,470
ENum wants a double
and it got an expression

1412
01:59:13,050 --> 01:59:14,350
because it wants B prime.

1413
01:59:15,170 --> 01:59:17,410
That would be one
of the things I would do

1414
01:59:17,410 --> 01:59:18,470
Too easy not to do it.

1415
01:59:20,470 --> 01:59:23,050
I would switch to using
a real tokeniser for parsec

1416
01:59:24,000 --> 01:59:26,820
because it would clear
up some problems we ran into

1417
01:59:26,820 --> 01:59:28,820
and make the code briefer

1418
01:59:28,820 --> 01:59:29,760
and easier to see.

1419
01:59:30,580 --> 01:59:33,880
You also have the ability to
define languages in parsec

1420
01:59:33,880 --> 01:59:35,760
so you can say what's the precedence

1421
01:59:35,760 --> 01:59:37,410
my various operators should be

1422
01:59:37,880 --> 01:59:40,230
and it will figure
out how to parse them all

1423
01:59:40,230 --> 01:59:41,410
in the correct order.

1424
01:59:43,410 --> 01:59:46,580
I might move to a
functor fixed point representation

1425
01:59:48,580 --> 01:59:50,110
of my Expr data type here

1426
01:59:50,580 --> 01:59:52,820
so that my
evaluators get easier to write.

1427
01:59:53,880 --> 01:59:55,520
Make a pretty printer.

1428
01:59:56,940 --> 02:00:00,470
The tool that we're modeling this
after is bc.

1429
02:00:01,760 --> 02:00:03,880
In bc it will echo back
out to you the expression

1430
02:00:03,880 --> 02:00:06,000
in pretty-printed form,
so I'd like to do that as well.

1431
02:00:08,820 --> 02:00:11,294
And I would like
tests that every expression

1432
02:00:12,470 --> 02:00:14,000
when printed, can read back in,

1433
02:00:14,588 --> 02:00:16,823
and then reprint
as the same expression.

1434
02:00:17,760 --> 02:00:20,110
That's pretty much
where I would go with this.

1435
02:00:20,350 --> 02:00:21,880
But I don't know if I'm trying
to compete

1436
02:00:21,880 --> 02:00:23,520
with mathematica, so

1437
02:00:23,880 --> 02:00:25,880
I would be happy with something

1438
02:00:25,880 --> 02:00:28,230
that just works nicely
on the command line.

1439
02:00:29,640 --> 02:00:32,230
OC: That's fantastic. Thanks a lot.

