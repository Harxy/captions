1
00:00:01,400 --> 00:00:02,777
Welcome to Peer to Peer.

2
00:00:03,337 --> 00:00:08,171
Where you can hone your
skills by watching live coding videos.

3
00:00:08,200 --> 00:00:10,720
Our guest today is John Wiegley,

4
00:00:10,720 --> 00:00:16,742
who's a researcher at BAE,
and author of many useful Haskell libraries.

5
00:00:16,900 --> 00:00:19,268
Our host is Ollie Charles.

6
00:00:19,320 --> 00:00:26,194
And the challenge that he set for John
is called Building a Basic Calculator Language.

7
00:00:26,300 --> 00:00:28,948
OC: OK John, would you like
to start by reading the problem out?

8
00:00:28,948 --> 00:00:33,965
JW: Sure, we have implement a system
that parses BC expressions and evaluates them.

9
00:00:33,960 --> 00:00:39,074
Basic Calculator (which we're calling BC)
is a calculator language, used for scripting

10
00:00:39,074 --> 00:00:41,737
and as an interactive mathematical shell.

11
00:00:41,737 --> 00:00:48,857
Here is an example expression:
we've got 1 + 9 x 20 divided by 5, should equal 40.

12
00:00:48,850 --> 00:00:52,342
The program should parse a
file, evaluate all expressions,

13
00:00:52,340 --> 00:00:55,348
and print the results to standard output.

14
00:00:55,400 --> 00:01:00,571
OC: And you should have a couple of example files
which we're going to aim to parse in this session.

15
00:01:00,605 --> 00:01:02,342
Yes, those are the ones.

16
00:01:02,800 --> 00:01:07,668
Would you like to open those up
and see if it all looks clear enough.

17
00:01:07,680 --> 00:01:10,100
See if you have any questions on the syntax.

18
00:01:13,485 --> 00:01:17,565
JW: It looks pretty straightforward to me.

19
00:01:17,560 --> 00:01:18,194
OC: OK.

20
00:01:18,190 --> 00:01:22,685
(John contemplates the problem)

21
00:01:22,680 --> 00:01:25,897
Chapter 2: Handling Primitive Operations.

22
00:01:25,900 --> 00:01:30,788
JW: Alright, the first thing I'm going
to do is keep these files in this directory

23
00:01:30,780 --> 00:01:34,217
and I'm going to turn this
into a git repository in here.

24
00:01:35,400 --> 00:01:38,754
We'll make a file and call it Parser.hs.

25
00:01:43,800 --> 00:01:49,005
And look to see if the first expression
we want to parse is an addition operation.

26
00:01:49,900 --> 00:01:56,685
I want to model this after I parse it into a
data type that I will run the evaluator against.

27
00:01:56,900 --> 00:02:01,302
So my expressions are going
to have to include an add operation.

28
00:02:01,400 --> 00:02:09,600
And that will need two numbers.
Which I think will be sub expressions in the future.

29
00:02:09,702 --> 00:02:13,965
So I will say: the addition
operation takes two expressions.

30
00:02:14,000 --> 00:02:18,468
Which means I will need a number...

31
00:02:18,468 --> 00:02:20,460
(Silence)

32
00:02:20,750 --> 00:02:30,754
To parse that I'm going to use Parsec.
Which is a library designed for parsing in Haskell.

33
00:02:31,900 --> 00:02:36,468
When I want to parse something,
I have a Parser that will return an integer.

34
00:02:36,700 --> 00:02:38,674
We'll call this num.

35
00:02:39,680 --> 00:02:42,100
And the number a Parser will take...

36
00:02:43,931 --> 00:02:45,440
Let's see...

37
00:02:45,500 --> 00:02:49,474
Many instances of some number.

38
00:02:50,100 --> 00:02:52,708
I'll do it the dumb way first.

39
00:02:52,800 --> 00:02:56,857
I often forget what the whole Parsec interface is.

40
00:02:56,900 --> 00:03:02,902
It's telling me oneOf is not in
scope, so I'm going to hit [inaudible].

41
00:03:05,700 --> 00:03:09,485
You can see I have the syntax
checking happening behind the scenes.

42
00:03:09,500 --> 00:03:15,805
If I press Control C Control H it will do a Hoogle
query, on whatever keyword is under my cursor.

43
00:03:16,100 --> 00:03:20,502
I have Hoogle running locally so that
it works whether I have internet access or not.

44
00:03:20,600 --> 00:03:23,577
I see right away that's in the Char sub module,

45
00:03:23,600 --> 00:03:27,840
so if I go up here and add Char,
then oneOf should be fine.

46
00:03:27,900 --> 00:03:31,348
Same with many, many is in...

47
00:03:31,931 --> 00:03:35,382
looks like Parsec.Prim.

48
00:03:42,960 --> 00:03:47,474
I've said I want a Parser that returns
an integer. This Parser will return characters.

49
00:03:47,500 --> 00:03:50,571
So I need a way to turn that into an integer.

50
00:03:50,800 --> 00:03:59,314
Which I can do using an applicative form of fmap

51
00:03:59,805 --> 00:04:05,200
Actually, I can use the
applicative definition, it will be fine.

52
00:04:06,125 --> 00:04:08,514
There we are... everything parses.

53
00:04:08,548 --> 00:04:12,800
Let me see if I can load this in...

54
00:04:12,982 --> 00:04:16,000
GHCi REPL

55
00:04:16,000 --> 00:04:18,300
I want to run this Parser on sample input.

56
00:04:18,300 --> 00:04:24,822
I need to go into Parsec to find out how to do that.

57
00:04:24,900 --> 00:04:31,405
There is one that will let you do a test parse.

58
00:04:31,800 --> 00:04:41,268
OC: I believe it's in the index,
that may be easier to find.

59
00:04:41,700 --> 00:04:43,100
JW: It's in the Prim module

60
00:04:43,291 --> 00:04:45,700
Yes, that's the one I was thinking of.

61
00:04:45,700 --> 00:04:49,120
It takes a Parser and an input string.

62
00:04:49,300 --> 00:04:54,034
So if I say parse test. I may
have to import the Prim module.

63
00:04:54,400 --> 00:05:01,851
If I say parseTest, then I should get my integer.

64
00:05:02,100 --> 00:05:04,720
Next, I want to parse the add operation.

65
00:05:05,000 --> 00:05:11,371
And that will yield an expression.

66
00:05:11,700 --> 00:05:18,994
Again, I'm using the applicative style to call...

67
00:05:19,400 --> 00:05:23,782
Well, I only have 'add' expressions.

68
00:05:23,900 --> 00:05:27,400
But I need something that's
going to branch based on what it finds.

69
00:05:27,622 --> 00:05:29,400
So I need something higher level.

70
00:05:30,500 --> 00:05:34,651
We need something that says, I'm going to do a choice...

71
00:05:34,650 --> 00:05:39,040
one of the num parser or the add parser

72
00:05:39,040 --> 00:05:43,234
And the add parser is going to inaudible call the expression parser.

73
00:05:43,554 --> 00:05:47,657
And GCHi does not know, so let's see what it's called.

74
00:05:50,320 --> 00:05:53,040
Choice, as in combinator.

75
00:05:53,100 --> 00:05:57,794
You always have a long
setup of imports with Parsec.

76
00:05:57,920 --> 00:06:02,228
OK, so num says "I don't want to return an integer".

77
00:06:02,500 --> 00:06:05,337
I don't want to 'read' here, I don't want to 'just read'.

78
00:06:05,400 --> 00:06:09,325
I need to wrap that up in my constructor.

79
00:06:09,337 --> 00:06:12,200
And then that means
this returns expression as well.

80
00:06:12,200 --> 00:06:13,800
OC: So what we're saying here is

81
00:06:13,805 --> 00:06:18,617
expr is a Parser that can either
parse addition or a single number.

82
00:06:18,700 --> 00:06:19,600
JW: Correct.

83
00:06:19,874 --> 00:06:28,685
I've forgotten the plus symbol here... so I need to have...

84
00:06:29,200 --> 00:06:33,097
The 'add' is going to read in an expression.

85
00:06:33,100 --> 00:06:36,708
Then it wants to read a plus,
and then another expression.

86
00:06:36,900 --> 00:06:43,108
So in front of the second expression,
I'm going to say that I'm looking for the string plus.

87
00:06:43,300 --> 00:06:45,920
And I'm going to use an
applicative operator that says

88
00:06:45,954 --> 00:06:50,571
"throw whatever you found away and keep reading".

89
00:06:50,600 --> 00:07:00,377
Now if I do 1 plus 2, (I need to make my thing show-able).

90
00:07:00,400 --> 00:07:03,588
The Parser is aborting, it's not recursing.

91
00:07:06,297 --> 00:07:12,514
OC: Is that because it's hitting white space in here?

92
00:07:12,610 --> 00:07:16,354
JW: It's hitting the white space but
if I look at my Parser for expression,

93
00:07:16,560 --> 00:07:22,125
I see that I've said the num Parser should
be first, and then choice only parses once.

94
00:07:22,400 --> 00:07:26,925
So I could say "many choice" to get a list
of expressions, but that's not quite what I want.

95
00:07:27,000 --> 00:07:31,931
I want a chance to parse add
first, but it's still not accepting it.

96
00:07:31,950 --> 00:07:36,880
Because it's trying to go into
add and it's failing to parse it.

97
00:07:36,880 --> 00:07:38,845
I think your right, its the white space.

98
00:07:38,857 --> 00:07:42,342
OC: let's try GCHi without the white space.

99
00:07:49,840 --> 00:07:54,582
JW: Oh! I'm still passing the
num Parser to parseTest (laughter).

100
00:07:54,600 --> 00:07:59,748
Here I have an infinite loop,
because I have no termination condition.

101
00:07:59,800 --> 00:08:03,200
Let's see if the add
expression is also an infinite loop.

102
00:08:04,300 --> 00:08:07,565
OC: What if we change the expr
that you have in add to num?

103
00:08:07,800 --> 00:08:11,700
So we don't have any kind of possibility.

104
00:08:12,600 --> 00:08:15,417
I imagine you're right and
we are going to need two expr.

105
00:08:15,420 --> 00:08:20,148
JW: We have the correct parsing
there, but we want our recursion.

106
00:08:20,200 --> 00:08:24,205
Let me think about why
this is infinitely recursing here.

107
00:08:24,200 --> 00:08:29,520
(John thinks).

108
00:08:29,700 --> 00:08:33,300
Ah! because the very first
thing that add does is call expression

109
00:08:33,300 --> 00:08:36,685
and the first thing that expression does
is call add which then calls expression.

110
00:08:36,720 --> 00:08:39,500
So it's never consuming anything.

111
00:08:39,500 --> 00:08:47,817
I need to have some way of knowing
in expression what the next step will be.

112
00:08:48,400 --> 00:08:51,200
OC: I think you were right by doing num first before,

113
00:08:51,200 --> 00:08:54,400
but we were simply calling
parseTest with the wrong Parser.

114
00:08:56,845 --> 00:08:59,851
So now we're seeing parse
errors that you would expect.

115
00:08:59,851 --> 00:09:01,850
Right, so now the...

116
00:09:04,100 --> 00:09:08,045
JW: If I call add without white space, I get what I want.

117
00:09:08,100 --> 00:09:11,360
Let's first add the notion of white space.

118
00:09:11,400 --> 00:09:16,422
So I want to have a Parser that says white space,

119
00:09:16,445 --> 00:09:20,080
(It's not going to return a value,
we're just going to throw it away).

120
00:09:20,100 --> 00:09:30,960
And we're going to say "many which says
zero or more", and then I'm going to throw it away.

121
00:09:31,400 --> 00:09:39,154
And then I'm going to say, after
the first expression I will accept white space.

122
00:09:39,542 --> 00:09:41,497
I need to flip this around.

123
00:09:41,700 --> 00:09:49,394
I want that after the operator.

124
00:09:49,700 --> 00:09:54,811
Now I can accept white space whether or not I have it.

125
00:09:54,900 --> 00:09:57,800
We still have the problem
that the choice is not correct.

126
00:09:58,331 --> 00:10:02,685
But if I remove them I have an infinite loop.

127
00:10:03,200 --> 00:10:09,257
We need to have a proper
top level expression Parser.

128
00:10:11,800 --> 00:10:13,840
OC: So it did recurse again, I take it?

129
00:10:13,851 --> 00:10:14,617
JW: Right.

130
00:10:14,640 --> 00:10:20,742
There is an eof Parser which
tells me when I'm at the end.

131
00:10:20,900 --> 00:10:26,708
So we're going to have a requirement be
that our string has to go to the end of the file.

132
00:10:26,720 --> 00:10:27,314
OC: OK.

133
00:10:27,325 --> 00:10:31,177
JW: And there can be white space at the end of the file.

134
00:10:31,300 --> 00:10:34,720
Now when I do parse I get that plus is not expected.

135
00:10:34,900 --> 00:10:43,988
The reason was because we parsed a
number and it thought it should be at space.

136
00:10:44,400 --> 00:10:48,914
Because we wanted to have
space or the end of the input.

137
00:10:48,914 --> 00:10:50,910
OC: Oh, yes OK.

138
00:10:50,910 --> 00:10:54,457
(John thinks).

139
00:10:54,617 --> 00:10:58,685
JW: Why is this happening?

140
00:10:58,720 --> 00:11:02,457
OC: What does parseTest with just add
do now? Now that we've got the white space in there?

141
00:11:02,468 --> 00:11:06,274
JW: It is not parsing correctly.

142
00:11:06,285 --> 00:11:10,400
It did call expr.

143
00:11:19,400 --> 00:11:23,382
OC: Usually when I'm parsing
grammars like this, I use something like chainl

144
00:11:23,500 --> 00:11:26,500
which factors out the
left recursion automatically.

145
00:11:26,500 --> 00:11:31,302
So we might be getting
problems with left recursion here.

146
00:11:31,400 --> 00:11:37,394
Maybe if we change add for
now to take just two numbers.

147
00:11:37,700 --> 00:11:42,491
And we can move on and see if
we can write an evaluator for addition.

148
00:11:42,570 --> 00:11:48,354
Keep the Parser simple for now and
we'll come back and add a bit more logic to it later.

149
00:11:48,500 --> 00:11:50,685
JW: That's working correctly.

150
00:11:50,700 --> 00:11:53,017
Let's write our first evaluator.

151
00:11:53,100 --> 00:11:58,445
Which is going to take an
expression and reduce it to a number.

152
00:11:58,440 --> 00:12:03,520
It's a requirement of our calculator that
it's going to produce numbers in the end.

153
00:12:03,800 --> 00:12:06,857
When we have a number, that's easy, we can get a number.

154
00:12:07,100 --> 00:12:09,700
And when we have an addition between two things,

155
00:12:09,700 --> 00:12:15,291
we have to recursively evaluate
those expressions and add them.

156
00:12:18,697 --> 00:12:20,022
OC: Yes.

157
00:12:20,560 --> 00:12:26,400
JW: And now in GHCi if I eval expression.

158
00:12:27,085 --> 00:12:30,628
Could not match.

159
00:12:30,720 --> 00:12:33,988
Oh! because parseTest is not in IO.

160
00:12:34,205 --> 00:12:36,651
So if I go over here to...

161
00:12:36,650 --> 00:12:42,994
(Silence)

162
00:12:43,600 --> 00:12:47,497
So parse will say "take a Parser".

163
00:12:49,874 --> 00:12:53,257
And it returns...

164
00:12:53,280 --> 00:12:57,017
And source name, let's see what that is.

165
00:13:01,200 --> 00:13:05,234
If I have an error it will just yield the error.

166
00:13:05,300 --> 00:13:16,057
And if I have a value, then I will
print the result of evaluating that.

167
00:13:16,050 --> 00:13:18,434
And I will do a show here.

168
00:13:18,430 --> 00:13:20,491
There we go, I get three.

169
00:13:20,500 --> 00:13:25,702
This is a lot of code to retype all
the time so we're going to call this test.

170
00:13:25,800 --> 00:13:29,977
OC: We are probably going to need the
exact same code when we read from the file.

171
00:13:29,970 --> 00:13:35,954
JW: So for now our test is just going
to take a String, and it's going to parse it.

172
00:13:36,000 --> 00:14:01,234
(Silence)

173
00:14:01,497 --> 00:14:02,640
Oh! it wanted Text.

174
00:14:07,300 --> 00:14:19,200
[inaudible]

175
00:14:21,600 --> 00:14:26,937
Ah! I don't have recursive parsing yet.

176
00:14:29,417 --> 00:14:31,691
Let's just do right recursion.

177
00:14:31,690 --> 00:14:37,942
(Silence).

178
00:14:38,537 --> 00:14:42,560
It's not liking that at all.

179
00:14:44,300 --> 00:14:46,537
It's not the white space.

180
00:14:46,530 --> 00:14:51,702
(Silence)

181
00:14:51,931 --> 00:14:56,342
OK so mark right recursion on add.

182
00:14:57,100 --> 00:15:00,674
We're going to need recursion
on those steps at some point.

183
00:15:00,720 --> 00:15:04,125
We really need to figure out what's going on here.

184
00:15:04,900 --> 00:15:11,360
OC: I wonder if that trailing white space
might cause us some problems on the expr Parser.

185
00:15:12,548 --> 00:15:14,800
That might be introducing the ambiguity.

186
00:15:15,600 --> 00:15:19,360
JW: It's possible.  We can certainly remove it for now.

187
00:15:19,400 --> 00:15:22,434
But I have a feeling that's not the problem.

188
00:15:22,500 --> 00:15:26,148
The problem is the left recursion here.

189
00:15:27,131 --> 00:15:31,177
Let me think.

190
00:15:31,300 --> 00:15:36,148
It needs a way of knowing if it
should descend into this add branch.

191
00:15:36,160 --> 00:15:41,691
Which means it needs to know
if there's going to be a plus there.

192
00:15:43,702 --> 00:15:46,605
Another thing I could do is go ask the Internet.

193
00:15:46,600 --> 00:15:50,480
Although I don't know if I have internet access here.

194
00:15:50,491 --> 00:15:52,100
Let me check, let's see:

195
00:15:52,822 --> 00:16:00,022
How to rate recursive math expression parcer.

196
00:16:00,020 --> 00:16:03,977
Parsing expressions by recursive
decent... the classic solution.

197
00:16:03,970 --> 00:16:19,291
So E is T and a plus and a minus
are a T. T and F. F is a P. P is a B and a T.

198
00:16:19,371 --> 00:16:23,005
The top level only recurs within parens here.

199
00:16:23,000 --> 00:16:30,628
(Silence)

200
00:16:30,651 --> 00:16:36,422
OC: Maybe look up chainl and see what that's doing?

201
00:16:36,420 --> 00:16:45,520
(Silence).

202
00:16:45,520 --> 00:16:49,542
JW: So, parse one or more
occurrences of P separated by op.

203
00:16:50,180 --> 00:16:56,708
Return the value obtained by left associate
application of all functions returned by op.

204
00:16:57,451 --> 00:17:00,102
(Inaudible).

205
00:17:00,100 --> 00:17:05,714
This can be used to eliminate left recursion
which typically occurs in expression grammars.

206
00:17:05,710 --> 00:17:08,788
That is exactly what we need to use.

207
00:17:09,337 --> 00:17:11,885
So why don't we try that.

208
00:17:12,100 --> 00:17:19,588
I also want to find out what the non-chainl
solution is, because I've never had this problem.

209
00:17:19,800 --> 00:17:25,302
OC: Surely you normally have parenthesis,
and it's they that break up the recursion.

210
00:17:25,531 --> 00:17:29,497
JW: But it's perfectly legitimate
to have one or one plus one.

211
00:17:29,542 --> 00:17:32,697
Without having parenthesis
to have that make sense.

212
00:17:32,708 --> 00:17:33,840
OC: Right.

213
00:17:33,840 --> 00:17:40,285
(Silence).

214
00:17:41,085 --> 00:17:45,851
OC: Because ultimately we're going
to be removing this thing anyway.

215
00:17:45,874 --> 00:17:46,700
JW: Right.

216
00:17:50,102 --> 00:17:53,885
Clearly we cant re-curse all the way back to the top.

217
00:17:53,880 --> 00:17:58,125
(Silence).

218
00:17:58,548 --> 00:18:01,977
This is the problem we're
running into, as you indicated.

219
00:18:01,970 --> 00:18:04,148
So left (inaudible) removal.

220
00:18:04,160 --> 00:18:08,057
OC: You have to explicitly do left factoring.

221
00:18:09,988 --> 00:18:16,902
You have that X Prime thing which starts
with addition. And that again is breaking it for you.

222
00:18:16,902 --> 00:18:19,234
JW: Ah, that's what it is.

223
00:18:19,230 --> 00:18:21,702
Bookmark: Introducing a term parser.

224
00:18:21,800 --> 00:18:26,971
JW: We left off here trying to
break the infinite recursion we have.

225
00:18:27,000 --> 00:18:29,840
We have a left recursion in  a top down Parser.

226
00:18:29,900 --> 00:18:33,851
Which is going to infinitely
re curse without parsing any input.

227
00:18:33,900 --> 00:18:40,811
We solve it by having a term Parser which
knows how to parse numbers, for example.

228
00:18:43,100 --> 00:18:45,771
OC: So what we're trying to
do is break that ambiguity.

229
00:18:45,800 --> 00:18:47,017
JW: Right.

230
00:18:47,017 --> 00:18:52,320
Our main expression Parser is
going to call the term Parser first.

231
00:18:52,902 --> 00:18:55,097
We'll do it in monadic style here.

232
00:18:55,165 --> 00:18:59,245
Now we have the term we can
look at what the next thing will be.

233
00:18:59,257 --> 00:19:04,274
And for example, if it's a plus,
we know it's a descendant to addition.

234
00:19:04,308 --> 00:19:10,388
So if that's the case we have to put a branch on this.

235
00:19:11,300 --> 00:19:14,262
So we will take a look at what the next token is.

236
00:19:16,228 --> 00:19:20,400
We know that it could be, say, a plus.

237
00:19:20,400 --> 00:19:25,874
(Silence).

238
00:19:25,870 --> 00:19:46,834
And then if Y is that, then we are going to return
Eadd X and then call inaudible expression parser.

239
00:19:48,000 --> 00:19:54,845
Otherwise if it's not plus, then at the
moment we just have an unrecognized operator.

240
00:19:54,914 --> 00:20:00,514
Over here again, we have the white space problem.

241
00:20:00,670 --> 00:20:05,428
We'll allow white space to be
thrown away here... and here.

242
00:20:05,420 --> 00:20:12,834
(Silence).

243
00:20:12,830 --> 00:20:16,057
Without white space.
Oh, we're still having a problem.

244
00:20:16,617 --> 00:20:20,502
OC: There's no termination condition here.

245
00:20:20,600 --> 00:20:24,377
So even when we see an addition sign we expect another one.

246
00:20:24,422 --> 00:20:26,548
JW: That's true.

247
00:20:28,540 --> 00:20:35,508
So we can have plus or we can have
eof, but eof is going to return nothing.

248
00:20:36,057 --> 00:20:41,565
So in that case, we're going to return the String.

249
00:20:43,382 --> 00:20:46,571
At the moment... to work around that.

250
00:20:46,600 --> 00:20:51,908
Unrecognised operator...

251
00:20:54,754 --> 00:21:01,062
OC: Maybe use Just for the operator
and use Nothing for end-of-file.

252
00:21:01,100 --> 00:21:02,468
JW: Excellent.

253
00:21:02,460 --> 00:21:34,262
Inaudible then we'll return just
our X and Y and we'll say is Y a plus.

254
00:21:35,931 --> 00:21:40,662
Now we've got rid of our
infinite left recursion problem.

255
00:21:40,700 --> 00:21:45,942
Now you were telling me about a
function called chainl, which I have not used yet.

256
00:21:45,942 --> 00:21:49,771
But in Parsec is designed to solve this problem.

257
00:21:49,800 --> 00:21:51,508
OC: That's what I'm telling you.

258
00:21:51,600 --> 00:22:04,068
JW: That's right, but we will say we want term, chainl1 and...

259
00:22:04,350 --> 00:22:06,365
which in this case... let's see...

260
00:22:06,445 --> 00:22:10,902
The addop is going to be...

261
00:22:10,948 --> 00:22:15,988
Oh! I see that's the
symbols that it's expecting to see.

262
00:22:16,000 --> 00:22:19,485
Let's do this, just like they have here:

263
00:22:19,497 --> 00:22:29,645
we'll say the add operation, and now if
we see add we're going to return the function plus.

264
00:22:29,657 --> 00:22:35,257
OC: I think you want EAdd there rather than addition.

265
00:22:35,300 --> 00:22:39,908
JW: That's right because I'm
not doing evaluation in the Parser.

266
00:22:41,565 --> 00:22:44,331
So I have term chain addop.

267
00:22:46,400 --> 00:22:49,600
I  will still need to deal with white space.

268
00:22:55,230 --> 00:23:05,085
I believe that symbol skips trailing white space,
so I don't need to worry about leaving white space.

269
00:23:05,451 --> 00:23:09,931
OC: Do you need to worry about
that if you're using symbol everywhere?

270
00:23:10,000 --> 00:23:11,245
JW: Perhaps not.

271
00:23:11,240 --> 00:23:13,725
OC: (Inaudible).

272
00:23:13,725 --> 00:23:18,342
Let's say that there can be white
space after terminals, for the moment.

273
00:23:18,340 --> 00:23:22,960
(Silence).

274
00:23:23,200 --> 00:23:26,731
Now the add Parser is going to go away.

275
00:23:27,000 --> 00:23:31,520
And we're going to have a new Parser for expressions.

276
00:23:31,954 --> 00:23:34,600
And now all this gets to go away.

277
00:23:34,600 --> 00:23:41,782
OC: It might be a Parser as a function to
expression to expression to expression, in addop...

278
00:23:41,794 --> 00:23:46,880
because you have EAdd as your return type.

279
00:23:46,880 --> 00:23:56,297
(Silence).

280
00:23:59,300 --> 00:24:07,657
JW: Their version of white space
here is too fancy for what I want just yet.

281
00:24:08,480 --> 00:24:14,594
Parsec allows you to describe what tokens look
like and what the white spacing comments are.

282
00:24:14,605 --> 00:24:18,994
I may use that a little bit but not at the moment.

283
00:24:20,480 --> 00:24:22,411
Symbol is applied to too few arguments...

284
00:24:22,434 --> 00:24:28,262
Ah! This symbol is coming from that fancy library.

285
00:24:28,400 --> 00:24:35,540
I don't want symbol. I want string and
I have to build in my own terminating white space.

286
00:24:35,540 --> 00:24:41,360
(Silence).

287
00:24:42,022 --> 00:24:43,302
OC: That's a lot simpler.

288
00:24:43,314 --> 00:24:44,300
JW: Much cleaner.

289
00:24:44,890 --> 00:24:51,348
Based on the example that they gave,
we want to extend this to more operations.

290
00:24:51,340 --> 00:24:57,668
So we will go ahead and add those,
because Math operations tend to be easy to put in.

291
00:24:57,800 --> 00:25:07,611
We're going to say we want
subtraction, multiplication and division.

292
00:25:08,200 --> 00:25:14,560
It's all still going to be on numbers.
Now we have to make three more versions of addop.

293
00:25:15,977 --> 00:25:19,268
We have inaudible.

294
00:25:20,000 --> 00:25:29,200
We only have to worry about precedence
because, what would it mean if we said this:

295
00:25:30,674 --> 00:25:32,400
In what order do we evaluate?

296
00:25:32,400 --> 00:25:37,245
We know we want the division to happen first.
How do we make sure the Parser enforces that.

297
00:25:37,400 --> 00:25:42,320
The way to do that is to
structure how we do our traversal.

298
00:25:42,354 --> 00:25:44,770
OC: Because now the Parser is just running from left to right,

299
00:25:44,788 --> 00:25:48,200
and basically just standing on the left.

300
00:25:48,200 --> 00:25:52,571
JW: The expression evaluator
is going to be equally trivial.

301
00:25:55,500 --> 00:25:57,700
OC: Can we not just work with 'int' anymore?

302
00:25:58,300 --> 00:26:05,051
JW: Ah true...

303
00:26:05,794 --> 00:26:11,017
we want the fractional numbers...

304
00:26:11,500 --> 00:26:18,674
And now our num will have to say... I always
forget what the conversion operations are called...

305
00:26:18,900 --> 00:26:21,600
OC: I wonder if it's easier to use doubles everywhere.

306
00:26:21,600 --> 00:26:31,680
In some of the later codes it assumes
you can assign to floating point numbers.

307
00:26:32,100 --> 00:26:36,662
We want a number... followed by...

308
00:26:37,500 --> 00:26:41,405
(we're going to have to do
this in a different style here).

309
00:26:41,530 --> 00:26:47,005
OC: I feel  that Parsec may already
have a pre-built Parser for doubles.

310
00:26:47,074 --> 00:26:50,200
JW: True, but I want us to write our own!

311
00:26:50,200 --> 00:26:55,028
So we want the part before and
after to be numerical parsing.

312
00:26:55,120 --> 00:26:56,834
So this is our numerical parser.

313
00:26:57,280 --> 00:27:04,297
We're going to say a numerical Parser is some number.

314
00:27:04,720 --> 00:27:10,411
And then we want an optional period character.

315
00:27:10,900 --> 00:27:15,097
And it's optional, so we will
get a maybe value out of it.

316
00:27:15,090 --> 00:27:20,685
(John thinks).

317
00:27:21,000 --> 00:27:29,268
Then we will take our X and
append it with yet another number.

318
00:27:29,440 --> 00:27:33,108
Otherwise, just return a number.

319
00:27:33,177 --> 00:27:37,302
It's complaining because there
are two definitions of optional.

320
00:27:37,634 --> 00:27:42,400
(John thinks).

321
00:27:42,500 --> 00:27:46,377
OC: The definitions are completely equivalent...

322
00:27:46,400 --> 00:27:49,120
we aren't making a choice about which ones we hide.

323
00:27:49,131 --> 00:27:51,908
Fairly arbitrary, right?
JW: Right.

324
00:28:03,900 --> 00:28:07,691
I think it may be re-exported nowadays.

325
00:28:07,794 --> 00:28:09,500
They have the same definition.

326
00:28:30,300 --> 00:28:36,948
OC: I believe we need to use that dot
character between the two num Parsers.

327
00:28:37,100 --> 00:28:38,274
JW: Yes.

328
00:28:39,531 --> 00:28:44,690
OC: Now we are consuming a dot
but we're ignoring it when we emit a string.

329
00:28:44,830 --> 00:28:48,491
JW: Oh yes, we have to add
it back in. Very good point.

330
00:28:48,490 --> 00:28:55,165
(John types).

331
00:28:55,234 --> 00:28:57,908
I can't do sections like that.

332
00:28:57,900 --> 00:29:01,885
(Ollie mumbles in agreement).

333
00:29:02,000 --> 00:29:05,211
JW: So now cannot deduce this being double.

334
00:29:05,660 --> 00:29:11,920
So we will say if double... there we go...
and now we get ... inaudible zero

335
00:29:11,970 --> 00:29:15,211
OC: Can we try to parse 1.5, something like that?

336
00:29:15,210 --> 00:29:18,720
(John trys this).

337
00:29:18,800 --> 00:29:20,900
JW: We can even multiply something in here.

338
00:29:23,220 --> 00:29:26,525
That did not work. Because
we haven't tied in the Parser.

339
00:29:28,137 --> 00:29:30,480
OC: These are all doing EAdd as well.

340
00:29:30,480 --> 00:29:33,588
JW: True, they're not plugged in.

341
00:29:37,700 --> 00:29:42,880
Now we want to extend our
parsing chain the way that they did.

342
00:29:43,890 --> 00:29:49,554
He did precedence by having it be at the same level.

343
00:29:50,331 --> 00:29:53,874
(John mumbles as he types).

344
00:29:53,890 --> 00:29:56,171
We're going to follow suit.

345
00:29:56,170 --> 00:30:08,662
(Silence).

346
00:30:09,485 --> 00:30:12,240
Now we want chain in the addop...

347
00:30:12,240 --> 00:30:17,565
And then we'll say...  a little snipped...

348
00:30:18,388 --> 00:30:22,137
A lot of good coding can come
from just copying. (laughter)

349
00:30:25,600 --> 00:30:28,845
We don't have parens yet...

350
00:30:28,900 --> 00:30:32,080
So instead we will call...

351
00:30:32,080 --> 00:30:35,965
(John thinks)

352
00:30:35,960 --> 00:30:41,417
We will just say... our own term...

353
00:30:43,394 --> 00:30:48,742
What am I going to call this for
now now... I'm going to call it sub expression.

354
00:30:48,740 --> 00:30:55,977
(inaudible mumbling).

355
00:30:56,400 --> 00:30:59,000
If I say that I get
correct multiplication.

356
00:30:59,000 --> 00:31:03,142
If I add the 5 to the back it works as we'd thought.

357
00:31:03,154 --> 00:31:06,100
But it also works the same if we add it to the front.

358
00:31:09,500 --> 00:31:13,017
I would like to have parenthesis so that we can do this...

359
00:31:13,020 --> 00:31:18,925
And if we add them, we will have
satisfied the first three lines of our file.

360
00:31:18,940 --> 00:31:22,720
OC: I wonder now if we could
try to hook this in to read from a file.

361
00:31:23,120 --> 00:31:27,965
and maybe try to parse the entire
file and watch the Parser eventually fail.

362
00:31:27,965 --> 00:31:29,960
JW: OK.

363
00:31:30,600 --> 00:31:33,794
OC: We should be ready to
parse the first two lines I think.

364
00:31:33,805 --> 00:31:37,211
It might eventually
start emitting some evaluation.

365
00:31:37,240 --> 00:31:42,480
JW: So let's write a function that we
can call from the REPL... called testFile...

366
00:31:42,502 --> 00:31:46,880
and that will take a FilePath,
instead of just a string.

367
00:31:47,600 --> 00:31:52,891
And then we want to get the contents of the path.

368
00:31:55,500 --> 00:32:02,617
We're going to parse the same
expression but we're going to do many of them.

369
00:32:05,000 --> 00:32:07,268
We could also cut the file up.

370
00:32:07,337 --> 00:32:11,268
But I want this expression
Parser to take in the whole thing.

371
00:32:11,300 --> 00:32:14,914
OC: Yes, We can give it the whole
file and it will evaluate it line by line.

372
00:32:15,291 --> 00:32:16,651
JW: Right.

373
00:32:16,685 --> 00:32:20,742
So... this will be a series of xs.

374
00:32:23,200 --> 00:32:26,514
Again we need this case here.

375
00:32:27,700 --> 00:32:30,811
So we're going to say for every x that we have...

376
00:32:30,810 --> 00:32:34,491
(Silence).

377
00:32:34,490 --> 00:32:37,371
I'm going to call it (inaudible).

378
00:32:38,274 --> 00:32:42,125
forM_ is not in scope, this comes from Control.Monad.

379
00:32:46,100 --> 00:32:49,405
If I didn't do this, if I said Control-c and Control-m...

380
00:32:49,410 --> 00:32:54,217
it would suggest to me all
the modules that it knows about.

381
00:32:54,270 --> 00:32:58,994
If I select Control.Monad
it will put it with the explicit.

382
00:33:01,200 --> 00:33:04,285
OC: Is that coming from
the normal Haskell mode for Emacs

383
00:33:04,290 --> 00:33:06,971
or is it an extra extension you have?

384
00:33:07,000 --> 00:33:08,925
JW: Let's see...

385
00:33:10,388 --> 00:33:16,491
ghc-ins-mod is providing that feature.

386
00:33:17,100 --> 00:33:22,000
I use Haskell mode and I use ghc-mod and hdevtools.

387
00:33:22,297 --> 00:33:28,902
And the code that jumps to the local
Hoogle is a patch that I did on ghc-mod's code,

388
00:33:29,300 --> 00:33:34,045
to jump over to the Hoogle
I have running on my local machine.

389
00:33:34,320 --> 00:33:36,502
So parser providing too few arguments.

390
00:33:36,500 --> 00:33:40,331
I definitely want to pass the
name of the file to the Parser.

391
00:33:40,937 --> 00:33:46,811
getContents... Ahh, I want readFile.

392
00:33:46,810 --> 00:33:56,308
(Silence).

393
00:33:56,600 --> 00:34:00,685
I did the case one level too far.

394
00:34:00,680 --> 00:34:08,754
(Silence)

395
00:34:08,750 --> 00:34:11,040
So let's say here...

396
00:34:11,500 --> 00:34:15,800
I'll do it in point free
just because I know you (laughter).

397
00:34:17,000 --> 00:34:20,251
I need to pack the string.

398
00:34:20,250 --> 00:34:23,222
(Silence).

399
00:34:23,220 --> 00:34:25,600
So, the actual type...

400
00:34:25,840 --> 00:34:28,320
OC: So I guess parse is a pure function?

401
00:34:28,354 --> 00:34:32,605
JW: Yes, we're working with
pure functions here. Good thing!

402
00:34:33,257 --> 00:34:38,022
And then this is a right value, not just value.

403
00:34:38,200 --> 00:34:40,800
I have no idea what this is going to do (laughter).

404
00:34:40,800 --> 00:34:47,988
Not all of this file will parse so we
will take a cut out of it and call it test.bc.

405
00:34:48,205 --> 00:34:51,108
Then I'm going to run this on test.bc

406
00:34:51,611 --> 00:34:55,954
And we go into an infinite loop (laughter).

407
00:34:56,308 --> 00:35:00,525
It would be nice to know why, so let's add some tracing.

408
00:35:00,600 --> 00:35:05,268
I tend to add a lot of tracing
when I'm initially developing.

409
00:35:05,260 --> 00:35:09,188
(Inaudible)

410
00:35:09,200 --> 00:35:14,251
I want to know when expr is being called.

411
00:35:17,000 --> 00:35:22,857
The tricky thing about doing traces is
that it's not like 'print' in an imperative language.

412
00:35:22,900 --> 00:35:27,028
It's not going to print a
statement as soon as it enters expr.

413
00:35:28,194 --> 00:35:33,417
It will cause that string to be
printed when expr's result gets evaluated.

414
00:35:33,500 --> 00:35:37,268
Which sometimes can be rather distant.

415
00:35:37,268 --> 00:35:40,274
Action of debugging at a distance.

416
00:35:40,290 --> 00:35:44,731
OC: So this is where Haskell's laziness
is more of a pain point than a benefit.

417
00:35:44,742 --> 00:35:48,068
JW: Right, it makes it harder to
find out when things are happening.

418
00:35:48,068 --> 00:35:51,017
So we are seeing that the
expression is only being called once.

419
00:35:51,051 --> 00:35:54,514
Our infinite recursion is happening elsewhere.

420
00:35:58,500 --> 00:36:02,891
My first version of many parsers will
have tracers on every function (laughter).

421
00:36:02,900 --> 00:36:07,188
So I can watch what's happening as it's going.

422
00:36:07,222 --> 00:36:10,560
So I will go ahead and put this in.

423
00:36:13,000 --> 00:36:19,588
After a certain point I have a keyboard macro.

424
00:36:20,068 --> 00:36:25,417
Now I can say control E and control... alright.

425
00:36:26,100 --> 00:36:28,171
So we get to addop and we stop.

426
00:36:29,817 --> 00:36:32,034
So addop...

427
00:36:32,125 --> 00:36:39,165
(Silence).

428
00:36:39,160 --> 00:36:43,211
Let me add traces, inaudible.

429
00:36:43,210 --> 00:36:50,297
(John mumbles to himself).

430
00:36:51,410 --> 00:36:56,720
Ah! the minus symbol. We don't have a minus symbol.

431
00:36:59,188 --> 00:37:03,645
OC: What happens if we just
shorten this file even more... yeah.

432
00:37:06,091 --> 00:37:08,674
JW: We're getting no output whatsoever.

433
00:37:08,700 --> 00:37:12,011
Oh! there we go, same place.

434
00:37:12,800 --> 00:37:18,400
OC: And if we run our test again?

435
00:37:21,400 --> 00:37:23,691
JW: Interesting...

436
00:37:26,480 --> 00:37:31,950
I don't have support for parens.
But there are no parens in this line

437
00:37:32,000 --> 00:37:37,314
OC: Maybe it's the new line
that's the problem... at the end of the file.

438
00:37:37,330 --> 00:37:43,188
JW: Right. Let's say that we want
there to be an eof at the end of the file.

439
00:37:47,337 --> 00:37:52,000
We don't even get there which means we
have infinite recursion happening somewhere.

440
00:37:52,000 --> 00:37:57,988
(Silence).

441
00:37:58,000 --> 00:38:04,525
Let's split the file up into
lines and do this differently:

442
00:38:04,520 --> 00:38:19,348
(Silence).

443
00:38:19,930 --> 00:38:24,434
Now we would expect that
we would get the 2.0 as a result.

444
00:38:24,765 --> 00:38:29,097
And if we go back to what we had before...

445
00:38:29,500 --> 00:38:33,108
It's failing parse these comments.

446
00:38:34,200 --> 00:38:36,662
OC: Maybe the empty strings as well. JW: Yes.

447
00:38:39,100 --> 00:38:41,954
JW: Cool, we don't have parentheses.

448
00:38:43,337 --> 00:38:48,891
So we definitely want to strip out the comments.

449
00:38:50,200 --> 00:38:53,131
Let's write a function called massage.

450
00:38:54,200 --> 00:39:02,022
That will take some input text and
strip out anything that looks like a comment.

451
00:39:02,400 --> 00:39:06,182
First we'll say strip comments on text.

452
00:39:06,180 --> 00:39:12,422
And then we want to be saying (inaudible).

453
00:39:12,420 --> 00:39:25,154
(Silence).

454
00:39:25,622 --> 00:39:31,131
And now we want string comments to say: given some...

455
00:39:31,130 --> 00:39:38,057
(John thinks)

456
00:39:38,200 --> 00:39:42,331
I'll go to Data.Text library
to find out how to partition a string.

457
00:39:42,857 --> 00:39:44,034
(Inaudible).

458
00:39:49,737 --> 00:39:54,502
Partition is not what I want, I want break or split.

459
00:39:54,811 --> 00:39:57,931
Split, is it on or is it at, now let's read it.

460
00:40:15,588 --> 00:40:19,097
We're never going to have
the hash be a valid character.

461
00:40:19,131 --> 00:40:26,891
So we're going to say take one not equal to...

462
00:40:35,714 --> 00:40:41,645
It's going to be tiresome to always type
that so we will allow ourselves a little (inaudible).

463
00:40:46,365 --> 00:40:56,050
And were still (inaudible), so
we want a first case on massage.

464
00:40:56,050 --> 00:41:01,657
(Silence).

465
00:41:01,657 --> 00:41:06,617
We want to be nice and trim, without an empty line.

466
00:41:06,610 --> 00:41:24,571
(Silence).

467
00:41:24,570 --> 00:41:31,782
(John mumbles as he types).

468
00:41:32,000 --> 00:41:33,600
OC: That's the parentheses again.

469
00:41:34,868 --> 00:41:37,440
I think we're skipping
over comments successfully now.

470
00:41:37,451 --> 00:41:44,388
And those two outputs do match
what we would expect from the input file.

471
00:41:44,400 --> 00:41:50,308
JW: OK, so we have now got
parsing of expressions and files.

472
00:41:50,330 --> 00:41:53,325
We know we have to do parens
and a couple of other things.

473
00:41:53,330 --> 00:41:59,120
What I would like to do next is do it in a REPL style.

474
00:41:59,154 --> 00:42:02,605
So that I could use this on
the command line for example.

475
00:42:02,605 --> 00:42:05,314
OK, so we want to have a function called REPL.

476
00:42:05,348 --> 00:42:08,068
And this will just loop forever.

477
00:42:09,474 --> 00:42:14,308
And I will say that forever I am going to get...

478
00:42:14,330 --> 00:42:18,285
I can't remember what the function
is to get input from the command line!

479
00:42:18,297 --> 00:42:19,730
Is it getLine?

480
00:42:19,730 --> 00:42:21,730
OC: I think there is a getLine, Yes.

481
00:42:21,748 --> 00:42:23,500
JW: It's not something I use.

482
00:42:23,500 --> 00:42:27,680
OC: You can also use interact.
That would be interesting to look at.

483
00:42:27,700 --> 00:42:31,600
JW: Yes, let's hop over to interact (inaudible).

484
00:42:31,645 --> 00:42:35,782
And then the output string
is going to be what it prints.

485
00:42:35,820 --> 00:42:41,131
So we're going to get an input
string, and run it against our test.

486
00:42:41,130 --> 00:42:44,857
(Silence).

487
00:42:44,857 --> 00:42:48,971
This one is in IO, which is unfortunate.

488
00:42:50,930 --> 00:42:54,754
There's no reason this function should
be in IO except when we're printing.

489
00:42:54,765 --> 00:42:57,337
So let's break this into two.

490
00:42:57,428 --> 00:43:06,045
And have this be text to text,
and it's going to return (inaudible).

491
00:43:06,830 --> 00:43:11,908
Or it's going to return show of evaluation.

492
00:43:12,457 --> 00:43:16,560
And now test... what will we call this...

493
00:43:18,194 --> 00:43:22,685
Eval string... (inaudible).

494
00:43:22,697 --> 00:43:25,828
I guess it would be more
appropriate to call it evalText.

495
00:43:25,840 --> 00:43:34,742
And our test is going to print the result of (inaudible).

496
00:43:34,742 --> 00:43:38,502
And you can see I have this ...

497
00:43:38,502 --> 00:43:40,900
That's not really a unicode character.

498
00:43:40,900 --> 00:43:42,754
OC: That's actually the ASCII 'dot'.

499
00:43:42,777 --> 00:43:45,382
JW: Yes but Emacs has this way to say

500
00:43:45,380 --> 00:43:52,662
'when you see this type of character in this context,
then show me this other character instead.'

501
00:43:52,700 --> 00:44:00,857
Like, when I type: not A or B...
I'd like to see the mathematical notations.

502
00:44:01,100 --> 00:44:04,411
OC: And you're doing the same with
the arrow and the double colon above.

503
00:44:04,434 --> 00:44:07,931
JW: And this arrow and a few other things.

504
00:44:08,434 --> 00:44:12,285
I have one for the proc incoming arrow.

505
00:44:14,740 --> 00:44:22,080
I interact with evalText, which simply needs
to pack and unpack because I'm using data.text.

506
00:44:22,500 --> 00:44:25,954
There's no particular reason I'm using Data.Text.

507
00:44:28,680 --> 00:44:32,571
OC: I think interact already runs forever.

508
00:44:32,754 --> 00:44:37,250
I think the idea of interact is you get
a lazy string of all of standard input.

509
00:44:37,700 --> 00:44:40,057
And you deliver a lazy string of output.

510
00:44:40,090 --> 00:44:47,131
So you might want to split that int
lines again then evalText over each line.

511
00:44:47,302 --> 00:44:49,074
JW: Right.

512
00:44:49,300 --> 00:44:55,280
Well if I'm going to be on a REPL...
Let's take a look at the (inaudible) here.

513
00:44:56,468 --> 00:44:59,988
Oh yes you're right, it takes the entire input.

514
00:45:02,800 --> 00:45:05,028
That's not really what I want then.

515
00:45:05,062 --> 00:45:11,405
I want to have my own forever because
I want to see the result of every line as I type.

516
00:45:13,040 --> 00:45:16,640
So we want our input to come from getLine.

517
00:45:16,640 --> 00:45:20,982
And then we are going to evalText the result.

518
00:45:20,994 --> 00:45:28,582
Actually, now that we're in
IO we can just run test on the input.

519
00:45:29,691 --> 00:45:31,794
It just has to be this.

520
00:45:32,925 --> 00:45:36,148
Alright, we can be a little bit fancier now.

521
00:45:36,140 --> 00:45:46,342
(John types and thinks).

522
00:45:46,340 --> 00:45:48,994
Alright, were dealing with packing and showing.

523
00:45:48,990 --> 00:46:13,188
(John thinks and types).

524
00:46:13,520 --> 00:46:18,651
I have to add in an
extension called OverloadedStrings.

525
00:46:19,382 --> 00:46:23,577
OC: And when you type that
have you got a templating thing for Emacs?

526
00:46:26,800 --> 00:46:30,754
JW: There is a module called YASnippet.

527
00:46:30,780 --> 00:46:35,348
And I have a snippet called 'lang'.

528
00:46:35,440 --> 00:46:39,668
So if I type 'lang' and hit tab
it will expand and then ask...

529
00:46:39,668 --> 00:46:42,617
It actually has gone to GHC and asked it.

530
00:46:44,080 --> 00:46:46,468
I'll show you what that snipped looks like.

531
00:46:48,690 --> 00:46:53,371
Let's see it's in Haskell mode what is it called...

532
00:46:53,370 --> 00:46:56,960
(John thinks).

533
00:46:56,960 --> 00:46:58,914
Yes, here it is.

534
00:46:59,257 --> 00:47:05,577
It inserts language, it requires and
then it says haskell-yas-ghc-language-pragmas.

535
00:47:05,760 --> 00:47:14,594
That is a function that will go out to GHC,

536
00:47:14,600 --> 00:47:16,674
and ask "what are all your extensions?"

537
00:47:16,674 --> 00:47:21,691
Actually I think the command
was right there: ghc --supported-extensions.

538
00:47:21,977 --> 00:47:27,428
And that will tell you what you can use.

539
00:47:27,440 --> 00:47:31,611
(Silence).

540
00:47:31,760 --> 00:47:34,845
Going back to our example code.

541
00:47:35,314 --> 00:47:38,354
So now we have this compiling.

542
00:47:38,400 --> 00:47:40,125
No this is not compiling yet.

543
00:47:40,160 --> 00:47:42,011
It still didn't like that.

544
00:47:42,010 --> 00:47:49,142
(John thinks).

545
00:47:49,360 --> 00:47:52,594
It wants a character?

546
00:47:52,590 --> 00:48:03,737
(John thinks and occasionally mumbles inaudibly).

547
00:48:04,160 --> 00:48:07,394
Oh! I don't want to use return.

548
00:48:07,400 --> 00:48:12,057
It was interpreting it in the
List monad... I was confusing that.

549
00:48:12,091 --> 00:48:17,634
Right, so now if we have a REPL I can say 1+2, I can say 1+5.

550
00:48:17,645 --> 00:48:20,880
This makes it much easier for me to do little tests.

551
00:48:21,714 --> 00:48:24,240
OK, so let's do parens.

552
00:48:24,240 --> 00:48:24,285
We want...
OK, so let's do parens.

553
00:48:24,285 --> 00:48:26,280
We want...

554
00:48:27,177 --> 00:48:29,542
What are parens?

555
00:48:29,680 --> 00:48:34,582
For this one I can use a Parsec feature.

556
00:48:34,580 --> 00:48:40,971
(John thinks about what it's called).

557
00:48:41,348 --> 00:48:46,010
It's in the combinators library,
and it's called 'between' I think.

558
00:48:46,560 --> 00:48:48,628
Yes.

559
00:48:48,620 --> 00:48:51,908
(Silence).

560
00:48:52,000 --> 00:48:54,971
I like this notion of symbol.

561
00:48:56,160 --> 00:49:00,651
A symbol can have white space on either side.

562
00:49:00,650 --> 00:49:05,725
(John types).

563
00:49:05,760 --> 00:49:09,645
OC: Maybe it would be better
if we passed a Parser in as well.

564
00:49:09,680 --> 00:49:15,508
So symbol is a kind of Parser transformer
that takes a Parser and gives you...

565
00:49:15,500 --> 00:49:19,657
JW: But then I would find myself
constantly doing things like that.

566
00:49:19,650 --> 00:49:22,400
I would rather just say this:

567
00:49:22,400 --> 00:49:24,674
So now I will go to all the places where I've done this.

568
00:49:24,685 --> 00:49:30,434
And now I can say symbol
without having to have this nonsense here.

569
00:49:31,680 --> 00:49:36,594
The symbol function that comes with Parsec...

570
00:49:39,051 --> 00:49:41,565
I'm returning the wrong thing... oh no.

571
00:49:41,680 --> 00:49:46,822
the one that is in the token module,
relies upon a definition of what

572
00:49:46,822 --> 00:49:50,422
the tokens of your language are,
which would include the commenting.

573
00:49:50,434 --> 00:49:54,354
We've handled commenting,
pre - input to the Parser.

574
00:49:54,400 --> 00:49:59,805
But Parsec does have the ability to say this is what...

575
00:49:59,817 --> 00:50:01,680
OC: So rather than sanitizing the input,

576
00:50:01,680 --> 00:50:04,880
you could have dealt with
comments as syntax themselves.

577
00:50:04,880 --> 00:50:05,440
JW: Right.

578
00:50:05,440 --> 00:50:09,634
If I go to the contents of the Parsec module.

579
00:50:09,630 --> 00:50:16,537
(John mumbles inaudibly).

580
00:50:16,571 --> 00:50:19,405
We have a module called token.

581
00:50:19,420 --> 00:50:22,617
In token there is this notion
of a language definition.

582
00:50:22,720 --> 00:50:29,302
Which you call makeTokenParser and
you pass in a definition of your language.

583
00:50:29,600 --> 00:50:33,577
And that definition defines these things.

584
00:50:33,610 --> 00:50:35,702
How do comments begin and end.

585
00:50:35,700 --> 00:50:41,245
What does a single line comment
look like. Can they be nested etc. etc.

586
00:50:41,268 --> 00:50:44,680
And finally you have
reservedNames and reservedOpNames.

587
00:50:44,740 --> 00:50:48,914
That way, when you say symbol
it has to be something from...

588
00:50:48,960 --> 00:50:51,840
I don't think it has to be
from your reservedNames list,

589
00:50:51,840 --> 00:50:58,502
but it won't confuse that as an
identifier name; it's been reserved.

590
00:50:58,520 --> 00:51:04,651
This is a very handy thing to use,
but we're not going to be using it right now,

591
00:51:04,662 --> 00:51:07,885
because our language is so simple.

592
00:51:07,880 --> 00:51:12,560
We want symbol, symbol, between...

593
00:51:15,142 --> 00:51:20,068
We want a parser for expressions between symbols.

594
00:51:22,205 --> 00:51:27,451
OC: I think between still needs
a third argument which is the Parser to run.

595
00:51:27,450 --> 00:51:31,177
(John types).

596
00:51:31,170 --> 00:51:33,611
JW: There we go, it types

597
00:51:33,610 --> 00:51:37,931
OK, symbol is (inaudible) again.

598
00:51:37,930 --> 00:51:49,394
(Silence).

599
00:51:49,394 --> 00:51:55,737
Expected string... Oh string is returning a ...

600
00:51:55,730 --> 00:52:01,942
You know what, I never
actually want the result of this.

601
00:52:01,940 --> 00:52:11,920
(John mumbles as he types).

602
00:52:11,920 --> 00:52:21,165
inaudible, 1+9 and I'll say 1+5x3.

603
00:52:21,550 --> 00:52:27,314
OC: Excellent. So we should be able
to call the function that's reading the file.

604
00:52:27,337 --> 00:52:30,114
And get a little further this time.

605
00:52:30,160 --> 00:52:37,337
JW: Previously we were using
testFile on test.bc which is a shorter file.

606
00:52:37,348 --> 00:52:38,160
There we go.

607
00:52:38,160 --> 00:52:40,160
OC: It looks like it gets all the way to the end there.

608
00:52:40,160 --> 00:52:45,405
JW: Right. Now we're going to
test.bc and add in the next thing.

609
00:52:46,205 --> 00:52:48,422
(Inaudible).

610
00:52:48,430 --> 00:52:53,588
As we're in a working state here,
I'm going to go ahead and commit this.

611
00:52:54,377 --> 00:53:00,011
So parser handles a simple expression in Repl

612
00:53:00,697 --> 00:53:01,942
There we go.

613
00:53:01,940 --> 00:53:05,085
[New Chapter]

614
00:53:05,108 --> 00:53:07,360
JW: Now how are we going to handle let binding?

615
00:53:07,360 --> 00:53:10,080
We will start by writing a parser for let bindings.

616
00:53:11,097 --> 00:53:13,131
So we'll call it let binding.

617
00:53:13,211 --> 00:53:14,960
And it's going to be an expression.

618
00:53:15,828 --> 00:53:19,440
I don't know what it's going to be yet. (inaudible)

619
00:53:19,977 --> 00:53:24,171
We want to represent this in our language.

620
00:53:24,320 --> 00:53:31,120
We're going to say,
"A let binding has a variable name and an expression".

621
00:53:34,182 --> 00:53:39,245
And then we know that we
will have let in our constructor.

622
00:53:39,645 --> 00:53:42,091
And we are going to parse...

623
00:53:44,034 --> 00:53:47,680
I cant remember inaudible

624
00:53:49,800 --> 00:53:55,440
Oh, actually, I can just say I want letter.

625
00:53:56,045 --> 00:53:59,177
I'm going to have some letter.

626
00:53:59,200 --> 00:54:03,645
OC: So some is like many but it requires one or more.

627
00:54:03,840 --> 00:54:06,742
JW: Yes, and we want, of course...

628
00:54:06,740 --> 00:54:09,508
(Silence).

629
00:54:09,531 --> 00:54:12,765
And of course we're going to get some conflict here.

630
00:54:12,800 --> 00:54:17,245
Oh! that's because letter returns a character.

631
00:54:17,240 --> 00:54:21,714
And then the aggregate raises a string and
then I need to pack it because we want to test.

632
00:54:21,760 --> 00:54:26,754
And then we want to tie
the let binding in to our Parser.

633
00:54:26,800 --> 00:54:30,502
OC: Do you need to introduce
the let keyword there at all?

634
00:54:31,645 --> 00:54:34,102
JW: Excellent point.

635
00:54:34,102 --> 00:54:36,100
So we're going to call that symbol.

636
00:54:38,034 --> 00:54:42,022
OC: Is there an equals between the keyword...

637
00:54:42,080 --> 00:54:45,908
JW: Let's see what your specification said.

638
00:54:45,900 --> 00:54:55,542
(John types).

639
00:54:55,565 --> 00:55:01,885
This is starting to go a little out in to
space here so let's write it more monadically.

640
00:55:02,434 --> 00:55:06,274
We want... some letter...

641
00:55:07,051 --> 00:55:12,937
inaudible name and we want to pack the name.

642
00:55:13,220 --> 00:55:16,948
And then we want to parse an equal.

643
00:55:16,940 --> 00:55:21,291
And we want to get a body of an expression.

644
00:55:21,290 --> 00:55:23,794
(Inaudible).

645
00:55:28,914 --> 00:55:31,142
And body is...

646
00:55:31,140 --> 00:55:33,817
(John thinks).

647
00:55:34,525 --> 00:55:36,662
What is going on there?

648
00:55:36,660 --> 00:55:40,285
(Silence).

649
00:55:40,400 --> 00:55:43,474
Why would it think that the type of body...

650
00:55:43,760 --> 00:55:51,200
OC: Is that error out of date because
you don't have that last line of code any more.

651
00:55:51,240 --> 00:55:56,308
JW: Oh, that's true. Sometimes
the background syntax checker...

652
00:55:56,331 --> 00:56:01,302
I'm getting a little ahead of it so
it's showing a result from a while ago.

653
00:56:01,325 --> 00:56:07,611
In the evaluator, we need
to do something with this let.

654
00:56:09,142 --> 00:56:13,702
We want to take in an environment.

655
00:56:13,760 --> 00:56:21,965
And that is going to be a map of names to expressions.

656
00:56:22,320 --> 00:56:26,834
We want the let to add an entry into
that map that we can later evaluate,

657
00:56:26,880 --> 00:56:29,200
if anyone makes a reference to it.

658
00:56:29,280 --> 00:56:34,411
We want to have Data.Map in scope.

659
00:56:37,870 --> 00:56:41,714
We don't JUST want a map of text to expressions because that would mean

660
00:56:41,737 --> 00:56:47,931
every time the variable was
referred to it would be re-evaluated.

661
00:56:48,240 --> 00:56:52,731
We want a function in there.

662
00:56:54,880 --> 00:56:57,611
We want our evaluator to be recursive.

663
00:56:57,611 --> 00:56:59,610
OC: OK.

664
00:56:59,680 --> 00:57:03,291
JW: I will need to have this be a little trickier.

665
00:57:07,280 --> 00:57:09,657
Let's go with the dumb way first.

666
00:57:09,840 --> 00:57:13,828
and build this up incrementally.

667
00:57:14,274 --> 00:57:17,474
It never pays to be too fancy in the beginning.

668
00:57:17,470 --> 00:57:21,771
And we will say ELet main body.

669
00:57:21,862 --> 00:57:25,580
We need to pass in the environment
and return the mutated environment.

670
00:57:25,611 --> 00:57:28,400
Which is the perfect job for state.

671
00:57:28,400 --> 00:57:31,371
Which means we need to bring in State.

672
00:57:32,422 --> 00:57:34,845
And I bring in from transformers...

673
00:57:35,611 --> 00:57:39,451
OK, which means now we are monadic.

674
00:57:39,520 --> 00:57:43,234
So all these have to do returns.

675
00:57:44,297 --> 00:57:46,388
Do returns.

676
00:57:47,040 --> 00:57:53,268
Now we are going to say "get the environment".
Oh, actually this modified the environment

677
00:57:53,440 --> 00:57:57,234
OC: modify is from Control.Monad.State.

678
00:57:57,257 --> 00:58:00,845
JW: So env is going to be the modified environment.

679
00:58:00,868 --> 00:58:11,714
I'm going to say insert at name body and inside
environments, since that's the last parameter.

680
00:58:11,714 --> 00:58:16,080
Parsec again has its own keyword named State

681
00:58:17,542 --> 00:58:22,628
[John thinks].

682
00:58:23,177 --> 00:58:27,862
I need to getEnv.

683
00:58:29,417 --> 00:58:31,474
OC: Ah, because Env is a new type.

684
00:58:31,485 --> 00:58:32,525
JW: Right

685
00:58:32,560 --> 00:58:35,908
OC: We need to wrap it back up.

686
00:58:38,280 --> 00:58:45,771
Modify returns no value, yet we have been
saying things return as Double all the time.

687
00:58:49,200 --> 00:58:55,600
Yet this sub expression...
Let's say if a let is evaluated...

688
00:58:55,782 --> 00:58:58,457
Oh, Let has one more component doesn't it?

689
00:58:59,840 --> 00:59:04,045
It has the body over which the let ranges.

690
00:59:05,405 --> 00:59:10,148
OC: Which in this fairly simple
syntax, is just to the end of the file.

691
00:59:11,165 --> 00:59:13,394
JW: This is actually an imperative notion now.

692
00:59:13,410 --> 00:59:18,754
This is a statement with no result.
That has an effect on the environment.

693
00:59:18,800 --> 00:59:23,257
Which is not part of our evaluator.

694
00:59:23,440 --> 00:59:29,805
OC: Well, you could still put this in the evaluator
but then the evaluator could return Maybe Double

695
00:59:29,840 --> 00:59:33,794
Maybe running an expression doesn't give you any output.

696
00:59:34,000 --> 00:59:36,114
JW: That's one way we could do it.

697
00:59:36,148 --> 00:59:38,594
Let me think...

698
00:59:40,320 --> 00:59:44,057
OC: We could take the more functional approach

699
00:59:44,080 --> 00:59:47,931
and have the let binding
scope over the rest of the file.

700
00:59:47,954 --> 00:59:51,150
And every time you're introducing
a new let you're introducing some more scope,

701
00:59:51,165 --> 00:59:53,840
that extends to the end of the file.

702
00:59:53,840 --> 00:59:59,920
JW: I like that idea more, but for
now let's go with the Maybe idea.

703
01:00:01,410 --> 01:00:03,828
So in this case we have this.

704
01:00:04,171 --> 01:00:06,651
And here we'll have...

705
01:00:09,170 --> 01:00:13,348
These guys all become 'Justs'.

706
01:00:19,051 --> 01:00:21,302
Syntactic uniformity here...

707
01:00:24,160 --> 01:00:27,474
Ah, these things now...

708
01:00:27,880 --> 01:00:31,394
We're in the monad now.

709
01:00:35,520 --> 01:00:40,674
So for example if we were to say 1 plus let phi equal 10...

710
01:00:41,828 --> 01:00:45,382
Let's have a let be it's body.

711
01:00:45,410 --> 01:00:46,708
OC: Sure.

712
01:00:46,700 --> 01:00:48,068
JW: That makes more sense.

713
01:00:48,068 --> 01:00:49,177
OC: Yes.

714
01:00:49,170 --> 01:00:53,462
JW: We're still monadic here so I'm
going to rewrite this into monadic form.

715
01:00:53,490 --> 01:00:59,222
Now, in another language we would not
name names. I could have said this couldn't I?

716
01:00:59,240 --> 01:01:04,308
And it would have meant the
same thing, but can't do that in Haskell yet.

717
01:01:04,342 --> 01:01:08,388
OC: So that's the style of
banana brackets that you were referring to,

718
01:01:08,410 --> 01:01:12,457
which is still somewhat controversial in the Haskell community.

719
01:01:18,350 --> 01:01:25,062
Now I want to modify and
evaluate expression B and return that.

720
01:01:25,060 --> 01:01:31,794
(Silence).

721
01:01:32,110 --> 01:01:36,354
Ah, I do not need to return
because that is itself monadic.

722
01:01:36,422 --> 01:01:42,297
Now we need to pass in an environment
to our evaluator wherever we use it.

723
01:01:42,350 --> 01:01:46,628
So let's have a way of creating a new environment...

724
01:01:49,154 --> 01:01:53,062
And the new environment is going
to be a wrapper around empty

725
01:01:54,194 --> 01:01:56,960
which is going to conflict of course.

726
01:02:00,251 --> 01:02:09,160
We want to say with environment
and I'll say with new environment will be...

727
01:02:10,971 --> 01:02:16,240
"You give me an expression
and I will give you back a double".

728
01:02:19,154 --> 01:02:26,891
And [naudible] do this
I will say [inaudible] expression.

729
01:02:26,890 --> 01:02:55,165
(John mumbles as he types).

730
01:02:55,170 --> 01:02:57,300
OC: Do we really want that

731
01:02:57,300 --> 01:02:57,314
because you want to pass on this
mutated environment for every step of the REPL.
OC: Do we really want that

732
01:02:57,314 --> 01:03:03,565
because you want to pass on this
mutated environment for every step of the REPL.

733
01:03:03,588 --> 01:03:06,160
JW: This will be a top level function.

734
01:03:06,205 --> 01:03:08,662
OC: OK.

735
01:03:09,640 --> 01:03:14,274
JW: This is for people who are further
down and don't have to worry like this.

736
01:03:14,491 --> 01:03:20,651
So we're going to say
"with new environment"... or we're going to say eval.

737
01:03:21,302 --> 01:03:24,011
We're going to have a new function called eval.

738
01:03:33,580 --> 01:03:39,245
It underlines warnings in blue and
I generally tend to pay attention to them.

739
01:03:39,410 --> 01:03:40,940
I'm getting rid of redundancy.

740
01:03:42,000 --> 01:03:43,410
I don't need so much tracing.

741
01:03:43,882 --> 01:03:46,588
This seems like a good
opportunity to delete some.

742
01:03:48,110 --> 01:03:51,764
OC: Those warnings about
redundant brackets are coming from hlint?

743
01:03:53,050 --> 01:03:53,880
JW: Correct.

744
01:03:55,880 --> 01:03:57,290
I'm using flycheck which is

745
01:03:57,290 --> 01:04:00,580
talking to both GHC and hlint.

746
01:04:03,050 --> 01:04:05,640
That will give me a
more comprehensive picture.

747
01:04:06,350 --> 01:04:08,000
I have one warning left which is

748
01:04:08,000 --> 01:04:09,640
the import of token is redundant.

749
01:04:10,820 --> 01:04:11,640
So I will drop it.

750
01:04:15,050 --> 01:04:16,580
We did this to do let bindings.

751
01:04:17,176 --> 01:04:18,941
We still can't refer our variables.

752
01:04:20,117 --> 01:04:22,352
OC: Because we're
using a new environment.

753
01:04:22,705 --> 01:04:25,058
JW: So I need a new
thing which we'll call EVar,

754
01:04:26,700 --> 01:04:28,580
which will be a variable reference.

755
01:04:29,640 --> 01:04:31,640
I know how I want eval to be evaluated.

756
01:04:34,230 --> 01:04:36,350
I don't yet know how
I want it to be parsed.

757
01:04:40,230 --> 01:04:42,230
I'm going to get my environment and do:

758
01:05:03,640 --> 01:05:05,520
This is where I said we we're going to

759
01:05:05,520 --> 01:05:06,820
re-evaluate all the time.

760
01:05:12,230 --> 01:05:15,410
OC: This is because the look up has
returned an Expr.

761
01:05:15,410 --> 01:05:15,880
JW: Yes.

762
01:05:15,880 --> 01:05:18,000
And we're storing
expressions in our map.

763
01:05:20,110 --> 01:05:22,000
Because Haskell is a lazy language

764
01:05:22,940 --> 01:05:25,520
we want to get the map to have thunks in
it.

765
01:05:26,000 --> 01:05:28,230
So that the first time you touch the
thunk,

766
01:05:28,940 --> 01:05:31,410
only then will it do
the work of evaluating it.

767
01:05:32,000 --> 01:05:34,000
From then on it
will have that value.

768
01:05:34,350 --> 01:05:34,700
OC: OK.

769
01:05:35,290 --> 01:05:36,820
JW: we'll do that next.  Let's see.

770
01:05:39,050 --> 01:05:39,640
I need to:

771
01:05:43,170 --> 01:05:46,000
Now we have a way to
define and reference variables.

772
01:05:48,000 --> 01:05:49,640
We just need a way to parse them.

773
01:05:50,820 --> 01:05:53,410
Variable's going to be
a fundamental term again

774
01:05:56,110 --> 01:05:57,764
in addition to our let bindings.

775
01:05:58,705 --> 01:06:00,117
So we're going to have terms,

776
01:06:02,110 --> 01:06:03,058
and we'll call them:

777
01:06:10,470 --> 01:06:11,410
What is a variable?

778
01:06:16,470 --> 01:06:19,640
variable has the same definition as a
name.

779
01:06:30,940 --> 01:06:32,820
OC: So this is the same parser we used

780
01:06:32,820 --> 01:06:34,820
when we introduced a name in the let
binding.

781
01:06:35,290 --> 01:06:35,764
JW: Yes.

782
01:06:41,176 --> 01:06:42,117
Let's have our name...

783
01:06:52,230 --> 01:06:54,700
That way if we want
to update to alphanumerics

784
01:06:56,000 --> 01:06:57,882
we only have to change it in one place.

785
01:06:59,760 --> 01:07:00,470
Let's say:

786
01:07:15,050 --> 01:07:17,640
OC: So that no parse is
not coming from our parser.

787
01:07:17,640 --> 01:07:19,170
it's coming from our use of the

788
01:07:19,170 --> 01:07:20,580
read function somewhere.

789
01:07:21,410 --> 01:07:21,880
JW: Yes.

790
01:07:30,470 --> 01:07:31,640
We can use trace here.

791
01:07:34,580 --> 01:07:36,230
Actually, I don't need to do that

792
01:07:36,230 --> 01:07:37,760
because I have a key binding

793
01:07:39,760 --> 01:07:42,820
I use that auto inserts.

794
01:07:43,760 --> 01:07:45,050
I change it to be traces.

795
01:07:48,580 --> 01:07:50,470
I'm going to do this return at the end

796
01:07:50,470 --> 01:07:52,230
because trace has to yield a value.

797
01:07:56,350 --> 01:07:58,000
Sometimes I use printf more

798
01:07:58,000 --> 01:07:59,640
and sometimes I use trace more.

799
01:07:59,640 --> 01:08:01,290
I should have two variants of it.

800
01:08:05,050 --> 01:08:06,470
We never even get to our let.

801
01:08:08,820 --> 01:08:09,880
It's trying to parse...

802
01:08:17,880 --> 01:08:19,170
We get the same problem

803
01:08:19,170 --> 01:08:20,820
even if we just use the word let.

804
01:08:22,235 --> 01:08:23,176
(Big sigh from John)

805
01:08:27,520 --> 01:08:29,520
OC: We do have trace lines above which

806
01:08:29,520 --> 01:08:32,110
seem to indicate we
have gone into addop

807
01:08:32,110 --> 01:08:34,110
and mulop.

808
01:08:35,410 --> 01:08:37,640
JW: I just have to
prioritize let binding.

809
01:08:40,823 --> 01:08:42,117
This is what parsec does.

810
01:08:48,230 --> 01:08:50,470
It read in the first
letter of the word let.

811
01:08:51,520 --> 01:08:54,000
Found that it wasn't
a number in the num parser

812
01:08:54,580 --> 01:08:55,760
and said "this isn't me".

813
01:08:56,820 --> 01:08:58,820
Choice said, "OK whats the next parser,"

814
01:08:59,290 --> 01:09:00,700
but it didn't give back the L.

815
01:09:01,640 --> 01:09:02,820
So you have to use try

816
01:09:03,290 --> 01:09:04,940
as a wrapper around your parser

817
01:09:04,940 --> 01:09:06,700
if you want the input to be re wound

818
01:09:07,520 --> 01:09:10,110
to the beginning of
where your last parse failed.

819
01:09:10,110 --> 01:09:12,580
But since let begins
with a concrete key word

820
01:09:12,580 --> 01:09:14,350
that we're not going to be re-using

821
01:09:14,350 --> 01:09:15,290
as a variable name,

822
01:09:15,290 --> 01:09:17,411
it's safe for us to
promote that higher

823
01:09:17,410 --> 01:09:19,170
OC: Because no other expressions

824
01:09:19,170 --> 01:09:20,580
are going to use that word.

825
01:09:20,820 --> 01:09:21,520
JW: Right.

826
01:09:24,940 --> 01:09:27,880
because variable is going
to be a similar type of parser,

827
01:09:27,880 --> 01:09:29,050
let's wrap that as well.

828
01:09:40,700 --> 01:09:42,700
The REPL creates a new environment.

829
01:09:44,350 --> 01:09:46,940
So we want a different
type of test for this to use.

830
01:09:48,940 --> 01:09:50,110
Let me expand this out.

831
01:09:52,940 --> 01:09:55,410
We want to run this
forever loop within State.

832
01:10:01,647 --> 01:10:03,882
We're going to do
execStateT on this one.

833
01:10:04,580 --> 01:10:05,880
And we're going to flip it

834
01:10:06,350 --> 01:10:08,000
and do it with a new environment.

835
01:10:11,760 --> 01:10:12,700
Forever runs an IO,

836
01:10:15,640 --> 01:10:16,700
so we want to go here.

837
01:10:20,000 --> 01:10:21,764
OC: Forever should work on any monad.

838
01:10:22,000 --> 01:10:24,580
I think your problem
there was was the getLine

839
01:10:24,580 --> 01:10:26,350
is forcing you to be in the IO monad.

840
01:10:33,880 --> 01:10:34,820
So we get our input

841
01:10:36,000 --> 01:10:37,640
and we want to run our evaluator

842
01:10:40,580 --> 01:10:42,700
For that we're going
to have to parse it.

843
01:10:43,520 --> 01:10:45,520
I'm getting a lot
of duplication here.

844
01:10:47,050 --> 01:10:49,410
But for the time
being we'll just let it slide.

845
01:11:00,580 --> 01:11:02,110
We need to have our evaluator.

846
01:11:07,880 --> 01:11:09,640
We're going to get the environment

847
01:11:09,640 --> 01:11:10,940
and do a sub evaluation.

848
01:11:35,410 --> 01:11:37,290
OC: Sounds like it should be possible

849
01:11:37,640 --> 01:11:39,760
to do that without
having to runState.

850
01:11:41,760 --> 01:11:43,050
JW: This StateT is over IO,

851
01:11:44,350 --> 01:11:45,880
and our function is a StateT

852
01:11:45,880 --> 01:11:47,050
that's over Identity.

853
01:11:48,350 --> 01:11:52,000
We could use the mmorph library's hoist
routine.

854
01:11:52,940 --> 01:11:54,350
To swap out between the two.

855
01:12:01,640 --> 01:12:02,940
We're going to say:

856
01:12:26,580 --> 01:12:28,470
We're going to go from Identity to IO.

857
01:12:33,880 --> 01:12:35,760
It should be just a matter of return.

858
01:12:52,110 --> 01:12:54,230
getLine is still will forcing us into the
wrong monad.

859
01:13:02,820 --> 01:13:05,050
OC: You might have
Data.Text.IO.getLine

860
01:13:07,050 --> 01:13:08,352
that you avoid packing.

861
01:13:19,290 --> 01:13:21,294
OC: And you have got T.readFile here.

862
01:13:41,050 --> 01:13:42,941
OC: Another problem is execState is

863
01:13:43,170 --> 01:13:45,411
apparently going to give you back the
file.

864
01:14:00,580 --> 01:14:03,170
JW: execState is giving us back a...

865
01:14:17,640 --> 01:14:20,000
It's losing the sense
of what monad we're in.

866
01:14:42,580 --> 01:14:44,940
Oh I always get a
surprise when that type checks!

867
01:14:44,940 --> 01:14:47,050
I didn't think that
hoist line was right

868
01:14:47,760 --> 01:14:48,700
but I guess it was.

869
01:14:49,290 --> 01:14:51,050
OC: You were pretty quick so maybe

870
01:14:51,050 --> 01:14:53,764
you were running ahead
of your flycheck again!

871
01:14:54,000 --> 01:14:55,170
JW: So we have 1 plus 4.

872
01:14:56,117 --> 01:14:57,529
We have let phi equals 20.

873
01:14:58,110 --> 01:14:59,529
Now I should be able to say

874
01:14:59,647 --> 01:15:00,941
phi plus 5 and I get no parse.

875
01:15:03,760 --> 01:15:06,000
we have been
stricken by this num parser

876
01:15:06,940 --> 01:15:09,058
OC: So maybe we can just do the same
trick twice

877
01:15:11,290 --> 01:15:12,588
JW: Well it's worth trying,

878
01:15:14,230 --> 01:15:16,470
So we can define
and reference variables.

879
01:15:20,230 --> 01:15:22,000
Now we want the ability to define

880
01:15:22,110 --> 01:15:24,350
not just sub
expressions, but functions.

881
01:15:25,170 --> 01:15:26,110
Before we do that

882
01:15:26,230 --> 01:15:27,410
I want to do this trick

883
01:15:27,410 --> 01:15:29,520
where we do not
re-evaluate expressions.

884
01:15:32,470 --> 01:15:33,760
We want our map to be a map

885
01:15:35,760 --> 01:15:36,820
of names to doubles.

886
01:15:38,820 --> 01:15:40,350
And the reason we can do that

887
01:15:40,352 --> 01:15:42,000
is because they are constants.

888
01:15:42,580 --> 01:15:44,700
They can only
ever refer other things

889
01:15:44,820 --> 01:15:46,110
inside the environment.

890
01:15:46,110 --> 01:15:48,580
So here, instead of
inserting our expression,

891
01:15:49,410 --> 01:15:51,410
into the map we we are going to insert...

892
01:15:56,700 --> 01:15:58,580
Oh I have to evaluate that outside.

893
01:16:00,352 --> 01:16:02,000
OC: Because that might refer to

894
01:16:02,000 --> 01:16:04,000
previously bound variables.

895
01:16:06,820 --> 01:16:09,290
This is not using any kind of laziness type trick

896
01:16:10,350 --> 01:16:12,230
it's just evaluating at that moment.

897
01:16:13,290 --> 01:16:15,640
OC: Should we change that last evalExpr b
as well

898
01:16:15,640 --> 01:16:16,820
to just return B prime.

899
01:16:21,880 --> 01:16:23,050
JW: Let's check this in.

900
01:16:25,640 --> 01:16:27,290
We can now define and reference.

901
01:16:31,520 --> 01:16:33,880
Now let's see if we can
parse this in our test.

902
01:16:37,520 --> 01:16:39,640
OC: I imagine we're
going to get a problem

903
01:16:39,640 --> 01:16:40,940
looking up square root.

904
01:16:43,410 --> 01:16:44,230
That's my guess.

905
01:16:45,640 --> 01:16:47,410
JW: Unknown variable square root.

906
01:16:49,760 --> 01:16:51,410
We have no way of defining functions yet.

907
01:16:52,000 --> 01:16:54,700
OC: We do seem to have
a couple of loop regressions.

908
01:16:55,170 --> 01:16:56,000
Oh, look at that...

909
01:16:59,520 --> 01:17:01,176
we're losing the sense of lines

910
01:17:01,290 --> 01:17:03,050
because we're chopping things up.

911
01:17:05,050 --> 01:17:06,700
So we got two but we didn't get 30

912
01:17:07,170 --> 01:17:09,294
Let's do this now
ourselves, at the REPL.

913
01:17:12,110 --> 01:17:14,230
We definitely have a regression there.

914
01:17:19,290 --> 01:17:22,110
I don't think division
is being handled correctly.

915
01:17:26,940 --> 01:17:29,411
I have a feeling that
if it's any other operator

916
01:17:29,640 --> 01:17:30,470
it will be fine.

917
01:17:30,470 --> 01:17:31,760
Yes, so it's just division.

918
01:17:35,760 --> 01:17:38,230
OC: We maybe forgot
to put a line in our parser.

919
01:18:06,000 --> 01:18:07,520
OC: Is it because we should be using

920
01:18:07,520 --> 01:18:08,940
symbol rather than string.

921
01:18:08,940 --> 01:18:10,110
JW: Of course that's why.

922
01:18:10,470 --> 01:18:11,050
Thank you.

923
01:18:13,050 --> 01:18:14,110
Yes now we have it.

924
01:18:18,110 --> 01:18:20,230
OC: So I  guess we
go back to that read file.

925
01:18:23,640 --> 01:18:26,820
we have all of our current lines
no square root

926
01:18:28,000 --> 01:18:29,520
JW: I guess you we're expecting

927
01:18:29,520 --> 01:18:30,820
that to be from a library?

928
01:18:34,110 --> 01:18:36,230
There's a prelude in
scope and I assumed...

929
01:18:36,580 --> 01:18:38,230
JW: Let's call it double instead,

930
01:18:39,170 --> 01:18:40,588
and let's say that double...

931
01:18:41,640 --> 01:18:44,000
Let's see what the
syntax for functions was.

932
01:18:52,230 --> 01:18:53,640
Now we need to define that.

933
01:18:54,580 --> 01:18:56,350
As usual I like to start by looking

934
01:18:56,350 --> 01:18:57,520
at my expression tree.

935
01:19:01,410 --> 01:19:02,940
This is a lot like a let binding,

936
01:19:04,470 --> 01:19:06,700
it's just one that
needs input parameters.

937
01:19:09,880 --> 01:19:11,170
This is like saying this:

938
01:19:17,290 --> 01:19:20,000
We have an expression
that's a lambda abstraction

939
01:19:21,410 --> 01:19:22,940
and we want to define double

940
01:19:22,940 --> 01:19:24,470
to be that lambda abstraction.

941
01:19:25,880 --> 01:19:27,640
So we'll call that ELam.

942
01:19:28,470 --> 01:19:30,230
At the moment we're going to allow

943
01:19:30,230 --> 01:19:32,350
that lambda to
take just one variable.

944
01:19:34,230 --> 01:19:35,760
OC: Yes, that's all that happens

945
01:19:35,760 --> 01:19:37,050
in these little example scripts.

946
01:19:37,050 --> 01:19:38,820
You can assume that these are all

947
01:19:38,820 --> 01:19:40,350
functions over one variable.

948
01:19:40,700 --> 01:19:41,290
JW: Right.

949
01:19:41,640 --> 01:19:43,520
So that variable is going to itself

950
01:19:46,700 --> 01:19:48,000
evaluate down to a value.

951
01:19:49,760 --> 01:19:50,230
OC: Yes,

952
01:19:50,230 --> 01:19:51,520
JW: So we can have our lambda

953
01:19:53,520 --> 01:19:54,940
be a host language lambda.

954
01:19:59,410 --> 01:20:00,940
Of expression to expression.

955
01:20:00,940 --> 01:20:02,700
OC: Why expression to expression

956
01:20:02,700 --> 01:20:04,230
and not double to expression?

957
01:20:06,940 --> 01:20:08,580
JW: Because it's a lambda in there

958
01:20:08,580 --> 01:20:10,820
and this would be
the higher order abstract syntax

959
01:20:11,520 --> 01:20:13,520
where we're using
the host language's

960
01:20:14,940 --> 01:20:17,290
ability to represent
functions as values..

961
01:20:18,470 --> 01:20:20,230
In order for our target language

962
01:20:22,000 --> 01:20:23,764
to represent functions as values.

963
01:20:24,110 --> 01:20:25,640
That's the higher order nature.

964
01:20:26,470 --> 01:20:28,110
There can be no automatically

965
01:20:28,110 --> 01:20:29,880
derived Show instance for these.

966
01:20:30,110 --> 01:20:31,410
This is the tedious part

967
01:20:31,410 --> 01:20:33,410
where we have to do a lot of boilerplate.

968
01:20:36,470 --> 01:20:37,880
We have to say for every one

969
01:20:38,940 --> 01:20:39,760
of these things...

970
01:20:43,880 --> 01:20:45,290
I need to say what it means

971
01:20:45,290 --> 01:20:46,230
to print that out.

972
01:20:48,230 --> 01:20:50,000
So I'm going to say what that means.

973
01:20:50,820 --> 01:20:52,580
OC: Do we still need Show instance?

974
01:20:53,410 --> 01:20:55,170
We could just drop that I suppose.

975
01:20:58,000 --> 01:21:00,350
JW: True, but it comes
in handy for debugging

976
01:21:10,700 --> 01:21:12,350
Lambda is not going to be there.

977
01:21:58,110 --> 01:22:01,760
It's not the show it's complaining about
it's the fact that this has to be monoid.

978
01:22:08,580 --> 01:22:10,700
Pretty soon this is going to be 300 lines

979
01:22:11,640 --> 01:22:13,290
as usually happens in Haskell!

980
01:22:13,290 --> 01:22:15,290
OC: but we do want to be working
with strings here right?

981
01:22:15,290 --> 01:22:17,410
because show is
defined as a function

982
01:22:17,520 --> 01:22:18,940
from something to string.

983
01:22:18,940 --> 01:22:20,000
JW: You're right.

984
01:22:31,760 --> 01:22:33,520
OC: I think we're OK using show.

985
01:22:34,941 --> 01:22:37,529
Oh yes! because we're
defining a Show instance.

986
01:22:38,000 --> 01:22:40,235
Yes, so we want
unpack in these two places.

987
01:22:45,050 --> 01:22:46,230
JW: Now I have my lambda.

988
01:22:48,230 --> 01:22:49,760
The first thing is to decide

989
01:22:49,760 --> 01:22:51,170
how I'm going to evaluate it.

990
01:22:52,230 --> 01:22:54,350
Before I go on to how
I'm going to parse it.

991
01:22:56,350 --> 01:22:58,000
So I get my lambda, and I have an F

992
01:22:59,410 --> 01:23:00,580
and now I'm going to say:

993
01:23:12,700 --> 01:23:13,760
I need a double.

994
01:23:14,940 --> 01:23:18,820
I need a body for my lambda

995
01:23:22,000 --> 01:23:24,235
I need to define
what application means.

996
01:23:24,230 --> 01:23:25,882
What it means to call a function.

997
01:23:26,000 --> 01:23:27,640
That's how it gets its argument.

998
01:23:29,170 --> 01:23:31,410
Application takes a
form and an argument.

999
01:23:36,700 --> 01:23:38,230
And we're going to show that as...

1000
01:23:46,230 --> 01:23:47,880
OC: Is F here going to be the name

1001
01:23:48,940 --> 01:23:50,350
of the lambda abstraction?

1002
01:23:51,410 --> 01:23:51,880
JW: Yes

1003
01:23:54,820 --> 01:23:56,941
We'll restrict it to
being nothing fancy

1004
01:23:57,410 --> 01:23:59,290
like an expression that evaluates

1005
01:24:01,290 --> 01:24:03,647
to a lambda that can
be passed as an argument.

1006
01:24:03,880 --> 01:24:05,410
That would be cool but for now

1007
01:24:05,760 --> 01:24:08,000
we'll have functions be only
referenceable by name.

1008
01:24:11,520 --> 01:24:12,941
So we have EApp be a name

1009
01:24:14,823 --> 01:24:17,411
and the argument is
going to be the expression.

1010
01:24:17,411 --> 01:24:18,823
So we only allow one argument.

1011
01:24:19,880 --> 01:24:20,820
We want unpack n.

1012
01:24:29,170 --> 01:24:30,110
We'll say:

1013
01:24:43,290 --> 01:24:44,470
Then look up in the map...

1014
01:24:58,470 --> 01:25:00,470
We can't store just doubles in our map.

1015
01:26:12,820 --> 01:26:14,000
Evaluating a lambda.

1016
01:26:20,230 --> 01:26:23,050
There should be no
context in which it's evaluating.

1017
01:26:25,050 --> 01:26:26,580
OC: That's basically a type error.

1018
01:26:26,580 --> 01:26:28,580
in our little language

1019
01:27:04,470 --> 01:27:06,470
Now we need a way to define these two things

1020
01:27:07,170 --> 01:27:09,647
OC: There's a little
more syntax to bring in here

1021
01:27:10,350 --> 01:27:11,760
We had that binding before,

1022
01:27:11,760 --> 01:27:13,520
now we're going to have fun binding.

1023
01:27:17,410 --> 01:27:19,880
OC: We're already having
fun binding. (laughter).

1024
01:27:26,580 --> 01:27:28,110
So we want the symbol define.

1025
01:27:30,110 --> 01:27:32,000
We want the name and the open parens

1026
01:27:35,050 --> 01:27:36,941
We want also, the argument to be a name.

1027
01:27:43,640 --> 01:27:45,170
Then we want closing parens,

1028
01:27:46,350 --> 01:27:47,880
and then open curly (laughter).

1029
01:27:51,050 --> 01:27:53,410
And then we can
have up to many expressions

1030
01:27:57,520 --> 01:27:58,940
in the body of the function.

1031
01:28:01,640 --> 01:28:03,290
Now, expressions that could end

1032
01:28:05,880 --> 01:28:06,580
in newlines.

1033
01:28:11,290 --> 01:28:13,050
And there is a thing we can use from

1034
01:28:15,050 --> 01:28:16,470
parser called text sepBy.

1035
01:28:20,580 --> 01:28:21,640
So we want sepBy1.

1036
01:28:24,350 --> 01:28:25,760
OC: So that parses at least one expression

1037
01:28:27,760 --> 01:28:29,170
that is separated by new lines.

1038
01:28:29,170 --> 01:28:30,000
JW: Right.

1039
01:28:32,000 --> 01:28:32,820
This is our body.

1040
01:28:34,820 --> 01:28:35,760
And now we're going to return ELam

1041
01:28:38,230 --> 01:28:40,000
We want a function that's going to

1042
01:28:40,000 --> 01:28:41,640
take in some number and return...

1043
01:28:47,050 --> 01:28:48,580
Let me ask you this question:

1044
01:28:50,110 --> 01:28:51,760
What if we evaluate a function

1045
01:28:52,940 --> 01:28:54,350
that has let bindings in it?

1046
01:28:54,350 --> 01:28:56,580
Those let bindings should
probably not escape

1047
01:28:56,940 --> 01:28:58,580
outside of the function should they?

1048
01:28:58,580 --> 01:29:00,470
And every time you run the function,

1049
01:29:01,050 --> 01:29:03,050
it should renew the let bindings.

1050
01:29:05,760 --> 01:29:08,580
JW: So a function is not
going to return an expression.

1051
01:29:09,880 --> 01:29:11,760
An expression is going to be a mutator

1052
01:29:11,760 --> 01:29:13,050
from doubles to doubles.

1053
01:29:16,350 --> 01:29:18,580
But, we want it to
inherit the environment.

1054
01:29:22,000 --> 01:29:23,760
that it was executed in each time.

1055
01:29:23,760 --> 01:29:26,820
OC: So we can refer to let bindings
outside the function definition.

1056
01:29:31,170 --> 01:29:33,760
So instead of using
something as fancy as reader,

1057
01:29:34,470 --> 01:29:37,050
we're going to take in
environment as an argument.

1058
01:29:37,050 --> 01:29:37,640
OC: Sure.

1059
01:29:40,700 --> 01:29:43,290
JW: We have our env

1060
01:29:44,230 --> 01:29:45,290
JW: We're going to say:

1061
01:30:00,110 --> 01:30:01,410
Oh, we can bind our name to...

1062
01:30:04,000 --> 01:30:06,470
OC: So we put that
double into the environment.

1063
01:30:06,470 --> 01:30:07,170
JW: Right.

1064
01:30:08,230 --> 01:30:09,170
We have to say:
"insert at arg"

1065
01:30:27,880 --> 01:30:28,940
It can't just be that.

1066
01:30:29,760 --> 01:30:31,880
OC: We need to wrap
it up as an expression.

1067
01:30:40,940 --> 01:30:44,000
And then this has to be getEnv
and then rewrapped.
Because type-wrapping is just as much
fun as you expect it to be.

1068
01:30:51,176 --> 01:30:53,411
Eval state T
returns an identity double.

1069
01:30:55,290 --> 01:30:56,705
Then arg is the wrong thing.

1070
01:30:59,880 --> 01:31:01,410
It is not the body expression.

1071
01:31:02,940 --> 01:31:04,580
Now we want to sequence through.

1072
01:31:08,000 --> 01:31:09,520
We want to fold down the body.

1073
01:31:11,520 --> 01:31:13,290
OC: You would probably be alright

1074
01:31:16,235 --> 01:31:18,823
taking the last value
of the expression for now.

1075
01:31:19,520 --> 01:31:21,170
JW: I need to evaluate every one

1076
01:31:22,470 --> 01:31:25,170
so that any internal
let bindings get established.

1077
01:31:25,170 --> 01:31:25,880
OC: Right, OK.

1078
01:31:31,880 --> 01:31:33,290
We're going to bind this in.

1079
01:31:35,170 --> 01:31:36,940
I'm going to do a flip binding here.

1080
01:31:40,470 --> 01:31:41,880
And then fold M inside here.

1081
01:31:45,640 --> 01:31:48,230
It's going to go from
environment to environment.

1082
01:31:49,520 --> 01:31:50,940
For every body expression.

1083
01:31:52,940 --> 01:31:54,820
Folding down from the environment

1084
01:31:54,820 --> 01:31:55,640
over the body.

1085
01:32:00,700 --> 01:32:02,000
So Env, expected type Double.

1086
01:32:13,640 --> 01:32:15,880
And fold M has the
accumulator on the left.

1087
01:32:23,640 --> 01:32:25,170
I don't need to fold M that way.

1088
01:32:32,350 --> 01:32:33,170
We're going to pass in a double

1089
01:32:34,470 --> 01:32:35,410
As it thinks I need.

1090
01:32:38,110 --> 01:32:40,230
And we're going to
ignore it in each step.

1091
01:32:41,640 --> 01:32:44,588
OC: So we're just taking
the last double that's produced.

1092
01:32:44,588 --> 01:32:45,882
JW: Right, and then we need

1093
01:32:45,882 --> 01:32:47,176
the right identity here.

1094
01:32:49,760 --> 01:32:51,050
OC: Cool, everything typechecks?

1095
01:32:54,580 --> 01:32:57,290
JW: No! Now the functions
are differently expressed.

1096
01:32:59,290 --> 01:33:01,520
Function application
now has to hand in

1097
01:33:01,520 --> 01:33:02,940
the current environment.

1098
01:33:04,000 --> 01:33:04,940
Which makes sense.

1099
01:33:08,940 --> 01:33:13,050
Couldn't match expected type
first argument.

1100
01:33:14,580 --> 01:33:16,580
This is now just going to be the value
we wanted, so we can just return it.

1101
01:33:22,820 --> 01:33:23,640
It type checked!
OC: [Laughs]
JC: I continue to be
perhaps incorrectly amazed.

1102
01:33:36,350 --> 01:33:38,230
I don't like excessively long lines.

1103
01:33:43,520 --> 01:33:45,290
OK, let's try this out with test file.

1104
01:33:46,820 --> 01:33:48,110
Unknown variable, fine.

1105
01:33:50,580 --> 01:33:52,230
We haven't tied it in yet so we need:
letBinding followed by funBinding.

1106
01:33:56,000 --> 01:33:57,290
What else did we define?

1107
01:33:57,290 --> 01:33:58,700
We need to do application.

1108
01:34:01,290 --> 01:34:02,820
A naked variable reference

1109
01:34:03,170 --> 01:34:04,940
could be a variable reference or

1110
01:34:04,940 --> 01:34:06,350
it could be a function call.

1111
01:34:09,640 --> 01:34:11,170
OC: I think all function calls

1112
01:34:11,170 --> 01:34:13,410
are a variable name immediately
followed by parentheses

1113
01:34:14,470 --> 01:34:16,230
with no white space between them.

1114
01:34:16,230 --> 01:34:16,820
JW:  Right.

1115
01:34:17,760 --> 01:34:19,760
So we're going to try to parse a funCall.

1116
01:34:27,880 --> 01:34:30,000
Because if there is
no paren after that,

1117
01:34:32,000 --> 01:34:33,520
we'll back track all the way up.

1118
01:34:42,110 --> 01:34:44,350
We want the name of
the function to come in.

1119
01:34:48,820 --> 01:34:51,290
And then we're going to look for this guy
except instead of parsing a varname,

1120
01:34:51,290 --> 01:34:53,290
we're going to parse a sub-expression.

1121
01:34:53,290 --> 01:34:54,470
Then we're going to say: return that
as an application of name to arg.

1122
01:35:07,640 --> 01:35:11,760
"Type error says Ollie!"
OC: [Laughs] Well I didn't say it but...

1123
01:35:11,760 --> 01:35:13,410
So we tried to evaluate a lambda

1124
01:35:13,880 --> 01:35:16,110
because we put a
lambda in our syntax tree

1125
01:35:18,940 --> 01:35:19,880
Why did we do that?

1126
01:35:24,110 --> 01:35:26,470
Oh that's right, what
does define evaluate to.

1127
01:35:27,760 --> 01:35:30,000
It evaluates to the
body of the function.

1128
01:35:30,820 --> 01:35:31,760
Which is a lambda.

1129
01:35:32,470 --> 01:35:34,000
In that case we're going to say

1130
01:35:34,820 --> 01:35:36,580
that functions evaluate to zero.

1131
01:35:44,940 --> 01:35:46,470
That just did not work at all.

1132
01:35:51,290 --> 01:35:52,940
OC: We have a zero from our define.

1133
01:35:53,520 --> 01:35:55,050
I guess the error is on the let.

1134
01:35:55,640 --> 01:35:57,520
JW: Yes, let me put some
boundary on there.

1135
01:35:59,170 --> 01:36:00,700
OC: so you're now tracing
in our language!

1136
01:36:01,520 --> 01:36:03,294
JW: Yes! I see the two, three and zero.

1137
01:36:04,940 --> 01:36:05,640
We defined it.

1138
01:36:07,170 --> 01:36:09,640
So it's the call that
we're having a problem with.

1139
01:36:11,640 --> 01:36:12,820
expecting define...

1140
01:36:12,820 --> 01:36:15,050
OC: Ah, so I think the problem here
is our function name

1141
01:36:16,110 --> 01:36:16,940
starts with a D.

1142
01:36:17,880 --> 01:36:19,640
And when it sees D it assumes
that it must be going to...
JW: Oh right!

1143
01:36:24,700 --> 01:36:26,700
OC: We'll probably have to try unbinding.

1144
01:36:32,110 --> 01:36:33,640
JW: Unknown function double.

1145
01:36:34,940 --> 01:36:37,170
OC: But we did just
define a function double.

1146
01:36:37,170 --> 01:36:38,000
JW: Yes, right.

1147
01:36:41,520 --> 01:36:43,290
We need to go to define and find out

1148
01:36:46,230 --> 01:36:48,110
why it did not get
inserted into the environment

1149
01:36:52,820 --> 01:36:53,760
Ah, that's what it is.

1150
01:36:54,820 --> 01:36:56,000
OC: Define gave us Elam...

1151
01:36:56,820 --> 01:36:58,580
JW: And the blue line is telling us

1152
01:36:58,580 --> 01:37:00,230
"your not doing anything with name".

1153
01:37:03,764 --> 01:37:04,700
Elam needs to have:

1154
01:37:07,640 --> 01:37:09,294
Just as let did, Elam needs a name.

1155
01:37:14,470 --> 01:37:16,941
Now when we go, we won't just
have Ollie's type error

1156
01:37:24,470 --> 01:37:27,050
Now we need something
new to go into our map, right?

1157
01:37:27,880 --> 01:37:29,410
We can just put ELam in there.

1158
01:37:30,580 --> 01:37:31,640
So we're going to say:

1159
01:37:33,640 --> 01:37:35,290
OC: It's exactly the same as ELet

1160
01:37:35,880 --> 01:37:37,760
but without the evaluation I guess.
JC: Right. It's just going to return 0.
OC: Bit of a hack, but oh well!

1161
01:38:01,170 --> 01:38:02,820
Elam should have two arguments.

1162
01:38:03,170 --> 01:38:05,760
Oh! The Show-er

1163
01:38:06,700 --> 01:38:07,640
We're going to say:
I like the way Lisp does it.

1164
01:38:24,350 --> 01:38:26,000
Yehey! Unknown function double.

1165
01:38:26,820 --> 01:38:29,410
This is where we put in
a little bit of our tracing.

1166
01:38:50,940 --> 01:38:52,820
It never showed it, so we get to there...

1167
01:38:55,290 --> 01:38:56,230
We must have done...

1168
01:38:58,230 --> 01:38:59,520
Oh, nobody used the value,

1169
01:39:00,000 --> 01:39:01,520
that's why the trace didn't get...

1170
01:39:02,700 --> 01:39:04,470
Since no one is forcing the value

1171
01:39:04,580 --> 01:39:07,050
that means the insert
is not happening either.

1172
01:39:10,470 --> 01:39:11,880
If it's just returning zero

1173
01:39:12,820 --> 01:39:15,410
it can elide out the rest.

1174
01:39:16,350 --> 01:39:18,000
OC: But we're in a monad, so it
should be forcing us to be [inaudible].

1175
01:39:18,000 --> 01:39:19,050
JW:  Your right.

1176
01:39:22,110 --> 01:39:25,050
OC: Maybe in our function
that reads from the file

1177
01:39:26,820 --> 01:39:28,940
we could print the environment
after every step.

1178
01:39:28,940 --> 01:39:30,235
JW: Oh! Is that our problem?

1179
01:39:32,705 --> 01:39:35,058
OC: Yes, the file doesn't
do what the REPL does.

1180
01:39:36,470 --> 01:39:37,290
JW: Ah, thank you.

1181
01:39:40,470 --> 01:39:42,110
In the file parser we need to do

1182
01:39:42,580 --> 01:39:44,820
the exact same thing
we we're doing before

1183
01:39:46,110 --> 01:39:46,700
Which is: to call...
Let's just copy and paste.

1184
01:40:06,588 --> 01:40:07,529
That did not work.

1185
01:40:19,290 --> 01:40:20,700
For every line in the input,

1186
01:40:20,700 --> 01:40:21,640
we parse the line,

1187
01:40:24,110 --> 01:40:25,760
and execute it within our state.

1188
01:40:26,820 --> 01:40:28,000
and print the result.

1189
01:40:33,880 --> 01:40:36,470
OC: Can we just flip back
to the error we had again.

1190
01:40:36,470 --> 01:40:38,470
JW: Now we have a much different error.

1191
01:40:40,470 --> 01:40:41,410
we have regressed.

1192
01:40:44,110 --> 01:40:45,529
Let me see what version of

1193
01:40:45,520 --> 01:40:47,294
the code we were using previously.

1194
01:41:17,760 --> 01:41:20,350
Oh, the massager!
We're not using the massager.

1195
01:41:21,640 --> 01:41:24,230
So I'm going to go
ahead and use the view patterns.

1196
01:41:26,820 --> 01:41:29,410
OC: So view patterns
here let us call a function

1197
01:41:29,410 --> 01:41:30,820
before binding a variable.

1198
01:41:31,170 --> 01:41:31,640
JW: Yes.

1199
01:41:31,640 --> 01:41:35,170
I could just do this. That's actually
a silly use of view patterns.

1200
01:41:40,000 --> 01:41:41,760
Except that it's going to be a Maybe.

1201
01:41:45,290 --> 01:41:47,410
So we have to lift one level out and say:
if it's Nothing, do nothing
otherwise we have some String.

1202
01:41:56,470 --> 01:41:58,000
OC: We could use forM_ again there.

1203
01:41:59,050 --> 01:42:00,470
You can use forM_ over a maybe.

1204
01:42:01,290 --> 01:42:03,170
I think we have to use data.foldable

1205
01:42:09,640 --> 01:42:12,000
which in real world projects
that's exactly what I do.

1206
01:42:15,410 --> 01:42:18,230
Look at that! We evaled it.
OC: Wonderful.

1207
01:42:20,110 --> 01:42:21,529
JC: So we have Phi equaling
1 plus double...

1208
01:42:24,470 --> 01:42:25,640
We even have an error.

1209
01:42:26,820 --> 01:42:28,350
We are missing a parenthesis

1210
01:42:28,350 --> 01:42:30,110
and yet we didn't get a syntax there.
OC: [Laughs]

1211
01:42:31,410 --> 01:42:33,760
JC: Let me see what
happens if I do that directly.

1212
01:42:38,820 --> 01:42:40,230
Might as well do it this way.

1213
01:42:41,640 --> 01:42:42,580
Ah! the parse stops.

1214
01:42:46,820 --> 01:42:48,470
Because it has reached a token

1215
01:42:48,470 --> 01:42:50,000
it doesn't recognise, it ends.

1216
01:42:50,700 --> 01:42:53,520
Other parsers like Trifecta,

1217
01:42:54,230 --> 01:42:55,520
I could coax it to tell me

1218
01:42:55,520 --> 01:42:57,410
what the remainder of the input was.

1219
01:42:57,410 --> 01:42:59,290
I don't know how that's done in parsec

1220
01:42:59,760 --> 01:43:02,350
and I don't think we
should worry about it just now.

1221
01:43:11,760 --> 01:43:13,170
We can restrict our parser

1222
01:43:13,170 --> 01:43:14,940
on the line by line parser and say

1223
01:43:14,940 --> 01:43:16,470
we want it to terminate at EOF.

1224
01:43:21,050 --> 01:43:23,410
OC: So that requires that we
successfully parse a line?

1225
01:43:25,410 --> 01:43:27,050
JW:  Right, so now I get unexpected.

1226
01:43:27,640 --> 01:43:29,640
Of course the line numbers are all off,

1227
01:43:29,640 --> 01:43:31,290
because we do this line by line.

1228
01:43:34,820 --> 01:43:35,640
There we go!

1229
01:43:40,000 --> 01:43:41,290
5 times 5 is 25 OK,

1230
01:43:42,000 --> 01:43:43,640
So 26 divided by 2 should be 13.
Alright!

1231
01:43:46,350 --> 01:43:48,940
I would say that's a
good place for us to check in.
Function definitions and calling now work.

1232
01:44:00,230 --> 01:44:00,940
OC: Awesome!

1233
01:44:07,410 --> 01:44:10,000
OC: Now we're getting
near the end of the session,

1234
01:44:10,000 --> 01:44:11,290
I wonder if we might try

1235
01:44:11,290 --> 01:44:13,410
to implement that Fibonacci function.

1236
01:44:13,760 --> 01:44:15,520
It's in one of these example files.

1237
01:44:17,050 --> 01:44:19,050
We should only need to redefine phi,

1238
01:44:21,640 --> 01:44:23,760
but we do need
a square root operation.

1239
01:44:23,760 --> 01:44:25,410
Maybe we could introduce that

1240
01:44:25,410 --> 01:44:27,050
as a primitive in the language.

1241
01:44:27,520 --> 01:44:29,640
That should allow
us to get all the way

1242
01:44:29,640 --> 01:44:31,050
to the bottom of this file.

1243
01:44:32,000 --> 01:44:33,880
JW: We should be able to do that easily.

1244
01:44:34,352 --> 01:44:36,340
Because we chose the higher order

1245
01:44:36,350 --> 01:44:37,764
abstract syntax notation.

1246
01:44:38,350 --> 01:44:40,350
That makes it easier for us to inject

1247
01:44:44,940 --> 01:44:47,290
what we would call built-ins
into our language.

1248
01:44:47,880 --> 01:44:49,050
All we need then is a parser

1249
01:44:51,520 --> 01:44:52,470
and we're going to have an option...

1250
01:44:53,050 --> 01:44:54,230
Let's extend funCall.

1251
01:44:55,290 --> 01:44:56,235
FunCall will say:
if name is 'sqrt'...

1252
01:45:08,230 --> 01:45:10,350
I don't want to
do it at call point, sorry.

1253
01:45:13,050 --> 01:45:15,520
I want to do it when
we define the environment.

1254
01:45:16,700 --> 01:45:17,760
So new environment.

1255
01:45:19,290 --> 01:45:20,940
Instead of having an empty map

1256
01:45:20,940 --> 01:45:22,230
we want a map where we can

1257
01:45:23,410 --> 01:45:24,700
insert into square root.

1258
01:45:40,700 --> 01:45:42,940
And we need to do this on an empty map.

1259
01:45:43,760 --> 01:45:45,290
We can call this a singleton.

1260
01:45:45,290 --> 01:45:55,882
See I have hlint down here suggesting
that I could say const sqrt because

1261
01:45:56,470 --> 01:45:58,000
I'm ignoring that parameter.

1262
01:45:58,000 --> 01:46:00,000
I still have an error, saying
I'm not using that language pragma.

1263
01:46:04,470 --> 01:46:05,170
Now we can say:

1264
01:46:10,350 --> 01:46:11,410
OC: Excellent.

1265
01:46:11,647 --> 01:46:13,058
JW: If we go over to our file,

1266
01:46:13,764 --> 01:46:15,176
and we see now that we have,

1267
01:46:16,470 --> 01:46:19,176
(I was doing a lot of
work in this little scratch file)

1268
01:46:19,176 --> 01:46:20,235
Phi should be fine.

1269
01:46:20,700 --> 01:46:22,350
Oh! we have a power operator here,

1270
01:46:24,350 --> 01:46:26,110
raising something to an exponent.

1271
01:46:26,110 --> 01:46:27,640
We need to quickly add that in.

1272
01:46:29,050 --> 01:46:30,820
It's rather like a multiplication.

1273
01:46:30,820 --> 01:46:33,050
OC: You can have
the same precedence there.

1274
01:46:33,050 --> 01:46:34,117
JW: We're going to say:

1275
01:46:39,050 --> 01:46:40,940
We'll use that as the same precedence.

1276
01:46:48,230 --> 01:46:50,820
We have now reached
a certain level of maturity

1277
01:46:50,820 --> 01:46:53,050
where we can drop
tracing from our parser

1278
01:47:07,640 --> 01:47:10,350
wherever EMul was

1279
01:47:21,520 --> 01:47:23,290
Is that appropriate for doubles?

1280
01:47:23,760 --> 01:47:24,700
I'll just check.

1281
01:47:33,760 --> 01:47:35,640
I will take a look at this file again.

1282
01:47:40,940 --> 01:47:42,700
Do you really want the return keyword?

1283
01:47:42,700 --> 01:47:44,820
Since the last
expression of the function

1284
01:47:44,820 --> 01:47:46,820
is defined to be the value of the call.

1285
01:47:46,820 --> 01:47:48,700
OC: Yes, I think we're OK dropping that.

1286
01:47:50,470 --> 01:47:52,700
JW: We've  got parens,
and we've got division.

1287
01:47:52,700 --> 01:47:53,410
we've got phi and psi...

1288
01:47:54,580 --> 01:47:57,520
A global phi and a local psi.

1289
01:47:57,520 --> 01:47:58,470
Let's give it a try...

1290
01:47:58,470 --> 01:48:00,000
Do you think it's going to work?

1291
01:48:02,820 --> 01:48:03,880
OC: I'm going to say no,

1292
01:48:03,880 --> 01:48:05,880
I don't think it will work (laughter).

1293
01:48:06,580 --> 01:48:07,880
JW:  So unknown variable N...

1294
01:48:09,880 --> 01:48:12,470
We're now making
reference to a local variable.

1295
01:48:13,050 --> 01:48:15,880
That's a good thing, to
check why isn't that happening.

1296
01:48:17,290 --> 01:48:18,110
When we defined...

1297
01:48:19,520 --> 01:48:22,000
OC: When we went into the lambda we
don't seem to be extending the environment.

1298
01:48:22,000 --> 01:48:23,760
we are extending the environment.

1299
01:48:24,230 --> 01:48:25,640
So we got the arg, as the name,

1300
01:48:26,700 --> 01:48:28,230
we extended the environment.

1301
01:48:30,230 --> 01:48:32,820
We evaluate within
that extended environment...

1302
01:48:34,820 --> 01:48:36,470
OC: Are we able to see which line

1303
01:48:36,470 --> 01:48:38,000
it's having this trouble with?

1304
01:48:41,880 --> 01:48:43,640
we've got quite a few unexpecteds.

1305
01:48:50,352 --> 01:48:51,882
JW:  It's the definition of fib

1306
01:48:53,410 --> 01:48:55,294
that seems to be having the problem.

1307
01:48:55,410 --> 01:48:56,588
Column 3 or column 8.

1308
01:48:59,290 --> 01:49:00,941
It wasn't expecting the word fib.

1309
01:49:12,580 --> 01:49:13,520
See that works.

1310
01:49:17,290 --> 01:49:18,820
Let's reduce the problem here,

1311
01:49:19,880 --> 01:49:22,580
get rid of these ones that are before it.

1312
01:49:27,050 --> 01:49:31,520
OC: The let binding is definitely working
because we're seeing that

1313
01:49:38,580 --> 01:49:41,410
OC: This isn't a problem
with the comment dropping those?...

1314
01:49:53,880 --> 01:49:55,760
Let's see if whitespace is consuming.

1315
01:49:57,760 --> 01:50:00,230
Oh! Whitespace only
takes space into account.

1316
01:50:01,050 --> 01:50:02,470
We want it to be space or tab,

1317
01:50:06,000 --> 01:50:07,764
or return or newline..

1318
01:50:12,000 --> 01:50:14,820
OC: Is it the leading
whitespace causing the problem?

1319
01:50:16,230 --> 01:50:18,350
or are we stripping the leading whitespace
out as well.

1320
01:50:18,350 --> 01:50:20,580
JW: We should be
stripping any whitespace

1321
01:50:20,580 --> 01:50:22,110
that occurs before the brace

1322
01:50:22,110 --> 01:50:23,050
and after the brace.

1323
01:50:33,290 --> 01:50:34,940
Let's see if it would help to have

1324
01:50:36,110 --> 01:50:38,000
a semi colon in our function bodies.

1325
01:50:44,470 --> 01:50:45,640
And that does not help.

1326
01:50:45,640 --> 01:50:47,290
I think the problem is outside.

1327
01:50:49,880 --> 01:50:51,760
We need to bring some tracing back in:

1328
01:51:13,050 --> 01:51:15,050
We're getting as far as parsing
funBinding seven

1329
01:51:15,050 --> 01:51:22,117
so it's not liking the closing brace.

1330
01:51:27,050 --> 01:51:29,880
OC: That expected F
assumes that the define is a variable
name

1331
01:51:31,290 --> 01:51:33,529
and it's trying to
do addition on that variable.

1332
01:51:41,170 --> 01:51:42,470
Maybe if we just try to do

1333
01:51:42,470 --> 01:51:44,235
one expression in the definition

1334
01:51:45,170 --> 01:51:47,290
see if that gives
us any more progress.

1335
01:51:58,000 --> 01:51:59,640
JW: We're getting as far as seven.

1336
01:52:25,170 --> 01:52:26,230
OC: Or maybe trace it?

1337
01:53:05,050 --> 01:53:07,170
JW: Let's try parsing the single expression.

1338
01:53:39,410 --> 01:53:42,110
JW: It's trying to parse
the funBinding and failing.

1339
01:53:44,110 --> 01:53:46,117
So it's trying to parse it as a funCall.

1340
01:53:48,820 --> 01:53:51,170
OC: But that's failing
because it doesn't see

1341
01:53:51,170 --> 01:53:53,290
an open parenthesis right after define.

1342
01:53:54,470 --> 01:53:57,170
JW: Exactly and then
it tries to do it as a variable

1343
01:53:58,110 --> 01:53:59,760
I'm surprised it's not telling us...

1344
01:54:01,760 --> 01:54:02,700
"unknown variable".

1345
01:54:05,050 --> 01:54:07,520
OC: It's still trying
to evaluate at that point.

1346
01:54:10,700 --> 01:54:12,230
we're failing in the parsing.

1347
01:54:21,640 --> 01:54:24,110
JW: It should read it
as a variable shouldn't it?

1348
01:54:25,760 --> 01:54:28,000
OC: It is giving a
variable called define.

1349
01:54:28,350 --> 01:54:29,640
And the next thing to do

1350
01:54:30,230 --> 01:54:32,580
is to look for a math operator.

1351
01:54:36,940 --> 01:54:38,820
JW: That's right. That's what it's saying

1352
01:54:38,823 --> 01:54:40,000
it's expecting to see

1353
01:54:40,000 --> 01:54:41,882
unexpected F wanted a math operator.

1354
01:54:44,580 --> 01:54:46,940
Because the define
expression is failing,

1355
01:54:51,410 --> 01:54:53,520
because of a failure to parse "d".

1356
01:54:59,520 --> 01:55:00,470
Ah, you know what...

1357
01:55:02,230 --> 01:55:04,000
We don't do multi line parsing yet.

1358
01:55:04,940 --> 01:55:07,410
We're handing these
to the parser line by line.

1359
01:55:09,410 --> 01:55:11,760
OC: We should be able
to put it all in one line

1360
01:55:11,760 --> 01:55:13,410
and then our test will be simple.

1361
01:55:13,410 --> 01:55:14,470
JW:  You would think.

1362
01:55:14,470 --> 01:55:15,640
OC: Let's try that first.

1363
01:55:19,050 --> 01:55:21,410
JW: So we're going to
have to break into lines,

1364
01:55:21,410 --> 01:55:22,700
strip out the comments,

1365
01:55:23,640 --> 01:55:25,520
and then put the lines back together.

1366
01:55:25,520 --> 01:55:27,880
OC:  If we just modify
our test bc file for now

1367
01:55:27,880 --> 01:55:30,230
we should be able to
join four lines into one.

1368
01:55:30,700 --> 01:55:31,640
JW: You mean in here?

1369
01:55:31,640 --> 01:55:32,110
OC: Yes.

1370
01:55:35,880 --> 01:55:37,411
Because we have a semi colon

1371
01:55:37,410 --> 01:55:38,941
between them we might be OK.

1372
01:55:39,050 --> 01:55:40,940
JW: I don't know if I kept the semi colon.

1373
01:55:43,290 --> 01:55:44,110
Oh I did keep it.

1374
01:55:48,700 --> 01:55:49,290
Very good!

1375
01:55:50,580 --> 01:55:51,880
So it's 1,2 and 55, correct.

1376
01:55:53,170 --> 01:55:54,580
OC: Yes, almost 55 anyway.

1377
01:56:01,050 --> 01:56:03,410
JW: We don't have
multi line working just yet

1378
01:56:03,410 --> 01:56:05,290
but we do have a way to do separators.

1379
01:56:05,880 --> 01:56:07,760
And since you're probably going to be

1380
01:56:07,760 --> 01:56:09,760
typing these at a REPL anyway

1381
01:56:09,760 --> 01:56:12,940
This probably makes more
sense for things to fit on one line.

1382
01:56:14,940 --> 01:56:16,580
Here's our file, we can show that...

1383
01:56:17,640 --> 01:56:20,352
(I can get rid of that
little devil at the beginning)

1384
01:56:22,110 --> 01:56:24,352
we do get a close
approximation (laughter).

1385
01:56:27,290 --> 01:56:28,823
It's just one of those things.

1386
01:56:30,470 --> 01:56:32,820
To wrap this up we
need a way to execute this

1387
01:56:32,820 --> 01:56:34,000
from the command line.

1388
01:56:34,820 --> 01:56:36,470
If I go into my parser and look at

1389
01:56:36,470 --> 01:56:38,700
this REPL function
we have been calling.

1390
01:56:38,700 --> 01:56:39,880
Really that IS our main.

1391
01:56:40,820 --> 01:56:41,290
If I now:

1392
01:57:09,050 --> 01:57:11,640
OC: This is also reading
from standard input then?

1393
01:57:11,640 --> 01:57:14,823
JW: Yes, in theory, we can pipe
that file we have been working on into it.

1394
01:57:16,580 --> 01:57:18,470
Maybe let's see what we get with that?

1395
01:57:24,000 --> 01:57:24,941
JW: Not quite!

1396
01:57:25,880 --> 01:57:28,940
OC: I guess our REPL
doesn't deal with comments like that

1397
01:57:28,940 --> 01:57:31,411
Let's try this outside
of Emacs, you never know.

1398
01:57:36,700 --> 01:57:37,050
JW:  No.

1399
01:57:37,760 --> 01:57:40,470
OC: I think our REPL isn't
dealing with the comments

1400
01:57:40,470 --> 01:57:42,470
within the file, and that kind of stuff.

1401
01:57:46,820 --> 01:57:49,170
OC: That's cool, I guess
we should wrap up then.

1402
01:57:50,580 --> 01:57:52,110
OC: What are the kind of things

1403
01:57:52,110 --> 01:57:54,230
that stand out to you: the itches
you want to scratch?

1404
01:57:55,410 --> 01:57:58,230
JW: If I wanted to build
this into a nice toy calculator

1405
01:57:59,290 --> 01:58:02,000
I would first want to
get rid of all the repetition

1406
01:58:02,580 --> 01:58:04,470
in dealing with calling of parsec.

1407
01:58:05,050 --> 01:58:07,640
I would factor that out
with some other function

1408
01:58:07,640 --> 01:58:09,520
and all these would call as helpers.

1409
01:58:11,050 --> 01:58:13,170
There are some inefficiencies in here.

1410
01:58:13,170 --> 01:58:14,700
The fact that in our map type,

1411
01:58:15,880 --> 01:58:17,880
we have a map from text to expression.

1412
01:58:17,880 --> 01:58:19,294
So as I mentioned earlier,

1413
01:58:19,410 --> 01:58:21,640
we would always
be re-evaluating variables.

1414
01:58:24,820 --> 01:58:26,820
I would rather have them as constants

1415
01:58:26,820 --> 01:58:28,820
that immediately reduce to doubles.

1416
01:58:34,940 --> 01:58:37,880
At the point where we're evaluating our
when we see an EVar.

1417
01:58:42,350 --> 01:58:45,290
When we see a let, instead
of putting the body of the let

1418
01:58:45,290 --> 01:58:47,050
into the map, we could evaluate it

1419
01:58:47,050 --> 01:58:48,470
stick it in an ENum.

1420
01:58:48,940 --> 01:58:50,350
and then put that in the map

1421
01:58:50,350 --> 01:58:52,110
and that would achieve what I want.

1422
01:58:52,110 --> 01:58:54,820
OC: You would basically be doing a kind of
memoization then?

1423
01:58:54,820 --> 01:58:57,290
JW:  Yes, something like
that, it hurts not to do it.

1424
01:58:59,290 --> 01:59:00,580
So we will just say this:

1425
01:59:10,110 --> 01:59:12,470
ENum wants a double
and it got an expression

1426
01:59:13,050 --> 01:59:14,350
because it wants B prime.

1427
01:59:15,170 --> 01:59:17,410
That would be one
of the things I would do

1428
01:59:17,410 --> 01:59:18,470
Too easy not to do it.

1429
01:59:20,470 --> 01:59:23,050
I would switch to using
a real tokeniser for parsec

1430
01:59:24,000 --> 01:59:26,820
because it would clear
up some problems we ran into

1431
01:59:26,820 --> 01:59:28,820
and make the code briefer

1432
01:59:28,820 --> 01:59:29,760
and easier to see.

1433
01:59:30,580 --> 01:59:33,880
You also have the ability to
define languages in parsec

1434
01:59:33,880 --> 01:59:35,760
so you can say what's the precedence

1435
01:59:35,760 --> 01:59:37,410
my various operators should be

1436
01:59:37,880 --> 01:59:40,230
and it will figure
out how to parse them all

1437
01:59:40,230 --> 01:59:41,410
in the correct order.

1438
01:59:43,410 --> 01:59:46,580
I might move to a
functor fixed point representation

1439
01:59:48,580 --> 01:59:50,110
of my Expr data type here

1440
01:59:50,580 --> 01:59:52,820
so that my
evaluators get easier to write.

1441
01:59:53,880 --> 01:59:55,520
Make a pretty printer.

1442
01:59:56,940 --> 02:00:00,470
The tool that we're modeling this
after is bc.

1443
02:00:01,760 --> 02:00:03,880
In bc it will echo back
out to you the expression

1444
02:00:03,880 --> 02:00:06,000
in pretty-printed form,
so I'd like to do that as well.

1445
02:00:08,820 --> 02:00:11,294
And I would like
tests that every expression

1446
02:00:12,470 --> 02:00:14,000
when printed, can read back in,

1447
02:00:14,588 --> 02:00:16,823
and then reprint
as the same expression.

1448
02:00:17,760 --> 02:00:20,110
That's pretty much
where I would go with this.

1449
02:00:20,350 --> 02:00:21,880
But I don't know if I'm trying
to compete

1450
02:00:21,880 --> 02:00:23,520
with mathematica, so

1451
02:00:23,880 --> 02:00:25,880
I would be happy with something

1452
02:00:25,880 --> 02:00:28,230
that just works nicely
on the command line.

1453
02:00:29,640 --> 02:00:32,230
OC: That's fantastic. Thanks a lot.

