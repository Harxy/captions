1
00:00:01,400 --> 00:00:02,600
Welcome to Peer to Peer.

2
00:00:03,200 --> 00:00:04,800
where you can hone your skills

3
00:00:04,800 --> 00:00:06,480
by watching live coding videos.

4
00:00:08,200 --> 00:00:10,000
Our guest today is
John Wiegley

5
00:00:10,720 --> 00:00:12,080
who's a researcher at BAE,

6
00:00:12,700 --> 00:00:15,100
and author of
many useful Haskell libraries.

7
00:00:16,900 --> 00:00:18,300
Our host is Ollie Charles.

8
00:00:19,400 --> 00:00:21,920
And the challenge that
we set for John is called ...

9
00:00:26,300 --> 00:00:28,080
OC: OK John, would you like to start

10
00:00:28,080 --> 00:00:29,760
by reading through the problem.

11
00:00:55,400 --> 00:00:57,800
And you should have
a couple of example files

12
00:00:57,800 --> 00:01:00,400
which we're going to
aim to pars in this session.

13
00:01:00,800 --> 00:01:02,000
Yes, those are the ones.

14
00:01:03,500 --> 00:01:05,100
Would you like to open those up

15
00:01:05,100 --> 00:01:07,000
and see if it all looks clear enough.

16
00:01:07,800 --> 00:01:10,100
See if you have any
questions on the syntax.

17
00:01:13,300 --> 00:01:15,500
JW: It looks pretty
straightforward to me.

18
00:01:25,900 --> 00:01:27,500
The first thing I'm going to do

19
00:01:28,500 --> 00:01:30,500
is keep these files in this directory

20
00:01:30,500 --> 00:01:33,500
and I'm going to turn this
into a git repository up here.

21
00:01:35,400 --> 00:01:37,400
we'll make a file and call it Parser.hs.

22
00:01:43,800 --> 00:01:46,700
And look to see if the
first expression we want to parse

23
00:01:46,700 --> 00:01:48,100
is an addition operation.

24
00:01:49,900 --> 00:01:52,600
I want to model this after
I  parse it into a data type

25
00:01:54,200 --> 00:01:56,200
that I will run the evaluator against.

26
00:01:56,900 --> 00:02:00,300
So my expressions are going
to have to include an add operation.

27
00:02:01,400 --> 00:02:03,000
And that will need two numbers.

28
00:02:06,100 --> 00:02:08,900
Which I think will
be sub expressions in the future.

29
00:02:09,800 --> 00:02:11,920
So I will say: the additional operation

30
00:02:12,560 --> 00:02:13,760
takes two expressions.

31
00:02:14,000 --> 00:02:15,700
Which means I will need a number ....

32
00:02:21,900 --> 00:02:23,800
To parse that I'm going to use Parsec.

33
00:02:24,900 --> 00:02:27,700
Which is a library
designed for parsing at Haskell.

34
00:02:31,900 --> 00:02:33,500
When I want to parse something,

35
00:02:33,800 --> 00:02:36,100
I have a Parser
that will return an integer.

36
00:02:36,700 --> 00:02:37,700
We'll call this num.

37
00:02:39,800 --> 00:02:41,500
And the number a Parser will take ....

38
00:02:45,500 --> 00:02:47,100
Many instances of some number.

39
00:02:50,100 --> 00:02:51,500
I'll do it the dumb way first.

40
00:02:52,800 --> 00:02:55,600
I often forget what
the whole Parsec interface is.

41
00:02:57,100 --> 00:02:59,360
It's telling me one of
them is not in scope,

42
00:02:59,360 --> 00:03:01,200
so I'm going to hit inaudible.

43
00:03:05,700 --> 00:03:08,700
You can see I have  the
syntax checking behind the scenes.

44
00:03:09,500 --> 00:03:12,400
If I press Control C Control H
it will do a Hoogle query,

45
00:03:13,100 --> 00:03:15,200
on whatever
keyword is under my cursor.

46
00:03:16,100 --> 00:03:17,700
I have Hoogle running locally

47
00:03:17,700 --> 00:03:20,600
so that it works whether
I have internet access or not.

48
00:03:20,600 --> 00:03:22,960
I see right away that's
in the Char sub module,

49
00:03:23,600 --> 00:03:25,100
so if I go up here and add Char,

50
00:03:25,700 --> 00:03:27,300
then one option should be fine.

51
00:03:27,900 --> 00:03:29,200
Same with many, many as in ....

52
00:03:31,800 --> 00:03:33,000
looks like Parsec.Prim.

53
00:03:42,960 --> 00:03:45,500
I've said I want the
Parser to return an integer.

54
00:03:45,500 --> 00:03:47,500
This Parser will return characters.

55
00:03:47,500 --> 00:03:49,700
So I need a way
to turn that into an integer.

56
00:03:50,800 --> 00:03:51,900
Which I can do like so ....

57
00:03:59,500 --> 00:04:05,200
Actually, I can use the applicative inaudible fine.

58
00:04:05,200 --> 00:04:06,900
There we are.... everything parses.

59
00:04:08,500 --> 00:04:10,100
Let me see if I can load this in ....

60
00:04:12,900 --> 00:04:16,000
GCI inaudible

61
00:04:16,000 --> 00:04:18,300
I want to run this Parser on several inputs.

62
00:04:18,300 --> 00:04:20,900
I need to go into Parsec
to find out how to do that.

63
00:04:24,900 --> 00:04:27,300
There is one that will
let you do a test parse.

64
00:04:31,800 --> 00:04:33,300
OC: I believe it's in the index,

65
00:04:33,300 --> 00:04:34,700
that may be easier to find.

66
00:04:41,700 --> 00:04:43,100
JW: It's in the Prim modules

67
00:04:43,900 --> 00:04:45,700
Yes, that's the one I was thinking of.

68
00:04:45,700 --> 00:04:47,700
It takes a Parser and an input string.

69
00:04:49,300 --> 00:04:50,100
So if I say:

70
00:04:51,200 --> 00:04:53,100
I may have to import the Prim module.

71
00:04:54,400 --> 00:04:56,900
If I say parse test,
then I should get my integer.

72
00:05:02,100 --> 00:05:04,100
Next, I want to
parse the add operation.

73
00:05:05,000 --> 00:05:06,800
And that will yield an expression.

74
00:05:11,700 --> 00:05:14,400
Again, I'm using the
applicative style to call ....

75
00:05:19,400 --> 00:05:21,200
well, I only have 'add' expressions.

76
00:05:23,900 --> 00:05:27,400
But I need something that's
going to branch based on what it finds.

77
00:05:30,500 --> 00:05:31,700
I'm going to say:

78
00:05:53,100 --> 00:05:56,000
You always have a long
setup with imports from Parsec.

79
00:05:58,000 --> 00:06:00,400
OK, so num says
"I don't want to return an integer".

80
00:06:02,500 --> 00:06:04,500
I don't want 'read'
here, I want 'just read'.

81
00:06:05,400 --> 00:06:07,520
I need to wrap
that up in my constructor.

82
00:06:12,200 --> 00:06:13,800
OC: So what we're saying here is

83
00:06:14,600 --> 00:06:16,720
inaudible is a Parser that can either

84
00:06:16,880 --> 00:06:18,700
parse addition or a single number.

85
00:06:18,700 --> 00:06:19,600
JW: Correct.

86
00:06:20,000 --> 00:06:21,840
I've forgotten the plus symbol here ....

87
00:06:29,200 --> 00:06:31,400
The 'add' is going
to read in an expression.

88
00:06:33,100 --> 00:06:34,500
Then it wants to read a plus,

89
00:06:35,300 --> 00:06:36,900
and then another expression.

90
00:06:36,900 --> 00:06:38,900
So in front of the second expression,

91
00:06:38,900 --> 00:06:41,700
I'm going to say that
I'm looking for the string plus.

92
00:06:43,300 --> 00:06:46,200
And I'm going to use an
applicative operator that says

93
00:06:47,040 --> 00:06:49,600
"throw whatever you
found away and keep reading".

94
00:06:50,600 --> 00:06:51,500
Now if I do 1 plus 2.

95
00:06:53,000 --> 00:06:54,700
(I need to make my thing show-able)

96
00:07:00,700 --> 00:07:02,600
The Parsers work, it's not re-cursing.

97
00:07:06,500 --> 00:07:09,200
OC: Is that because it's
hitting white space in here ?

98
00:07:12,800 --> 00:07:14,640
JW: It's hitting the white space but

99
00:07:14,640 --> 00:07:16,560
if I look at my Parser for expression,

100
00:07:16,560 --> 00:07:19,200
I see that I've said the
num Parser should be first,

101
00:07:20,100 --> 00:07:21,900
and then choice only Parsers once.

102
00:07:22,400 --> 00:07:25,400
So I  could say "many choice"
to get a list of expressions,

103
00:07:25,400 --> 00:07:27,000
but that's not quite what I want.

104
00:07:27,000 --> 00:07:28,900
I want a chance to parse add at least,

105
00:07:30,000 --> 00:07:31,600
but it's still not accepting it.

106
00:07:33,360 --> 00:07:36,080
It's trying to go to add
and it's failing to parse it.

107
00:07:38,700 --> 00:07:40,240
OC:  GCHi white space inaudible add.

108
00:07:49,840 --> 00:07:51,900
JW: Oh ! I'm  still
passing the num Parser.

109
00:07:54,600 --> 00:07:56,000
Here I have an import loop,

110
00:07:57,600 --> 00:07:59,800
because I have no
termination condition.

111
00:07:59,800 --> 00:08:03,200
Let's see if the add expression is also inaudible

112
00:08:04,300 --> 00:08:07,000
OC: What if we change the inaudible to none.

113
00:08:07,800 --> 00:08:11,700
So we don't have any inaudible

114
00:08:12,600 --> 00:08:15,400
I imagine inaudible

115
00:08:15,400 --> 00:08:17,300
JW: We have the correct Parsing there.

116
00:08:17,300 --> 00:08:20,200
inaudible recursion.

117
00:08:20,200 --> 00:08:23,400
Let me think about why
this is infinitely re cursing here.

118
00:08:29,700 --> 00:08:33,300
Ah! because the very first
thing that add does is call expression

119
00:08:33,300 --> 00:08:36,100
and the first thing that
expression does is call add.

120
00:08:36,100 --> 00:08:37,700
Which then calls expression

121
00:08:37,700 --> 00:08:39,500
so it's never consuming anything.

122
00:08:39,500 --> 00:08:42,100
I need to have some way
of knowing, in expression

123
00:08:44,400 --> 00:08:45,760
what the next step will be.

124
00:08:48,400 --> 00:08:51,200
OC: I think you where right
by doing num first before,

125
00:08:51,200 --> 00:08:54,400
but we were simply calling
parse test for the wrong Parser.

126
00:08:57,000 --> 00:09:00,000
So now we're seeing parse
errors that you would expect.

127
00:09:04,100 --> 00:09:06,800
JW: If I call add without
white space, I get what I want.

128
00:09:08,100 --> 00:09:10,300
Let's first add the
notion of white space.

129
00:09:11,400 --> 00:09:13,200
So I want to have a Parser that says:

130
00:09:16,800 --> 00:09:20,100
(It's not going to become a value,
we're just going to throw it away).

131
00:09:20,100 --> 00:09:22,700
And we're going to say
"many which says zero or more".

132
00:09:31,400 --> 00:09:32,600
And then I'm going to say:

133
00:09:39,300 --> 00:09:40,700
I need to flip this around.

134
00:09:41,700 --> 00:09:43,300
I want that after the operator.

135
00:09:49,700 --> 00:09:52,400
Now I can accept white space
whether or not I have it.

136
00:09:54,900 --> 00:09:57,800
We still have the problem
that choice is not correct.

137
00:09:57,800 --> 00:10:01,700
But if I remove them inaudible.

138
00:10:03,200 --> 00:10:06,000
We need to have a proper
top level expression Parser.

139
00:10:11,800 --> 00:10:13,600
OC: So it did re-curse again, I take it ?

140
00:10:13,600 --> 00:10:14,300
JW: Right.

141
00:10:14,640 --> 00:10:15,840
There is an eof Parser

142
00:10:18,720 --> 00:10:20,400
which tells me when I'm at the end.

143
00:10:20,900 --> 00:10:22,880
So we're going to
have a requirement 'B'

144
00:10:23,500 --> 00:10:25,900
that our string has to
go to the end of the file.

145
00:10:26,400 --> 00:10:26,800
OC: OK.

146
00:10:27,300 --> 00:10:30,100
JW: And there can be white
space at the end of the file.

147
00:10:31,300 --> 00:10:32,240
Now when I do parse

148
00:10:32,800 --> 00:10:34,400
I get that plus is not expected.

149
00:10:34,900 --> 00:10:37,100
The reason was
because we parsed a number

150
00:10:38,700 --> 00:10:41,040
and it thought it
should be at the add space.

151
00:10:44,400 --> 00:10:49,400
We wanted to have space inaudible.

152
00:10:54,700 --> 00:10:55,900
Why is this happening ?

153
00:10:58,900 --> 00:11:00,500
OC: Would just parse test inaudible

154
00:11:00,500 --> 00:11:02,400
Have we got the
white space in there ?

155
00:11:02,400 --> 00:11:04,000
JW: It is not parsing correctly.

156
00:11:06,700 --> 00:11:10,400
inaudible

157
00:11:19,400 --> 00:11:22,000
OC: Usually when I'm
parsing randoms like these,

158
00:11:22,000 --> 00:11:23,500
I use something like chain L

159
00:11:23,500 --> 00:11:26,500
which factors out the
left recursion automatically.

160
00:11:26,500 --> 00:11:28,160
So we might be getting problems

161
00:11:28,160 --> 00:11:29,520
with left recursion here.

162
00:11:31,400 --> 00:11:32,960
Maybe if we change add for now

163
00:11:34,800 --> 00:11:36,080
to take just two numbers.

164
00:11:37,700 --> 00:11:39,000
And we can move on and see

165
00:11:39,000 --> 00:11:41,200
if we can write an
evaluator for addition.

166
00:11:42,800 --> 00:11:44,900
Keep the Parser
simple for now and we'll

167
00:11:44,900 --> 00:11:47,300
come back and add a
bit more logic to it later.

168
00:11:48,500 --> 00:11:50,000
JW: That's working correctly.

169
00:11:50,700 --> 00:11:52,400
Let's write our first evaluator.

170
00:11:53,100 --> 00:11:55,000
Which is going to take an expression

171
00:11:55,000 --> 00:11:56,300
and reduce it to a number.

172
00:11:58,600 --> 00:12:00,500
it's a requirement of our calculator

173
00:12:00,500 --> 00:12:02,900
that it's going to
produce numbers in the end.

174
00:12:03,800 --> 00:12:05,500
When we have a number, that's easy,

175
00:12:05,500 --> 00:12:06,500
we can get a number.

176
00:12:07,100 --> 00:12:09,700
And when we have an
addition between two things,

177
00:12:09,700 --> 00:12:12,500
we have to recursively
evaluate those expressions.

178
00:12:26,900 --> 00:12:27,900
Could not match.

179
00:12:30,800 --> 00:12:36,200
Oh! because inaudible in io.

180
00:12:43,600 --> 00:12:45,200
So parse will say "take a Parser"

181
00:12:50,100 --> 00:12:51,100
And it returns...

182
00:12:53,500 --> 00:12:55,500
and source name,
let's see what that is.

183
00:13:01,200 --> 00:13:03,700
If I have an error it
will just yield the error.

184
00:13:05,300 --> 00:13:06,400
And if I have a value,

185
00:13:07,000 --> 00:13:09,600
then I will print the
result of evaluating that.

186
00:13:20,500 --> 00:13:22,700
This is a lot of code to retype all the time

187
00:13:23,600 --> 00:13:25,200
So we're going to call this test.

188
00:13:25,800 --> 00:13:29,800
OC: I would have used the exact same code inaudible file.

189
00:13:30,200 --> 00:13:33,000
JW: So for now our test
is just going to take a string.

190
00:13:33,000 --> 00:13:34,300
And it's going to parse it.

191
00:14:01,200 --> 00:14:02,100
Oh! it wanted text.

192
00:14:07,300 --> 00:14:19,200
inaudible

193
00:14:21,600 --> 00:14:26,600
Ah! I don't have recursive parsing yet

194
00:14:29,400 --> 00:14:30,700
Let's do right recursion.

195
00:14:44,300 --> 00:14:45,500
It's not the white space.

196
00:14:57,100 --> 00:14:59,500
we're going to need
recursion on those steps.

197
00:15:00,800 --> 00:15:03,400
We really need to figure
out what's going on here.

198
00:15:04,900 --> 00:15:07,100
OC: I wonder if that trailing white space

199
00:15:07,100 --> 00:15:08,700
might cause us some problems....

200
00:15:08,700 --> 00:15:10,700
on the inaudible Parser.

201
00:15:12,600 --> 00:15:14,800
That might be introducing the ambiguity.

202
00:15:15,600 --> 00:15:18,200
It's possible.  We can
certainly remove it for now.

203
00:15:19,400 --> 00:15:21,600
but I have a feeling that's not the problem.

204
00:15:22,500 --> 00:15:24,600
The problem is the left recursion here.

205
00:15:31,300 --> 00:15:32,700
It needs a way of knowing if

206
00:15:32,700 --> 00:15:34,800
it should descend into this add branch.

207
00:15:36,300 --> 00:15:37,800
Which means it needs to know

208
00:15:37,800 --> 00:15:39,600
if there's going to be a plus there.

209
00:15:43,800 --> 00:15:46,300
Another thing I could
do is go ask the internet.

210
00:15:51,400 --> 00:15:52,100
Lets see:

211
00:16:02,300 --> 00:16:03,500
The classic solution.

212
00:16:19,300 --> 00:16:21,700
The top level only
recurs within parens here.

213
00:16:30,700 --> 00:16:33,300
OC: Maybe look up chain L
and see what that's doing.

214
00:17:09,400 --> 00:17:10,300
JW: I will try that.

215
00:17:12,100 --> 00:17:15,900
I also want to find out what the non  inaudible, chain L

216
00:17:17,500 --> 00:17:19,400
Because I've never had this problem.

217
00:17:19,800 --> 00:17:22,000
OC: Surely you
normally have parenthesis

218
00:17:22,000 --> 00:17:24,100
and it's they that
break up the recursion.

219
00:17:25,600 --> 00:17:28,700
JW: But it's perfectly legitimate
to have one or one plus one.

220
00:17:29,700 --> 00:17:32,500
Without having parenthesis
to have that make sense.

221
00:17:32,500 --> 00:17:33,200
OC: Right.

222
00:17:41,200 --> 00:17:44,900
OC: Because ultimately we're going
to be removing this thing anyway.

223
00:17:46,000 --> 00:17:46,700
JW: Right.

224
00:17:50,300 --> 00:17:53,000
Clearly we cant re-curse
all the way back to the top.

225
00:17:58,600 --> 00:18:00,600
This is the problem we're running into.

226
00:18:00,600 --> 00:18:03,200
inaudible

227
00:18:04,200 --> 00:18:06,600
OC: You have to
explicitly do left factoring.

228
00:18:09,800 --> 00:18:12,720
You have that X Prime
thing that starts with addition.

229
00:18:14,000 --> 00:18:16,000
And that again is breaking it for you.

230
00:18:21,800 --> 00:18:25,300
JW: We left off here trying to
break the internet recursion we have.

231
00:18:27,000 --> 00:18:29,360
We have a left
recursion in  a top down Parser.

232
00:18:29,900 --> 00:18:31,900
which is going to infinitely re curse

233
00:18:31,900 --> 00:18:33,300
without parsing any input.

234
00:18:33,900 --> 00:18:35,700
We solve it by having a term Parser

235
00:18:37,100 --> 00:18:38,900
which knows how to parse numbers.

236
00:18:43,100 --> 00:18:45,800
OC: So what we're trying to
do is break that ambiguity.

237
00:18:45,800 --> 00:18:46,500
JW: Right.

238
00:18:47,100 --> 00:18:49,500
Our main expression
Parser is going to call

239
00:18:49,500 --> 00:18:50,700
the term Parser first.

240
00:18:53,100 --> 00:18:54,800
we'll do it in monadic style here.

241
00:18:55,300 --> 00:18:56,700
Now we have the term we can

242
00:18:56,700 --> 00:18:58,500
look at what the next thing will be.

243
00:18:59,600 --> 00:19:01,100
And for example, if it's a plus,

244
00:19:01,800 --> 00:19:05,400
we know it's inaudible to addition

245
00:19:05,400 --> 00:19:08,000
So if that's the case we
have to put a branch on this

246
00:19:11,300 --> 00:19:13,520
we'll take a look at
what the next token is.

247
00:19:16,800 --> 00:19:18,200
We know that it could be say:

248
00:19:55,300 --> 00:19:57,900
Over here again, we
have the white space problem.

249
00:20:00,800 --> 00:20:03,300
we'll allow white space
to be thrown away here

250
00:20:04,600 --> 00:20:05,200
and here.

251
00:20:17,400 --> 00:20:19,600
OC: There's no
termination condition here.

252
00:20:20,600 --> 00:20:22,480
So even when we see an addition sign

253
00:20:22,480 --> 00:20:23,680
we expect another one.

254
00:20:24,500 --> 00:20:25,500
JW: That's true.

255
00:20:29,500 --> 00:20:31,300
We can have plus or we can have eof

256
00:20:33,100 --> 00:20:34,900
but eof is going to return nothing.

257
00:20:35,700 --> 00:20:36,500
So in that case:

258
00:20:46,600 --> 00:20:47,900
Unrecognised operator ....

259
00:20:54,900 --> 00:20:56,700
OC: Maybe use 'just' for the operator

260
00:20:59,100 --> 00:21:00,700
and use nothing for end of file.

261
00:21:01,100 --> 00:21:02,100
JW: Excellent.

262
00:21:36,080 --> 00:21:39,120
Now we've got rid of our
internet left recursion problem.

263
00:21:40,700 --> 00:21:43,700
Now you we're telling me
about a function called chain L,

264
00:21:44,500 --> 00:21:45,800
which I have not used yet.

265
00:21:45,800 --> 00:21:48,200
But Parsec is designed
to solve this problem.

266
00:21:49,800 --> 00:21:51,000
OC: inaudible telling you.

267
00:21:51,600 --> 00:21:53,200
JW: That's right, but we will say

268
00:21:54,200 --> 00:21:55,680
we want term, chain on one and ....

269
00:22:06,500 --> 00:22:07,700
The add op is going to be ......

270
00:22:11,000 --> 00:22:13,800
Oh! I see that's the
symbols that it's expecting to see.

271
00:22:16,000 --> 00:22:16,700
Let's do this:

272
00:22:24,500 --> 00:22:27,000
If we see add we're
going to return the function

273
00:22:29,700 --> 00:22:33,200
OC: I think you want inaudible there rather than addition.

274
00:22:35,300 --> 00:22:38,100
That's right because I'm
not doing evaluation Parser.

275
00:22:41,800 --> 00:22:43,300
JW: So I have term chain addop.

276
00:22:46,400 --> 00:22:48,600
I  will still need to
deal with white space.

277
00:22:54,900 --> 00:22:57,600
I believe that symbol
gives trailing white space,

278
00:23:02,100 --> 00:23:04,800
so I don't need to worry
about leaving white space.

279
00:23:05,500 --> 00:23:07,200
OC: Do you need to worry about that

280
00:23:07,200 --> 00:23:09,000
if your using symbol everywhere ?

281
00:23:10,000 --> 00:23:11,100
JW: Perhaps not.

282
00:23:14,100 --> 00:23:16,300
JW: Let's say that
there can be white space

283
00:23:16,300 --> 00:23:18,000
after terminals, for the moment.

284
00:23:23,200 --> 00:23:25,200
Now the add Parser is going to go away.

285
00:23:27,000 --> 00:23:28,600
And we're going to have a Parser

286
00:23:28,600 --> 00:23:30,600
for the new inaudible expressions.

287
00:23:34,600 --> 00:23:37,300
OC: It might be a Parser
as a function to expression

288
00:23:37,300 --> 00:23:40,080
to expression, to expression,
to expression, in addop

289
00:23:41,840 --> 00:23:46,320
because you have inaudible in your return type.

290
00:23:59,300 --> 00:24:01,800
Their version of white
space here is too fancy

291
00:24:03,200 --> 00:24:04,400
for what I want just yet.

292
00:24:08,300 --> 00:24:11,100
Parsec allows you to
describe what tokens look like

293
00:24:12,600 --> 00:24:14,800
and what the white
spacing comments are,

294
00:24:14,800 --> 00:24:16,700
I don't want to use that at the moment.

295
00:24:22,900 --> 00:24:25,400
This symbol is coming
from that fancy library.

296
00:24:28,500 --> 00:24:30,960
I don't want symbol.
I want string and I have to

297
00:24:31,840 --> 00:24:34,000
build in my own
terminating white space.

298
00:24:42,200 --> 00:24:43,400
OC: That's a lot simpler.

299
00:24:43,400 --> 00:24:44,300
JW: Much cleaner.

300
00:24:44,700 --> 00:24:46,600
Based on the example that they gave ...

301
00:24:48,600 --> 00:24:50,900
We want to extend
this to more operations.

302
00:24:50,900 --> 00:24:52,600
So we will go ahead and add those.

303
00:24:53,600 --> 00:24:55,800
Math operations
tend to be easy to put in.

304
00:24:57,800 --> 00:24:58,700
we're going to say:

305
00:24:59,500 --> 00:25:00,600
We want subtraction ....

306
00:25:04,200 --> 00:25:05,800
multiplication and division ....

307
00:25:08,200 --> 00:25:10,080
It's all still going to be on numbers.

308
00:25:10,160 --> 00:25:13,760
Now we have to make three more inaudible add up

309
00:25:20,000 --> 00:25:22,000
We only have to worry about presence

310
00:25:23,900 --> 00:25:26,100
because, what would
it mean if we said this:

311
00:25:30,900 --> 00:25:32,400
In what order do we evaluate.

312
00:25:32,400 --> 00:25:34,800
We know we want
the division to happen first.

313
00:25:34,800 --> 00:25:37,200
How do we make sure
the Parser enforces that.

314
00:25:37,400 --> 00:25:40,400
The way to do that is to
structure how we do our traversal.

315
00:25:42,400 --> 00:25:44,100
OC: Because right now the Parser

316
00:25:44,100 --> 00:25:45,900
is just running from left to right.

317
00:25:45,900 --> 00:25:48,200
OC: And basically
just standing on the left.

318
00:25:48,200 --> 00:25:49,800
JW: The expression evaluator

319
00:25:50,600 --> 00:25:52,200
is going to be equally trivial.

320
00:25:55,500 --> 00:25:57,700
OC: Can we not just
work with 'int 'anymore

321
00:25:58,300 --> 00:26:00,500
JW: Ah true, we
want the fractional numbers...

322
00:26:11,500 --> 00:26:13,200
And know our num will have to say ....

323
00:26:18,900 --> 00:26:21,600
OC: I wonder if it's easier
to use doubles everywhere.

324
00:26:21,600 --> 00:26:25,600
In some of the later codes it assumes you can assign to inaudible.

325
00:26:32,100 --> 00:26:33,000
We want a number .....

326
00:26:34,800 --> 00:26:35,500
followed by ....

327
00:26:37,500 --> 00:26:40,400
(we're going to have to
do this in a different style here).

328
00:26:41,600 --> 00:26:43,600
OC: I feel  that Parsec may already have

329
00:26:43,600 --> 00:26:45,200
a pre-built Parser for doubles.

330
00:26:47,500 --> 00:26:50,200
JW: True, but I want us to inaudible

331
00:26:50,200 --> 00:26:52,100
So we want the part before and after

332
00:26:53,000 --> 00:26:54,300
to be numerical parsing.

333
00:26:57,400 --> 00:26:58,300
we're going to say:

334
00:26:58,300 --> 00:27:00,100
a numerical Parser is some number.

335
00:27:05,000 --> 00:27:07,600
And then we want an
optional period character.

336
00:27:10,900 --> 00:27:13,800
And it's optional, so we will
get a maybe value out of it.

337
00:27:21,000 --> 00:27:22,200
Then we will take our X

338
00:27:24,700 --> 00:27:27,100
and append it with inaudible number.

339
00:27:29,500 --> 00:27:31,200
Otherwise, just return a number.

340
00:27:33,200 --> 00:27:35,100
It's complaining because there are

341
00:27:35,100 --> 00:27:36,700
two definitions of optional.

342
00:27:42,500 --> 00:27:46,700
OC: inaudible definitions completely equivalent

343
00:27:46,700 --> 00:27:48,100
OC: We aren't making a choice

344
00:27:48,100 --> 00:27:49,400
about which ones we hide.

345
00:27:49,400 --> 00:27:50,700
Fairly arbitrary, right ?

346
00:28:03,900 --> 00:28:05,900
I think it may
be re-exported nowadays.

347
00:28:07,900 --> 00:28:09,500
They have the same definition.

348
00:28:30,300 --> 00:28:32,800
OC: I believe we need
to use that dot character

349
00:28:34,000 --> 00:28:35,500
between the two num Parsers.

350
00:28:37,100 --> 00:28:37,600
JW: Yes.

351
00:28:39,600 --> 00:28:41,100
OC: Now we are consuming a dot

352
00:28:41,100 --> 00:28:42,200
but we're ignoring it

353
00:28:42,200 --> 00:28:43,300
when we omit a string.

354
00:28:44,900 --> 00:28:46,600
JW: Oh yes, we have to add it back in.

355
00:28:47,100 --> 00:28:48,000
Very good point.

356
00:28:55,500 --> 00:28:57,000
I can't do sections like that.

357
00:29:02,000 --> 00:29:04,100
So now cannot
deduce this being double.

358
00:29:11,700 --> 00:29:14,160
OC: Can we try to parse
1.5, something like that ?

359
00:29:18,800 --> 00:29:20,900
We can even
multiply something in here.

360
00:29:23,400 --> 00:29:24,300
That did not work.

361
00:29:24,600 --> 00:29:26,600
Because we haven't tied in the Parser.

362
00:29:27,700 --> 00:29:30,200
OC: These are all doing inaudible as well.

363
00:29:30,200 --> 00:29:35,700
JW: True inaudible

364
00:29:37,700 --> 00:29:39,800
Now we want to
extend our parsing chain

365
00:29:41,400 --> 00:29:42,500
The way that they did.

366
00:29:44,100 --> 00:29:46,800
He did precedence by
having it be at the same level.

367
00:29:54,400 --> 00:29:55,800
we're going to follow suit.

368
00:30:09,600 --> 00:30:11,000
Now we want chain and add up ....

369
00:30:18,200 --> 00:30:20,700
A lot of good coding can
come from just copying.

370
00:30:25,600 --> 00:30:26,800
We don't have parens in ....

371
00:30:28,900 --> 00:30:30,100
so instead we will call ....

372
00:30:56,400 --> 00:30:59,000
If I say that I get inaudible verification,

373
00:30:59,000 --> 00:31:00,400
and I have five to the front.

374
00:31:00,400 --> 00:31:06,100
inaudible the back but should also work....

375
00:31:09,500 --> 00:31:11,200
I would like to have parenthesis

376
00:31:11,700 --> 00:31:13,200
to see what I can do with this.

377
00:31:13,800 --> 00:31:15,400
and if we have them, we will have

378
00:31:16,200 --> 00:31:18,600
satisfied the first three lines of our file.

379
00:31:19,000 --> 00:31:21,100
OC: I wonder if now we could inaudible this in

380
00:31:21,100 --> 00:31:24,000
to read the file and
maybe try to parse the entire file

381
00:31:26,000 --> 00:31:28,000
and watch the Parser eventually fail

382
00:31:30,600 --> 00:31:33,500
We should be ready to
pars the first two lines I think.

383
00:31:33,500 --> 00:31:36,400
It might eventually
start emitting some evaluation.

384
00:31:37,300 --> 00:31:40,500
JW: inaudible rebel.

385
00:31:40,500 --> 00:31:41,900
called Test File,

386
00:31:42,600 --> 00:31:44,300
and that will take your file path,

387
00:31:44,300 --> 00:31:45,600
instead of just a string.

388
00:31:47,600 --> 00:31:48,600
And then say:

389
00:31:55,500 --> 00:31:57,700
we're going to
parse the same expression

390
00:31:59,700 --> 00:32:01,400
but we're going to do many of them.

391
00:32:05,000 --> 00:32:06,500
We could also cut the file up.

392
00:32:08,100 --> 00:32:09,900
But I want this expression Parser

393
00:32:09,900 --> 00:32:11,300
to take in the whole thing.

394
00:32:11,300 --> 00:32:13,100
OC: Yes, We can give it the whole file

395
00:32:13,100 --> 00:32:15,000
and it will evaluate it line by line.

396
00:32:15,000 --> 00:32:15,700
JW: Right.

397
00:32:18,200 --> 00:32:19,600
This will be a series of Xs.

398
00:32:27,700 --> 00:32:28,800
So we're going to say:

399
00:32:37,800 --> 00:32:41,600
inaudible is not in scope, this comes from inaudible

400
00:32:46,100 --> 00:32:48,700
If I didn't do this, if I
said control C and Control M

401
00:32:49,600 --> 00:32:52,700
It would suggest to me all
the modules that it knows about.

402
00:32:53,200 --> 00:32:55,500
inaudible control monad,

403
00:32:56,500 --> 00:32:58,200
It will put it with the explicit.

404
00:33:01,200 --> 00:33:04,000
OC: Is that coming from
the normal Haskell mode for emacs

405
00:33:04,400 --> 00:33:06,300
or is it an extra extension you have ?

406
00:33:07,000 --> 00:33:07,900
JW: Let's see .....

407
00:33:11,600 --> 00:33:13,400
GHC ins-mod is providing that feature.

408
00:33:17,100 --> 00:33:22,000
I use Haskell mode and I use GHC mod and hdevtools.

409
00:33:22,700 --> 00:33:25,000
And the code that
jumps to the local Hoogle

410
00:33:25,000 --> 00:33:26,800
is a patch that I did on GHC mod code

411
00:33:29,300 --> 00:33:32,500
To jump over to the Hoogle I
have running on my local machine.

412
00:33:36,500 --> 00:33:38,900
I definitely want to
pass the name of the file

413
00:33:38,900 --> 00:33:39,600
to the Parser.

414
00:33:41,200 --> 00:33:42,800
Get contents .... I want read file.

415
00:33:56,600 --> 00:33:58,200
I did the case one level too far.

416
00:34:11,500 --> 00:34:15,800
I'll do it in point three
just because I know you (laughter).

417
00:34:17,000 --> 00:34:18,300
I need to pack the string.

418
00:34:19,500 --> 00:34:29,700
inaudible

419
00:34:38,200 --> 00:34:40,800
I have no idea what
this is going to do (laughter).

420
00:34:40,800 --> 00:34:42,400
not all of this file will parse

421
00:34:44,200 --> 00:34:45,500
so we will cut it out of it

422
00:34:46,200 --> 00:34:47,200
and call it 'Test BC'

423
00:34:48,000 --> 00:34:49,200
Then I'm going to write:

424
00:34:51,800 --> 00:34:54,000
And we go into an
infinite loop (laughter).

425
00:34:56,000 --> 00:34:58,600
inaudible tracing.

426
00:35:00,600 --> 00:35:02,100
I tend to add a lot of tracing

427
00:35:02,100 --> 00:35:03,700
when I'm initially developing.

428
00:35:09,200 --> 00:35:11,700
I want to know when
expression is being called.

429
00:35:17,000 --> 00:35:19,000
The tricky thing about doing traces

430
00:35:19,000 --> 00:35:21,300
is that it's not like print in inaudible language.

431
00:35:22,900 --> 00:35:24,700
It's not going to print a statement

432
00:35:24,700 --> 00:35:26,400
as soon as it enters expression.

433
00:35:28,400 --> 00:35:30,500
It will cause that
string to be printed

434
00:35:30,500 --> 00:35:32,700
when expressions
result gets evaluated.

435
00:35:33,500 --> 00:35:35,600
Which sometimes
can be rather distant.

436
00:35:38,100 --> 00:35:39,400
Debugging at a distance.

437
00:35:40,500 --> 00:35:42,900
OC: So this is more
down to Haskells laziness

438
00:35:42,900 --> 00:35:44,900
rather than a inaudible.

439
00:35:44,900 --> 00:35:47,800
JW: It makes it harder to find out inaudible.

440
00:35:47,800 --> 00:35:49,500
So we are seeing the expression

441
00:35:49,500 --> 00:35:50,700
only being called once.

442
00:35:51,100 --> 00:35:53,800
Our internet recursion
is happening elsewhere.

443
00:35:58,500 --> 00:36:01,200
My first version of many
parsers will have tracers.

444
00:36:02,900 --> 00:36:05,300
So I can watch what's
happening as it's going.

445
00:36:13,000 --> 00:36:15,500
After a certain point
I have a keyboard macro.

446
00:36:26,100 --> 00:36:27,600
So we get to 'addop' and we stop.

447
00:36:27,600 --> 00:36:28,500
So:

448
00:36:54,800 --> 00:36:56,200
We don't have a minus symbol.

449
00:37:06,000 --> 00:37:07,900
we're getting no output whatsoever.

450
00:37:08,700 --> 00:37:10,000
Oh! there we go, same place.

451
00:37:12,800 --> 00:37:18,400
OC: And if we run our test again inaudible one plus.

452
00:37:21,400 --> 00:37:22,300
JW: Interesting.

453
00:37:26,300 --> 00:37:27,900
I don't have support for parens.

454
00:37:29,300 --> 00:37:31,200
But there are no parens in this line

455
00:37:32,000 --> 00:37:34,300
OC: Maybe it's the
new line that's the problem,

456
00:37:35,900 --> 00:37:37,000
at the end of the file.

457
00:37:38,200 --> 00:37:39,900
Let's say that we want there to be

458
00:37:39,900 --> 00:37:41,300
an eof at the end of the file.

459
00:37:47,400 --> 00:37:49,200
We don't even get there which means

460
00:37:49,200 --> 00:37:52,000
we have infinite
recursion happening somewhere.

461
00:37:58,000 --> 00:38:03,600
Let's look for the file inaudible

462
00:38:20,100 --> 00:38:22,500
 Now we would expect
that we would get the two

463
00:38:23,100 --> 00:38:24,000
as a result.

464
00:38:27,000 --> 00:38:28,700
If we go back to what we had before

465
00:38:29,500 --> 00:38:32,700
It's failing parse inaudible comments.

466
00:38:34,400 --> 00:38:36,200
OC: Maybe the empty strings as well.

467
00:38:36,200 --> 00:38:36,700
JW: Yes.

468
00:38:39,100 --> 00:38:41,600
OC: Cool, we don't have inaudible.

469
00:38:43,600 --> 00:38:45,920
We definitely want to strip out  the comments.

470
00:38:50,200 --> 00:38:52,200
Let's write a function called visage.

471
00:38:54,200 --> 00:38:55,800
That will take some input text

472
00:38:57,800 --> 00:39:00,400
and strip out anything
that looks like a comment.

473
00:39:02,400 --> 00:39:03,200
First we'll say:

474
00:39:38,320 --> 00:39:39,760
I'll go to data.Text library

475
00:39:39,760 --> 00:39:41,680
to find out how to partition a string.

476
00:39:49,900 --> 00:39:52,500
Partition is not what I
want, I want break or split.

477
00:40:15,400 --> 00:40:18,160
we're never going to have
the hash B a valid character.

478
00:40:19,600 --> 00:40:20,640
So we're going to say:

479
00:41:32,000 --> 00:41:33,600
OC: Plus the parenthesis again.

480
00:41:35,300 --> 00:41:37,300
I think we're skipping over comments

481
00:41:37,300 --> 00:41:39,500
successfully now,
and those two outputs

482
00:41:39,500 --> 00:41:42,160
do match what we
would expect from the input file.

483
00:41:45,900 --> 00:41:48,600
JW: We have now got
parsing of expressions and files.

484
00:41:50,200 --> 00:41:51,600
We know we have to do parens

485
00:41:51,600 --> 00:41:52,960
and a mass of other things.

486
00:41:53,600 --> 00:41:55,000
What I would like to do next

487
00:41:57,000 --> 00:41:58,160
is do it in Rebel style.

488
00:41:59,100 --> 00:42:03,000
So that I can use this on the command line for inaudible.

489
00:42:03,000 --> 00:42:05,100
We want to have a function called rebel.

490
00:42:05,100 --> 00:42:06,800
And this will just loop forever.

491
00:42:14,900 --> 00:42:16,800
I can't remember what the function is

492
00:42:16,800 --> 00:42:18,600
to get  input from the command line

493
00:42:18,600 --> 00:42:19,300
Is it get line ?

494
00:42:22,300 --> 00:42:23,500
It's not something I use.

495
00:42:23,500 --> 00:42:25,000
OC: You can also use interact.

496
00:42:25,000 --> 00:42:27,000
That would be interesting to look at.

497
00:42:27,700 --> 00:42:29,700
Let's hop over to interact inaudible.

498
00:42:32,200 --> 00:42:34,700
The output string is
going to be what it prints.

499
00:42:36,000 --> 00:42:37,900
So we're going to get an input string,

500
00:42:38,900 --> 00:42:40,300
and run it against our test.

501
00:42:45,100 --> 00:42:47,100
This one is in io, which is unfortunate.

502
00:42:51,000 --> 00:42:53,200
There's no reason this
function should be in io

503
00:42:53,200 --> 00:42:54,600
except when we're printing.

504
00:42:54,600 --> 00:42:56,000
So let's break this into two.

505
00:42:58,000 --> 00:42:58,600
Let this be:

506
00:43:23,000 --> 00:43:25,300
I guess it would be more appropriate inaudible

507
00:43:25,600 --> 00:43:26,800
And our test is going to ....

508
00:43:38,400 --> 00:43:40,900
That inaudible not actually a unit code character.

509
00:43:40,900 --> 00:43:42,400
OC: That's the inaudible dot

510
00:43:42,400 --> 00:43:44,100
JW: Yes but UNIX has this way to say

511
00:43:45,500 --> 00:43:48,300
when you see this type
of character in this context,

512
00:43:48,800 --> 00:43:51,000
then show me
this other character instead.

513
00:43:52,700 --> 00:43:53,300
When I type:

514
00:43:57,900 --> 00:44:00,100
I like to see the
mathematical notations

515
00:44:01,100 --> 00:44:03,280
OC: And your doing
the same with the arrow

516
00:44:03,280 --> 00:44:04,560
and the double colon above.

517
00:44:04,600 --> 00:44:05,500
JW: And this arrow,

518
00:44:07,500 --> 00:44:12,000
I have a few things inaudible incoming arrow.

519
00:44:14,800 --> 00:44:16,200
I interact with eval text,

520
00:44:17,500 --> 00:44:21,500
which simply needs to pack inaudible

521
00:44:22,500 --> 00:44:25,100
There's no particular
reason I'm using data.text.

522
00:44:28,900 --> 00:44:30,900
OC: I think interact already runs for a ....

523
00:44:32,900 --> 00:44:35,500
The idea with interact
is you get a lazy strain

524
00:44:35,500 --> 00:44:36,800
of all of standard input.

525
00:44:37,700 --> 00:44:39,800
And you deliver a lazy string with that.

526
00:44:40,200 --> 00:44:42,800
So you might want to
split that into lines again.

527
00:44:44,300 --> 00:44:45,600
Eval text over each line.

528
00:44:47,400 --> 00:44:48,000
JW: Right.

529
00:44:49,300 --> 00:44:50,900
Well if I'm going to be on a rebel....

530
00:44:51,400 --> 00:44:52,300
Lets take a look....

531
00:44:56,500 --> 00:44:57,400
Oh yes your right.

532
00:44:58,000 --> 00:44:59,400
it takes the entire input.

533
00:45:02,800 --> 00:45:04,300
That's not really what I want.

534
00:45:07,300 --> 00:45:09,800
I want to see the
result of every line as I type.

535
00:45:13,040 --> 00:45:14,640
So I want an input from get line.

536
00:45:22,000 --> 00:45:24,640
Now that we're in io
I can run the test on the input.

537
00:45:33,360 --> 00:45:35,120
We can be a little bit fancier now.

538
00:46:13,520 --> 00:46:16,640
I have to add in an
extension called 'overloaded strings'.

539
00:46:19,520 --> 00:46:20,800
OC: And when you type that

540
00:46:20,800 --> 00:46:22,480
have you got a template for Emacs?

541
00:46:26,800 --> 00:46:28,960
JW: There is a module called YASnippet

542
00:46:30,880 --> 00:46:32,560
And I have a snippet called 'lang'.

543
00:46:35,440 --> 00:46:36,320
So if I type 'lang' and hit tab

544
00:46:37,760 --> 00:46:39,200
It will expand and then ask ....

545
00:46:39,680 --> 00:46:41,680
It actually has gone to GHC and asked it.

546
00:46:44,080 --> 00:46:45,440
I can show you the snippet

547
00:46:57,360 --> 00:46:58,160
Here it is.

548
00:47:00,160 --> 00:47:03,600
inaudible language it requires and then it says Haskell inaudible.

549
00:47:05,760 --> 00:47:08,400
That is a function that will go out to GHC,

550
00:47:14,400 --> 00:47:16,960
and ask "what are all your extensions inaudible".

551
00:47:18,240 --> 00:47:20,160
Right there GHC - support extension.

552
00:47:22,160 --> 00:47:26,720
And that will tell you .... inaudible

553
00:47:31,760 --> 00:47:33,040
Back to our example code.

554
00:47:38,400 --> 00:47:39,760
This is not compiling yet.

555
00:47:40,160 --> 00:47:41,440
It still didn't like that.

556
00:47:49,360 --> 00:47:50,480
It wants a character !

557
00:48:04,320 --> 00:48:05,760
Oh! I don't want to use return.

558
00:48:07,760 --> 00:48:09,840
It was interpreting it in the inaudible

559
00:48:11,840 --> 00:48:13,760
Right, so now we have a inaudible I can say:

560
00:48:17,760 --> 00:48:20,880
This makes it a little easier for me to do inaudible.

561
00:48:22,240 --> 00:48:23,120
So let's do parens.

562
00:48:29,680 --> 00:48:31,680
For this one I can use a Parsec feature.

563
00:48:41,200 --> 00:48:42,880
It's in the combinators library.

564
00:48:43,760 --> 00:48:45,200
Its called 'between' I think.

565
00:48:46,720 --> 00:48:46,960
Yes.

566
00:48:52,000 --> 00:48:53,520
I like this notion of symbol.

567
00:48:56,160 --> 00:48:58,480
A symbol can have
white space on either side.

568
00:49:05,760 --> 00:49:07,200
OC: Maybe it would be better

569
00:49:07,200 --> 00:49:08,960
if we passed the Parser in as well.

570
00:49:09,680 --> 00:49:12,320
 inaudible Parser transformer that takes a Parser

571
00:49:13,760 --> 00:49:15,360
and gives you ...

572
00:49:15,600 --> 00:49:18,880
JW: Then I would find myself
constantly doing things like that.

573
00:49:20,240 --> 00:49:21,760
I would rather just say this:

574
00:49:22,640 --> 00:49:25,280
Now I will go to all the
places where I've done this.

575
00:49:25,280 --> 00:49:28,400
I can say symbol without
having to have this nonsense here.

576
00:49:31,680 --> 00:49:34,080
The symbol function that comes with Parsec,

577
00:49:41,680 --> 00:49:43,440
the one that is in the token module,

578
00:49:43,440 --> 00:49:45,200
relies upon a definition of what

579
00:49:46,560 --> 00:49:48,240
the tokens of your language are

580
00:49:48,240 --> 00:49:49,680
including the commenting.

581
00:49:50,400 --> 00:49:53,120
We've handled commenting,
pre - input to the Parser.

582
00:49:54,400 --> 00:49:56,960
Parsec does have the
ability to say this is what .....

583
00:49:59,600 --> 00:50:01,680
OC: So rather than sanitizing the input,

584
00:50:01,680 --> 00:50:04,880
you could have dealt with
comments as syntax themselves.

585
00:50:04,880 --> 00:50:05,440
JW: Right.

586
00:50:05,440 --> 00:50:07,760
If I go to the contents of the Parsec module.

587
00:50:16,880 --> 00:50:18,480
We have a module called token.

588
00:50:19,360 --> 00:50:20,960
In token there is this notion

589
00:50:20,960 --> 00:50:22,320
of a language definition.

590
00:50:22,720 --> 00:50:24,560
Which you call maybe token Parser

591
00:50:26,560 --> 00:50:28,960
and you pass in a
definition of your language.

592
00:50:29,600 --> 00:50:31,840
And that definition defines these things.

593
00:50:33,840 --> 00:50:35,120
How do they begin and end.

594
00:50:35,120 --> 00:50:37,360
What does a single
line comment look like.

595
00:50:38,320 --> 00:50:39,680
Can they be nested etc. etc.

596
00:50:41,200 --> 00:50:43,040
And finally you have reserve names

597
00:50:43,040 --> 00:50:44,800
and reserve inaudible names.

598
00:50:44,800 --> 00:50:46,880
That way, when you
say symbol it has to be,

599
00:50:47,200 --> 00:50:48,080
something from ....

600
00:50:48,960 --> 00:50:51,840
I don't think it has to be
from your reserve names list,

601
00:50:51,840 --> 00:50:54,480
but it won't confuse
that as an identifier phrase.

602
00:50:56,800 --> 00:50:57,760
it's been reserved.

603
00:50:58,560 --> 00:51:00,240
This is a very handy thing to use

604
00:51:02,880 --> 00:51:04,720
but we're not going to go into it now.

605
00:51:05,200 --> 00:51:06,400
Our language is simple.

606
00:51:22,320 --> 00:51:24,960
OC: I think between
still needs a third argument

607
00:51:24,960 --> 00:51:26,320
which is the Parser to run.

608
00:52:22,240 --> 00:52:23,840
OC: So we should be able to call

609
00:52:24,080 --> 00:52:26,000
the function that's reading the file

610
00:52:27,440 --> 00:52:29,200
And get a little further this time.

611
00:52:30,160 --> 00:52:32,640
Previously we were
using test file on test.bc

612
00:52:35,760 --> 00:52:36,960
which is a shorter file.

613
00:52:37,520 --> 00:52:38,160
There we go.

614
00:52:38,160 --> 00:52:40,160
OC: It looks like it's inaudible

615
00:52:40,160 --> 00:52:42,160
JW: Right. Now we're
going to test our bc

616
00:52:42,160 --> 00:52:43,440
and add in the next thing.

617
00:52:48,960 --> 00:52:50,560
As we're in a working state here,

618
00:52:50,880 --> 00:52:52,800
I'm going to go ahead and commit this.

619
00:53:05,520 --> 00:53:07,360
JW: How inaudible

620
00:53:07,360 --> 00:53:10,080
We will start by writing
a Parser for let bindings.

621
00:53:13,360 --> 00:53:14,960
It's going to be an expression.

622
00:53:14,960 --> 00:53:16,000
I don't know what yet.

623
00:53:20,080 --> 00:53:22,320
We want to
represent this in our language.

624
00:53:24,320 --> 00:53:25,200
We're going to say:

625
00:53:25,200 --> 00:53:27,920
A let binding has a
variable name and an expression.

626
00:53:34,640 --> 00:53:37,280
We know that we will
have let in our constructor.

627
00:53:52,960 --> 00:53:53,760
I want letter.

628
00:53:59,200 --> 00:54:02,880
OC: So some is like many but it requires at least inaudible.

629
00:54:03,840 --> 00:54:04,960
And we want, of course ....

630
00:54:10,640 --> 00:54:12,560
We're going to get some conflict here.

631
00:54:12,800 --> 00:54:15,280
Oh! that's because
letter returns a character,

632
00:54:18,160 --> 00:54:20,560
the aggregate raise a string and then pack it

633
00:54:20,560 --> 00:54:21,760
because we want to test.

634
00:54:21,760 --> 00:54:24,160
We want to tie the let
binding in to our Parser.

635
00:54:26,800 --> 00:54:29,760
OC: Do you need to introduce
the let keyword there at all.

636
00:54:31,600 --> 00:54:32,880
JW: Excellent point.

637
00:54:39,600 --> 00:54:41,440
OC: Then equals between the keyword .....

638
00:54:42,080 --> 00:54:44,720
JW: Let's see what
your specification said

639
00:54:56,320 --> 00:54:58,800
It's starting to go a
little out in to space here.

640
00:55:34,640 --> 00:55:35,840
What is going on there ?

641
00:55:40,400 --> 00:55:42,480
Why would it think
that the type of body ....

642
00:55:43,760 --> 00:55:45,360
OC: Have you an error out of date

643
00:55:46,400 --> 00:55:47,600
because you don't have

644
00:55:47,600 --> 00:55:49,200
that last line of code any more.

645
00:55:52,160 --> 00:55:55,280
JW: That's true. Sometimes
the background syntax checker

646
00:55:55,280 --> 00:55:56,240
 inaudible

647
00:55:57,200 --> 00:55:58,800
I'm getting a little ahead of it

648
00:55:58,800 --> 00:56:00,880
so it's showing a result from a while ago.

649
00:56:02,000 --> 00:56:04,880
In the evaluator, we need
to do something with this let.

650
00:56:09,440 --> 00:56:11,200
We need to take in an environment.

651
00:56:13,760 --> 00:56:15,200
And that is going to be a map.

652
00:56:19,040 --> 00:56:20,320
of names to expressions.

653
00:56:22,320 --> 00:56:24,640
We want the let to
add an entry into that map.

654
00:56:25,120 --> 00:56:26,560
That we can later evaluate,

655
00:56:26,880 --> 00:56:28,640
if anyone makes a reference to it.

656
00:56:29,280 --> 00:56:30,960
We want to have data map in scope.

657
00:56:38,160 --> 00:56:40,560
We don't JUST want a
map of text to expression

658
00:56:40,880 --> 00:56:42,800
because that would mean every time

659
00:56:42,800 --> 00:56:44,320
the variable was referred to

660
00:56:44,320 --> 00:56:45,600
it would be re-evaluated.

661
00:56:48,240 --> 00:56:49,680
We want a function in there.

662
00:56:54,880 --> 00:56:56,880
We want our evaluator to be recursive.

663
00:56:59,680 --> 00:57:02,240
I will have to have
this made a little trickier.

664
00:57:07,280 --> 00:57:08,880
Let's go with the dumb way first

665
00:57:11,600 --> 00:57:13,360
and build this up incrementally.

666
00:57:14,400 --> 00:57:16,800
It never pays to be
too fancy in the beginning.

667
00:57:22,160 --> 00:57:24,000
We need to pass in the environment

668
00:57:24,000 --> 00:57:26,000
and return the mutated environment.

669
00:57:26,000 --> 00:57:28,400
Which is the perfect job for state.

670
00:57:28,400 --> 00:57:30,400
Which means we need to bring in state.

671
00:57:35,920 --> 00:57:37,520
Which means now we are monadic.

672
00:57:39,520 --> 00:57:41,120
So all these have to do returns.

673
00:57:47,040 --> 00:57:48,240
Now we are going to say:

674
00:57:53,520 --> 00:57:55,200
OC: Modify is from control.state.

675
00:57:57,600 --> 00:57:59,920
Env is going to be
the modified environment.

676
00:58:00,560 --> 00:58:01,680
I'm going to say:

677
00:58:11,840 --> 00:58:16,080
Parsec again has its own inaudible

678
00:58:23,280 --> 00:58:24,160
I need to get env.

679
00:58:29,680 --> 00:58:31,280
OC: Because the env is a new type.

680
00:58:31,520 --> 00:58:32,160
JW: Right

681
00:58:32,560 --> 00:58:33,440
OC: That's a back up.

682
00:58:38,800 --> 00:58:40,080
Modify returns no value,

683
00:58:40,480 --> 00:58:42,080
yet we have been saying things

684
00:58:42,080 --> 00:58:43,520
return double all the time.

685
00:58:49,200 --> 00:58:49,840
Lets say:

686
00:58:55,920 --> 00:58:57,920
Let has one more
component doesn't it ?

687
00:58:59,840 --> 00:59:02,000
It has the body
over which the let ranges.

688
00:59:05,440 --> 00:59:07,040
OC: Which in this simple syntax,

689
00:59:08,320 --> 00:59:09,840
is just to the end of the file.

690
00:59:11,200 --> 00:59:13,600
JW: This is actually an
imperative notion now.

691
00:59:13,600 --> 00:59:15,360
This is a statement with no result.

692
00:59:15,920 --> 00:59:18,000
That has an
effect on the environment.

693
00:59:18,800 --> 00:59:20,560
Which is not part of our evaluator.

694
00:59:23,440 --> 00:59:25,120
OC: Well, you could still put this

695
00:59:25,600 --> 00:59:29,200
in the evaluator inaudible may double.

696
00:59:29,200 --> 00:59:30,800
Maybe running an expression

697
00:59:31,040 --> 00:59:32,480
doesn't give you any output.

698
00:59:34,000 --> 00:59:35,600
JW: That's one way we could do it.

699
00:59:36,240 --> 00:59:36,880
Let me think.

700
00:59:40,320 --> 00:59:42,800
OC: We could take
the more functional approach

701
00:59:43,920 --> 00:59:46,960
and have the let binding
scope over the rest of the file.

702
00:59:48,000 --> 00:59:50,240
And every time
you're introducing a new let

703
00:59:50,240 --> 00:59:52,000
you're introducing some more scope

704
00:59:52,000 --> 00:59:53,840
that extends to the end of the file.

705
00:59:53,840 --> 00:59:55,040
JW: I like that idea more,

706
00:59:56,400 --> 00:59:58,480
but for now let's
go with the maybe idea.

707
01:00:01,410 --> 01:00:02,820
So in this case we have this.

708
01:00:04,700 --> 01:00:05,640
And here we'll have ....

709
01:00:09,170 --> 01:00:10,700
These guys all become 'justs'.

710
01:00:27,880 --> 01:00:28,940
we're into monad now.

711
01:00:35,520 --> 01:00:37,640
So for example if
you we're to say 1 plus

712
01:00:37,640 --> 01:00:38,941
let feed equal 10 .....

713
01:00:43,290 --> 01:00:44,700
Let's have a let be it's body.

714
01:00:44,820 --> 01:00:45,410
OC: Sure.

715
01:00:46,700 --> 01:00:48,000
JW: That makes more sense.

716
01:00:48,000 --> 01:00:48,470
OC: Yes.

717
01:00:49,170 --> 01:00:51,410
JW: We're still monadic
here so I'm going to

718
01:00:51,410 --> 01:00:53,050
rewrite this into monadic form.

719
01:00:54,230 --> 01:00:56,588
In another language
we would not name names.

720
01:00:57,050 --> 01:00:58,705
I could have said this couldn't I ?

721
01:00:59,520 --> 01:01:01,290
It would have meant the same thing.

722
01:01:02,350 --> 01:01:03,760
Can't do that in Haskell yet.

723
01:01:04,470 --> 01:01:07,410
OC: So that's the start of the inaudible that you were referring to

724
01:01:08,580 --> 01:01:10,700
Which is still somewhat controversial

725
01:01:10,700 --> 01:01:12,110
in the Haskell community.

726
01:01:18,350 --> 01:01:19,290
Now I want to:

727
01:01:32,110 --> 01:01:35,760
Maybe not self return because that isn't inaudible

728
01:01:36,580 --> 01:01:38,580
Now we need to pass in an environment

729
01:01:39,170 --> 01:01:41,050
to our evaluator wherever we use it.

730
01:01:42,350 --> 01:01:44,940
So let's have a way of
creating a new environment ....

731
01:02:55,170 --> 01:02:56,470
OC: Do we really want that

732
01:02:57,170 --> 01:02:58,820
because you want to pass on this

733
01:02:59,880 --> 01:03:02,470
mutated environment
for every step of the rebel.

734
01:03:03,640 --> 01:03:05,520
JW: This will be a top level function.

735
01:03:06,110 --> 01:03:06,470
OC: OK.

736
01:03:09,640 --> 01:03:11,880
JW: This is for people
who are further down

737
01:03:11,880 --> 01:03:13,520
and don't have to worry like this.

738
01:03:14,350 --> 01:03:15,411
So we're going to say ....

739
01:03:21,058 --> 01:03:27,411
inaudible a function just call eval.

740
01:03:33,760 --> 01:03:35,410
It underlines warnings in blue.

741
01:03:37,170 --> 01:03:39,410
I generally tend to
pay attention to them,

742
01:03:39,410 --> 01:03:40,940
I'm getting rid of redundancy.

743
01:03:42,000 --> 01:03:43,410
I don't need so much tracing.

744
01:03:43,882 --> 01:03:46,588
This seems like a good
opportunity to delete some.

745
01:03:48,110 --> 01:03:51,764
OC: Those warnings about
redundant brackets are coming from hlint?

746
01:03:53,050 --> 01:03:53,880
JW: Correct.

747
01:03:55,880 --> 01:03:57,290
I'm using flycheck which is

748
01:03:57,290 --> 01:04:00,580
talking to both GHC and inaudible.

749
01:04:03,050 --> 01:04:05,640
That will give me a
more comprehensive picture.

750
01:04:06,350 --> 01:04:08,000
I have one warning left which is

751
01:04:08,000 --> 01:04:09,640
the import of token redundant.

752
01:04:10,820 --> 01:04:11,640
So I will drop it.

753
01:04:15,050 --> 01:04:16,580
We did this to do let bindings.

754
01:04:17,176 --> 01:04:18,941
We still can't refer our variables.

755
01:04:20,117 --> 01:04:22,352
OC: Because we're
using a new environment.

756
01:04:22,705 --> 01:04:25,058
JW: So I need a new
thing which we'll call evar,

757
01:04:26,700 --> 01:04:28,580
which will be a variable reference.

758
01:04:29,640 --> 01:04:31,640
I know how I want eval to be evaluated.

759
01:04:34,230 --> 01:04:36,350
I don't yet know how
I want it to be parsed.

760
01:04:40,230 --> 01:04:42,230
I'm going to get my environment and do:

761
01:05:03,640 --> 01:05:05,520
This is where I said we we're going to

762
01:05:05,520 --> 01:05:06,820
re-evaluate all the time.

763
01:05:12,230 --> 01:05:15,410
OC: This is because the look up has returned inaudible.

764
01:05:15,410 --> 01:05:15,880
JW: Yes.

765
01:05:15,880 --> 01:05:18,000
And we're storing
expression in our map.

766
01:05:20,110 --> 01:05:22,000
Because Haskell is a lazy language

767
01:05:22,940 --> 01:05:25,520
we want to get the map to inaudible in it.

768
01:05:26,000 --> 01:05:28,230
So that the first time you touch the inaudible,

769
01:05:28,940 --> 01:05:31,410
only then will it do
the work of evaluating it.

770
01:05:32,000 --> 01:05:34,000
From then on it
will have that value.

771
01:05:34,350 --> 01:05:34,700
OC: OK.

772
01:05:35,290 --> 01:05:36,820
JW: we'll do that next.  Let's see.

773
01:05:39,050 --> 01:05:39,640
I need to:

774
01:05:43,170 --> 01:05:46,000
Now we have a way to
define and reference variables.

775
01:05:48,000 --> 01:05:49,640
We just need a way to parse them.

776
01:05:50,820 --> 01:05:53,410
Variable's going to be
a fundamental term again

777
01:05:56,110 --> 01:05:57,764
in addition to our let bindings.

778
01:05:58,705 --> 01:06:00,117
So we're going to have terms,

779
01:06:02,110 --> 01:06:03,058
and we'll call them:

780
01:06:10,470 --> 01:06:11,410
What is a variable ?

781
01:06:16,470 --> 01:06:19,640
variable has the same definition as inaudible

782
01:06:30,940 --> 01:06:32,820
OC: So this is the same parser we used

783
01:06:32,820 --> 01:06:34,820
when we introduced the inaudible

784
01:06:35,290 --> 01:06:35,764
JW: Yes.

785
01:06:41,176 --> 01:06:42,117
Let's have our name ....

786
01:06:52,230 --> 01:06:54,700
That way if we want
to update to alphanumerics

787
01:06:56,000 --> 01:06:57,882
we only have to change it in one place.

788
01:06:59,760 --> 01:07:00,470
Let's say:

789
01:07:15,050 --> 01:07:17,640
OC: So that no parse is
not coming from our parser.

790
01:07:17,640 --> 01:07:19,170
it's coming from our use of the

791
01:07:19,170 --> 01:07:20,580
read function somewhere.

792
01:07:21,410 --> 01:07:21,880
JW: Yes.

793
01:07:30,470 --> 01:07:31,640
We can use trace here.

794
01:07:34,580 --> 01:07:36,230
Actually, I don't need to do that

795
01:07:36,230 --> 01:07:37,760
because I have a key binding.

796
01:07:39,760 --> 01:07:42,820
the auto insert inaudible

797
01:07:43,760 --> 01:07:45,050
I change it to be traces.

798
01:07:48,580 --> 01:07:50,470
I'm going to do this return at the end

799
01:07:50,470 --> 01:07:52,230
because trace has to yield a value.

800
01:07:56,350 --> 01:07:58,000
Sometimes I use print out more

801
01:07:58,000 --> 01:07:59,640
and sometimes I use trace more.

802
01:07:59,640 --> 01:08:01,290
I should have two variants of it.

803
01:08:05,050 --> 01:08:06,470
We never even get to our let.

804
01:08:08,820 --> 01:08:09,880
It's trying to parse ....

805
01:08:17,880 --> 01:08:19,170
We get the same problem

806
01:08:19,170 --> 01:08:20,820
even if we just use the word let.

807
01:08:22,235 --> 01:08:23,176
(Big sigh from John)

808
01:08:27,520 --> 01:08:29,520
OC: We do have trace lines above which

809
01:08:29,520 --> 01:08:32,110
seem to indicate we
have got something to add on.

810
01:08:32,110 --> 01:08:34,110
 inaudible.

811
01:08:35,410 --> 01:08:37,640
JW: I just have to
prioritize let binding.

812
01:08:40,823 --> 01:08:42,117
This is what parsec does.

813
01:08:48,230 --> 01:08:50,470
It read in the first
letter of the word let.

814
01:08:51,520 --> 01:08:54,000
Found that it wasn't
a number in the num parser

815
01:08:54,580 --> 01:08:55,760
and said "this isn't me".

816
01:08:56,820 --> 01:08:58,820
Choice said, "OK whats the next parser,"

817
01:08:59,290 --> 01:09:00,700
but it didn't give back the L.

818
01:09:01,640 --> 01:09:02,820
So you have to use try

819
01:09:03,290 --> 01:09:04,940
as a wrapper around your parser

820
01:09:04,940 --> 01:09:06,700
if you want the input to be re wound

821
01:09:07,520 --> 01:09:10,110
to the beginning of
where your last parse failed.

822
01:09:10,110 --> 01:09:12,580
But since let begins
with a concrete key word

823
01:09:12,580 --> 01:09:14,350
that we're not going to be re-using

824
01:09:14,350 --> 01:09:15,290
as a variable name,

825
01:09:15,290 --> 01:09:17,411
it's safe for us to
promote that higher

826
01:09:17,410 --> 01:09:19,170
OC: Because no other expressions

827
01:09:19,170 --> 01:09:20,580
are going to use that word.

828
01:09:20,820 --> 01:09:21,520
JW: Right.

829
01:09:24,940 --> 01:09:27,880
because variable is going
to be a similar type of parser,

830
01:09:27,880 --> 01:09:29,050
let's wrap that as well.

831
01:09:40,700 --> 01:09:42,700
The rebel creates a new environment.

832
01:09:44,350 --> 01:09:46,940
So we want a different
type of test for this to use.

833
01:09:48,940 --> 01:09:50,110
Let me expand this out.

834
01:09:52,940 --> 01:09:55,410
We want to run this
forever loop within state.

835
01:10:01,647 --> 01:10:03,882
We're going to do
exact state T on this one.

836
01:10:04,580 --> 01:10:05,880
And we're going to flip it

837
01:10:06,350 --> 01:10:08,000
and do it with a new environment.

838
01:10:11,760 --> 01:10:12,700
Forever runs an io,

839
01:10:15,640 --> 01:10:16,700
so we want to go here.

840
01:10:20,000 --> 01:10:21,764
OC: Forever should work on any line.

841
01:10:22,000 --> 01:10:24,580
I think your problem
there was was the get line

842
01:10:24,580 --> 01:10:26,350
is forcing you to inaudible

843
01:10:33,880 --> 01:10:34,820
So we get our input

844
01:10:36,000 --> 01:10:37,640
and we want to run our evaluator

845
01:10:40,580 --> 01:10:42,700
For that we're going
to have to parse it.

846
01:10:43,520 --> 01:10:45,520
I'm getting a lot
of implication here.

847
01:10:47,050 --> 01:10:49,410
But for the time
being we'll just let it slide.

848
01:11:00,580 --> 01:11:02,110
We need to have our evaluator.

849
01:11:07,880 --> 01:11:09,640
We're going to get the environment

850
01:11:09,640 --> 01:11:10,940
and do a sub evaluation.

851
01:11:35,410 --> 01:11:37,290
OC: Sounds like it should be possible

852
01:11:37,640 --> 01:11:39,760
to do that without
having to run state.

853
01:11:41,760 --> 01:11:43,050
JW: This state T is over io,

854
01:11:44,350 --> 01:11:45,880
and our function is a state T

855
01:11:45,880 --> 01:11:47,050
that's over identity.

856
01:11:48,350 --> 01:11:52,000
We could use the inaudible flag hoist routine.

857
01:11:52,940 --> 01:11:54,350
To swap out between the two.

858
01:12:01,640 --> 01:12:02,940
We're going to say:

859
01:12:26,580 --> 01:12:28,470
We're going to go from identity to io.

860
01:12:33,880 --> 01:12:35,760
It should be just a matter of return.

861
01:12:52,110 --> 01:12:54,230
Get line is still will forcing us inaudible.

862
01:13:02,820 --> 01:13:05,050
OC: You might have
data.text on io.get line

863
01:13:07,050 --> 01:13:08,352
that you avoid packing.

864
01:13:19,290 --> 01:13:21,294
OC: And you have got T.readFile here.

865
01:13:41,050 --> 01:13:42,941
OC: Another problem is exact state is 

866
01:13:43,170 --> 01:13:45,411
apparently going to give you back the file.

867
01:14:00,580 --> 01:14:03,170
JW: Exact state is giving us back a ....

868
01:14:17,640 --> 01:14:20,000
It's loosing the sense
of what monad we're in.

869
01:14:42,580 --> 01:14:44,940
Oh I always get a
surprise when that checks!

870
01:14:44,940 --> 01:14:47,050
I didn't think that
hoist line was right

871
01:14:47,760 --> 01:14:48,700
but I guess it was.

872
01:14:49,290 --> 01:14:51,050
OC: You we're pretty quick so maybe

873
01:14:51,050 --> 01:14:53,764
you we're running ahead
of your flight check again !

874
01:14:54,000 --> 01:14:55,170
JW: So we have one plus 4.

875
01:14:56,117 --> 01:14:57,529
We have let feed equals 20.

876
01:14:58,110 --> 01:14:59,529
Now I should be able to say  

877
01:14:59,647 --> 01:15:00,941
T plus 5 and I get no parse.

878
01:15:03,760 --> 01:15:06,000
we have been
stricken by this num parser

879
01:15:06,940 --> 01:15:09,058
OC: So maybe we can just do the same tricks.

880
01:15:11,290 --> 01:15:12,588
JW: Well it's worth trying,

881
01:15:14,230 --> 01:15:16,470
So we can define
and reference variables.

882
01:15:20,230 --> 01:15:22,000
Now we want the ability to define

883
01:15:22,110 --> 01:15:24,350
not just sub
expressions, but functions.

884
01:15:25,170 --> 01:15:26,110
Before we do that

885
01:15:26,230 --> 01:15:27,410
I want to do this trick

886
01:15:27,410 --> 01:15:29,520
where we do not
re-evaluate expression.

887
01:15:32,470 --> 01:15:33,760
We want our map to be a map

888
01:15:35,760 --> 01:15:36,820
of names to doubles.

889
01:15:38,820 --> 01:15:40,350
And the reason we can do that

890
01:15:40,352 --> 01:15:42,000
is because there are constants.

891
01:15:42,580 --> 01:15:44,700
They can only
ever refer other things

892
01:15:44,820 --> 01:15:46,110
inside the environment.

893
01:15:46,110 --> 01:15:48,580
So here, instead of
inserting our expression,

894
01:15:49,410 --> 01:15:51,410
into the map we we are going to insert.....

895
01:15:56,700 --> 01:15:58,580
Oh I have to evaluate inaudible.

896
01:16:00,352 --> 01:16:02,000
OC: Because that might refer to

897
01:16:02,000 --> 01:16:04,000
previously evaluated variables.

898
01:16:06,820 --> 01:16:09,290
This is not using any inaudible laziness type trick

899
01:16:10,350 --> 01:16:12,230
it's just evaluating at that moment.

900
01:16:13,290 --> 01:16:15,640
OC: So if you change that inaudible as well

901
01:16:15,640 --> 01:16:16,820
to just return B prime.

902
01:16:21,880 --> 01:16:23,050
JW: Let's check this in.

903
01:16:25,640 --> 01:16:27,290
We can now define and reference.

904
01:16:31,520 --> 01:16:33,880
Now let's see if we can
parse this in our test.

905
01:16:37,520 --> 01:16:39,640
OC:  I imagine we're
going to get a problem

906
01:16:39,640 --> 01:16:40,940
looking up square root.

907
01:16:43,410 --> 01:16:44,230
That's my guess.

908
01:16:45,640 --> 01:16:47,410
JW: That number equals square root.

909
01:16:49,760 --> 01:16:51,410
We have no inaudible functions yet.

910
01:16:52,000 --> 01:16:54,700
OC: We do seem to have
a couple of loop regressions.

911
01:16:55,170 --> 01:16:56,000
Oh, look at that ....

912
01:16:59,520 --> 01:17:01,176
we're losing the sense of lines

913
01:17:01,290 --> 01:17:03,050
because we're chopping things up.

914
01:17:05,050 --> 01:17:06,700
So we got two but we didn't get 30

915
01:17:07,170 --> 01:17:09,294
Let's do this now
ourselves, at the rebel.

916
01:17:12,110 --> 01:17:14,230
We definitely have a regression there.

917
01:17:19,290 --> 01:17:22,110
I don't think the vision
is being handled correctly.

918
01:17:26,940 --> 01:17:29,411
I have a feeling that
with any other operator

919
01:17:29,640 --> 01:17:30,470
it will be fine.

920
01:17:30,470 --> 01:17:31,760
Yes, so it's just division.

921
01:17:35,760 --> 01:17:38,230
OC: You maybe forgot
to put a line in our parser.

922
01:18:06,000 --> 01:18:07,520
OC: Is it because we are using

923
01:18:07,520 --> 01:18:08,940
symbol rather than string.

924
01:18:08,940 --> 01:18:10,110
JW: Of course that's why.

925
01:18:10,470 --> 01:18:11,050
Thank you.

926
01:18:13,050 --> 01:18:14,110
Yes there we have it.

927
01:18:18,110 --> 01:18:20,230
OC: So I  guess we
go back to that read file.

928
01:18:23,640 --> 01:18:26,820
inaudible

929
01:18:28,000 --> 01:18:29,520
JW: I guess you we're expecting

930
01:18:29,520 --> 01:18:30,820
that to be from a library ?

931
01:18:34,110 --> 01:18:36,230
There's a prelude in
scope and I assumed ....

932
01:18:36,580 --> 01:18:38,230
JW: Let's call it double instead,

933
01:18:39,170 --> 01:18:40,588
and let's say that double ....

934
01:18:41,640 --> 01:18:44,000
Let's see what the
syntax for functions was.

935
01:18:52,230 --> 01:18:53,640
Now we need to define that.

936
01:18:54,580 --> 01:18:56,350
As usual I like to start by looking

937
01:18:56,350 --> 01:18:57,520
at my expression tree.

938
01:19:01,410 --> 01:19:02,940
This is a lot like let binding,

939
01:19:04,470 --> 01:19:06,700
it's just one that
needs input parameters.

940
01:19:09,880 --> 01:19:11,170
This is like saying this:

941
01:19:17,290 --> 01:19:20,000
We have an expression
that's a lambda abstraction

942
01:19:21,410 --> 01:19:22,940
and we want to define double

943
01:19:22,940 --> 01:19:24,470
to be that lambda abstraction.

944
01:19:25,880 --> 01:19:27,640
So we'll call that inaudible.

945
01:19:28,470 --> 01:19:30,230
At the moment we're going to allow

946
01:19:30,230 --> 01:19:32,350
that lambda to
take just one variable.

947
01:19:34,230 --> 01:19:35,760
OC: Yes, that's all that happens

948
01:19:35,760 --> 01:19:37,050
in these little example scripts.

949
01:19:37,050 --> 01:19:38,820
You can assume that these are all

950
01:19:38,820 --> 01:19:40,350
functions over one variable.

951
01:19:40,700 --> 01:19:41,290
JW: Right.

952
01:19:41,640 --> 01:19:43,520
So that variable is going to itself

953
01:19:46,700 --> 01:19:48,000
evaluate down to a value.

954
01:19:49,760 --> 01:19:50,230
OC: Yes,

955
01:19:50,230 --> 01:19:51,520
JW: So we can have a lambda

956
01:19:53,520 --> 01:19:54,940
be a host language lambda.

957
01:19:59,410 --> 01:20:00,940
Of expression to expression.

958
01:20:00,940 --> 01:20:02,700
OC: Why expression to expression

959
01:20:02,700 --> 01:20:04,230
and not double to expression ?

960
01:20:06,940 --> 01:20:08,580
JW: Because it's a lambda in there

961
01:20:08,580 --> 01:20:10,820
and this would be
the higher order syntax

962
01:20:11,520 --> 01:20:13,520
where we're using
the host languages'

963
01:20:14,940 --> 01:20:17,290
ability to represent
functions as values..

964
01:20:18,470 --> 01:20:20,230
In order for our target language

965
01:20:22,000 --> 01:20:23,764
to represent functions as values.

966
01:20:24,110 --> 01:20:25,640
That's the high order nature.

967
01:20:26,470 --> 01:20:28,110
There can be no automatically

968
01:20:28,110 --> 01:20:29,880
derived show instance for these.

969
01:20:30,110 --> 01:20:31,410
This is the tedious part

970
01:20:31,410 --> 01:20:33,410
where we have to do a lot of inaudible.

971
01:20:36,470 --> 01:20:37,880
We have to say for every one

972
01:20:38,940 --> 01:20:39,760
of these things.....

973
01:20:43,880 --> 01:20:45,290
I need to say what it means

974
01:20:45,290 --> 01:20:46,230
to print that out.

975
01:20:48,230 --> 01:20:50,000
So I'm going to say what that means.

976
01:20:50,820 --> 01:20:52,580
OC: Do we still need show instance ?

977
01:20:53,410 --> 01:20:55,170
 We could just drop that I suppose.

978
01:20:58,000 --> 01:21:00,350
JW: True, but it comes
in handy for debugging

979
01:21:10,700 --> 01:21:12,350
Lambda is not going to be there.

980
01:21:58,110 --> 01:22:01,760
It's not  inaudible it's the fact that this has to be modeled.

981
01:22:08,580 --> 01:22:10,700
Pretty soon this is going to be 300 lines

982
01:22:11,640 --> 01:22:13,290
as usually happens at Haskell !

983
01:22:13,290 --> 01:22:15,290
OC: inaudible strings here right ?

984
01:22:15,290 --> 01:22:17,410
because show is
defined as a function

985
01:22:17,520 --> 01:22:18,940
from something to string.

986
01:22:18,940 --> 01:22:20,000
JW: Your right.

987
01:22:31,760 --> 01:22:33,520
OC: I think your alright using show.

988
01:22:34,941 --> 01:22:37,529
Oh yes ! because we're
defining a show of instance.

989
01:22:38,000 --> 01:22:40,235
Yes, so we want
unpack in these two places.

990
01:22:45,050 --> 01:22:46,230
JW: Now I have my lambda.

991
01:22:48,230 --> 01:22:49,760
The first thing is to decide

992
01:22:49,760 --> 01:22:51,170
how I'm going to evaluate it.

993
01:22:52,230 --> 01:22:54,350
Before I go on to how
I'm going to parse it.

994
01:22:56,350 --> 01:22:58,000
So I get my lambda, and I have an F

995
01:22:59,410 --> 01:23:00,580
and now I'm going to say:

996
01:23:12,700 --> 01:23:13,760
I need a double.

997
01:23:14,940 --> 01:23:18,820
I need a body inaudible

998
01:23:22,000 --> 01:23:24,235
I need to define
what application means.

999
01:23:24,230 --> 01:23:25,882
What it means to call a function.

1000
01:23:26,000 --> 01:23:27,640
That's how it gets it's argument.

1001
01:23:29,170 --> 01:23:31,410
Application takes a
form and an argument.

1002
01:23:36,700 --> 01:23:38,230
And we're going to show that as ....

1003
01:23:46,230 --> 01:23:47,880
OC: Is F here going to be the name

1004
01:23:48,940 --> 01:23:50,350
of the lambda abstraction ?

1005
01:23:51,410 --> 01:23:51,880
JW: Yes

1006
01:23:54,820 --> 01:23:56,941
We'll restrict it to
being nothing fancy

1007
01:23:57,410 --> 01:23:59,290
like a restriction that evaluates

1008
01:24:01,290 --> 01:24:03,647
to a lambda that can
be passed as an argument.

1009
01:24:03,880 --> 01:24:05,410
That would be cool but for now

1010
01:24:05,760 --> 01:24:08,000
we'll have functions
referenced by name.

1011
01:24:11,520 --> 01:24:12,941
So we have EApp be the name 

1012
01:24:14,823 --> 01:24:17,411
and the argument is
going to be the expression.

1013
01:24:17,411 --> 01:24:18,823
So we only allow arguments.

1014
01:24:19,880 --> 01:24:20,820
We want unpack  in.

1015
01:24:29,170 --> 01:24:30,110
We'll say:

1016
01:24:43,290 --> 01:24:44,470
Then look up in the map ....

1017
01:24:58,470 --> 01:25:00,470
We can't store just doubles in our map.

1018
01:26:12,820 --> 01:26:14,000
Evaluating a lambda.

1019
01:26:20,230 --> 01:26:23,050
There should be no
context in which it's evaluating.

1020
01:26:25,050 --> 01:26:26,580
OC: That's basically a type error.

1021
01:26:26,580 --> 01:26:28,580
inaudible language

1022
01:27:04,470 --> 01:27:06,470
Now I need to define these two things

1023
01:27:07,170 --> 01:27:09,647
OC: There's a little
more syntax to bring in here

1024
01:27:10,350 --> 01:27:11,760
We had that binding before,

1025
01:27:11,760 --> 01:27:13,520
now we're going to have fun binding.

1026
01:27:17,410 --> 01:27:19,880
OC: We're already having
fun binding. (laughter).

1027
01:27:26,580 --> 01:27:28,110
So we want the symbol define.

1028
01:27:30,110 --> 01:27:32,000
We want the name and the open parens

1029
01:27:35,050 --> 01:27:36,941
We want also, the argument to be name.

1030
01:27:43,640 --> 01:27:45,170
Then we want closing parens,

1031
01:27:46,350 --> 01:27:47,880
and then open curly (laughter).

1032
01:27:51,050 --> 01:27:53,410
And then we can
have up to many expressions

1033
01:27:57,520 --> 01:27:58,940
in the body of the function.

1034
01:28:01,640 --> 01:28:03,290
Now, expressions that could end

1035
01:28:05,880 --> 01:28:06,580
in new lines.

1036
01:28:11,290 --> 01:28:13,050
And there is a thing we can use from

1037
01:28:15,050 --> 01:28:16,470
parser called text set-by.

1038
01:28:20,580 --> 01:28:21,640
So we want set-by one.

1039
01:28:24,350 --> 01:28:25,760
OC: So that at least one line

1040
01:28:27,760 --> 01:28:29,170
is separated by new lines.

1041
01:28:29,170 --> 01:28:30,000
JW: Right.

1042
01:28:32,000 --> 01:28:32,820
This is our body.

1043
01:28:34,820 --> 01:28:35,760
And now I'm going to:

1044
01:28:38,230 --> 01:28:40,000
We want a function that's going to

1045
01:28:40,000 --> 01:28:41,640
take in some number and return.....

1046
01:28:47,050 --> 01:28:48,580
Let me ask you this question:

1047
01:28:50,110 --> 01:28:51,760
What if we evaluate a function

1048
01:28:52,940 --> 01:28:54,350
that has let bindings in it ?

1049
01:28:54,350 --> 01:28:56,580
Because let
bindings should not escape

1050
01:28:56,940 --> 01:28:58,580
out of the function should they ?

1051
01:28:58,580 --> 01:29:00,470
And every time you run the function,

1052
01:29:01,050 --> 01:29:03,050
it should remove the let bindings.

1053
01:29:05,760 --> 01:29:08,580
JW: So a function is not
going to return an expression.

1054
01:29:09,880 --> 01:29:11,760
An expression is going to be a mutator

1055
01:29:11,760 --> 01:29:13,050
from doubles to doubles.

1056
01:29:16,350 --> 01:29:18,580
But, we want it to
inherit the environment.

1057
01:29:22,000 --> 01:29:23,760
that it was executed in each time.

1058
01:29:23,760 --> 01:29:26,820
OC: So we can refer to let
bindings outside the function.

1059
01:29:31,170 --> 01:29:33,760
So instead of using
something as fancy as reader,

1060
01:29:34,470 --> 01:29:37,050
we're going to take in
environment as an argument.

1061
01:29:37,050 --> 01:29:37,640
OC: Sure.

1062
01:29:40,700 --> 01:29:43,290
JW: We have our inaudible

1063
01:29:44,230 --> 01:29:45,290
JW: We're going to say:

1064
01:30:00,110 --> 01:30:01,410
Oh, we can bind our name to ....

1065
01:30:04,000 --> 01:30:06,470
OC: So we put that
double into the environment.

1066
01:30:06,470 --> 01:30:07,170
JW: Right.

1067
01:30:08,230 --> 01:30:09,170
We have to say:

1068
01:30:27,880 --> 01:30:28,940
It can't just be that.

1069
01:30:29,760 --> 01:30:31,880
OC: We need to wrap
it up as an expression.

1070
01:30:40,940 --> 01:30:44,000
inaudible wrapped.

1071
01:30:51,176 --> 01:30:53,411
Eval state T
returns an identity double.

1072
01:30:55,290 --> 01:30:56,705
Then arg is the wrong thing.

1073
01:30:59,880 --> 01:31:01,410
It is not the body expression.

1074
01:31:02,940 --> 01:31:04,580
Now we want to sequence through.

1075
01:31:08,000 --> 01:31:09,520
 We want to fold down the body.

1076
01:31:11,520 --> 01:31:13,290
OC: You would probably be alright

1077
01:31:16,235 --> 01:31:18,823
taking the last value
of the expression for now.

1078
01:31:19,520 --> 01:31:21,170
JW: I need to evaluate every one

1079
01:31:22,470 --> 01:31:25,170
so that any internal
let bindings get established.

1080
01:31:25,170 --> 01:31:25,880
OC: Right, OK.

1081
01:31:31,880 --> 01:31:33,290
We're going to bind this in.

1082
01:31:35,170 --> 01:31:36,940
I'm going to do a flip binding here.

1083
01:31:40,470 --> 01:31:41,880
And then fold M inside here.

1084
01:31:45,640 --> 01:31:48,230
It's going to go from
environment to environment.

1085
01:31:49,520 --> 01:31:50,940
For every body expression.

1086
01:31:52,940 --> 01:31:54,820
Folding down from the environment

1087
01:31:54,820 --> 01:31:55,640
over the body.

1088
01:32:00,700 --> 01:32:02,000
So inaudible expected type.

1089
01:32:13,640 --> 01:32:15,880
And fold M has the
accumulator on the left.

1090
01:32:23,640 --> 01:32:25,170
I don't need to fold M that way.

1091
01:32:32,350 --> 01:32:33,170
Pass in a double

1092
01:32:34,470 --> 01:32:35,410
As it thinks I need.

1093
01:32:38,110 --> 01:32:40,230
And we're going to
ignore it in each step.

1094
01:32:41,640 --> 01:32:44,588
OC: So we're just taking
the last double that's produced.

1095
01:32:44,588 --> 01:32:45,882
JW: Right, and then we need 

1096
01:32:45,882 --> 01:32:47,176
the right identity here.

1097
01:32:49,760 --> 01:32:51,050
OC: Yes, cool, everything ...

1098
01:32:54,580 --> 01:32:57,290
JW: Now the functions
are differently expressed.

1099
01:32:59,290 --> 01:33:01,520
Function application
now has to hand in

1100
01:33:01,520 --> 01:33:02,940
the current environment.

1101
01:33:04,000 --> 01:33:04,940
Which makes sense.

1102
01:33:08,940 --> 01:33:13,050
inaudible first argument.

1103
01:33:14,580 --> 01:33:16,580
This is now just going to be the value.

1104
01:33:22,820 --> 01:33:23,640
Type check time.

1105
01:33:36,350 --> 01:33:38,230
I don't like excessively long lines.

1106
01:33:43,520 --> 01:33:45,290
OK, let's try this out with test file.

1107
01:33:46,820 --> 01:33:48,110
Unknown variable, fine.

1108
01:33:50,580 --> 01:33:52,230
We haven't tied it in yet so we need:

1109
01:33:56,000 --> 01:33:57,290
What else did we define ?

1110
01:33:57,290 --> 01:33:58,700
We need to do application.

1111
01:34:01,290 --> 01:34:02,820
A naked variable reference

1112
01:34:03,170 --> 01:34:04,940
could be a variable reference or

1113
01:34:04,940 --> 01:34:06,350
it could be a function call.

1114
01:34:09,640 --> 01:34:11,170
OC: I think all function calls

1115
01:34:11,170 --> 01:34:13,410
are immediately followed by parenthesis

1116
01:34:14,470 --> 01:34:16,230
with no white space between them.

1117
01:34:16,230 --> 01:34:16,820
JW:  Right.

1118
01:34:17,760 --> 01:34:19,760
So we're going to try to parse a fun-cal.

1119
01:34:27,880 --> 01:34:30,000
Because if there is
no paren after that,

1120
01:34:32,000 --> 01:34:33,520
we'll back track all the way up.

1121
01:34:42,110 --> 01:34:44,350
We want the name of
the function to come in.

1122
01:34:48,820 --> 01:34:51,290
Except instead of parsing a inaudible,

1123
01:34:51,290 --> 01:34:53,290
we're going to parse a sub expression.

1124
01:34:53,290 --> 01:34:54,470
Then we're going to say:

1125
01:35:07,640 --> 01:35:11,760
inaudible

1126
01:35:11,760 --> 01:35:13,410
So we tried to evaluate a lambda

1127
01:35:13,880 --> 01:35:16,110
because we put a
lambda in our syntax tree

1128
01:35:18,940 --> 01:35:19,880
Why did we do that ?

1129
01:35:24,110 --> 01:35:26,470
Oh that's right, what
does define evaluate to.

1130
01:35:27,760 --> 01:35:30,000
 It evaluates to the
body of the function.

1131
01:35:30,820 --> 01:35:31,760
Which is a lambda.

1132
01:35:32,470 --> 01:35:34,000
In that case we're going to say

1133
01:35:34,820 --> 01:35:36,580
that functions evaluate to zero.

1134
01:35:44,940 --> 01:35:46,470
That just did not work at all.

1135
01:35:51,290 --> 01:35:52,940
OC: We have a zero from our define.

1136
01:35:53,520 --> 01:35:55,050
I guess the error is on the let.

1137
01:35:55,640 --> 01:35:57,520
JW: Yes, we put some boundary on there.

1138
01:35:59,170 --> 01:36:00,700
OC: so tracing  inaudible

1139
01:36:01,520 --> 01:36:03,294
JW:  Yes. I see the two, three and zero.

1140
01:36:04,940 --> 01:36:05,640
We defined it.

1141
01:36:07,170 --> 01:36:09,640
So it's the call that
we're having a problem with.

1142
01:36:11,640 --> 01:36:12,820
expecting define ....

1143
01:36:12,820 --> 01:36:15,050
OC: The problem here
is our function name

1144
01:36:16,110 --> 01:36:16,940
starts with a D.

1145
01:36:17,880 --> 01:36:19,640
And when it sees D it presumes it's ....

1146
01:36:24,700 --> 01:36:26,700
We'll probably have to try unbinding.

1147
01:36:32,110 --> 01:36:33,640
JW: Unknown function double.

1148
01:36:34,940 --> 01:36:37,170
But we did just
define a function double.

1149
01:36:37,170 --> 01:36:38,000
JW: Yes, right.

1150
01:36:41,520 --> 01:36:43,290
We need to go to define and find out

1151
01:36:46,230 --> 01:36:48,110
why it did not get inserted into the ...

1152
01:36:52,820 --> 01:36:53,760
Ah, that's what it is.

1153
01:36:54,820 --> 01:36:56,000
OC: Define gave us Elam ....

1154
01:36:56,820 --> 01:36:58,580
JW: And the blue line is telling us

1155
01:36:58,580 --> 01:37:00,230
"your not doing anything with me".

1156
01:37:03,764 --> 01:37:04,700
Elam needs to have:

1157
01:37:07,640 --> 01:37:09,294
Just as let did, Elam needs a name.

1158
01:37:14,470 --> 01:37:16,941
Now when we go, we
won't just have the type error

1159
01:37:24,470 --> 01:37:27,050
Now we need something
new to go into our map, right ?

1160
01:37:27,880 --> 01:37:29,410
We can just put Elam in there.

1161
01:37:30,580 --> 01:37:31,640
So we're going to say:

1162
01:37:33,640 --> 01:37:35,290
OC: It's exactly the same as Elet

1163
01:37:35,880 --> 01:37:37,760
but without the evaluation I guess.

1164
01:38:01,170 --> 01:38:02,820
Elam should have two arguments.

1165
01:38:03,170 --> 01:38:05,760
Oh ! the inaud..

1166
01:38:06,700 --> 01:38:07,640
We're going to say:

1167
01:38:24,350 --> 01:38:26,000
Yehey ! unknown function double.

1168
01:38:26,820 --> 01:38:29,410
This is where we put in
a little bit of our tracing.

1169
01:38:50,940 --> 01:38:52,820
It never showed it, so we get to there ....

1170
01:38:55,290 --> 01:38:56,230
We must have done ....

1171
01:38:58,230 --> 01:38:59,520
Oh, nobody used the value,

1172
01:39:00,000 --> 01:39:01,520
that's why the trace didn't get ....

1173
01:39:02,700 --> 01:39:04,470
Since no one is forcing the value

1174
01:39:04,580 --> 01:39:07,050
that means the insert
is not happening either.

1175
01:39:10,470 --> 01:39:11,880
If it's just returning zero

1176
01:39:12,820 --> 01:39:15,410
it can inaudible out the rest.

1177
01:39:16,350 --> 01:39:18,000
OC: It should be forcing us inaudible

1178
01:39:18,000 --> 01:39:19,050
JW:  Your right.

1179
01:39:22,110 --> 01:39:25,050
OC: Maybe in our inaudible file

1180
01:39:26,820 --> 01:39:28,940
we print environment after every step.

1181
01:39:28,940 --> 01:39:30,235
JW: Oh! Is that our problem ?

1182
01:39:32,705 --> 01:39:35,058
OC: Yes, the file doesn't
do what the rebel does.

1183
01:39:36,470 --> 01:39:37,290
JW: Ah, thank you.

1184
01:39:40,470 --> 01:39:42,110
In the file parser we need to do

1185
01:39:42,580 --> 01:39:44,820
the exact same thing
we we're doing before

1186
01:39:46,110 --> 01:39:46,700
Which is :

1187
01:40:06,588 --> 01:40:07,529
That did not work.

1188
01:40:19,290 --> 01:40:20,700
For every line in the input,

1189
01:40:20,700 --> 01:40:21,640
we parse the line,

1190
01:40:24,110 --> 01:40:25,760
and execute it within our state.

1191
01:40:26,820 --> 01:40:28,000
and print the result.

1192
01:40:33,880 --> 01:40:36,470
OC: Can we just flip back
to the error we had again.

1193
01:40:36,470 --> 01:40:38,470
JW: Now we have a much different error.

1194
01:40:40,470 --> 01:40:41,410
we have regressed.

1195
01:40:44,110 --> 01:40:45,529
Let me see what version of 

1196
01:40:45,520 --> 01:40:47,294
the code we were using previously.

1197
01:41:17,760 --> 01:41:20,350
We're not using the inaudible.

1198
01:41:21,640 --> 01:41:24,230
So I'm going to go
ahead and use the view patterns.

1199
01:41:26,820 --> 01:41:29,410
OC: So view patterns
here let us call a function

1200
01:41:29,410 --> 01:41:30,820
before binding a variable.

1201
01:41:31,170 --> 01:41:31,640
JW: Yes.

1202
01:41:31,640 --> 01:41:35,170
I could just do that inaudible silly use of a pattern.

1203
01:41:40,000 --> 01:41:41,760
Except that it's going to be a maybe.

1204
01:41:45,290 --> 01:41:47,410
So we have to lift
one level out, and say ....

1205
01:41:56,470 --> 01:41:58,000
OC: We could use 4 M again there.

1206
01:41:59,050 --> 01:42:00,470
You can use 4 M over a maybe.

1207
01:42:01,290 --> 01:42:03,170
I think we have to use data.foldable

1208
01:42:09,640 --> 01:42:12,000
which in real
world projects is very useful.

1209
01:42:15,410 --> 01:42:18,230
Look at that inaudible

1210
01:42:20,110 --> 01:42:21,529
So we have 5 equaling 1 plus ....

1211
01:42:24,470 --> 01:42:25,640
We even have an error.

1212
01:42:26,820 --> 01:42:28,350
We are missing a parenthesis

1213
01:42:28,350 --> 01:42:30,110
and yet we didn't get a syntax there.

1214
01:42:31,410 --> 01:42:33,760
Let me see what
happens if I do that directly.

1215
01:42:38,820 --> 01:42:40,230
Might as well do it this way.

1216
01:42:41,640 --> 01:42:42,580
Ah ! the parse stops.

1217
01:42:46,820 --> 01:42:48,470
Because it has reached a token

1218
01:42:48,470 --> 01:42:50,000
it doesn't recognise, it ends.

1219
01:42:50,700 --> 01:42:53,520
Other parsers like inaudible,

1220
01:42:54,230 --> 01:42:55,520
I could coax it to tell me

1221
01:42:55,520 --> 01:42:57,410
what the remainder of the input was.

1222
01:42:57,410 --> 01:42:59,290
I don't know how that's done in parsec

1223
01:42:59,760 --> 01:43:02,350
and I don't think we
should worry about it just now.

1224
01:43:11,760 --> 01:43:13,170
We can restrict our parser

1225
01:43:13,170 --> 01:43:14,940
on the line by line parser and say

1226
01:43:14,940 --> 01:43:16,470
we want it to terminate at EOF.

1227
01:43:21,050 --> 01:43:23,410
OC: So that requires
successful parser line ?

1228
01:43:25,410 --> 01:43:27,050
JW:  Right, so now I get unexpected.

1229
01:43:27,640 --> 01:43:29,640
Of course the line numbers are all off,

1230
01:43:29,640 --> 01:43:31,290
because we do this line by line.

1231
01:43:34,820 --> 01:43:35,640
There we go.

1232
01:43:40,000 --> 01:43:41,290
five times five is 25 OK,

1233
01:43:42,000 --> 01:43:43,640
So 26 divided by two should be 13.

1234
01:43:46,350 --> 01:43:48,940
I would say that's a
good place for us to check in.

1235
01:44:00,230 --> 01:44:00,940
 OC: Awesome!

1236
01:44:07,410 --> 01:44:10,000
OC: Now we're getting
near the end of the session,

1237
01:44:10,000 --> 01:44:11,290
I wonder if we might try

1238
01:44:11,290 --> 01:44:13,410
to implement that Fibonacci function.

1239
01:44:13,760 --> 01:44:15,520
It's in one of these example files.

1240
01:44:17,050 --> 01:44:19,050
We should only need to redefine feed,

1241
01:44:21,640 --> 01:44:23,760
but we do need
a square root operation.

1242
01:44:23,760 --> 01:44:25,410
Maybe we could introduce that

1243
01:44:25,410 --> 01:44:27,050
as a primitive in the language.

1244
01:44:27,520 --> 01:44:29,640
That should allow
us to get all the way

1245
01:44:29,640 --> 01:44:31,050
to the bottom of this file.

1246
01:44:32,000 --> 01:44:33,880
JW: We should be able to do that easily.

1247
01:44:34,352 --> 01:44:36,352
Because we chose the higher order 

1248
01:44:36,350 --> 01:44:37,764
abstract syntax notation.

1249
01:44:38,350 --> 01:44:40,350
That makes it easier for us to inject

1250
01:44:44,940 --> 01:44:47,290
what we would call a inaudible in our language.

1251
01:44:47,880 --> 01:44:49,050
All we need is a parser ....

1252
01:44:51,520 --> 01:44:52,470
and have an option ....

1253
01:44:53,050 --> 01:44:54,230
Let's extend funCall.

1254
01:44:55,290 --> 01:44:56,235
FunCall will say:

1255
01:45:08,230 --> 01:45:10,350
I don't want to
do it at call point, sorry.

1256
01:45:13,050 --> 01:45:15,520
I want to do it when
we define the environment.

1257
01:45:16,700 --> 01:45:17,760
So new environment.

1258
01:45:19,290 --> 01:45:20,940
Instead of having an empty map

1259
01:45:20,940 --> 01:45:22,230
we want a map where we can

1260
01:45:23,410 --> 01:45:24,700
insert into square root.

1261
01:45:40,700 --> 01:45:42,940
And we need to do this on an empty map.

1262
01:45:43,760 --> 01:45:45,290
We can call this a singleton.

1263
01:45:45,290 --> 01:45:55,882
See I have hlint down here suggesting
that I could say const sqrt because

1264
01:45:56,470 --> 01:45:58,000
I'm ignoring that parameter.

1265
01:45:58,000 --> 01:46:00,000
I still have an error, saying
I'm not using that language pragma.

1266
01:46:04,470 --> 01:46:05,170
Now we can say:

1267
01:46:10,350 --> 01:46:11,410
OC: Excellent.

1268
01:46:11,647 --> 01:46:13,058
JW: If we go over to our file,

1269
01:46:13,764 --> 01:46:15,176
and we see now that we have,

1270
01:46:16,470 --> 01:46:19,176
(I was doing a lot of
work in this little scratch file)

1271
01:46:19,176 --> 01:46:20,235
Phi should be fine.

1272
01:46:20,700 --> 01:46:22,350
Oh! we have a power operator here,

1273
01:46:24,350 --> 01:46:26,110
raising something to an exponent.

1274
01:46:26,110 --> 01:46:27,640
We need to quickly add that in.

1275
01:46:29,050 --> 01:46:30,820
It's rather like a multiplication.

1276
01:46:30,820 --> 01:46:33,050
OC: You can have
the same precedence there.

1277
01:46:33,050 --> 01:46:34,117
JW: We're going to say:

1278
01:46:39,050 --> 01:46:40,940
We'll use that as the same precedence.

1279
01:46:48,230 --> 01:46:50,820
We have now reached
a certain level of maturity

1280
01:46:50,820 --> 01:46:53,050
where we can drop
tracing from our parser

1281
01:47:07,640 --> 01:47:10,350
wherever EMul was

1282
01:47:21,520 --> 01:47:23,290
Is that appropriate for doubles ?

1283
01:47:23,760 --> 01:47:24,700
I'll just check.

1284
01:47:33,760 --> 01:47:35,640
I will take a look at this file again.

1285
01:47:40,940 --> 01:47:42,700
Do you really want the return keyword ?

1286
01:47:42,700 --> 01:47:44,820
Since the last
expression of the function

1287
01:47:44,820 --> 01:47:46,820
is defined to be the value of the call.

1288
01:47:46,820 --> 01:47:48,700
OC: Yes, I think we're OK dropping that.

1289
01:47:50,470 --> 01:47:52,700
JW: We've  got parens,
and we've got division.

1290
01:47:52,700 --> 01:47:53,410
we've got phi and psi ....

1291
01:47:54,580 --> 01:47:57,520
A global phi and a local psi.

1292
01:47:57,520 --> 01:47:58,470
Let's give it a try ....

1293
01:47:58,470 --> 01:48:00,000
Do you think it's going to work ?

1294
01:48:02,820 --> 01:48:03,880
OC: I'm going to say no,

1295
01:48:03,880 --> 01:48:05,880
I don't think it will work (laughter).

1296
01:48:06,580 --> 01:48:07,880
JW:  So unknown variable N ....

1297
01:48:09,880 --> 01:48:12,470
We're now making
reference to a local variable.

1298
01:48:13,050 --> 01:48:15,880
That's a good thing, to
check why isn't that happening.

1299
01:48:17,290 --> 01:48:18,110
When we defined ....

1300
01:48:19,520 --> 01:48:22,000
OC: When we went into the lambda we
don't seem to be extending the environment.

1301
01:48:22,000 --> 01:48:23,760
we are extending the environment.

1302
01:48:24,230 --> 01:48:25,640
So we got the arg, as the name,

1303
01:48:26,700 --> 01:48:28,230
we extended the environment.

1304
01:48:30,230 --> 01:48:32,820
We evaluate within
that extended environment ....

1305
01:48:34,820 --> 01:48:36,470
OC: Are we able to see which line

1306
01:48:36,470 --> 01:48:38,000
it's having this trouble with ?

1307
01:48:41,880 --> 01:48:43,640
we've got quite a few unexpecteds.

1308
01:48:50,352 --> 01:48:51,882
JW:  It's the definition of fib

1309
01:48:53,410 --> 01:48:55,294
that seems to be having the problem.

1310
01:48:55,410 --> 01:48:56,588
Column 3 or column 8.

1311
01:48:59,290 --> 01:49:00,941
It wasn't expecting the word fib.

1312
01:49:12,580 --> 01:49:13,520
See that works.

1313
01:49:17,290 --> 01:49:18,820
Let's reduce the problem here,

1314
01:49:19,880 --> 01:49:22,580
get rid of these ones that are before it.

1315
01:49:27,050 --> 01:49:31,520
OC: The let binding is definitely working 
because we're seeing that

1316
01:49:38,580 --> 01:49:41,410
OC: This isn't a problem
with the comment dropping those ?...

1317
01:49:53,880 --> 01:49:55,760
Let's see if whitespace is consuming.

1318
01:49:57,760 --> 01:50:00,230
Oh! Whitespace only
takes space into account.

1319
01:50:01,050 --> 01:50:02,470
We want it to be space or tab,

1320
01:50:06,000 --> 01:50:07,764
or return or newline..

1321
01:50:12,000 --> 01:50:14,820
OC: Is it the leading
whitespace causing the problem ?

1322
01:50:16,230 --> 01:50:18,350
or are we stripping the leading whitespace
out as well.

1323
01:50:18,350 --> 01:50:20,580
JW: We should be
stripping any white space

1324
01:50:20,580 --> 01:50:22,110
that occurs before the brace

1325
01:50:22,110 --> 01:50:23,050
and after the brace.

1326
01:50:33,290 --> 01:50:34,940
Let's see if it would help to have

1327
01:50:36,110 --> 01:50:38,000
a semi colon in our function bodies.

1328
01:50:44,470 --> 01:50:45,640
And that does not help.

1329
01:50:45,640 --> 01:50:47,290
I think the problem is outside.

1330
01:50:49,880 --> 01:50:51,760
We need to bring some tracing back in:

1331
01:51:13,050 --> 01:51:15,050
We're getting as far as parsing
funBinding seven

1332
01:51:15,050 --> 01:51:22,117
so it's not liking the closing brace.

1333
01:51:27,050 --> 01:51:29,880
OC: That expected F
assumes that the define is a variable
name

1334
01:51:31,290 --> 01:51:33,529
and it's trying to
do addition on that variable.

1335
01:51:41,170 --> 01:51:42,470
Maybe if we just try to do 

1336
01:51:42,470 --> 01:51:44,235
one expression in the definition

1337
01:51:45,170 --> 01:51:47,290
see if that gives
us any more progress.

1338
01:51:58,000 --> 01:51:59,640
JW: We're getting as far as seven.

1339
01:52:25,170 --> 01:52:26,230
OC: Or maybe trace it ?

1340
01:53:05,050 --> 01:53:07,170
JW: Let's try parsing the single expression.

1341
01:53:39,410 --> 01:53:42,110
JW: It's trying to parse
the funBinding and failing.

1342
01:53:44,110 --> 01:53:46,117
So it's trying to parse it as a funCall.

1343
01:53:48,820 --> 01:53:51,170
OC: But that's failing
because it doesn't see

1344
01:53:51,170 --> 01:53:53,290
an open parenthesis right after define.

1345
01:53:54,470 --> 01:53:57,170
JW: Exactly and then
it tries to do it as a variable

1346
01:53:58,110 --> 01:53:59,760
I'm surprised it's not telling us ....

1347
01:54:01,760 --> 01:54:02,700
"unknown variable".

1348
01:54:05,050 --> 01:54:07,520
OC: It's still trying
to evaluate at that point.

1349
01:54:10,700 --> 01:54:12,230
we're failing in the parsing.

1350
01:54:21,640 --> 01:54:24,110
JW: It should read it
as a variable shouldn't it ?

1351
01:54:25,760 --> 01:54:28,000
OC: It is giving a
variable called define.

1352
01:54:28,350 --> 01:54:29,640
And the next thing to do

1353
01:54:30,230 --> 01:54:32,580
is to look for a math operator.

1354
01:54:36,940 --> 01:54:38,820
JW: That's right. That's what it's saying

1355
01:54:38,823 --> 01:54:40,000
it's expecting to see 

1356
01:54:40,000 --> 01:54:41,882
unexpected F wanted a math operator.

1357
01:54:44,580 --> 01:54:46,940
Because the define
expression is failing,

1358
01:54:51,410 --> 01:54:53,520
because of a failure to parse "d".

1359
01:54:59,520 --> 01:55:00,470
Ah, you know what ....

1360
01:55:02,230 --> 01:55:04,000
We don't do multi line parsing yet.

1361
01:55:04,940 --> 01:55:07,410
We're handing these
to the parser line by line.

1362
01:55:09,410 --> 01:55:11,760
OC: We should be able
to put it all in one line

1363
01:55:11,760 --> 01:55:13,410
and then our test will be simple.

1364
01:55:13,410 --> 01:55:14,470
JW:  You would think.

1365
01:55:14,470 --> 01:55:15,640
OC: Let's try that first.

1366
01:55:19,050 --> 01:55:21,410
JW: So we're going to
have to break into lines,

1367
01:55:21,410 --> 01:55:22,700
strip out the comments,

1368
01:55:23,640 --> 01:55:25,520
and then put the lines back together.

1369
01:55:25,520 --> 01:55:27,880
OC:  If we just modify
our test pc file for now

1370
01:55:27,880 --> 01:55:30,230
we should be able to
join four lines into one.

1371
01:55:30,700 --> 01:55:31,640
JW: You mean in here ?

1372
01:55:31,640 --> 01:55:32,110
OC: Yes.

1373
01:55:35,880 --> 01:55:37,411
Because we have a semi colon

1374
01:55:37,410 --> 01:55:38,941
between them we might be OK.

1375
01:55:39,050 --> 01:55:40,940
JW: I don't know if I kept the semi colon.

1376
01:55:43,290 --> 01:55:44,110
Oh I did keep it.

1377
01:55:48,700 --> 01:55:49,290
Very good !

1378
01:55:50,580 --> 01:55:51,880
So it's 1,2 and 55, correct.

1379
01:55:53,170 --> 01:55:54,580
OC: Yes, almost 55 anyway.

1380
01:56:01,050 --> 01:56:03,410
JW: We don't have
multi line working just yet

1381
01:56:03,410 --> 01:56:05,290
but we do have a way to do separators.

1382
01:56:05,880 --> 01:56:07,760
And since you're probably going to be

1383
01:56:07,760 --> 01:56:09,760
typing these at a repl anyway

1384
01:56:09,760 --> 01:56:12,940
This probably makes more
sense for things to fit on one line.

1385
01:56:14,940 --> 01:56:16,580
Here's our file, we can show that...

1386
01:56:17,640 --> 01:56:20,352
(I can get rid of that
little devil at the beginning)

1387
01:56:22,110 --> 01:56:24,352
we do get a close
approximation (laughter).

1388
01:56:27,290 --> 01:56:28,823
It's just one of those things.

1389
01:56:30,470 --> 01:56:32,820
To wrap this up we
need a way to execute this

1390
01:56:32,820 --> 01:56:34,000
from the command line.

1391
01:56:34,820 --> 01:56:36,470
If I go into my parser and look at

1392
01:56:36,470 --> 01:56:38,700
this repl function
we have been calling.

1393
01:56:38,700 --> 01:56:39,880
Really that IS our main.

1394
01:56:40,820 --> 01:56:41,290
If I now:

1395
01:57:09,050 --> 01:57:11,640
OC: This is also reading
from standard input then ?

1396
01:57:11,640 --> 01:57:14,823
JW: Yes, in theory, we can pipe
that file we have been working on into it.

1397
01:57:16,580 --> 01:57:18,470
Maybe let's see what we get with that ?

1398
01:57:24,000 --> 01:57:24,941
JW: Not quite !

1399
01:57:25,880 --> 01:57:28,940
OC: I guess our repl
doesn't deal with comments like that

1400
01:57:28,940 --> 01:57:31,411
Let's try this outside
of Emacs, you never know.

1401
01:57:36,700 --> 01:57:37,050
JW:  No.

1402
01:57:37,760 --> 01:57:40,470
OC: I think our repl isn't
dealing with the comments

1403
01:57:40,470 --> 01:57:42,470
within the file, and that kind of stuff.

1404
01:57:46,820 --> 01:57:49,170
OC: That's cool, I guess
we should wrap up then.

1405
01:57:50,580 --> 01:57:52,110
OC: What are the kind of things

1406
01:57:52,110 --> 01:57:54,230
that stand out to you: the itches
you want to scratch?

1407
01:57:55,410 --> 01:57:58,230
JW: If I wanted to build
this into a nice toy calculator

1408
01:57:59,290 --> 01:58:02,000
I would first want to
get rid of all the repetition

1409
01:58:02,580 --> 01:58:04,470
in dealing with calling the parsecs.

1410
01:58:05,050 --> 01:58:07,640
I would factor that out
with some other function

1411
01:58:07,640 --> 01:58:09,520
and all these would call as helpers.

1412
01:58:11,050 --> 01:58:13,170
There are some inefficiencies in here.

1413
01:58:13,170 --> 01:58:14,700
The fact that in our map type,

1414
01:58:15,880 --> 01:58:17,880
we have a map from text to expression.

1415
01:58:17,880 --> 01:58:19,294
So as I mentioned earlier,

1416
01:58:19,410 --> 01:58:21,640
we would always
be re-evaluating variables.

1417
01:58:24,820 --> 01:58:26,820
I would rather have them as constants

1418
01:58:26,820 --> 01:58:28,820
that immediately reduce to doubles.

1419
01:58:34,940 --> 01:58:37,880
At the point we're we're evaluating our inaudible.

1420
01:58:42,350 --> 01:58:45,290
When we see a let, instead
of putting the body of the let

1421
01:58:45,290 --> 01:58:47,050
into the map, we could evaluate it

1422
01:58:47,050 --> 01:58:48,470
stick it in an enum.

1423
01:58:48,940 --> 01:58:50,350
and then put that in the map

1424
01:58:50,350 --> 01:58:52,110
and that would achieve what I want.

1425
01:58:52,110 --> 01:58:54,820
OC: You would be basically be doing a inaudible then ?

1426
01:58:54,820 --> 01:58:57,290
JW:  Yes, something like
that, it hurts not to do it.

1427
01:58:59,290 --> 01:59:00,580
So we will just say this:

1428
01:59:10,110 --> 01:59:12,470
Enum wants a double
and it got an expression

1429
01:59:13,050 --> 01:59:14,350
because it wants B prime.

1430
01:59:15,170 --> 01:59:17,410
That would be one
of the things I would do

1431
01:59:17,410 --> 01:59:18,470
Too easy not to do it.

1432
01:59:20,470 --> 01:59:23,050
I would switch to using
a real tokeniser parsec

1433
01:59:24,000 --> 01:59:26,820
because it would clear
up some problems we ran into

1434
01:59:26,820 --> 01:59:28,820
 inaudible code

1435
01:59:28,820 --> 01:59:29,760
and easier to see.

1436
01:59:30,580 --> 01:59:33,880
You also have the ability to
see define languages in parsec

1437
01:59:33,880 --> 01:59:35,760
so you can see what's the precedence

1438
01:59:35,760 --> 01:59:37,410
my various operators should be

1439
01:59:37,880 --> 01:59:40,230
and it will figure
out how to parse them all

1440
01:59:40,230 --> 01:59:41,410
in the correct order.

1441
01:59:43,410 --> 01:59:46,580
I might move to a
fixed point of representation

1442
01:59:48,580 --> 01:59:50,110
of my expert data type here

1443
01:59:50,580 --> 01:59:52,820
so that my
evaluators get easier to write.

1444
01:59:53,880 --> 01:59:55,520
inaudible

1445
01:59:56,940 --> 02:00:00,470
The tool inaudible bc

1446
02:00:01,760 --> 02:00:03,880
In bc I go back
out to do the expression

1447
02:00:03,880 --> 02:00:06,000
and inaudible

1448
02:00:08,820 --> 02:00:11,294
And I would like
tests that every expression

1449
02:00:12,470 --> 02:00:14,000
when printed, can read back in,

1450
02:00:14,588 --> 02:00:16,823
and then reprint
as the same expression.

1451
02:00:17,760 --> 02:00:20,110
That's pretty much
where I would go with this.

1452
02:00:20,350 --> 02:00:21,880
But if I was trying to compete

1453
02:00:21,880 --> 02:00:23,520
with a mathematics professor

1454
02:00:23,880 --> 02:00:25,880
I wouldn't be too happy with something

1455
02:00:25,880 --> 02:00:28,230
that just works nicely
on the command line.

1456
02:00:29,640 --> 02:00:32,230
OC: That's fantastic. Thanks a lot.

