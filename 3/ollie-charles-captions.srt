1
00:00:02,000 --> 00:00:03,920
NARRATOR: Welcome to Peer to Peer

2
00:00:03,930 --> 00:00:07,245
where  you can hone your
skills by watching live coding videos

3
00:00:08,800 --> 00:00:11,097
Our guest today is Ollie Charles

4
00:00:11,140 --> 00:00:13,245
who's a Haskell developer at Fynder

5
00:00:13,250 --> 00:00:15,897
and the author of 24 days of Hackage.

6
00:00:16,800 --> 00:00:18,571
Our host is Steve Purcell

7
00:00:19,062 --> 00:00:21,645
and the challenge
that we set for Ollie is called:

8
00:00:24,251 --> 00:00:26,354
Steve Purcell: So Ollie would you like to start

9
00:00:26,354 --> 00:00:28,190
by reading through the question description?

10
00:00:28,190 --> 00:00:31,897
Ollie Charles: So it's write a
program that solves word chain puzzles.

11
00:00:55,820 --> 00:00:58,310
OC: So that seems pretty straightforward to me.

12
00:00:58,310 --> 00:01:00,450
I guess that we've got a restriction there,

13
00:01:00,450 --> 00:01:02,114
that the start and the end words

14
00:01:02,114 --> 00:01:03,714
will have to be the same length?

15
00:01:03,714 --> 00:01:04,570
SP: Yes they will.

16
00:01:08,285 --> 00:01:10,937
OC: You've given me this dictionary as well.

17
00:01:14,670 --> 00:01:17,382
And I see that some of these are different case.

18
00:01:17,880 --> 00:01:20,171
Is that going to have any impact on the problem ?

19
00:01:20,182 --> 00:01:21,588
Do I need to preserve case or

20
00:01:21,580 --> 00:01:22,914
or lower case everything?

21
00:01:22,960 --> 00:01:24,942
SP: I would like the resulting chain

22
00:01:25,880 --> 00:01:30,548
to include the original case
of the word from this file,

23
00:01:30,560 --> 00:01:34,754
and if you ask for a chain
between two particular words

24
00:01:34,765 --> 00:01:37,740
they should be present
with the same case in the

25
00:01:37,740 --> 00:01:40,628
word list file in order to be considered valid.

26
00:01:40,620 --> 00:01:44,800
OC: OK.  And is changing case
going to be considered an operation ?

27
00:01:45,097 --> 00:01:47,748
So if I have something
that starts with a lower case A

28
00:01:47,740 --> 00:01:52,400
and an upper case A is that a difference of one ?

29
00:01:53,000 --> 00:01:55,028
SP: I think so, I think a word will

30
00:01:55,028 --> 00:02:00,662
either be capitalized
or not in the dictionary.

31
00:02:02,182 --> 00:02:05,920
I don't think you would
find the same word in there twice,

32
00:02:06,205 --> 00:02:08,080
once capitalized and once not.

33
00:02:08,080 --> 00:02:12,640
OC: OK, Yes. Well,
I suppose we'll see what happens.

34
00:02:15,028 --> 00:02:19,462
The first thing to do
is get my environment set up.

35
00:02:19,817 --> 00:02:21,337
I want to have a Cabal file

36
00:02:21,340 --> 00:02:24,251
so I'll treat this
like a proper project.

37
00:02:24,260 --> 00:02:26,365
I'm going to be using nix  shell

38
00:02:26,365 --> 00:02:28,540
to work with that
kabal file to do builds

39
00:02:28,540 --> 00:02:31,177
and bring down
dependencies and stuff like that.

40
00:02:33,460 --> 00:02:35,771
OC: So I've got a terminal here,

41
00:02:35,782 --> 00:02:38,440
I should be able to run kabal in it.

42
00:02:38,520 --> 00:02:41,165
So let's call this Word Puzzle.

43
00:02:41,440 --> 00:02:44,742
It doesn't really matter about the version

44
00:02:44,754 --> 00:02:47,508
and I'll just use another license.

45
00:02:52,560 --> 00:02:56,594
I'll leave that blank ... and all this blank.

46
00:02:57,908 --> 00:03:01,371
SP: Yes it will probably become executable

47
00:03:02,045 --> 00:03:07,200
OC: And we'll go with word puzzle (inaudible) the main part

48
00:03:11,897 --> 00:03:16,342
So now I believe I have my spell bar (inaud)

49
00:03:16,537 --> 00:03:19,960
So I should be able to use the space bar (inaudible)

50
00:03:30,880 --> 00:03:33,600
OC: I'm using the UNIX compile command there

51
00:03:33,600 --> 00:03:36,514
to use the kabal file to do a build

52
00:03:36,811 --> 00:03:38,902
OC:  I'm just going to see if that compiles.

53
00:03:38,902 --> 00:03:42,422
Hopefully it's configuring.

54
00:03:42,434 --> 00:03:45,028
And it looks like we've got something.

55
00:03:45,645 --> 00:03:49,257
I'm going to have to (inaudible)

56
00:03:54,090 --> 00:03:57,634
OK, so that seems to be happy
compiling something like that

57
00:03:57,810 --> 00:04:01,725
and we can also subject that to the terminal 

58
00:04:02,457 --> 00:04:05,382
and run that .... yes.

59
00:04:08,594 --> 00:04:10,640
OC: I think the first thing I'm going to do

60
00:04:10,651 --> 00:04:12,845
is work with loading the dictionary words.

61
00:04:13,394 --> 00:04:15,760
so we've got some data to play with

62
00:04:15,970 --> 00:04:18,880
I'm going to start by making a type alias

63
00:04:18,890 --> 00:04:21,725
for the dictionary and for our purposes

64
00:04:21,725 --> 00:04:25,325
the dictionary is
just going to be a list of text values.

65
00:04:25,417 --> 00:04:29,988
And the text there is the type from Data.Text

66
00:04:32,570 --> 00:04:35,314
And I think I'll make a new function, dictionary

67
00:04:35,310 --> 00:04:40,034
which will take the file path
and give me back a dictionary. 

68
00:04:47,417 --> 00:04:49,108
I'll take that out for now.

69
00:04:53,900 --> 00:04:57,108
We're going to need
the Data Text library as well.

70
00:04:57,680 --> 00:04:59,554
So I'll add that to the Cabal file.

71
00:05:03,200 --> 00:05:04,617
And because I'm using nix

72
00:05:04,617 --> 00:05:06,971
I'm going to need to add it to my nix file as well

73
00:05:06,971 --> 00:05:09,085
so that's going to just pull down.

74
00:05:21,540 --> 00:05:25,154
Let's scrub that out for now.

75
00:05:27,634 --> 00:05:30,445
SP: So the underscore
you're leaving there is the hole?

76
00:05:30,445 --> 00:05:33,394
OC: Yes, so if we expand the compilation

77
00:05:33,474 --> 00:05:36,160
it says that there are two holes in this program

78
00:05:36,274 --> 00:05:38,708
We need to provide some type of computation

79
00:05:38,700 --> 00:05:41,680
that's going to be an io action
that will return the dictionary.

80
00:05:41,691 --> 00:05:43,910
And we also have another hole for main as well

81
00:05:43,931 --> 00:05:46,280
SP: And this is a new feature in the latest GHC?

82
00:05:46,280 --> 00:05:48,000
OC: yes. I think this came in GHC 7.8

83
00:05:50,140 --> 00:05:53,245
So  I'll leave the hole name for now,

84
00:05:53,245 --> 00:05:55,080
because it's probably going to be

85
00:05:55,085 --> 00:05:56,685
one of the last ones we fill in.

86
00:05:56,800 --> 00:05:59,314
I'll work on reading this dictionary.

87
00:06:01,490 --> 00:06:03,942
I think I'm going to
switch over to Hackage now,

88
00:06:03,942 --> 00:06:06,880
and look at the
documentation from the Text Library.

89
00:06:08,628 --> 00:06:11,325
This module has all
sorts of IO routines that are

90
00:06:11,337 --> 00:06:13,110
going  to give us text values back,

91
00:06:13,110 --> 00:06:15,540
and the one that I'm interested in is readfile,

92
00:06:15,540 --> 00:06:16,771
which takes a file path

93
00:06:16,771 --> 00:06:18,970
that gives us back a single text strength,

94
00:06:18,970 --> 00:06:21,820
and then we can split
that up into a dictionary later.

95
00:06:22,251 --> 00:06:24,834
The first thing I'm going to do ....

96
00:06:33,710 --> 00:06:35,542
The text library tends to work best

97
00:06:35,542 --> 00:06:37,142
if you use qualified inputs.

98
00:06:37,851 --> 00:06:41,680
So I'm going to import Data.Text as T.

99
00:06:42,285 --> 00:06:44,297
SP: So your just avoiding the confusion

100
00:06:44,290 --> 00:06:46,777
of clobbering the built ins in the mode.

101
00:06:46,788 --> 00:06:48,582
OC: Yes, the prelude has things like

102
00:06:48,594 --> 00:06:50,377
length, filter and stuff like that,

103
00:06:50,377 --> 00:06:52,537
but text also has length and filter.

104
00:06:52,537 --> 00:06:56,205
So to avoid ambiguous names
I'm going to call that entirely qualified.

105
00:06:57,611 --> 00:07:00,850
SP: So it's about hiding the symbols.

106
00:07:00,857 --> 00:07:02,657
OC: Yes, I'm probably not going to be

107
00:07:02,650 --> 00:07:04,514
using the prelude stuff very much,

108
00:07:05,742 --> 00:07:07,542
but that will save me some hassle.

109
00:07:09,120 --> 00:07:10,982
I'm going to have a type hole in there

110
00:07:10,982 --> 00:07:13,062
so I've got some well formed syntax.

111
00:07:14,011 --> 00:07:18,034
And now I have a hole
that needs to be in the dictionary

112
00:07:18,434 --> 00:07:22,114
and I have available
dictionary contents which is a piece of text.

113
00:07:22,377 --> 00:07:26,480
So I need to split this
single text string into a list of lines.

114
00:07:26,490 --> 00:07:30,285
I believe we have a function to
do that in the Text Library as well,

115
00:07:30,285 --> 00:07:35,702
which is un-line. (Inaudible)

116
00:07:35,782 --> 00:07:38,685
Which is going to break
the text up into a list of texts.

117
00:07:38,685 --> 00:07:41,600
SP: It's the exact analogue
of the lines in the prelude.

118
00:07:41,610 --> 00:07:44,045
OC: Exactly. The text type itself is very

119
00:07:44,045 --> 00:07:46,200
similar to the string type in the prelude

120
00:07:46,228 --> 00:07:48,542
except the string type is quite inefficient.

121
00:07:48,542 --> 00:07:50,370
It's just a link list of characters,

122
00:07:50,370 --> 00:07:53,828
whereas text type is more
efficient in terms of representation.

123
00:07:53,820 --> 00:07:57,200
SP: So you make a point
of defaulting to the text type.

124
00:08:04,200 --> 00:08:07,634
Now I can just take
the lines of dictionary contents,

125
00:08:14,034 --> 00:08:17,737
Now I should have
a way to read the dictionary.

126
00:08:18,220 --> 00:08:24,205
I'm going to switch back
over to the terminal at GCHi

127
00:08:24,205 --> 00:08:26,200
and then
we can have a play with that.

128
00:08:28,537 --> 00:08:34,902
I need to refresh my shell to
bring down that text. (inaudible)

129
00:08:38,000 --> 00:08:42,034
We've still got these holes here
which prevents me from using GHCi.

130
00:08:42,045 --> 00:08:44,525
But, I can use another feature of a list

131
00:08:44,525 --> 00:08:47,234
produced at GHC called defer-type errors.

132
00:08:47,988 --> 00:08:50,994
Which is going to let me load code

133
00:08:51,170 --> 00:08:53,280
which doesn't strictly type check

134
00:08:53,291 --> 00:08:56,342
but as long as I don't run
something that doesn't type check,

135
00:08:56,342 --> 00:08:58,080
I can still evaluate the program.

136
00:08:58,085 --> 00:08:59,571
I can work around the fact that

137
00:08:59,850 --> 00:09:02,320
I've got an incomplete bit of code in there (inaudible).

138
00:09:02,880 --> 00:09:05,462
SP: So does it effectively replace that code

139
00:09:05,474 --> 00:09:07,531
with undefined (inaudible)

140
00:09:07,542 --> 00:09:09,520
OC: We can find out.

141
00:09:09,620 --> 00:09:12,354
It's the main function that we have to find

142
00:09:14,180 --> 00:09:17,348
well actually it doesn't
terminate at all (laughter).

143
00:09:17,720 --> 00:09:22,708
But we do have the dictionary (inaudible)

144
00:09:24,502 --> 00:09:25,942
so why don't we try:

145
00:09:35,748 --> 00:09:41,051
I'm going to bind that into - no I'm not

146
00:09:48,274 --> 00:09:50,354
SP: It's not going to print it straight off is it?

147
00:09:50,354 --> 00:09:52,640
OC: No, because of the size of the dictionary,

148
00:09:52,640 --> 00:09:54,720
I want to put that in the variable so I can

149
00:09:54,720 --> 00:09:57,257
try and read out a few things from it.

150
00:09:57,300 --> 00:10:00,125
So we'll take the length of the dictionary.

151
00:10:08,200 --> 00:10:09,800
it's a pretty large dictionary,

152
00:10:10,420 --> 00:10:12,500
We have to be quite efficient in the way

153
00:10:12,500 --> 00:10:13,710
we search through this.

154
00:10:13,710 --> 00:10:14,925
SP: Yes

155
00:10:15,120 --> 00:10:18,571
But we do seem to have got some stuff.

156
00:10:18,571 --> 00:10:22,274
I guess we've got some
windows and other things there.

157
00:10:22,730 --> 00:10:24,011
Which is going to be annoying.

158
00:10:24,011 --> 00:10:25,885
I'll probably
want to trim that stuff out.

159
00:10:25,897 --> 00:10:27,310
SP: Feel free to convert the file,

160
00:10:27,310 --> 00:10:31,428
If you want to change the
line endings that's fine with me.

161
00:10:32,540 --> 00:10:38,022
OC: Maybe if we just
filter those character terms out

162
00:10:38,480 --> 00:10:40,662
that might be easy enough.

163
00:10:51,257 --> 00:10:53,154
Let's see if that's any better.

164
00:10:53,988 --> 00:10:55,085
So I'm happy with that.

165
00:10:55,080 --> 00:10:57,380
We're just filtering out character returns

166
00:10:57,380 --> 00:10:59,874
on the whole dictionary string.

167
00:11:03,660 --> 00:11:06,548
So it looks like the
dictionary has loaded up fine.

168
00:11:06,720 --> 00:11:10,754
So now we're ready to start solving the problem.

169
00:11:12,110 --> 00:11:15,588
There's no real reason
to restrict ourselves to the IO here,

170
00:11:15,748 --> 00:11:19,268
this feels like it should
be solvable by pure functions.

171
00:11:19,260 --> 00:11:19,965
SP: Yes.

172
00:11:19,970 --> 00:11:23,462
So I'm going to introduce
a top little function called ....

173
00:11:25,748 --> 00:11:27,097
we'll go with word puzzle,

174
00:11:27,097 --> 00:11:29,200
which is going to take, 2 text strings

175
00:11:31,820 --> 00:11:34,310
which are going to be our start and end strings,

176
00:11:37,340 --> 00:11:39,714
and the dictionary. I think I'll bring that in.

177
00:11:44,080 --> 00:11:46,880
So a possible solution
is going to be a list of words,

178
00:11:46,880 --> 00:11:49,740
but I imagine there
are multiple possible solutions

179
00:11:49,740 --> 00:11:52,250
for some of these
problems so I'm going to return

180
00:11:52,250 --> 00:11:53,748
a list of list of words.

181
00:11:53,748 --> 00:11:56,000
And because
that's getting a bit confusing

182
00:11:56,010 --> 00:11:58,697
we'll introduce a types in there called solution.

183
00:11:58,697 --> 00:12:00,342
SP: Perhaps a word chain?

184
00:12:00,502 --> 00:12:03,702
OC: Yes, good we'll go with word chain.

185
00:12:04,960 --> 00:12:06,720
Which is going to be a list of text.

186
00:12:09,485 --> 00:12:11,710
SP: So you'll have
a list of possible chains

187
00:12:12,240 --> 00:12:14,240
from the first word to the second word.

188
00:12:14,257 --> 00:12:16,714
OC: And if it's not
possible to solve the problem

189
00:12:16,710 --> 00:12:18,714
then we can just return the empty list.

190
00:12:18,714 --> 00:12:21,142
that there are no possible word chains at all.

191
00:12:28,720 --> 00:12:31,268
I'm going to try to solve this
by pattern matching basically

192
00:12:31,268 --> 00:12:32,982
and try to break the problem down slowly,

193
00:12:32,982 --> 00:12:34,914
hopefully we'll get
to the solution that way.

194
00:12:34,914 --> 00:12:36,942
And there's one really obvious pattern:

195
00:12:36,940 --> 00:12:40,080
you gave me the restriction that
the words have to be the same length.

196
00:12:40,090 --> 00:12:42,742
So if the words aren't the
same length then there's certainly

197
00:12:42,742 --> 00:12:44,137
no word chain between them.

198
00:12:44,137 --> 00:12:45,748
I'll get that case out of the way.

199
00:12:45,740 --> 00:12:47,657
I'm going to use a pattern after that:

200
00:12:54,880 --> 00:12:57,188
Then I'll just return nothing.

201
00:12:59,540 --> 00:13:01,200
Otherwise I'll leave that.

202
00:13:03,480 --> 00:13:04,600
It seems to be solved.

203
00:13:07,480 --> 00:13:08,910
OK so what have we got there?

204
00:13:11,200 --> 00:13:12,740
It seems to be happy with that,

205
00:13:12,740 --> 00:13:15,977
we've got a hole on
line 19 but that's not a problem

206
00:13:15,980 --> 00:13:21,131
so if I try now and solve
the word puzzle with our dictionary,

207
00:13:21,142 --> 00:13:25,371
between Hello and Haskell.

208
00:13:26,205 --> 00:13:29,668
Whoops the dictionary
escaped, I'll just put that back in.

209
00:13:31,710 --> 00:13:35,131
I need to use an extension here from GHC

210
00:13:35,140 --> 00:13:36,617
called overloaded strings.

211
00:13:36,628 --> 00:13:38,250
Normally when we inaud a string,

212
00:13:38,320 --> 00:13:40,400
it's as the type
strength but obviously

213
00:13:40,400 --> 00:13:42,057
we are working with text values

214
00:13:42,050 --> 00:13:45,131
so the overloaded
string extension is going to

215
00:13:45,200 --> 00:13:47,611
let us use literal strings

216
00:13:47,622 --> 00:13:49,310
but they will have a type text.

217
00:13:50,160 --> 00:13:51,900
And as we would expect- Hello and Haskell

218
00:13:51,900 --> 00:13:54,685
don't have the same length
so there's no solution at all

219
00:13:54,697 --> 00:13:55,931
We can move on now ....

220
00:13:56,050 --> 00:13:58,811
so you actually try to find some solutions.

221
00:13:59,740 --> 00:14:02,971
SP:  Might I suggest another case where we

222
00:14:02,970 --> 00:14:05,451
might be able to rule
out other possible solutions?

223
00:14:05,451 --> 00:14:06,457
OC: Sure.

224
00:14:06,570 --> 00:14:09,668
SP: So if either of the
words are not in the dictionary

225
00:14:09,885 --> 00:14:12,994
I don't know if you
want to handle that now.

226
00:14:13,131 --> 00:14:14,960
OC: No that seems reasonable.

227
00:14:19,382 --> 00:14:21,062
I've just had a thought that

228
00:14:21,062 --> 00:14:23,540
I might want to have
a more efficient dictionary type,

229
00:14:23,542 --> 00:14:24,942
but we'll come to that later.

230
00:14:24,948 --> 00:14:27,325
So were giving two words A and B:

231
00:14:55,520 --> 00:14:56,845
I think that's what we want. 

232
00:14:57,291 --> 00:15:00,765
See if that compiles:

233
00:15:02,450 --> 00:15:08,205
SP: You'll probably find that
Haskell will not be in the dictionary.

234
00:15:08,910 --> 00:15:11,794
OC: OK well we can check that .........

235
00:15:17,600 --> 00:15:19,394
It is in the dictionary ! (laughter)

236
00:15:19,965 --> 00:15:22,308
SP: It's a respectable word !

237
00:15:25,880 --> 00:15:29,474
I guess then we
probably need to deal with case,

238
00:15:29,540 --> 00:15:32,331
or maybe I should case sensitive an A.

239
00:15:32,740 --> 00:15:34,770
Capital Hello is not in the dictionary.

240
00:15:35,050 --> 00:15:38,080
Lower case however, will be. Yes

241
00:15:38,710 --> 00:15:40,280
I think I'll leave that for now.

242
00:15:40,285 --> 00:15:42,720
SP: I think that's how it should work. Yes.

243
00:15:42,822 --> 00:15:43,600
OC: OK

244
00:15:43,820 --> 00:15:46,370
SP: Let's presume
that the input would be exactly

245
00:15:46,370 --> 00:15:47,710
as it is in the dictionary

246
00:15:47,710 --> 00:15:49,931
or it's strictly considered invalid.

247
00:15:49,942 --> 00:15:51,085
OC: OK.  

248
00:15:53,950 --> 00:15:57,165
And I expect
there's another obvious pattern,

249
00:15:57,200 --> 00:16:00,114
which is, regardless of the dictionary,

250
00:16:00,160 --> 00:16:02,570
we have two words
A and B, and they are the same,

251
00:16:02,570 --> 00:16:05,977
and were done......
so that has one possible solution,

252
00:16:06,000 --> 00:16:08,457
and I think I'm still
going to put that solution

253
00:16:08,480 --> 00:16:09,931
in the word chain.

254
00:16:09,970 --> 00:16:12,680
So if we go from
hello to hello, the solution will be

255
00:16:12,680 --> 00:16:15,370
one word chain
which contains just the word hello.

256
00:16:16,710 --> 00:16:19,188
so we can try that on two.

257
00:16:22,570 --> 00:16:24,662
So let's see:

258
00:16:30,800 --> 00:16:32,731
It does indeed have one solution

259
00:16:32,731 --> 00:16:34,777
which is the word chain hello. Good!

260
00:16:35,668 --> 00:16:39,577
So, beyond that
we've ruled out the obvious case

261
00:16:39,570 --> 00:16:41,862
and we need to start doing some real work.

262
00:16:41,880 --> 00:16:44,571
And I think a useful
function that we're going

263
00:16:44,582 --> 00:16:47,740
to need is something that's
going to determine the distance

264
00:16:47,748 --> 00:16:48,811
between two words.

265
00:16:49,108 --> 00:16:51,165
Which is going to
be the amount of changes

266
00:16:51,177 --> 00:16:53,360
you have to make
to get between two words.

267
00:16:53,497 --> 00:16:55,931
SP: Yes, or at least whether they are

268
00:16:56,651 --> 00:16:58,570
one step apart from each other.

269
00:16:58,582 --> 00:16:59,805
OC: Yes

270
00:17:08,890 --> 00:17:10,880
The neighbours are going to be words

271
00:17:10,914 --> 00:17:12,731
some distance away... by one

272
00:17:13,154 --> 00:17:13,805
So let's have:

273
00:17:13,828 --> 00:17:17,310
Distance is going to take two text values

274
00:17:17,310 --> 00:17:18,620
and give us back a number.

275
00:17:20,365 --> 00:17:22,422
So if they are the
same then of course,

276
00:17:22,480 --> 00:17:24,125
the distance is just zero.

277
00:17:27,340 --> 00:17:29,314
So how we going to do this next.......let's see.

278
00:17:32,890 --> 00:17:35,451
Yes, I'm probably
going to break the string apart

279
00:17:35,451 --> 00:17:37,474
and treat it as if it were a list,

280
00:17:37,474 --> 00:17:38,811
and I will compare the head,

281
00:17:38,811 --> 00:17:41,782
and see if they're
different, and if they're not

282
00:17:41,782 --> 00:17:43,622
the distance there is zero

283
00:17:43,622 --> 00:17:45,790
but if they're different
the difference will be one.

284
00:17:45,794 --> 00:17:49,097
SP: Are you once again assuming
that A and B are the same length?

285
00:17:49,130 --> 00:17:53,211
OC: Yes I'm going to assume
for this function they are the same length.

286
00:17:53,210 --> 00:18:00,537
and if not, well it might actually
work even if they're different lengths.

287
00:18:03,085 --> 00:18:06,765
SP:  What comes to my mind is
zipping the characters of the two together

288
00:18:06,777 --> 00:18:09,565
and seeing how many pairs are not identical.

289
00:18:09,620 --> 00:18:12,902
OC: Yes, that sounds like
the kind of thing we could do.

290
00:18:12,940 --> 00:18:14,740
I think now because were zipping,

291
00:18:14,740 --> 00:18:16,571
even if they're different lengths 

292
00:18:16,571 --> 00:18:19,110
we can probably just
drop the extra characters.

293
00:18:19,110 --> 00:18:21,370
And I think we have
a zip function already

294
00:18:21,370 --> 00:18:26,708
in the text library ...... we do.

295
00:18:26,800 --> 00:18:29,628
that's going to compare characters. 

296
00:18:30,030 --> 00:18:36,102
It works on text so we can only
use it to zip two pieces of text

297
00:18:36,102 --> 00:18:38,140
which is not so useful.

298
00:18:38,600 --> 00:18:44,331
So take A and B and
we will zip A and B 

299
00:18:45,200 --> 00:18:49,170
so I'm going to use type (inaudible) here.

300
00:18:49,910 --> 00:18:54,377
OK, So we need to have
a function which takes a list

301
00:18:54,377 --> 00:18:56,902
of pairs of characters to a number.

302
00:19:02,377 --> 00:19:06,560
I think first thing we'll do is map over those,

303
00:19:06,674 --> 00:19:09,862
so we can consider each
pair of characters independently.

304
00:19:12,548 --> 00:19:18,594
Oh dear, I'll ignore that for now, next type hole

305
00:19:18,594 --> 00:19:20,140
we have a pair of characters,

306
00:19:20,140 --> 00:19:21,910
which have to produce something.

307
00:19:30,620 --> 00:19:37,291
So if x is equal to y ......... then zero provides ....

308
00:19:37,474 --> 00:19:39,910
That's one possible
correction we have to do.

309
00:19:44,710 --> 00:19:47,280
Now we need to take
a list of things like a number.

310
00:19:47,280 --> 00:19:51,462
I don't know why it hasn't ....
Oh, because B could be any type of numeric.

311
00:19:56,600 --> 00:19:58,457
Ok, so that's good.

312
00:19:58,600 --> 00:20:00,880
So it's hacking into our distance functions

313
00:20:00,910 --> 00:20:02,582
we can switch back to GHCi

314
00:20:02,600 --> 00:20:04,434
and see what it makes of that.

315
00:20:05,740 --> 00:20:07,714
So let's see if the difference between

316
00:20:07,710 --> 00:20:10,320
dog and cog is indeed one.

317
00:20:12,617 --> 00:20:15,794
That's what you would expect. A basic example.

318
00:20:18,765 --> 00:20:22,000
Let's see if we can
fit this into our word puzzle.

319
00:20:22,971 --> 00:20:28,540
We're certainly going
to need the dictionary. (inaudible)

320
00:20:32,080 --> 00:20:34,262
So I'm going to start with the word A

321
00:20:34,274 --> 00:20:36,708
and we need to
find the neighbours of word A.

322
00:20:42,068 --> 00:20:49,714
Let's filter the dictionary
so we don't have A in it.

323
00:21:03,680 --> 00:21:07,211
That's going to give me a
dictionary that doesn't have A in it.

324
00:21:10,740 --> 00:21:14,240
Maybe if we pair
every word with its distance

325
00:21:14,765 --> 00:21:17,005
so I can take every word in the dictionary

326
00:21:17,000 --> 00:21:19,280
and find its distance against word A,

327
00:21:19,302 --> 00:21:22,777
and then I can take
the ones that just have a distance of 1

328
00:21:23,017 --> 00:21:26,651
and that again feels like
I'm zipping 2 lists together.

329
00:21:26,650 --> 00:21:28,217
SP: OK.

330
00:21:29,820 --> 00:21:34,114
OC:  First we need to map that for every word.

331
00:21:34,770 --> 00:21:37,531
We're going to keep
the word and I'm also going to keep

332
00:21:37,531 --> 00:21:39,817
the distance between A and W.

333
00:21:43,510 --> 00:21:46,331
Actually this is like what I'm saying.

334
00:21:46,340 --> 00:21:47,222
Let's say:

335
00:22:04,445 --> 00:22:07,085
And now we've got this map

336
00:22:07,097 --> 00:22:09,222
and we need to filter this for all things

337
00:22:09,245 --> 00:22:11,977
that have a distance of exactly 1.

338
00:22:11,988 --> 00:22:13,394
So let's filter:

339
00:22:23,177 --> 00:22:27,862
It's a bit long there...... I'll re-format that slightly.

340
00:22:37,000 --> 00:22:39,954
Bit of a hole there, we can come back to that,

341
00:22:39,970 --> 00:22:44,710
so (inaudible) build.

342
00:22:45,474 --> 00:22:47,120
OK, so what have we got here?

343
00:22:49,771 --> 00:22:54,685
Ah, OK, so I've filtered this
but I also need to map it

344
00:22:54,680 --> 00:22:56,445
just so it will take the word, so that's A.

345
00:22:57,280 --> 00:23:00,468
and once more, and take just the word

346
00:23:00,740 --> 00:23:03,680
and the (inaudible) distance.

347
00:23:03,988 --> 00:23:06,994
SP: Is there a function for that, is it fst?

348
00:23:07,680 --> 00:23:10,057
OC: Yes, we can use first now.

349
00:23:23,400 --> 00:23:26,205
Good, so we're
back to compiling once more.

350
00:23:27,600 --> 00:23:28,994
So I'll give that a try.

351
00:23:41,600 --> 00:23:44,685
Let's find neighbours of dog.

352
00:23:44,845 --> 00:23:46,800
We need the dictionary there as well.

353
00:23:49,760 --> 00:23:52,011
It doesn't seem quite right to me (laughter)

354
00:23:52,011 --> 00:23:55,668
SP: I think this is probably a result of zipping,

355
00:23:55,820 --> 00:24:00,754
and not taking into
consideration that if the lengths

356
00:24:00,765 --> 00:24:05,870
of the two words are
different, then zip would finish

357
00:24:05,940 --> 00:24:08,525
at the shortest sequence. OC: Right.

358
00:24:09,931 --> 00:24:12,228
SP: And so, all of these like 'downfall'

359
00:24:13,897 --> 00:24:16,571
would be only
one letter away from 'dog',

360
00:24:16,570 --> 00:24:19,040
so maybe you should
only look at the first one.

361
00:24:19,051 --> 00:24:21,940
OC: Maybe we should be
filtering the dictionary first

362
00:24:21,942 --> 00:24:24,428
on getting words
that are only the same length.

363
00:24:24,428 --> 00:24:26,510
We certainly have done that here.
SP: Yes

364
00:24:35,874 --> 00:24:40,540
OC: I'm going to bring
in some smaller functions there.

365
00:24:53,570 --> 00:24:56,971
The idea here is I'm probably
going to use the Applicative Syntax

366
00:24:56,970 --> 00:24:59,428
to combine 2 operations together

367
00:24:59,450 --> 00:25:01,880
so I want to take
things that are not equal to A.

368
00:25:03,940 --> 00:25:06,331
SP: And also the slash equals operator?

369
00:25:06,450 --> 00:25:07,885
OC: Oh yes, of course,

370
00:25:09,740 --> 00:25:12,370
in fact we'll put that (inaudible) in there.

371
00:25:15,680 --> 00:25:18,697
So we need it to satisfy 2 conditions.

372
00:25:23,400 --> 00:25:24,820
We should be able to do this:

373
00:25:36,340 --> 00:25:40,194
I think we'll probably be
able to tidy that function up as well.

374
00:25:40,280 --> 00:25:42,137
So I'll take those back out,

375
00:25:43,020 --> 00:25:47,600
and we're going to
need to import Control.Applicative.

376
00:25:47,874 --> 00:25:50,662
SP: So I notice here that
even though you presumably knew

377
00:25:50,660 --> 00:25:55,085
that you were going
to import Control.Applicative

378
00:25:55,188 --> 00:25:59,108
your habit is to immediately try compiling

379
00:25:59,108 --> 00:26:01,420
and have the compiler to tell you that.
OC: Yes.

380
00:26:01,420 --> 00:26:05,188
SP: So this is really an
analogue of the TDD work-flow 

381
00:26:05,188 --> 00:26:07,405
where you are going for the failing test?

382
00:26:07,405 --> 00:26:08,902
OC: That's right yes,

383
00:26:22,450 --> 00:26:24,280
And I have to context switch again.

384
00:26:26,370 --> 00:26:28,400
I've used length from the prelude here,

385
00:26:28,420 --> 00:26:29,620
but we have text values

386
00:26:29,770 --> 00:26:33,771
and length cannot be used on text values.

387
00:26:33,771 --> 00:26:36,731
inaudible strings so we need to use T.length.

388
00:26:40,540 --> 00:26:44,000
So hopefully were back to compiling that.

389
00:26:44,400 --> 00:26:46,114
So let's try that one again.

390
00:26:46,114 --> 00:26:49,428
See if it makes more sense this time.

391
00:26:51,620 --> 00:26:53,080
That looks a lot better to me.

392
00:26:54,020 --> 00:26:54,925
OK!

393
00:26:59,097 --> 00:27:01,805
SP: Now Ollie could
you explain this section here

394
00:27:01,817 --> 00:27:06,217
where you've used
the operators from Control.Applicative.

395
00:27:06,910 --> 00:27:10,262
OC:  We're working
under the reader applicative here,

396
00:27:10,310 --> 00:27:13,200
which is basically
an applicative functor

397
00:27:13,250 --> 00:27:14,970
that works for function arrows.

398
00:27:15,250 --> 00:27:17,620
So what I want to
do is, take the same argument

399
00:27:17,620 --> 00:27:19,280
as I filter over the dictionary

400
00:27:19,280 --> 00:27:20,885
for every word in the dictionary.

401
00:27:20,914 --> 00:27:23,220
I need to check  that
that word is not equal to A.

402
00:27:23,220 --> 00:27:25,280
And I also need to check that its length

403
00:27:25,280 --> 00:27:26,680
is equal to the length of A.

404
00:27:27,080 --> 00:27:30,217
So I need to do an
operation on the same value.

405
00:27:30,228 --> 00:27:31,165
SP: Right

406
00:27:31,165 --> 00:27:33,462
OC: So I could have introduced a lambda here

407
00:27:33,470 --> 00:27:35,542
and banged that to a variable called W

408
00:27:35,542 --> 00:27:38,022
and said W is not equal to A

409
00:27:38,022 --> 00:27:41,462
and that the length
of W is the length of A.

410
00:27:41,570 --> 00:27:44,902
But by using this syntax here, it's going to

411
00:27:44,902 --> 00:27:48,210
implicitly thread that argument
through to both the functions for me.

412
00:27:48,210 --> 00:27:51,040
So I don't have to worry
about passing the right argument in.

413
00:27:51,050 --> 00:27:54,331
By using the right structure
here that kind of comes for free.

414
00:27:55,280 --> 00:27:57,600
And there's one other
thing I want to tidy up

415
00:27:57,600 --> 00:27:59,085
this is looking a bit weird,

416
00:27:59,211 --> 00:28:00,594
and we've got some helpful

417
00:28:00,617 --> 00:28:02,982
functions in the Data.Function library,

418
00:28:02,982 --> 00:28:05,611
that comes in the base library of Haskell,

419
00:28:05,988 --> 00:28:08,370
so I'm wondering if
we can use something there.

420
00:28:08,370 --> 00:28:11,020
I'm going to have a quick look at the base library

421
00:28:11,020 --> 00:28:13,220
just to see if anything looks useful there.

422
00:28:15,540 --> 00:28:17,417
SP: Do you tend to use Hoogle?

423
00:28:18,300 --> 00:28:20,777
OC: I do use Hoogle occasionally but that's more

424
00:28:20,788 --> 00:28:23,310
when I know the function
that I'm going to work with,

425
00:28:23,314 --> 00:28:25,400
whereas in this case
I just want to look at the types

426
00:28:25,417 --> 00:28:27,340
and see if anything stands out.

427
00:28:27,342 --> 00:28:29,910
SP: Because in Hoogle
you can search by the type.

428
00:28:29,940 --> 00:28:33,405
OC: Right yes, but here
I suppose I'm not entirely sure

429
00:28:33,725 --> 00:28:36,370
what type I'm
going to be looking for.

430
00:28:36,370 --> 00:28:39,177
I want to just look through it
and see if anything comes intuitively.

431
00:28:39,170 --> 00:28:41,611
But if we don't find
anything then I will leave it for now.

432
00:28:41,611 --> 00:28:43,737
But it's these combinates down here, like 'on'

433
00:28:43,737 --> 00:28:47,740
which is probably going to be the most useful.

434
00:28:47,740 --> 00:28:49,770
So, you can see that 'on' as a typical usage

435
00:28:49,770 --> 00:28:51,450
lets you call the same function

436
00:28:51,450 --> 00:28:52,910
on two different arguments.

437
00:28:53,885 --> 00:28:55,394
So let's see if we can use that.

438
00:28:55,510 --> 00:28:57,450
So we're certainly going to be doing 'on'

439
00:28:58,050 --> 00:28:59,450
well it takes 2 arguments

440
00:29:00,620 --> 00:29:03,770
and: .....it takes a function of two arguments

441
00:29:04,370 --> 00:29:06,250
and also a function of one argument.

442
00:29:06,250 --> 00:29:08,540
Well our function one argument is T.length,

443
00:29:11,650 --> 00:29:14,310
and our function two arguments is just equality.

444
00:29:15,820 --> 00:29:18,080
So we need the check for equality on length.

445
00:29:26,450 --> 00:29:27,800
So you can normally use it

446
00:29:27,800 --> 00:29:29,450
with infix notation like this,

447
00:29:31,250 --> 00:29:33,880
but that's when
you've got two arguments to supply.

448
00:29:34,680 --> 00:29:36,740
We're only going to supply one argument,

449
00:29:36,740 --> 00:29:39,600
so I think
I'm actually going to switch this back round

450
00:29:39,620 --> 00:29:41,280
and do a normal prefix notation.

451
00:29:41,280 --> 00:29:42,970
So 'on' equality, T.length against 'A'

452
00:29:44,340 --> 00:29:47,020
and it's going to
supply us with  a second argument

453
00:29:47,020 --> 00:29:49,170
for each word in the dictionary.
SP: Right.

454
00:29:50,280 --> 00:29:52,650
OC: So compile that
and we're going to be told

455
00:29:52,650 --> 00:29:53,940
that we need to import it,

456
00:29:53,940 --> 00:29:56,480
so let's bring that in..... and that's in.... Data.Function,

457
00:30:04,080 --> 00:30:05,770
Good! So that's back to compiling

458
00:30:06,510 --> 00:30:08,080
and we're back in the hole here.

459
00:30:08,510 --> 00:30:10,000
So I think I'm happy with that,

460
00:30:10,000 --> 00:30:12,310
it's a fairly
clean readable description.

461
00:30:12,800 --> 00:30:15,110
We do have quite a lot of loops going on there,

462
00:30:15,110 --> 00:30:16,880
but I'm going to ignore that for now,

463
00:30:16,880 --> 00:30:19,340
maybe we can
optimise that later, but for now

464
00:30:19,680 --> 00:30:21,680
that's certainly solved the problem.

465
00:30:26,620 --> 00:30:28,940
For our actual
word puzzle problem, we know

466
00:30:28,940 --> 00:30:31,540
that the words
are different, but the same length.

467
00:30:31,570 --> 00:30:34,340
I'm going to find all
the neighbours around the word A,

468
00:30:34,340 --> 00:30:36,540
and then try and find all of the solutions

469
00:30:36,540 --> 00:30:38,170
from all of
the neighbours of A.

470
00:30:38,710 --> 00:30:40,170
See if any of them gets us to B.

471
00:30:40,650 --> 00:30:42,510
In which case (inaudible) solutions.

472
00:30:42,510 --> 00:30:44,857
OC: So we'll start by taking the neighbours of A.

473
00:30:44,850 --> 00:30:49,770
(inaudible) dictionary (inaudible).

474
00:30:53,540 --> 00:30:54,600
I've got a hole here

475
00:30:54,600 --> 00:30:56,771
so I'm going to write some sort of function

476
00:30:56,771 --> 00:30:58,680
that will take all these neighbours.

477
00:30:58,680 --> 00:31:00,510
Let's have a look at the type of that.

478
00:31:02,000 --> 00:31:04,340
We're going to
have a list of text and we need

479
00:31:04,340 --> 00:31:05,800
to go to a list of word chains.

480
00:31:06,940 --> 00:31:09,657
so that list of text
is all the possible neighbours

481
00:31:09,657 --> 00:31:11,485
So I'm going
to map over that and now

482
00:31:12,420 --> 00:31:15,285
I have the function that
goes from  text to word chain.

483
00:31:18,142 --> 00:31:18,628
SP: OK

484
00:31:20,600 --> 00:31:22,000
OC: So how is best to do this.

485
00:31:38,940 --> 00:31:42,085
Even though this has
the same type I want to see what we get to.

486
00:31:42,080 --> 00:31:44,285
We're going to be using the same dictionary

487
00:31:44,428 --> 00:31:46,571
and were going to go to b and  (inaud) and N to B.

488
00:31:52,850 --> 00:31:54,910
That's probably not going to type check.

489
00:31:57,600 --> 00:31:59,970
We could have matched a list of text with text.

490
00:32:00,250 --> 00:32:02,800
Oh! that's because
the word chain is a list of text

491
00:32:02,800 --> 00:32:04,740
so it's expecting a single word chain

492
00:32:05,800 --> 00:32:07,942
but we've actually
got many word chains.

493
00:32:07,971 --> 00:32:10,057
So I think
the problem here is that if we

494
00:32:11,140 --> 00:32:13,650
put another
type hole there, well see that this

495
00:32:13,650 --> 00:32:15,080
could actually typecheck,

496
00:32:15,110 --> 00:32:17,400
provided we
had a function that went from

497
00:32:17,400 --> 00:32:20,285
a list of lists word
chains to just a list of word chains.

498
00:32:20,314 --> 00:32:21,685
Which is of course 'concat',

499
00:32:22,200 --> 00:32:24,650
and we have a
function in the standard library

500
00:32:25,310 --> 00:32:29,000
(inaudible) that hole.

501
00:32:29,000 --> 00:32:31,800
There's a function
in the standard library that does

502
00:32:31,820 --> 00:32:33,770
these two things together.... Concat map

503
00:32:33,770 --> 00:32:35,570
that just such a common operation.

504
00:32:35,570 --> 00:32:36,710
Concat that there...... and

505
00:32:39,740 --> 00:32:40,970
I guess we'll leave that ,

506
00:32:43,140 --> 00:32:46,540
there's a hole for now (inaudible) GCHi again.

507
00:32:46,540 --> 00:32:49,540
By loading the dictionary, I should be able to know

508
00:32:49,570 --> 00:32:52,600
(inaudible) problems.

509
00:32:52,600 --> 00:32:54,714
Let's try word puzzles dict. and dog to cat.

510
00:33:04,250 --> 00:33:06,770
That is impressively slow right now (laughter)

511
00:33:07,250 --> 00:33:10,170
And I'm not sure if that's because this doesn't  terminate

512
00:33:10,170 --> 00:33:12,220
or because were being so inefficient.

513
00:33:12,250 --> 00:33:14,280
SP: No,
by the time you go from dog to dot

514
00:33:16,740 --> 00:33:18,600
one of the neighbours of dot is dog

515
00:33:19,370 --> 00:33:22,371
OC: So we're actually
going back on ourselves probably

516
00:33:22,371 --> 00:33:24,370
SP: (inaudible)

517
00:33:24,370 --> 00:33:26,370
That sounds very reasonable to me. Yes.

518
00:33:28,370 --> 00:33:31,140
so we need to probably
carry some extra state around.

519
00:33:33,170 --> 00:33:34,850
So I'm going to put this down here.

520
00:33:39,570 --> 00:33:42,710
We probably need
to remove something from the dictionary

521
00:33:43,970 --> 00:33:46,170
which I guess
is going to be when we go here.

522
00:33:47,940 --> 00:33:50,140
It will probably want to be a dictionary

523
00:33:51,200 --> 00:33:53,314
without the word N itself and also not A.

524
00:33:59,650 --> 00:34:01,057
I've already removed A here

525
00:34:01,650 --> 00:34:03,970
so I'm wondering
if maybe that should be done

526
00:34:03,970 --> 00:34:04,820
further up here.

527
00:34:07,800 --> 00:34:09,880
We'll try it anyway,
let's just try it here.

528
00:34:17,850 --> 00:34:19,485
So let's filter the dictionary

529
00:34:20,680 --> 00:34:22,342
for stuff that's not to equal to N.

530
00:34:28,280 --> 00:34:29,771
It's still having (inaudible)

531
00:34:38,080 --> 00:34:41,257
That's better but apparently
we now have no solutions at all,

532
00:34:41,250 --> 00:34:43,028
at least we do terminate. (laughter)

533
00:34:46,450 --> 00:34:49,680
SP: So termination we're wrong
is better than no termination.

534
00:34:49,680 --> 00:34:52,514
OC: I think so.
At least we know that it will eventually

535
00:34:52,514 --> 00:34:54,542
deliver and so give us the right answer.

536
00:34:54,910 --> 00:34:56,310
So what I want to check now,

537
00:34:56,910 --> 00:34:58,940
we expected
this sort of chain dog, cog,

538
00:34:59,420 --> 00:35:01,650
cot to cat,
so maybe if we just try cot to cat

539
00:35:03,650 --> 00:35:05,050
see if we get that solution.

540
00:35:05,050 --> 00:35:06,714
OC: For the smallest (inaudible)

541
00:35:09,371 --> 00:35:12,400
that was cot to cat.
Again that seems to have no solutions.

542
00:35:18,657 --> 00:35:21,910
It does indeed contain
cat but it's right there at the start,

543
00:35:21,910 --> 00:35:24,542
so we should certainly be seeing that.
So let's see,

544
00:35:29,280 --> 00:35:31,710
The neighbours around A
and for each of those

545
00:35:33,850 --> 00:35:35,000
We've got a word puzzle

546
00:35:42,110 --> 00:35:42,740
Save target

547
00:35:50,880 --> 00:35:53,820
SP: So here your excluding
words that are the neighbour

548
00:35:56,020 --> 00:35:56,340
OC: Yes

549
00:35:56,340 --> 00:35:58,800
SP: Whereas,
perhaps you should be excluding A.

550
00:36:00,450 --> 00:36:03,400
Because that's the
one you don't want to return to later.

551
00:36:09,000 --> 00:36:10,942
You know that you've got that one.
Yes.

552
00:36:11,310 --> 00:36:15,680
(inaudible)

553
00:36:15,680 --> 00:36:18,280
OC:  So we don't want
to come back to where we started

554
00:36:20,140 --> 00:36:21,770
that certainly does make sense.

555
00:36:30,110 --> 00:36:31,570
And now we go from cot to cat.

556
00:36:33,850 --> 00:36:36,050
OC: Were certainly finding some solutions

557
00:36:37,220 --> 00:36:39,370
but never stopping the search (laughter)

558
00:36:41,680 --> 00:36:44,080
which is interesting. So, what's going on there?

559
00:36:46,740 --> 00:36:48,200
when we loop over there this  ......

560
00:36:49,480 --> 00:36:53,650
Well I'm interested to see
if this will actually terminate at the same length

561
00:36:53,650 --> 00:36:55,170
for all the neighbours of cot.

562
00:36:58,820 --> 00:37:00,400
But maybe this won't terminate.

563
00:37:07,080 --> 00:37:08,280
OK, maybe not (laughter).

564
00:37:09,540 --> 00:37:13,310
SP: The (inaudible) indicated that some where (inaudible) (laughter)

565
00:37:13,310 --> 00:37:18,570
OC: (inaud) we certainly are OK.

566
00:37:20,020 --> 00:37:22,340
So, we're not hitting our base case properly,

567
00:37:23,450 --> 00:37:24,600
which is interesting.

568
00:37:34,140 --> 00:37:36,450
We're certainly getting here because that's

569
00:37:38,000 --> 00:37:39,420
where we return the result.

570
00:37:49,480 --> 00:37:52,080
Maybe if we
take all the solutions of neighbour.

571
00:37:58,710 --> 00:38:01,570
So if we couldn't
find any solutions there then we won't

572
00:38:03,280 --> 00:38:05,280
be able to find any bigger solutions

573
00:38:14,850 --> 00:38:16,140
If we did find a solution

574
00:38:16,910 --> 00:38:18,620
then we should be able to go for it.

575
00:38:23,940 --> 00:38:25,370
Yes, that seems reasonable.

576
00:38:27,020 --> 00:38:28,420
So I think that's largely OK.

577
00:38:32,820 --> 00:38:34,740
We've got an error on that somewhere.

578
00:38:36,110 --> 00:38:37,680
So N is expecting a word chain

579
00:38:40,220 --> 00:38:41,850
that's actually a piece of text

580
00:38:43,540 --> 00:38:44,820
that seems somewhat odd.

581
00:38:49,770 --> 00:38:52,570
SP: So the word puzzle
will return a list of solutions

582
00:38:53,620 --> 00:38:55,085
so do you not need to prepend

583
00:38:56,457 --> 00:38:59,680
each of the items in that list (inaudible)

584
00:38:59,680 --> 00:39:00,650
OC: Ah! of course, yes.

585
00:39:02,057 --> 00:39:04,714
SP: So I think it would be just 'map of prepend.
OC: Yes

586
00:39:05,420 --> 00:39:07,540
OC:  We could also use Applicative Syntax

587
00:39:08,510 --> 00:39:10,020
which is not much different,

588
00:39:10,080 --> 00:39:12,450
(inaudible) something like that

589
00:39:12,450 --> 00:39:14,628
for every S we're going to prepend it with N.

590
00:39:15,600 --> 00:39:16,050
SP: Right

591
00:39:18,620 --> 00:39:20,620
OC: OK,
so we're back to compiling again

592
00:39:33,400 --> 00:39:35,510
Let's see if
we can make any sense of that.

593
00:39:37,540 --> 00:39:40,480
Cat to cat and then
every other word in the dictionary.

594
00:39:40,680 --> 00:39:43,940
We're eventually getting to cat.
That's certainly happening.

595
00:39:45,740 --> 00:39:48,020
I guess that is a valid word chain (laughter).

596
00:39:48,800 --> 00:39:52,220
Is it just that there
are this many possible word chains ? I guess

597
00:39:52,970 --> 00:39:55,080
The first one is certainly wrong though.

598
00:39:55,080 --> 00:39:57,280
That's certainly not a chain from cat to cat.

599
00:39:57,280 --> 00:39:58,970
That should be cot to cat.
SP: Yes

600
00:40:00,600 --> 00:40:04,080
(inaudible)

601
00:40:08,480 --> 00:40:09,940
SP: They are very long chains

602
00:40:09,940 --> 00:40:11,400
SP: Cod to cat was the next one.

603
00:40:12,650 --> 00:40:15,110
They're certainly valid chains though
SP: Yes

604
00:40:19,370 --> 00:40:21,770
OC: So what's going on on that first one though?

605
00:40:26,940 --> 00:40:27,685
We have cat.

606
00:40:29,940 --> 00:40:32,857
The problem is I think
we should have been prepending .....

607
00:40:34,850 --> 00:40:36,910
A rather than N - or possibly both of them.

608
00:40:38,970 --> 00:40:41,400
Let's just see what that is, because we want to go

609
00:40:41,400 --> 00:40:42,970
from the word we're starting at.

610
00:40:48,910 --> 00:40:52,080
and now we certainly
have the right solution at the front

611
00:40:52,080 --> 00:40:54,020
and we can of course exploit laziness,

612
00:40:54,020 --> 00:40:56,420
hopefully just see the very first solution

613
00:40:56,420 --> 00:40:57,428
and it terminates.

614
00:40:58,480 --> 00:41:00,285
and finally that's one word chain

615
00:41:00,280 --> 00:41:01,942
that has certainly got us there.

616
00:41:01,940 --> 00:41:02,285
SP: OK

617
00:41:03,450 --> 00:41:05,850
OC: So we need to
decide where we want to go next.

618
00:41:05,850 --> 00:41:08,110
If we want to
find all possible word chains,

619
00:41:08,110 --> 00:41:10,680
in a short amount of time,
or if we want to make sure

620
00:41:10,680 --> 00:41:12,940
that this is definitely the shortest chain.

621
00:41:15,220 --> 00:41:18,080
At this point,
finding the shortest chain we just need

622
00:41:18,080 --> 00:41:19,800
to sort by the length descending.

623
00:41:23,250 --> 00:41:26,000
But this now
because if we're sorting  the entire list

624
00:41:26,000 --> 00:41:29,600
Is going to have to
consider the entire set of possible solutions.

625
00:41:30,140 --> 00:41:31,942
SP: We probably need to think about

626
00:41:32,771 --> 00:41:34,771
expanding the chains progressively,

627
00:41:39,310 --> 00:41:42,020
and returning first
the ones that are the shortest.

628
00:41:44,400 --> 00:41:46,910
OC: Right so reading
the search, as we go through.

629
00:41:50,250 --> 00:41:52,310
I'm going to try and see how long it takes

630
00:41:53,110 --> 00:41:55,050
to solve the whole list of solutions.

631
00:41:55,420 --> 00:41:57,685
We have a function here, 'sort by' which takes

632
00:41:58,940 --> 00:42:01,571
a list of type A and
if we have a way to compare them

633
00:42:02,050 --> 00:42:03,940
for an ordering we can do something.

634
00:42:03,940 --> 00:42:05,710
So Data.Function also has Data.Ord

635
00:42:12,400 --> 00:42:13,510
So we have  comparing.

636
00:42:14,570 --> 00:42:16,885
So we can say comparing on length (inaudible)

637
00:42:21,400 --> 00:42:22,800
which is just what we want

638
00:42:23,510 --> 00:42:25,080
a word chain as a  list of texts.

639
00:42:26,620 --> 00:42:28,110
So sort by comparing length

640
00:42:35,280 --> 00:42:37,280
and it's certainly not a good solution.

641
00:42:37,570 --> 00:42:40,770
In the original spec of the (inaudible) it said

642
00:42:40,770 --> 00:42:43,600
it should be
returning results in less than a second

643
00:42:43,600 --> 00:42:44,800
but were well over that.

644
00:42:59,080 --> 00:43:01,910
So I think we got
our one solution there from cog to cat,

645
00:43:03,680 --> 00:43:06,910
purely by chance
because cat comes first in the dictionary.

646
00:43:06,940 --> 00:43:09,910
What we're doing here
is basically a depth first search.

647
00:43:09,910 --> 00:43:12,080
OC: So the moment we hit that one neighbour,

648
00:43:12,080 --> 00:43:13,370
we go as far away  as we can

649
00:43:13,370 --> 00:43:15,400
to try and get all the way to cat which is

650
00:43:15,420 --> 00:43:17,770
not really the most efficient use of our time.

651
00:43:17,770 --> 00:43:21,140
We're going to need to
change this from a depth first solution

652
00:43:21,140 --> 00:43:22,650
to a breadth first solution.

653
00:43:23,080 --> 00:43:25,910
What we're going to do
is go over each of the neighbours

654
00:43:25,910 --> 00:43:28,450
and try to expand
that word chain of the neighbour

655
00:43:28,450 --> 00:43:29,310
to go one bigger,

656
00:43:29,370 --> 00:43:31,620
and hopefully we will eventually end at B.

657
00:43:32,510 --> 00:43:34,620
B is certainly in the dictionary itself,

658
00:43:35,450 --> 00:43:38,280
in which case we've finished our breadth first search.

659
00:43:38,280 --> 00:43:40,000
At least to get the shortest path

660
00:43:40,000 --> 00:43:42,420
SP: And since your removing the word each time

661
00:43:42,420 --> 00:43:44,420
eventually you won't be able to expand

662
00:43:44,420 --> 00:43:45,740
your search any further

663
00:43:46,140 --> 00:43:48,420
because you'll run out of neighbours.
OC, Yes.

664
00:43:48,420 --> 00:43:51,340
OC: So I'm going to
leave word puzzle alone for the moment

665
00:43:53,770 --> 00:43:55,740
Instead let's try and use some kind of

666
00:43:57,220 --> 00:43:58,110
expand function.

667
00:43:58,540 --> 00:44:01,200
So that's going to
take a word chain and give us back

668
00:44:02,220 --> 00:44:04,480
all possible expansions of the word chain,

669
00:44:04,480 --> 00:44:06,480
we need the dictionary there as well.

670
00:44:09,170 --> 00:44:10,770
I think that's what I want to do.

671
00:44:20,450 --> 00:44:22,820
We're going to
work from the head of the chain

672
00:44:22,820 --> 00:44:24,020
and try to expand that.

673
00:44:26,250 --> 00:44:28,600
There is
obviously the case where we've got

674
00:44:29,570 --> 00:44:31,020
no words at all in the chain.

675
00:44:31,020 --> 00:44:35,570
That's not really (inaudible) to have the code,

676
00:44:35,570 --> 00:44:39,740
in which case there's no expansions on that.

677
00:44:40,510 --> 00:44:42,880
Otherwise we have
a word on some other words

678
00:44:46,370 --> 00:44:48,880
and now by all
the neighbours in the dictionary

679
00:44:51,050 --> 00:44:53,510
W and put those
on the word chain we've got so far.

680
00:45:04,370 --> 00:45:06,650
So neighbours
gives us a list of words and

681
00:45:08,370 --> 00:45:10,280
that's already a list of word chains.

682
00:45:15,770 --> 00:45:18,370
Find the neighbours
of W but I need to use a  list

683
00:45:22,050 --> 00:45:24,050
(inaudible) there.

684
00:45:32,420 --> 00:45:36,340
I'm going to move away from the top there.

685
00:45:41,680 --> 00:45:44,770
SP: That's not a bad example
of a case for a miscomprehension.

686
00:45:46,510 --> 00:45:46,770
OC: OK.

687
00:45:49,340 --> 00:45:52,140
OC: Sure well let's
try another one of those conventions

688
00:45:52,220 --> 00:45:56,910
(inaudible) we need to go over there

689
00:45:56,910 --> 00:46:01,200
(inaudible) neighbours dict. W

690
00:46:08,370 --> 00:46:11,650
and we'll put that into (inaudible) N.

691
00:46:14,050 --> 00:46:16,510
Now I need to
produce a single word chain here,

692
00:46:18,620 --> 00:46:20,220
that will be NW dot something.

693
00:46:26,340 --> 00:46:27,940
Back to compiling again - good.

694
00:46:29,800 --> 00:46:31,970
I should be able to put the dictionary in...

695
00:46:39,370 --> 00:46:41,020
and expand and type that back up...

696
00:46:46,140 --> 00:46:49,050
word chains,
so why don't I just start with the word cat.

697
00:46:50,620 --> 00:46:52,940
So that seems
to be doing what I would expect,

698
00:46:52,940 --> 00:46:54,770
the expansion is on the front, so now

699
00:46:55,740 --> 00:46:58,650
let's see if we can
feed this back in to our word puzzle.

700
00:47:01,620 --> 00:47:03,571
I think I'll leave this around for now.

701
00:47:09,880 --> 00:47:12,140
So we're going
to  start at word A and we need

702
00:47:12,140 --> 00:47:13,114
to reach word B.

703
00:47:15,200 --> 00:47:16,850
So we'll start with a word chain

704
00:47:18,680 --> 00:47:19,910
which is just the word A

705
00:47:20,740 --> 00:47:22,250
(inaudible)

706
00:47:22,280 --> 00:47:24,910
and expand that
to a list of possible word chains.

707
00:47:27,050 --> 00:47:28,850
Let's see what I need to do with that.

708
00:47:31,510 --> 00:47:33,370
Well that one actually works so far,

709
00:47:33,370 --> 00:47:35,800
but it's certainly
not going to be the solution.

710
00:47:35,800 --> 00:47:40,940
(inaudible)

711
00:47:47,880 --> 00:47:50,280
So that's just one
level breadth-first search.

712
00:47:51,420 --> 00:47:54,542
we need to go a bit further
than that to find something useful,

713
00:47:54,570 --> 00:47:56,910
so I think now
we just need to keep expanding

714
00:48:00,820 --> 00:48:03,170
until we have B at the front of the list.
SP: Yes.

715
00:48:11,110 --> 00:48:13,280
OC: We can probably use iterate to do that.

716
00:48:13,280 --> 00:48:15,970
SP: Or until you don't
have any further expansions.

717
00:48:15,970 --> 00:48:18,170
OC: Ah ! that's one
thing we've not done so far

718
00:48:19,170 --> 00:48:20,740
yes, reducing this dictionary.

719
00:48:26,340 --> 00:48:27,650
Where would I put that in?

720
00:48:27,650 --> 00:48:30,570
so after one expansion,
this is probably returning me

721
00:48:33,170 --> 00:48:34,770
a smaller dictionary as well.

722
00:48:36,020 --> 00:48:39,220
When I expand a word chain
the dictionary becomes smaller.

723
00:48:45,480 --> 00:48:46,940
SP: That would be reasonable.

724
00:48:46,940 --> 00:48:48,650
OC: let's see what we get with that...

725
00:48:52,650 --> 00:48:54,420
so word chain and the dictionary.

726
00:49:00,620 --> 00:49:03,940
SP: The alternative is
that you keep the dictionary the same

727
00:49:04,250 --> 00:49:06,510
each time, but you don't allow the addition

728
00:49:07,220 --> 00:49:09,450
into the chain of a word that's already in it.

729
00:49:11,310 --> 00:49:12,850
OC: Yes, but were
going to  keep

730
00:49:13,570 --> 00:49:15,770
searching through a word chain every time,

731
00:49:15,770 --> 00:49:18,400
it feels like
we just make the dictionary smaller

732
00:49:18,420 --> 00:49:20,910
then our neighbours gradually become smaller.

733
00:49:21,000 --> 00:49:23,910
so we return the possible
list of word chains as before.

734
00:49:27,940 --> 00:49:30,050
Now I'm thinking
it would be nice if we had

735
00:49:30,050 --> 00:49:32,400
a bridger (inaudible) type for our dictionary.

736
00:49:32,650 --> 00:49:34,970
Like a set
or something like that, so I can  do a

737
00:49:34,970 --> 00:49:37,880
set difference and easily
remove a set of words from it.

738
00:49:39,280 --> 00:49:39,600
SP: Yes

739
00:49:40,420 --> 00:49:42,457
OC: That's going to be a bit of a
back jump

740
00:49:42,485 --> 00:49:44,285
but I think it's going to be worth it

741
00:49:45,200 --> 00:49:47,770
so I'm going to import
the Data.Set library as well

742
00:49:54,085 --> 00:49:56,714
and that also works best
when you import qualified.

743
00:50:00,000 --> 00:50:02,910
We need to depend on
the containment library for that.

744
00:50:06,400 --> 00:50:08,510
And to get that I need to put that in there.

745
00:50:11,110 --> 00:50:13,400
Actually  it looks as if we already have that.

746
00:50:17,200 --> 00:50:18,885
Bit of a misnomer there I reckon.

747
00:50:21,200 --> 00:50:24,570
So now that we've got
set imported maybe we can make this like so.

748
00:50:28,220 --> 00:50:30,110
So rather than having a list of text,

749
00:50:30,110 --> 00:50:31,310
let's go with A set text,

750
00:50:32,970 --> 00:50:35,740
and we'll just ask
the compiler to tell us everything

751
00:50:35,740 --> 00:50:37,540
we need to update to change.
SP: Yes

752
00:50:40,450 --> 00:50:42,820
Well, first thing we
need to do is return a set

753
00:50:42,820 --> 00:50:44,770
rather than a list: that's easy enough,

754
00:50:44,770 --> 00:50:46,314
we can just say S.list

755
00:50:48,680 --> 00:50:50,820
which takes a list and turns it into a set.

756
00:50:51,510 --> 00:50:54,000
Next, rather than checking a list to see if (inaud)

757
00:50:57,420 --> 00:50:59,857
use S.member, which checks to see if an element

758
00:51:03,050 --> 00:51:04,050
is a member of a set.

759
00:51:06,140 --> 00:51:07,600
(inaudible) the same here. ......

760
00:51:17,280 --> 00:51:18,880
That has put a hole back there.

761
00:51:25,820 --> 00:51:27,680
That should probably just return.

762
00:51:34,540 --> 00:51:35,050
.....like that .....

763
00:51:41,280 --> 00:51:45,050
The filter is for lists but we
have a set so we ask S.filter to filter a set.

764
00:51:55,970 --> 00:51:57,770
I'll check the type of that in there.

765
00:52:05,370 --> 00:52:07,742
OK, I've some idea
of where that error came up.

766
00:52:10,540 --> 00:52:12,480
Ah yes,  we can't map over a set like that.

767
00:52:17,480 --> 00:52:20,570
Do we have that.. yes we do ...
so we just change that to S.dot map

768
00:52:24,220 --> 00:52:29,510
(inaudible)

769
00:52:29,510 --> 00:52:31,880
Now this is not going to give us a list of text,

770
00:52:31,940 --> 00:52:33,620
it's going to give us a set of text.

771
00:52:39,885 --> 00:52:42,514
SP: There are built in facilities like traversible.

772
00:52:46,910 --> 00:52:49,510
Does that help with
this sort of code where you

773
00:52:49,510 --> 00:52:51,400
change from one data type to another?

774
00:52:53,400 --> 00:52:55,710
There are some gereralised forms of some of

775
00:52:55,710 --> 00:52:57,200
these functions arn't there.

776
00:52:57,540 --> 00:52:59,850
OC: Right. We can't generalise map I dont think

777
00:53:00,620 --> 00:53:03,340
because this is a set and sets have the constraint

778
00:53:03,340 --> 00:53:05,850
that the things inside the set must be orderable.

779
00:53:05,850 --> 00:53:06,110
SP: Ok

780
00:53:06,110 --> 00:53:08,220
We can't map between our 3 types because

781
00:53:08,220 --> 00:53:10,820
we wouldn't necessarily map the same (inaudible)

782
00:53:10,850 --> 00:53:13,740
The filter - there's probably something in Data. Foldable

783
00:53:15,710 --> 00:53:17,910
that will probably let us filter the set.

784
00:53:17,910 --> 00:53:20,571
But I think I'm quite happy working with sets here.

785
00:53:23,000 --> 00:53:23,710
SP: That's fine.

786
00:53:23,710 --> 00:53:25,250
OC: I don't think generalising

787
00:53:25,250 --> 00:53:27,170
would give us much of a benefit here.

788
00:53:27,170 --> 00:53:30,228
SP: Why I was wondering
is because I like to use that myself.

789
00:53:33,142 --> 00:53:36,971
OC: Now we may not be able to
use the list comprehension anymore.

790
00:53:39,110 --> 00:53:41,370
what we could do
though is just go to a list.

791
00:53:44,770 --> 00:53:46,310
We could turn this into a list.

792
00:53:51,880 --> 00:53:53,970
And now were back to trying to solve this.

793
00:53:54,370 --> 00:53:56,450
To recap where
we were, we wanted to have

794
00:53:57,140 --> 00:53:59,140
the dictionary smaller and smaller

795
00:53:59,140 --> 00:54:01,400
we return the
word chain and now we need to

796
00:54:01,940 --> 00:54:04,600
return the dictionary
but without a set of words

797
00:54:06,370 --> 00:54:08,020
that we've already considered.

798
00:54:08,400 --> 00:54:11,800
I believe those are going
to be to the head of the list of chains

799
00:54:13,540 --> 00:54:16,970
that we just expanded
to so that will be all the neighbours again.

800
00:54:19,570 --> 00:54:23,050
Although maybe it's more
beneficial to bring more neighbours out

801
00:54:25,310 --> 00:54:26,310
as a set of binding.

802
00:54:27,820 --> 00:54:28,140
SP: Yes.

803
00:54:33,400 --> 00:54:36,770
So now we can take
the dictionary without any of the neighbours.

804
00:54:36,770 --> 00:54:39,020
I've got a slightly smaller dictionary now.

805
00:54:39,020 --> 00:54:40,420
And let's start type checks.

806
00:54:44,710 --> 00:54:47,050
We certainly want to call in expand and then

807
00:54:47,050 --> 00:54:48,057
we need to work out

808
00:54:48,057 --> 00:54:50,114
what were going to do with that result.

809
00:54:50,114 --> 00:54:52,571
We have to write
a function that's going to take

810
00:54:52,570 --> 00:54:54,457
a list of word chains, the dictionary,

811
00:54:54,457 --> 00:54:56,285
and eventually gets to a word chain.

812
00:54:59,280 --> 00:55:01,400
I think we'll end up using some functions

813
00:55:02,940 --> 00:55:04,770
that are already in prelude anyway

814
00:55:04,770 --> 00:55:06,910
but let's just follow the types manually.

815
00:55:06,910 --> 00:55:08,250
and see what we end up with.

816
00:55:08,514 --> 00:55:11,280
OC: We have some function
F that's going to take a chain

817
00:55:11,291 --> 00:55:14,914
and a new dictionary (inaudible) something

818
00:55:16,850 --> 00:55:18,250
and pull that there as well.

819
00:55:22,510 --> 00:55:25,370
Now we want to expand
every single one of these chains

820
00:55:26,080 --> 00:55:27,680
using the smaller dictionary.

821
00:55:28,770 --> 00:55:33,200
So do something with chain and chain is (inaud).

822
00:55:33,220 --> 00:55:35,800
These type holes are not going to help (inaudible)

823
00:55:35,800 --> 00:55:38,200
just have to
trust our intuition a bit more.

824
00:55:38,970 --> 00:55:40,740
but I should be able to map expand.

825
00:55:48,480 --> 00:55:50,370
I should bring this down a little bit.

826
00:55:54,680 --> 00:55:57,285
Expand takes
the dictionary in first position

827
00:55:57,370 --> 00:55:59,800
and word chain (inaudible) second

828
00:55:59,800 --> 00:56:01,680
so that's going to work quite nicely,

829
00:56:01,680 --> 00:56:02,850
Apart from (inaudible)

830
00:56:05,050 --> 00:56:06,480
so that was a list of chains.

831
00:56:16,000 --> 00:56:17,880
Going in the right direction there.

832
00:56:19,850 --> 00:56:22,450
We need to go from
a list of a list of word chains.

833
00:56:23,050 --> 00:56:25,000
to (inaudible) word chain

834
00:56:27,880 --> 00:56:29,050
So, expand every chain.

835
00:56:31,200 --> 00:56:33,310
I'm going to
have to call F on that again.

836
00:56:42,820 --> 00:56:45,600
So, I think we're
struggling to find a nice kind of way

837
00:56:45,620 --> 00:56:47,850
to repeatedly apply this expand function,

838
00:56:47,850 --> 00:56:49,400
and what comes to mind here is,

839
00:56:49,400 --> 00:56:52,220
it looks like an
unfold which is like the dual to fold,

840
00:56:52,220 --> 00:56:54,310
which a lot of people are familiar with.

841
00:56:54,310 --> 00:56:56,450
When you fold
you have a list and you keep

842
00:56:56,450 --> 00:56:58,340
reducing it into something smaller.

843
00:56:58,570 --> 00:57:01,850
Whereas in this case
we actually want to get something bigger.

844
00:57:01,850 --> 00:57:03,710
Which as unfolding until the point

845
00:57:03,710 --> 00:57:05,400
where we maybe can't go any bigger.

846
00:57:05,400 --> 00:57:07,850
So we have a
function in the Prelude to do that

847
00:57:09,620 --> 00:57:10,742
which is unfoldr.

848
00:57:13,800 --> 00:57:16,480
But that requires
for this function that we have

849
00:57:16,480 --> 00:57:18,880
something that returns maybe any value.
SP: OK

850
00:57:18,880 --> 00:57:20,940
OC: But this actually looks quite a lot

851
00:57:20,940 --> 00:57:22,600
like what we have in expand here.

852
00:57:22,940 --> 00:57:24,600
OC: But we don't have a maybe here,

853
00:57:24,940 --> 00:57:26,910
so the maybe represents the fact that

854
00:57:26,910 --> 00:57:28,600
you can't actually go any bigger,

855
00:57:28,710 --> 00:57:31,940
which is what we were
modeling here with this pattern match,

856
00:57:32,200 --> 00:57:35,450
where we simply said
we have an endless list of word chains,

857
00:57:35,450 --> 00:57:37,650
but that felt a bit weird, so maybe let's try

858
00:57:38,800 --> 00:57:40,170
bringing in a "maybe" there.

859
00:57:42,200 --> 00:57:43,740
SP: Maybe let's maybe (laughter)

860
00:57:45,540 --> 00:57:47,940
OC: Ok, so in this case
there's nothing we can do,

861
00:57:49,650 --> 00:57:50,820
so we just say nothing

862
00:57:51,310 --> 00:57:52,420
whereas in this case,

863
00:57:54,000 --> 00:57:56,020
we have just that result  of word chains.

864
00:57:57,140 --> 00:57:59,850
NARRATOR: We're going to speed through this section

865
00:57:59,850 --> 00:58:02,050
because Ollie and Steve found themselves

866
00:58:02,050 --> 00:58:03,280
deep into a Rabbit hole.

867
00:58:03,680 --> 00:58:05,250
They eventually backtracked

868
00:58:05,250 --> 00:58:06,800
on this idea of using unfoldr,

869
00:58:07,600 --> 00:58:09,370
so let's skip ahead to the section

870
00:58:09,420 --> 00:58:10,880
where they changed course.

871
00:58:14,740 --> 00:58:17,450
SP: You are typing faster than I can think.
(laughter)

872
00:58:18,370 --> 00:58:20,170
OC: Even though we're using unfold,

873
00:58:20,170 --> 00:58:22,710
which does feel
like the right thing to be using

874
00:58:23,450 --> 00:58:25,370
I think we're getting ourselves into

875
00:58:25,370 --> 00:58:27,910
a bit of a muddle here.
And one of the big culprits

876
00:58:27,910 --> 00:58:30,200
is what we're doing
in this expand function

877
00:58:30,250 --> 00:58:32,170
so I'm going to try and simplify that

878
00:58:32,170 --> 00:58:34,400
and see if a
nice solution comes out there.

879
00:58:35,000 --> 00:58:36,710
What I'm going to go with instead ..

880
00:58:36,820 --> 00:58:40,170
expands going to take
a single word chain and the dictionary

881
00:58:41,310 --> 00:58:43,250
and it's going to expand that to a list

882
00:58:44,200 --> 00:58:47,000
of possible word
chains and smaller dictionaries.

883
00:58:48,080 --> 00:58:48,340
SP:OK

884
00:58:48,540 --> 00:58:50,400
OC: So whenever I make one expansion,

885
00:58:50,400 --> 00:58:52,680
I consider all of the neighbours around the

886
00:58:52,680 --> 00:58:54,140
first word of the word chain.

887
00:58:54,140 --> 00:58:56,080
And for each of those new word chains,

888
00:58:56,080 --> 00:58:57,910
I'll have the neighbour at the front,

889
00:58:57,910 --> 00:58:59,680
and we're going to remove that word

890
00:58:59,680 --> 00:59:01,885
from the dictionary because we don't want

891
00:59:01,880 --> 00:59:03,171
to go back on ourselves.

892
00:59:03,514 --> 00:59:05,542
OC: So I have a word chain with nothing in

893
00:59:05,542 --> 00:59:07,000
but there's nothing I can do.

894
00:59:07,510 --> 00:59:10,310
We have to
(inaudible) but otherwise if we have a chain

895
00:59:12,200 --> 00:59:13,600
that starts with the word W,

896
00:59:14,820 --> 00:59:16,542
we have the dictionary and then

897
00:59:18,110 --> 00:59:20,220
we need to take
the neighbours around W

898
00:59:24,310 --> 00:59:26,200
which will equal N, and put that on the

899
00:59:26,200 --> 00:59:28,080
front of the chain, so N is going to be

900
00:59:29,080 --> 00:59:31,914
the neighbours using the
same dictionary around W.

901
00:59:37,540 --> 00:59:38,940
But we also need to return

902
00:59:38,940 --> 00:59:40,820
this slightly smaller dictionary.

903
00:59:43,740 --> 00:59:45,370
Tootle (inaudible) that up with......

904
00:59:48,280 --> 00:59:49,400
the same dictionary,........

905
00:59:52,540 --> 00:59:54,540
but  we'll delete N from the dictionary.

906
00:59:54,540 --> 00:59:55,000
SP: Right

907
00:59:55,170 --> 00:59:56,000
OC: Lets try that......

908
00:59:59,800 --> 01:00:01,400
get rid of our old definition.

909
01:00:02,400 --> 01:00:04,080
You can see this is very similar

910
01:00:04,080 --> 01:00:05,885
to what we had in pattern (inaud) one.

911
01:00:05,885 --> 01:00:07,828
OC: (inaudible) from there smaller one

912
01:00:12,910 --> 01:00:13,680
So ignore this ...........

913
01:00:15,510 --> 01:00:17,140
lets keep that (inaudible) there

914
01:00:22,050 --> 01:00:24,910
and that's expecting
a list of text from the other set

915
01:00:24,910 --> 01:00:25,510
(inaud) list

916
01:00:36,480 --> 01:00:37,280
we're back - good!

917
01:00:41,570 --> 01:00:43,740
So if we load
the dictionary in we should

918
01:00:49,000 --> 01:00:50,970
be able to use expand with (inaudible)

919
01:00:50,970 --> 01:00:52,080
one expansion of cat.

920
01:00:54,340 --> 01:00:55,710
So what we're doing here is

921
01:00:55,710 --> 01:00:58,085
we end up printing the out dictionary as well.

922
01:00:58,085 --> 01:01:00,114
SP: Yes. (inaudible)

923
01:01:00,140 --> 01:01:01,280
OC: Map first over that,

924
01:01:06,480 --> 01:01:08,600
and we see just the one level expansion.

925
01:01:08,600 --> 01:01:09,485
(inaudible)

926
01:01:11,771 --> 01:01:13,971
So we're going
to repeatedly apply this

927
01:01:13,971 --> 01:01:15,542
but we'll keep the small chains.

928
01:01:15,542 --> 01:01:17,850
Then we will have the
bigger chains on the end.

929
01:01:17,850 --> 01:01:20,000
So that's giving us a flattening of a tree

930
01:01:20,000 --> 01:01:22,020
of a breadth-first search. Which I think

931
01:01:22,020 --> 01:01:24,620
is going to be better
than the depth first search

932
01:01:24,620 --> 01:01:25,650
that we saw earlier.

933
01:01:28,110 --> 01:01:28,657
SP: Ok

934
01:01:30,680 --> 01:01:33,220
I'm going to do a little function up here called go.

935
01:01:37,740 --> 01:01:40,170
Go is going to
take a list of word word chains

936
01:01:44,170 --> 01:01:45,370
and the dictionaries.

937
01:01:46,480 --> 01:01:47,910
And this becomes apparent

938
01:01:47,910 --> 01:01:50,710
you can see how I'm
going to pull the cursor backwards

939
01:01:51,310 --> 01:01:53,910
And it's going to
give us back a list of word chains.

940
01:01:55,110 --> 01:01:57,310
and that's going to let us repeatedly apply

941
01:01:57,310 --> 01:01:58,250
that to ourselves

942
01:01:58,250 --> 01:02:00,770
OC: So if we have
nothing in the first (inaudible)

943
01:02:00,770 --> 01:02:03,220
There's nothing we
can do, we simply return that

944
01:02:03,800 --> 01:02:06,310
Otherwise we have
some chains so what we can do

945
01:02:08,050 --> 01:02:11,110
SP: We have some
combinations of chains and dictionaries.

946
01:02:11,110 --> 01:02:13,650
OC: Yes, but for every word chain in the dictionary

947
01:02:13,650 --> 01:02:15,400
we want to expand that word chain

948
01:02:15,400 --> 01:02:16,740
using its own dictionary.

949
01:02:17,880 --> 01:02:19,450
So I'm going to map over chains,

950
01:02:20,940 --> 01:02:22,940
and what we'll have here is a word chain

951
01:02:22,940 --> 01:02:24,540
and the dictionary. We want to

952
01:02:25,050 --> 01:02:26,940
expand the chain in the dictionary.

953
01:02:28,050 --> 01:02:30,400
We're going to have
to concat on that because

954
01:02:30,400 --> 01:02:32,370
expand gives us a list of word chains.

955
01:02:34,820 --> 01:02:36,450
SP: Can you rename chains there ?

956
01:02:37,450 --> 01:02:38,400
OC: Sure (inaudible)

957
01:02:41,600 --> 01:02:43,428
or did you want to drop it entirely?

958
01:02:47,080 --> 01:02:49,250
We're not going to
be able to because we've

959
01:02:49,250 --> 01:02:50,710
pattern matched on one here.

960
01:02:50,710 --> 01:02:51,620
SP: Maybe in pairs

961
01:02:51,770 --> 01:02:53,450
OC: Ok, because of the dictionary.

962
01:03:11,680 --> 01:03:12,280
So that's ok ...

963
01:03:12,970 --> 01:03:15,140
but what we've
done now is, we've throw away

964
01:03:16,540 --> 01:03:17,740
these original chains

965
01:03:17,740 --> 01:03:19,800
we need to retain those as well.
SP: Right.

966
01:03:25,110 --> 01:03:26,370
OC: So we'll keep the pairs,

967
01:03:27,770 --> 01:03:30,000
and then add on
the expansions afterwards.

968
01:03:30,000 --> 01:03:30,340
SP: Yes.

969
01:03:30,650 --> 01:03:33,000
So for the smaller
chains that might already

970
01:03:33,020 --> 01:03:34,620
have finished, we'll keep those.

971
01:03:34,940 --> 01:03:37,510
SP: So then later
you would look at all the chains

972
01:03:37,510 --> 01:03:39,310
starting with the smallest first

973
01:03:42,510 --> 01:03:44,420
and try to select only the ones that

974
01:03:44,420 --> 01:03:46,250
finish on the target word.
OC: Right.

975
01:03:46,770 --> 01:03:49,570
OC: And because in
expand we're putting neighbours

976
01:03:50,450 --> 01:03:52,710
at the front of the list, were going to have to

977
01:03:52,710 --> 01:03:55,200
filter word chains that start with our target

978
01:03:55,710 --> 01:03:58,771
It's a bit weird but
obviously cons is a lot more efficient

979
01:03:59,620 --> 01:04:01,420
to the (inaudible) because we don't

980
01:04:01,420 --> 01:04:03,050
have to traverse the list at all.

981
01:04:03,050 --> 01:04:05,000
SP: We can always reverse the solution.

982
01:04:05,020 --> 01:04:05,650
OC: We can yes.

983
01:04:08,880 --> 01:04:11,480
I'll just check that
that's all the compiling done.

984
01:04:11,480 --> 01:04:13,820
We should be able
to have a play with this now.

985
01:04:13,828 --> 01:04:15,571
(inaudible) GHCi

986
01:04:15,828 --> 01:04:17,028
So we've got go so I'll try ....

987
01:04:19,971 --> 01:04:22,050
to bring the dictionary back into scope.

988
01:04:23,940 --> 01:04:25,914
Word chains plus words, so I'll try cat

989
01:04:27,340 --> 01:04:29,571
and it needs
a dictionary in there as well.

990
01:04:35,280 --> 01:04:37,080
And we'll start with just that one.

991
01:04:37,170 --> 01:04:41,080
And that's going to expand forever (inaudible) go

992
01:04:41,080 --> 01:04:42,370
SP: Ok.

993
01:04:42,370 --> 01:04:43,820
OC: And take the head of that.

994
01:04:44,850 --> 01:04:46,450
There's a lot of possibilities ...

995
01:04:46,480 --> 01:04:47,910
because of the dictionary.

996
01:04:52,340 --> 01:04:54,540
We'll just take the word chains out of that

997
01:04:54,770 --> 01:04:59,050
(inaudible)

998
01:05:09,020 --> 01:05:10,540
So every time we take one more

999
01:05:10,540 --> 01:05:12,000
our chains get a bit longer

1000
01:05:12,000 --> 01:05:13,342
SP: Can you see the next one?

1001
01:05:15,020 --> 01:05:17,110
Oh ! that's because we've flattened it, yes.

1002
01:05:19,280 --> 01:05:22,540
SP: That's not the level
that's just the chains as they change.

1003
01:05:23,820 --> 01:05:24,140
OC: Yes

1004
01:05:24,140 --> 01:05:27,250
SP: (inaudible)

1005
01:05:30,680 --> 01:05:34,250
OC: So gradually they're
going to start getting bigger at some point

1006
01:05:35,250 --> 01:05:37,250
(inaudible)

1007
01:05:44,370 --> 01:05:45,457
That's not re cursing.

1008
01:05:46,680 --> 01:05:48,620
Actually go is never calling itself,

1009
01:05:49,080 --> 01:05:50,480
which is the problem here.

1010
01:05:50,680 --> 01:05:53,250
So were only ever
looking at one level expansion.

1011
01:05:54,050 --> 01:05:56,340
so if we take the original pairs and what we

1012
01:05:56,340 --> 01:05:58,400
need to do is go again on the concat map.

1013
01:06:02,880 --> 01:06:03,340
SP: Right

1014
01:06:03,340 --> 01:06:06,280
So we're going to
keep going to bigger and bigger chains.

1015
01:06:06,280 --> 01:06:08,340
But we're always putting these chains

1016
01:06:08,370 --> 01:06:09,480
on the end of the list.

1017
01:06:18,710 --> 01:06:20,828
So if we go back to taking 20 we should be

1018
01:06:20,828 --> 01:06:21,942
back to where we were

1019
01:06:23,400 --> 01:06:25,257
and as I take more, you can see we are

1020
01:06:26,770 --> 01:06:29,110
starting to get
bigger and bigger chains now.

1021
01:06:29,110 --> 01:06:31,020
SP: Right, and all of them ending on cat.

1022
01:06:31,600 --> 01:06:32,000
OC: Yes

1023
01:06:34,800 --> 01:06:36,680
SP: That's because that was our start.

1024
01:06:37,280 --> 01:06:38,820
OC: Yes, were going out from cat

1025
01:06:39,480 --> 01:06:43,000
SP: (inaudible)

1026
01:06:44,850 --> 01:06:47,940
OC: So now were ready
to put this back into the  word puzzle

1027
01:06:47,970 --> 01:06:49,850
to solve the puzzle properly .. again !

1028
01:06:52,880 --> 01:06:54,970
So we need to
call go and we're going to be

1029
01:06:56,050 --> 01:06:57,828
using the (inaudible) dictionary.

1030
01:06:58,050 --> 01:07:00,800
But were going
to have to delete our starting word

1031
01:07:00,800 --> 01:07:02,450
from the dictionary.
SP: Right

1032
01:07:03,420 --> 01:07:05,857
OC: Because we don't
want to go back to the start.

1033
01:07:05,857 --> 01:07:08,000
And we're going to
start with a word chain

1034
01:07:08,028 --> 01:07:09,314
that begins at the word A.

1035
01:07:11,200 --> 01:07:13,420
And this is going to give us all the chains

1036
01:07:13,420 --> 01:07:14,340
that start from A.

1037
01:07:14,340 --> 01:07:16,800
But we're interested
in chains that start at A

1038
01:07:16,828 --> 01:07:17,600
and finish at B.

1039
01:07:17,940 --> 01:07:19,650
So we filter the result of chains

1040
01:07:21,370 --> 01:07:22,680
by  taking ........ for each chain.

1041
01:07:26,080 --> 01:07:28,110
Sorry, first we should just throw away

1042
01:07:29,450 --> 01:07:30,710
the extra dictionaries.

1043
01:07:30,710 --> 01:07:33,420
SP: Because the two (inaudible) will come back from go.

1044
01:07:33,540 --> 01:07:35,570
OC: Yes, so it will give us two word chains

1045
01:07:35,570 --> 01:07:36,800
from the dictionaries,

1046
01:07:37,250 --> 01:07:39,685
whereas we're
only interested in word chains.

1047
01:07:39,685 --> 01:07:42,080
(inaudible)

1048
01:07:42,080 --> 01:07:43,857
Now we've got a list of word chains.

1049
01:07:44,080 --> 01:07:46,771
I can filter the list for ones whose first element

1050
01:07:48,820 --> 01:07:54,050
is equal to our target. (inaudible)
SP: Right

1051
01:07:54,050 --> 01:07:55,710
OC: And I think that's what we need

1052
01:07:56,910 --> 01:07:59,110
to solve the puzzle..so that all compiles

1053
01:08:04,370 --> 01:08:05,820
Put that dictionary back in

1054
01:08:05,820 --> 01:08:08,800
(inaudible) word puzzle using the dictionary

1055
01:08:08,800 --> 01:08:10,800
it will go from dog to cat.

1056
01:08:15,620 --> 01:08:17,420
And we are indeed getting result.

1057
01:08:19,000 --> 01:08:21,080
The interesting thing we're seeing here

1058
01:08:21,080 --> 01:08:23,142
is as it's gradually printing results,

1059
01:08:23,142 --> 01:08:25,220
we are seeing how Haskells' (inaudible)

1060
01:08:25,220 --> 01:08:27,050
evaluation works to our advantage.

1061
01:08:27,850 --> 01:08:30,340
So if I only wanted
to get the very first result,

1062
01:08:30,340 --> 01:08:33,020
I could simply
take the head of all the solutions

1063
01:08:33,020 --> 01:08:34,650
and the result is already done,

1064
01:08:34,650 --> 01:08:37,310
it didn't bother
computing all the extra values.

1065
01:08:37,420 --> 01:08:39,680
But if I needed the extra results, maybe if I

1066
01:08:39,680 --> 01:08:42,110
wanted to find
the first ten shortest chains

1067
01:08:43,220 --> 01:08:45,770
I could just take10
and that's going to give you

1068
01:08:45,770 --> 01:08:47,570
10 word chains and then terminate,

1069
01:08:48,970 --> 01:08:50,600
which is really nice.
SP: Right.

1070
01:08:52,600 --> 01:08:55,080
OC: I think that
solves the problem that we had

1071
01:08:57,370 --> 01:08:58,970
in the original problem spec.

1072
01:08:59,910 --> 01:09:01,650
SP: Shall we try it on longer input ?

1073
01:09:02,400 --> 01:09:04,200
How about the words Ruby and Code.

1074
01:09:05,800 --> 01:09:07,650
OC: Ok so I'll take the first of those.

1075
01:09:24,050 --> 01:09:25,910
It's certainly a lot slower but we do

1076
01:09:25,910 --> 01:09:27,280
get a word chain in the end.

1077
01:09:32,050 --> 01:09:34,600
So it might be worth trying to improve the forms

1078
01:09:34,620 --> 01:09:36,050
of this text (inaudible).

1079
01:09:36,050 --> 01:09:38,257
SP: Absolutely,
there are longer examples

1080
01:09:39,310 --> 01:09:40,770
such as from house to shout,

1081
01:09:42,110 --> 01:09:43,710
we could see if that completes

1082
01:09:43,710 --> 01:09:45,370
in a reasonable amount of time.

1083
01:09:45,880 --> 01:09:48,510
This one's quite
tricky because the search space

1084
01:09:48,880 --> 01:09:51,000
for it is quite large in the dictionary

1085
01:09:51,000 --> 01:09:51,970
that I've given you.

1086
01:09:53,650 --> 01:09:56,280
OC: This looks like
it's terminating any time soon.

1087
01:09:58,140 --> 01:10:00,370
SP: So maybe we
can have a look to determine

1088
01:10:02,170 --> 01:10:03,480
where the bottle neck is ?

1089
01:10:04,370 --> 01:10:06,370
OC: Yes, well I'm going to leave that one

1090
01:10:06,370 --> 01:10:09,310
running in the
background anyway, see if we get a result

1091
01:10:09,310 --> 01:10:11,310
while we start looking for some (inaudible).

1092
01:10:11,310 --> 01:10:13,200
To me, the biggest source of expense

1093
01:10:14,540 --> 01:10:16,540
feels like this neighbours function.

1094
01:10:17,450 --> 01:10:19,480
We're filtering twice and the map twice

1095
01:10:20,510 --> 01:10:22,280
and we are doing this repeatedly

1096
01:10:22,280 --> 01:10:23,800
every single time we expand.

1097
01:10:23,800 --> 01:10:26,000
And the set of
neighbours around a word

1098
01:10:27,020 --> 01:10:28,220
doesn't really change.

1099
01:10:28,228 --> 01:10:30,571
There may be
potential neighbours that we

1100
01:10:30,650 --> 01:10:33,620
can't consider because
we've already looked at them once.

1101
01:10:33,620 --> 01:10:35,370
and we would go back on ourselves.

1102
01:10:36,280 --> 01:10:39,540
But we can probably prune
the set of neighbours afterwards

1103
01:10:39,540 --> 01:10:42,050
I'm thinking maybe
we can have an optimisation

1104
01:10:42,050 --> 01:10:43,742
where we have a map of neighbours

1105
01:10:48,220 --> 01:10:51,114
It's going to be a map
from text to its set of neighbours.

1106
01:10:55,285 --> 01:10:56,485
And we should be able to

1107
01:10:56,485 --> 01:10:58,714
pre-compute this against the dictionary .

1108
01:10:59,340 --> 01:11:01,220
We're going to need the map data type

1109
01:11:01,850 --> 01:11:03,250
which comes from Data.Map,

1110
01:11:06,340 --> 01:11:08,620
again I'll be importing this from qualified.

1111
01:11:15,370 --> 01:11:17,250
Now we look up the list of neighbours.

1112
01:11:21,220 --> 01:11:23,420
We can still take the dictionary as input

1113
01:11:23,770 --> 01:11:26,080
but rather than just taking that, we can also

1114
01:11:26,450 --> 01:11:27,770
take in a neighbours map

1115
01:11:29,110 --> 01:11:30,310
and the word to look up

1116
01:11:30,310 --> 01:11:32,940
and it's going to
give us a set of neighbours again.

1117
01:11:32,940 --> 01:11:35,200
And the reason I'm taking that dictionary

1118
01:11:35,200 --> 01:11:37,400
is because we keep making that dictionary

1119
01:11:37,400 --> 01:11:39,480
smaller and smaller. We want to make sure

1120
01:11:39,480 --> 01:11:41,510
the neighbours we look up from this map

1121
01:11:41,510 --> 01:11:43,657
are actually in the dictionary because

1122
01:11:43,650 --> 01:11:45,600
we might have made the dictionary smaller

1123
01:11:45,600 --> 01:11:47,420
and removed possible names

1124
01:11:47,428 --> 01:11:49,200
so we're going to filter those out.

1125
01:11:49,228 --> 01:11:50,971
OK, so we've got, I'll call that M and W.

1126
01:11:52,510 --> 01:11:54,370
And this becomes straightforward,

1127
01:11:54,370 --> 01:12:01,080
we simply do a map look-up (inaudible)

1128
01:12:01,110 --> 01:12:04,020
which will throw up an error
if the word isn't in the map

1129
01:12:04,740 --> 01:12:07,314
but we'll have to
gloss over that for now I guess.

1130
01:12:08,420 --> 01:12:09,600
SP: yes,  (inaud) maybes'.

1131
01:12:10,200 --> 01:12:12,200
OC: If I was doing this production code

1132
01:12:12,200 --> 01:12:14,714
I would probably want
to keep the maybes' and the

1133
01:12:14,710 --> 01:12:16,171
chance of possibly failing

1134
01:12:16,171 --> 01:12:17,680
and reflect that in the types

1135
01:12:17,685 --> 01:12:19,620
that would add up, but for our purposes

1136
01:12:19,910 --> 01:12:21,340
this should be sufficient.

1137
01:12:21,910 --> 01:12:23,400
So, this is saying in the map M

1138
01:12:25,400 --> 01:12:26,310
look up the word W.

1139
01:12:28,770 --> 01:12:30,510
We need to take the intersection

1140
01:12:31,280 --> 01:12:33,080
of the set of possible neighbours.

1141
01:12:37,170 --> 01:12:38,620
We take the set into section

1142
01:12:40,200 --> 01:12:42,114
SP: Is it (inaudible), ?
I can't remember.

1143
01:12:43,540 --> 01:12:46,571
OC: From map I believe
it's just a single exclamation mark,

1144
01:12:46,742 --> 01:12:49,140
whereas for lists it's two exclamation marks.

1145
01:12:55,850 --> 01:12:58,020
So we don't seem to have any compile errors

1146
01:12:58,020 --> 01:12:59,850
around this neighbours function.

1147
01:13:00,680 --> 01:13:02,250
That's quite straightforward.

1148
01:13:02,250 --> 01:13:04,570
We also need a
way to pre-compute neighbours.

1149
01:13:06,880 --> 01:13:09,680
So that takes the
dictionary and turns it into a map,

1150
01:13:12,770 --> 01:13:15,540
SP: So here your
starting from saying; from right down

1151
01:13:15,540 --> 01:13:17,620
in the lowest level of this computation

1152
01:13:17,620 --> 01:13:20,800
you would like to have
that extra information available

1153
01:13:21,280 --> 01:13:24,050
in a neighbour map.
and you're working your way back up

1154
01:13:24,680 --> 01:13:27,340
to the (inaudible) levels to see

1155
01:13:27,340 --> 01:13:29,340
how to pass that down into it.

1156
01:13:32,000 --> 01:13:34,050
OC: Yes.  We've got a neighbours function.

1157
01:13:34,050 --> 01:13:36,310
I would like to be able to test that in GHCi

1158
01:13:36,310 --> 01:13:38,857
but we don't have
a way to build a neighbour map yet.

1159
01:13:38,857 --> 01:13:40,600
So I'm going to work on this (inaudible)

1160
01:13:40,628 --> 01:13:42,710
neighbours function then I can (inaud)

1161
01:13:43,400 --> 01:13:44,850
GCHi so I can actually see if

1162
01:13:44,850 --> 01:13:46,740
the neighbour map seems to be working

1163
01:13:46,740 --> 01:13:47,710
as we would expect.

1164
01:13:47,710 --> 01:13:50,714
Then we can work
through the rest of the compile errors

1165
01:13:50,714 --> 01:13:54,371
(inaud).  That's what we do.

1166
01:13:55,540 --> 01:13:58,140
So this looks like
it should be straightforward,

1167
01:13:58,170 --> 01:14:00,940
we just take
our dictionary, which is a set of words,

1168
01:14:02,280 --> 01:14:03,370
so if we go set to list.

1169
01:14:05,080 --> 01:14:07,340
and  for every word
in here we can map over .....

1170
01:14:12,200 --> 01:14:14,820
Ah ! We did need our
original neighbours function

1171
01:14:14,850 --> 01:14:16,340
which I have thrown away now

1172
01:14:16,970 --> 01:14:18,370
because we want to use that.

1173
01:14:19,740 --> 01:14:21,620
OC: So let's see if I can go back to that.

1174
01:14:26,450 --> 01:14:27,510
So I'll call this one ............

1175
01:14:30,570 --> 01:14:31,620
neighboursLookup

1176
01:14:37,620 --> 01:14:39,080
and this is back to how it was.

1177
01:14:53,080 --> 01:14:56,080
SP: We could also call this
neighbours and could the old

1178
01:14:56,080 --> 01:14:58,970
neighbours function
simply be a function returning

1179
01:15:01,370 --> 01:15:04,220
a list of the words
with the neighbours and distances?

1180
01:15:05,140 --> 01:15:06,880
OC: In the neighbours function or ....

1181
01:15:08,050 --> 01:15:09,940
SP: Yes, so you could - at this level here

1182
01:15:12,620 --> 01:15:14,650
where your returning W with distance,

1183
01:15:18,340 --> 01:15:21,485
in order to avoid having two similar (inaudible) functions.

1184
01:15:21,971 --> 01:15:23,342
Maybe we should continue ....

1185
01:15:23,342 --> 01:15:25,742
OC: It's probably worth renaming this though

1186
01:15:25,771 --> 01:15:27,371
because we want compile error,

1187
01:15:27,370 --> 01:15:29,828
well we're going to get compile errors anyway

1188
01:15:29,828 --> 01:15:31,371
because the types different.

1189
01:15:31,770 --> 01:15:34,428
I'm going to move this
into preview of neighbours

1190
01:15:38,000 --> 01:15:38,942
whatever I do ....

1191
01:15:39,428 --> 01:15:42,110
because we don't
have any reason to ever call this

1192
01:15:42,110 --> 01:15:43,770
other than inside string names.

1193
01:15:48,740 --> 01:15:50,450
SP: And you can rename the top one.

1194
01:15:50,457 --> 01:15:52,685
OC: Exactly,
The dictionary is going to be

1195
01:15:54,457 --> 01:15:55,820
available up here anyway,

1196
01:16:01,000 --> 01:16:03,657
We need to turn our
dictionary into a list of words

1197
01:16:04,740 --> 01:16:06,480
move that neighbours over there.

1198
01:16:12,110 --> 01:16:14,940
So I need to pair
them up with the original word as well.

1199
01:16:17,770 --> 01:16:20,910
There's a fairly nice
function in the Control.Arrow module

1200
01:16:22,710 --> 01:16:25,510
which lets us run two
functions on the same argument.

1201
01:16:27,400 --> 01:16:29,080
I can say that it and neighbours

1202
01:16:29,770 --> 01:16:33,110
so that's the identity
function and the neighbours function

1203
01:16:33,114 --> 01:16:35,171
and it's going to Tootle (inaudible) those up for me.

1204
01:16:35,171 --> 01:16:35,680
SP: OK.

1205
01:16:37,400 --> 01:16:38,970
OC: I think I'll just import that ....

1206
01:16:42,480 --> 01:16:44,110
We've got a lot of compile errors.

1207
01:17:12,110 --> 01:17:14,680
We apparently need the word A as well. (inaudible)

1208
01:17:17,710 --> 01:17:28,200
(inaudible)

1209
01:17:31,480 --> 01:17:33,880
OC: So now we have
prelude neighbours but that's

1210
01:17:33,880 --> 01:17:36,050
not returning the neighbours from there.

1211
01:17:41,420 --> 01:17:44,050
We don't really need to (inaudible)

1212
01:17:44,050 --> 01:17:47,140
because were using that in neighbours

1213
01:17:48,910 --> 01:17:52,110
Now this is going to be a list of tootles (inaudible)

1214
01:17:52,110 --> 01:17:54,910
OC: We can turn that into a map. (inaud)

1215
01:17:58,140 --> 01:18:00,680
So we've turned our
dictionary into a list of text

1216
01:18:00,680 --> 01:18:02,910
and for every text and for every text value

1217
01:18:02,910 --> 01:18:04,970
turned that into the text word itself

1218
01:18:06,000 --> 01:18:07,400
and its set of neighbours.

1219
01:18:08,000 --> 01:18:10,680
SP: And each word will
be distinct so you don't need

1220
01:18:10,970 --> 01:18:12,740
to worry about combining entries.

1221
01:18:13,850 --> 01:18:14,480
OC: Right, yes

1222
01:18:17,600 --> 01:18:19,310
OC: Let's see what we get from that.

1223
01:18:23,370 --> 01:18:25,800
Neighbours is
going to be neighbours look up

1224
01:18:28,080 --> 01:18:31,171
so that's ... well, yes
let's keep it as neighboursLookup

1225
01:18:38,220 --> 01:18:41,280
OC: I'm just checking to
see if that's the only compile error

1226
01:18:41,280 --> 01:18:42,942
we've got, and it looks like it is,

1227
01:18:42,942 --> 01:18:44,800
so we've just got two arrows up here.

1228
01:18:46,370 --> 01:18:49,340
That means expand
rather than just take the dictionary

1229
01:18:49,340 --> 01:18:50,742
it also need to take a nMap.

1230
01:19:02,220 --> 01:19:04,340
The order here is dictionary, nMap

1231
01:19:10,250 --> 01:19:11,650
I just had a thought there,

1232
01:19:11,650 --> 01:19:15,000
because we're always
passing these two things together maybe

1233
01:19:15,000 --> 01:19:16,450
I should be combining these.

1234
01:19:16,450 --> 01:19:18,142
SP: I was having the same thought.

1235
01:19:18,228 --> 01:19:20,220
OC: So I think maybe our neighbour map

1236
01:19:20,220 --> 01:19:23,310
could be a data type
containing the full pre-computed map,

1237
01:19:24,510 --> 01:19:26,020
but also a set of exclusions.

1238
01:19:26,820 --> 01:19:29,510
And every time we
need to drop something out of the

1239
01:19:29,510 --> 01:19:32,110
neighbour map
we can do that quite efficiently.

1240
01:19:33,250 --> 01:19:33,710
SP: Right.

1241
01:19:33,710 --> 01:19:36,000
OC: Or we maybe (inaud) but we'll see

1242
01:19:36,000 --> 01:19:37,420
I'll come back to that later,

1243
01:19:37,600 --> 01:19:39,770
but it certainly does feel suspect so far.

1244
01:19:42,420 --> 01:19:44,850
So I think I better
put this the right way round

1245
01:19:46,480 --> 01:19:48,080
...dictionary and neighbour map

1246
01:19:50,080 --> 01:19:52,200
This is the dictionary and neighbour map

1247
01:19:59,740 --> 01:20:02,340
and now expand
needs that neighbour map as well.

1248
01:20:05,000 --> 01:20:07,880
But interestingly,
this doesn't have to be added to go.

1249
01:20:07,880 --> 01:20:10,371
Because the neighbour map doesn't ever change

1250
01:20:11,257 --> 01:20:13,771
from what we've got so far. So that's just a constant. (inaudible)

1251
01:20:19,742 --> 01:20:22,600
SP: (inaudible)the first one.

1252
01:20:22,600 --> 01:20:23,250
OC: Yes it did.

1253
01:20:28,280 --> 01:20:30,314
And, we need to call that recurser map (inaudible

1254
01:20:36,200 --> 01:20:38,020
and you can use pass in here as well.

1255
01:20:38,600 --> 01:20:43,200
So here (inaudible)

1256
01:20:58,970 --> 01:21:01,800
So now our word puzzle
should be using this preview as

1257
01:21:01,820 --> 01:21:03,200
neighbours map.
SP: Right.

1258
01:21:03,820 --> 01:21:06,280
And were using
our more efficient neighbours

1259
01:21:06,280 --> 01:21:07,880
look-up function. So hopefully

1260
01:21:07,880 --> 01:21:09,510
we are going to see some results.

1261
01:21:10,450 --> 01:21:13,600
Impressively its still
trying to find solutions between

1262
01:21:13,600 --> 01:21:15,220
house and shout, on the old code.

1263
01:21:16,250 --> 01:21:18,020
So let's see what we get out of this.

1264
01:21:20,850 --> 01:21:23,220
We didn't really
look at seeing a pre-compute

1265
01:21:24,540 --> 01:21:27,600
preview of neighbours,
so let's have a quick look at that.

1266
01:21:35,310 --> 01:21:40,940
OK, so (inaud) type checks.

1267
01:21:44,628 --> 01:21:46,800
Let's bind that to it, something like that.

1268
01:21:47,428 --> 01:21:48,142
We can do nMap ....

1269
01:21:54,340 --> 01:21:55,942
SP: Jellow and hells. (laughter)

1270
01:21:56,914 --> 01:21:59,428
OC: So bringing in
neighbours does seem to be working.

1271
01:21:59,428 --> 01:22:01,510
We seem to be getting some actual neighbours,

1272
01:22:01,514 --> 01:22:04,857
so let's see what happens
with the others, let's do ruby code then.

1273
01:22:08,942 --> 01:22:11,628
It doesn't seem to
be a huge amount more efficient

1274
01:22:14,428 --> 01:22:17,142
But maybe we'll
actually get a result from this now

1275
01:22:24,400 --> 01:22:26,114
We've still got a little bit to go.

1276
01:22:30,000 --> 01:22:32,657
SP: Does it take long
to re-compute the entire map ?

1277
01:22:33,000 --> 01:22:34,914
can you force that computation on c. ?

1278
01:22:36,400 --> 01:22:38,857
OC: We can try
forcing that and see what happens.

1279
01:22:40,110 --> 01:22:42,942
SP: So of course here
your going to be pre-computing the

1280
01:22:45,600 --> 01:22:48,680
neighbours across
the full dictionary, not necessarily

1281
01:22:48,680 --> 01:22:51,914
the dictionary
pruned down to only the the words (inaudible)

1282
01:22:52,880 --> 01:22:55,200
OC: Yes that's probably worth doing already.

1283
01:22:57,140 --> 01:22:59,857
Rather than ridding
the dictionary of everything.

1284
01:23:01,080 --> 01:23:03,457
We're using a
lazy map here which means that

1285
01:23:04,250 --> 01:23:07,342
we'll get a map back
that contains all of the words as keys,

1286
01:23:09,340 --> 01:23:12,480
but the values underneath
that map won't be fully evaluated.

1287
01:23:12,480 --> 01:23:14,940
So it's only when we
look up those keys in the map

1288
01:23:14,940 --> 01:23:16,257
that we will do that work.

1289
01:23:17,110 --> 01:23:19,742
So hopefully
having the full dictionary in there

1290
01:23:19,742 --> 01:23:21,200
doesn't make any difference.

1291
01:23:21,710 --> 01:23:24,485
But I think for clarity
that's slightly nicer if we

1292
01:23:25,000 --> 01:23:27,085
just say filter, length, equal to length

1293
01:23:36,514 --> 01:23:38,885
SP: Of course, this way your run length across....

1294
01:23:40,257 --> 01:23:42,228
is it hundreds of thousands of words ?

1295
01:23:42,570 --> 01:23:42,914
OC: Yes.

1296
01:23:44,570 --> 01:23:45,600
SP: So its a tradeoff.

1297
01:24:06,542 --> 01:24:07,771
OC. So we take the length.......

1298
01:24:11,940 --> 01:24:14,457
I think that's
because we have text values here.

1299
01:24:16,220 --> 01:24:19,285
We've already seen
this type of function before anyway.

1300
01:24:21,740 --> 01:24:25,171
So (inaudible) here.
Maybe we could do something about that.

1301
01:24:29,020 --> 01:24:31,850
The maybe neighbours
doesn't have to worry about that,

1302
01:24:31,850 --> 01:24:33,314
we've already done that once.

1303
01:24:33,850 --> 01:24:36,280
I think I'll just
leave that for now, see if that

1304
01:24:36,280 --> 01:24:37,457
has made a difference.

1305
01:24:44,770 --> 01:24:46,742
It seems a bit saggy doesn't it?
SP: Yes

1306
01:24:49,771 --> 01:24:51,280
SP:: So the acid test. (laughter)

1307
01:24:55,970 --> 01:24:58,571
There's still no
results between house and shout.

1308
01:25:03,800 --> 01:25:05,942
SP: So that's great, we've reached a point now

1309
01:25:05,942 --> 01:25:08,542
were we're able to
find chains quite efficiently,

1310
01:25:08,571 --> 01:25:11,142
Not just from cat to dog
but also from rude to code.

1311
01:25:15,371 --> 01:25:17,885
SP: Where do you
think you would go next with this ?

1312
01:25:19,940 --> 01:25:23,457
OC: One thing that's always (inaud) quite a bit is

1313
01:25:24,280 --> 01:25:26,028
in go we are using  foss boss (inaud)

1314
01:25:27,828 --> 01:25:30,400
which means that
because were always having to

1315
01:25:30,400 --> 01:25:32,085
put things on the end of the list.

1316
01:25:32,085 --> 01:25:34,914
we're always have to
walk through the start of the list

1317
01:25:34,914 --> 01:25:37,857
to get to the end.
And we're having to do that repeatedly.

1318
01:25:39,257 --> 01:25:41,857
There's a couple of
well known ways we can go about

1319
01:25:41,857 --> 01:25:43,314
optimising that at Haskell.

1320
01:25:43,314 --> 01:25:45,257
Difference lists are one possiblity.

1321
01:25:45,942 --> 01:25:48,571
Which means that
appending has much less of a cost

1322
01:25:50,020 --> 01:25:53,085
provided we don't
ever try to inspect the front early on

1323
01:25:53,085 --> 01:25:55,142
but we don't need to do that, we only need

1324
01:25:55,142 --> 01:25:58,485
to start inspecting
once we've built up this big computation

1325
01:25:58,480 --> 01:26:00,514
of all possible solutions, and then we can

1326
01:26:00,514 --> 01:26:02,480
start filtering things off the front.

1327
01:26:02,485 --> 01:26:05,371
So that could be
an interesting optimisation to see.

1328
01:26:05,371 --> 01:26:06,942
Maybe we'll be able to allocate

1329
01:26:06,942 --> 01:26:08,542
a bit less than the go function.

1330
01:26:08,542 --> 01:26:11,710
Beyond that I'd probably
want to look at the code profiling.

1331
01:26:11,714 --> 01:26:13,200
Try and work out (inaudible)

1332
01:26:13,800 --> 01:26:15,510
a little too frequently, and see

1333
01:26:15,510 --> 01:26:17,000
if we can do something there

1334
01:26:20,020 --> 01:26:22,740
Obvious strategies
and any graph search problem

1335
01:26:22,740 --> 01:26:24,000
would be memorisation.

1336
01:26:26,057 --> 01:26:28,085
Which works really nicely at Haskell.

1337
01:26:28,085 --> 01:26:29,885
That wouldn't be too hard to add in.

1338
01:26:29,885 --> 01:26:33,457
It's just a case of
working out exactly what needs to be optimised.

1339
01:26:34,000 --> 01:26:35,480
And a couple of other things.

1340
01:26:35,480 --> 01:26:37,480
Just in terms of the feel of this code,

1341
01:26:37,480 --> 01:26:38,740
that I'd want to clean up.

1342
01:26:38,740 --> 01:26:40,971
As I pointed out earlier, the neighbour map

1343
01:26:40,970 --> 01:26:43,885
always has to be
paired with the dictionary so forcing

1344
01:26:43,885 --> 01:26:46,685
the user to pass the
dictionary and the neighbour map

1345
01:26:46,685 --> 01:26:48,228
around felt a bit cumbersome.

1346
01:26:48,370 --> 01:26:51,880
It would be nice if
we could work out some sort of abstraction there.

1347
01:26:51,880 --> 01:26:55,000
A neighbour map
data type that has an operation like look - up

1348
01:26:55,000 --> 01:26:55,571
and remove ........

1349
01:26:57,000 --> 01:26:59,310
SP: Or the dictionary itself is more complex

1350
01:26:59,310 --> 01:27:02,650
and opaque structure
which can provide you with neighbours.

1351
01:27:02,650 --> 01:27:03,457
OC: Absolutely,

1352
01:27:04,650 --> 01:27:06,600
SP:  Because that's the only operation

1353
01:27:07,710 --> 01:27:09,828
we have on the (inaudible)

1354
01:27:09,820 --> 01:27:12,371
OC: Yes, it needs
efficient look up and efficient

1355
01:27:12,371 --> 01:27:14,400
removal of the things you've already seen.

1356
01:27:14,457 --> 01:27:17,028
Beyond that,
we don't have any other requirements.

1357
01:27:17,020 --> 01:27:19,085
I think were using a new (inaudible) set...

1358
01:27:23,171 --> 01:27:23,685
we did yes.

1359
01:27:24,114 --> 01:27:26,885
so the set does
have efficient look up and deletion.

1360
01:27:27,250 --> 01:27:29,285
But if we were able to combine that with

1361
01:27:31,714 --> 01:27:33,342
the pre-computed neighbour map

1362
01:27:33,620 --> 01:27:35,620
we would probably get a much nicer api.

1363
01:27:35,620 --> 01:27:37,400
SP: And having worked through this,

1364
01:27:37,942 --> 01:27:41,400
the overall approach of using
lists to represent the word chains

1365
01:27:42,514 --> 01:27:43,914
and  expanding those lists.

1366
01:27:48,000 --> 01:27:50,085
Is that the approach you would use again ?

1367
01:27:50,657 --> 01:27:53,142
OC: I think, now that we've got more familiar with

1368
01:27:53,140 --> 01:27:54,485
the problem,and its clear

1369
01:27:54,480 --> 01:27:56,028
that it has this tree structure

1370
01:27:56,028 --> 01:27:57,800
when you do a breadth-first search.

1371
01:27:57,800 --> 01:28:00,257
It would have been
nice to make that explicit

1372
01:28:00,257 --> 01:28:01,542
in the types themselves.

1373
01:28:01,542 --> 01:28:03,910
So use some
sort of tree structure to represent

1374
01:28:03,910 --> 01:28:05,657
the branching out, because I think

1375
01:28:05,650 --> 01:28:07,771
a couple of times we've confused ourselves

1376
01:28:07,771 --> 01:28:10,400
with lists of lists of text,
when we actually wanted

1377
01:28:10,400 --> 01:28:12,142
a list of texts, and it was  unclear

1378
01:28:12,142 --> 01:28:13,657
how we actually got them from

1379
01:28:13,657 --> 01:28:15,514
that nest of lists to a single list.

1380
01:28:15,685 --> 01:28:17,940
Was compact
the right version to be using

1381
01:28:17,940 --> 01:28:20,085
or have we
made a mistake somewhere else.

1382
01:28:20,085 --> 01:28:22,540
So we didn't really (inaudible) on the types there,

1383
01:28:22,540 --> 01:28:25,420
it would have  been nice
if we could have taken a bit more

1384
01:28:25,420 --> 01:28:27,110
advantage from the type system.

1385
01:28:27,110 --> 01:28:29,514
I think if I
were to do it again I would choose

1386
01:28:29,514 --> 01:28:31,280
a slightly better data structure

1387
01:28:32,028 --> 01:28:33,857
for word chains in the first place

1388
01:28:34,028 --> 01:28:36,420
SP: So there's a built in tree type,
isn't there?

1389
01:28:36,420 --> 01:28:38,740
OC: Yes, its not
one that I'm very familiar with.

1390
01:28:38,740 --> 01:28:41,200
It's in the same library
as data.set and data.map.

1391
01:28:42,910 --> 01:28:44,685
It doesn't have a hugh avi/api(inaud)

1392
01:28:46,400 --> 01:28:48,371
but it does avoid me (inaud) in terms of

1393
01:28:49,110 --> 01:28:50,857
just coming up with the data type.

1394
01:28:51,110 --> 01:28:54,050
And the other thing
that I might be interested in doing

1395
01:28:54,050 --> 01:28:56,057
there's a lot of hidden recursion here.

1396
01:28:57,000 --> 01:28:58,771
It's quite hard to follow this code,

1397
01:28:59,940 --> 01:29:01,710
it calls itself in different ways.

1398
01:29:02,914 --> 01:29:04,628
It's more of a (inaudible) Haskell

1399
01:29:06,828 --> 01:29:08,914
where you can
split that recursion out

1400
01:29:08,914 --> 01:29:10,280
and make it very explicit.

1401
01:29:10,280 --> 01:29:12,371
You have some
N functions that operate

1402
01:29:12,370 --> 01:29:14,114
on just one thing, and then you have

1403
01:29:14,114 --> 01:29:16,085
a recursion scheme you can apply to that.

1404
01:29:16,085 --> 01:29:18,828
And that might
come out with some slightly cleaner code,

1405
01:29:18,828 --> 01:29:21,314
but it's going to
take a lot more work to get that.

1406
01:29:23,200 --> 01:29:24,680
But I think maybe (inaudible)

1407
01:29:24,680 --> 01:29:26,371
could clear up a lot of this code.

1408
01:29:27,420 --> 01:29:29,857
SP: Right, that seems like a successful session.

1409
01:29:30,770 --> 01:29:32,457
OC: I think so - got there in the end.

1410
01:29:32,770 --> 01:29:33,485
SP: Yes, thanks.

1411
01:29:36,280 --> 01:29:36,542
OC: OK

