1
00:00:02,000 --> 00:00:03,800
NARRATOR: Welcome to Peer to Peer

2
00:00:03,828 --> 00:00:05,485
where  you can hone your skills

3
00:00:05,485 --> 00:00:07,114
by watching live coding videos

4
00:00:08,800 --> 00:00:10,570
Our guest today is Ollie Charles

5
00:00:11,142 --> 00:00:13,028
who's a Haskell developer at Fynder

6
00:00:13,020 --> 00:00:14,885
and the author of 24 days of Hackage.

7
00:00:16,800 --> 00:00:20,742
Our host is Steve Purcell and the
challenge that we set for Ollie is called

8
00:00:23,228 --> 00:00:26,250
Steve Purcell: So Ollie would you
like to start by reading

9
00:00:26,257 --> 00:00:28,171
through the question description?

10
00:00:28,300 --> 00:00:32,170
Ollie Charles: Ok, so its write a
program that solves word chain puzzles.

11
00:00:55,820 --> 00:00:58,310
OC: So that seems pretty straightforward to me.

12
00:00:58,310 --> 00:01:00,450
I guess that we've got a restriction there,

13
00:01:00,450 --> 00:01:02,114
that the start and the end words

14
00:01:02,114 --> 00:01:03,714
will have to be the same length?

15
00:01:03,714 --> 00:01:04,570
SP: Yes they will.

16
00:01:07,220 --> 00:01:09,450
OC: You've given me this dictionary as well.

17
00:01:14,000 --> 00:01:16,420
And I see that some of these are different case.

18
00:01:17,080 --> 00:01:19,570
Is that going to have any impact on the problem ?

19
00:01:19,570 --> 00:01:21,028
Do I need to preserve case or

20
00:01:21,028 --> 00:01:22,885
is it to be lower case on everything?

21
00:01:22,960 --> 00:01:24,942
SP: I would like the resulting chain to

22
00:01:25,885 --> 00:01:28,600
include the original case of the word from this file

23
00:01:29,340 --> 00:01:32,250
and if you ask for a chain between two particular words

24
00:01:35,140 --> 00:01:37,740
they should be present with the same case in the

25
00:01:37,740 --> 00:01:40,200
word list file in order to be considered valid

26
00:01:40,620 --> 00:01:44,020
OC: OK.  And is changing case going to be considered an operation ?

27
00:01:44,020 --> 00:01:46,857
So if I have something that starts with a lower case A

28
00:01:47,740 --> 00:01:50,171
and an upper case A is that a difference of one ?

29
00:01:53,000 --> 00:01:54,628
SP: I think so, I think a word will

30
00:01:54,628 --> 00:01:57,857
either be capitalized or not in the dictionary.

31
00:02:00,800 --> 00:02:05,980
I don't think
you would find the same word in there twice,

32
00:02:06,028 --> 00:02:07,600
once capitalized and once not.

33
00:02:10,657 --> 00:02:13,428
OC: OK, Yes. Well I suppose we'll see what happens

34
00:02:14,371 --> 00:02:15,742
So I think the first thing

35
00:02:15,742 --> 00:02:17,940
I'm going to do is get my environment set up.

36
00:02:19,942 --> 00:02:21,342
I want to have a Cabal file

37
00:02:21,342 --> 00:02:23,480
so I'll treat this like a
proper project.

38
00:02:24,260 --> 00:02:25,828
I'm going to be using nix  shell

39
00:02:26,380 --> 00:02:28,540
to work
with that kabal file to do builds

40
00:02:28,540 --> 00:02:31,200
and bring down
dependencies and stuff like that.

41
00:02:33,460 --> 00:02:34,970
OC: So I've got a terminal here,

42
00:02:34,970 --> 00:02:36,680
I should be able to run kabal in it

43
00:02:38,520 --> 00:02:40,080
So let's call this Word Puzzle

44
00:02:41,440 --> 00:02:43,740
It doesn't really matter about the version

45
00:02:44,770 --> 00:02:46,510
and I'll just use another licence

46
00:02:52,560 --> 00:02:54,685
I'll leave that blank ... and all this blank

47
00:02:57,000 --> 00:02:59,280
SP: Yes it will probably become executable

48
00:03:01,000 --> 00:03:07,200
OC: And we'll go with word puzzle (inaudible) the main part

49
00:03:11,460 --> 00:03:15,700
So now I believe I have my spell bar (inaud)

50
00:03:15,700 --> 00:03:19,960
So I should be able to use the space bar (inaudible)

51
00:03:30,800 --> 00:03:33,000
OC: I'm using the UNIX compile command there

52
00:03:33,000 --> 00:03:34,714
to use the kabal file to do a build

53
00:03:36,580 --> 00:03:38,680
OC:  I'm just going to see if that compiles.

54
00:03:38,680 --> 00:03:40,170
Hopefully it's configuring.

55
00:03:42,020 --> 00:03:43,910
And it looks like we've got something

56
00:03:45,060 --> 00:03:51,880
I'm going to have to (inaudible)

57
00:03:53,885 --> 00:03:55,342
OK, so that seems to be happy

58
00:03:55,342 --> 00:03:57,028
compiling something like that

59
00:03:57,160 --> 00:04:06,880
and we can also subject (inaudible)

60
00:04:08,370 --> 00:04:10,400
OC: I think the first thing I'm going to do

61
00:04:10,400 --> 00:04:12,680
is work with loading the dictionary words

62
00:04:12,860 --> 00:04:14,600
so we've got some data to play with

63
00:04:15,970 --> 00:04:18,080
I'm going to start by making a type alias

64
00:04:18,080 --> 00:04:20,280
for the dictionary and for our purposes

65
00:04:21,340 --> 00:04:24,340
the dictionary is
just going to be a list of text values

66
00:04:25,340 --> 00:04:27,620
And the text there is the type from Data.Text

67
00:04:32,570 --> 00:04:35,020
And I think I'll make a new function, dictionary

68
00:04:35,020 --> 00:04:37,220
which will take the file path and keep it.

69
00:04:37,220 --> 00:04:38,800
and give me back a dictionary

70
00:04:46,480 --> 00:04:49,240
I'll take that out for now.

71
00:04:53,900 --> 00:04:56,370
We're going to need the Data Text library as well

72
00:04:57,200 --> 00:04:58,910
so I'll add that to the Cabal file,

73
00:05:02,760 --> 00:05:04,080
And because I'm using nix

74
00:05:04,080 --> 00:05:06,420
I'm going to need to add it to my nix file as well

75
00:05:06,420 --> 00:05:08,085
so that's going to just pull down.

76
00:05:21,542 --> 00:05:23,085
so lets scrub that out for now

77
00:05:27,370 --> 00:05:30,120
SP: So the underscore you're leaving there is the hole?

78
00:05:30,140 --> 00:05:32,114
OC: Yes so if we expand the compilation

79
00:05:33,560 --> 00:05:36,160
it says that there are two holes in this programme

80
00:05:36,160 --> 00:05:38,510
We need to provide some type of computation

81
00:05:38,510 --> 00:05:39,428
that's going to be

82
00:05:39,420 --> 00:05:40,971
(inaudible) in the dictionary

83
00:05:41,480 --> 00:05:43,910
And we also have another hole for main as well

84
00:05:43,960 --> 00:05:46,280
SP: And this is a new feature in the lastest GHC ?

85
00:05:46,280 --> 00:05:48,000
OC: yes. I think this came in GHC 7.8

86
00:05:50,140 --> 00:05:51,857
So  I'll leave the hole name for now,

87
00:05:53,371 --> 00:05:55,085
because it's probably going to be

88
00:05:55,085 --> 00:05:56,685
one of the last ones we fill in.

89
00:05:56,800 --> 00:05:58,680
I'll work on reading this dictionary.

90
00:05:59,400 --> 00:06:01,800
I think I'm going to switch over to Hackage now,

91
00:06:03,920 --> 00:06:06,880
and look at the
documentation from the Text Library.

92
00:06:08,220 --> 00:06:10,880
This module has all sorts of IO routines that are

93
00:06:11,370 --> 00:06:13,110
going  to give us text values back,

94
00:06:13,110 --> 00:06:15,540
and the one that I'm interested in is readfile,

95
00:06:15,540 --> 00:06:16,771
which takes a file path

96
00:06:16,771 --> 00:06:18,970
that gives us back a single text strength,

97
00:06:18,970 --> 00:06:21,820
and then we can split
that up into a dictionary later.

98
00:06:21,980 --> 00:06:23,971
The first thing I'm going to do is that.

99
00:06:33,710 --> 00:06:35,571
The text library tends to work best

100
00:06:35,571 --> 00:06:37,085
if you use qualified inputs.

101
00:06:37,140 --> 00:06:38,970
so I'm going to import Data.Text as T.

102
00:06:41,840 --> 00:06:43,371
SP: So your just avoiding the

103
00:06:43,371 --> 00:06:45,500
confusion of clobbering the built ins

104
00:06:45,500 --> 00:06:46,885
in the mode. (inaudible)

105
00:06:46,885 --> 00:06:48,685
OC: Yes, the prelude has things like

106
00:06:48,685 --> 00:06:50,600
length, filter and things like that,

107
00:06:50,600 --> 00:06:53,050
but text also has length and filter, so to avoid

108
00:06:53,057 --> 00:06:56,120
ambiguous names I'm going to call that entirely qualified.

109
00:06:58,714 --> 00:07:00,857
SP: So its about hiding the symbols (inaud).

110
00:07:00,857 --> 00:07:02,657
OC: Yes, I'm probably not going to be

111
00:07:02,650 --> 00:07:04,514
using the prelude stuff very much,

112
00:07:05,742 --> 00:07:07,542
But that will save me some hassle.

113
00:07:08,720 --> 00:07:10,171
Just had a type hole in there

114
00:07:10,885 --> 00:07:12,514
so I've got a well formed syntax.

115
00:07:12,714 --> 00:07:15,680
And now I have a hole
that needs to be in the dictionary

116
00:07:17,940 --> 00:07:21,420
and I have available
dictionary contents which is a piece of text.

117
00:07:22,140 --> 00:07:25,370
So I need to split this
single text string into a list of lines.

118
00:07:26,400 --> 00:07:27,857
I believe we have a function

119
00:07:27,857 --> 00:07:29,828
to do that in the Text Library as well,

120
00:07:30,020 --> 00:07:34,360
which is un-line. (Inaudible)

121
00:07:34,360 --> 00:07:37,314
Which is going to break
the text up into a list of texts.

122
00:07:38,240 --> 00:07:41,080
SP: It's the exact analogue
of the lines in the prelude.

123
00:07:41,085 --> 00:07:41,657
OC: Exactly.

124
00:07:42,280 --> 00:07:44,028
OC: So the text type itself is very

125
00:07:44,020 --> 00:07:46,200
similar to the string type in the prelude

126
00:07:46,228 --> 00:07:48,542
except the string type is quite inefficient.

127
00:07:48,542 --> 00:07:50,370
It's just a link list of characters,

128
00:07:50,370 --> 00:07:53,828
whereas text type is more
efficient in terms of representation.

129
00:07:53,828 --> 00:07:56,542
SP: So you make a point
of defaulting to the text type.

130
00:08:04,200 --> 00:08:06,970
Now I can just take
the lines of dictionary contents,

131
00:08:11,900 --> 00:08:14,250
And I should have
a way to read the dictionary.

132
00:08:18,228 --> 00:08:20,428
I'm going to switch
back over to my terminal

133
00:08:21,885 --> 00:08:24,114
at GCHi and then
we can have a play with that.

134
00:08:25,400 --> 00:08:28,371
I need to refresh my shell to
bring down that text. (inaudible)

135
00:08:36,800 --> 00:08:38,450
We've still got these holes here

136
00:08:39,400 --> 00:08:41,200
which prevents me from using GHCi.

137
00:08:41,780 --> 00:08:43,800
But, I can use another feature of a list

138
00:08:44,620 --> 00:08:46,820
produced at GHC called defer-type errors.

139
00:08:47,300 --> 00:08:49,028
which is going to let me run code

140
00:08:51,170 --> 00:08:52,942
which doesn't strictly type check

141
00:08:53,310 --> 00:08:54,342
but as long as I don't

142
00:08:54,342 --> 00:08:56,370
run something
that doesn't type check,

143
00:08:56,370 --> 00:08:58,085
I can still evaluate the program.

144
00:08:58,085 --> 00:08:59,571
I can work around the fact that

145
00:08:59,850 --> 00:09:02,320
I've got an incomplete bit of code in there (inaudible).

146
00:09:02,320 --> 00:09:04,085
SP: So does it effectively replace

147
00:09:04,085 --> 00:09:07,560
that code with undefined (inaudible)

148
00:09:07,560 --> 00:09:08,450
OC: We can find out.

149
00:09:09,620 --> 00:09:11,800
It's the main function that we have to find

150
00:09:12,400 --> 00:09:15,140
well actually it doesn't terminate at all (laughter).

151
00:09:17,720 --> 00:09:23,000
But we do have the dictionary (inaudible)

152
00:09:23,000 --> 00:09:25,600
so why don't we try read dictionary, word list txt.

153
00:09:33,740 --> 00:09:36,428
I'm going to bind that into variable dict
no I'm not

154
00:09:47,910 --> 00:09:50,310
SP: It's not going to print it straight off is it?

155
00:09:50,310 --> 00:09:52,640
OC: No, because of the size of the dictionary,

156
00:09:52,640 --> 00:09:54,720
I want to put that in the variable so I can

157
00:09:54,720 --> 00:09:56,628
try and read out a few things from it.

158
00:09:57,300 --> 00:09:59,940
So we'll take the length of the dictionary.

159
00:10:08,200 --> 00:10:09,800
it's a pretty large dictionary,

160
00:10:10,420 --> 00:10:12,500
We have to be quite efficient in the way

161
00:10:12,500 --> 00:10:13,710
we search through this.

162
00:10:13,710 --> 00:10:14,050
SP: Yes

163
00:10:15,457 --> 00:10:17,314
But we do seem to have got some stuff.

164
00:10:18,457 --> 00:10:21,314
I guess we've got some
windows and other things there.

165
00:10:21,600 --> 00:10:23,400
Which is going to be a bit annoying,

166
00:10:23,400 --> 00:10:25,600
I'll probably
want to trim that stuff out.

167
00:10:25,628 --> 00:10:27,314
SP: Feel free to convert the file

168
00:10:27,314 --> 00:10:29,057
If you want to change the line endings

169
00:10:29,085 --> 00:10:29,971
that's fine with me.

170
00:10:32,540 --> 00:10:35,400
OC: Maybe if we just
filter those character terms out

171
00:10:38,485 --> 00:10:39,828
that might be easy enough.

172
00:10:51,000 --> 00:10:52,450
Let's see if that's any better.

173
00:10:53,600 --> 00:10:54,680
So I'm happy with that.

174
00:10:55,080 --> 00:10:57,380
We're just filtering out character returns

175
00:10:57,380 --> 00:10:59,080
on the whole dictionary string.

176
00:11:02,420 --> 00:11:05,314
Good so it looks like
the dictionary has loaded up fine.

177
00:11:06,600 --> 00:11:09,028
So now we're ready to start solving the problem.

178
00:11:12,114 --> 00:11:15,200
There's no real reason
to restrict ourselves to the IO here,

179
00:11:15,840 --> 00:11:18,850
this feels like it should
be solvable by pure functions

180
00:11:19,340 --> 00:11:21,800
So I'm going to introduce a top little function,

181
00:11:25,310 --> 00:11:26,628
we'll go with word puzzle,

182
00:11:27,200 --> 00:11:29,200
which is going to take , 2 text strings

183
00:11:31,820 --> 00:11:34,310
which are going to be our start and end strings,

184
00:11:37,340 --> 00:11:39,714
and the dictionary. I think I'll bring that in.

185
00:11:44,080 --> 00:11:46,880
So a possible solution
is going to be a list of words,

186
00:11:46,880 --> 00:11:49,740
but I imagine there
are multiple possible solutions

187
00:11:49,740 --> 00:11:52,250
for some of these
problems so I'm going to return

188
00:11:52,250 --> 00:11:53,400
a list of list of words.

189
00:11:53,400 --> 00:11:55,770
And because
that's getting a bit confusing

190
00:11:55,770 --> 00:11:58,710
I think we'll introduce
types in there called solution.

191
00:11:58,710 --> 00:12:00,170
SP: Perhaps a word chain ?

192
00:12:00,400 --> 00:12:02,170
OC: Yes, good we'll go with word chain.

193
00:12:03,780 --> 00:12:05,510
Which is going to be a list of text.

194
00:12:09,485 --> 00:12:11,710
SP: So you'll have
a list of possible chains

195
00:12:12,240 --> 00:12:14,240
from the first word to the second word.

196
00:12:14,257 --> 00:12:16,714
OC: And if it's not
possible to solve the problem

197
00:12:16,710 --> 00:12:18,714
then we can just return the empty list.

198
00:12:18,714 --> 00:12:21,142
that there are no possible word chains at all.

199
00:12:26,228 --> 00:12:28,628
I'm going to try to
solve this by pattern match

200
00:12:30,114 --> 00:12:32,340
and try to break
the problem down slowly,

201
00:12:32,514 --> 00:12:34,857
hopefully we'll get
to the solution that way.

202
00:12:34,914 --> 00:12:36,942
And there's one really obvious pattern:

203
00:12:36,942 --> 00:12:39,228
you gave me
the restriction that the words

204
00:12:39,228 --> 00:12:40,828
have got to be the same length.

205
00:12:40,820 --> 00:12:43,200
so if the words aren't
the same length then there's

206
00:12:43,228 --> 00:12:44,457
no word chain between them

207
00:12:44,485 --> 00:12:45,914
so I'll get that case out the way.

208
00:12:45,914 --> 00:12:47,710
I'm going to use a pattern after that

209
00:12:47,714 --> 00:12:49,857
so if the length of A
is not the length of B

210
00:12:54,140 --> 00:12:55,685
then I'll just return nothing.

211
00:12:59,540 --> 00:13:00,940
Otherwise I'll leave that.

212
00:13:03,480 --> 00:13:04,600
It seems to be solved.

213
00:13:07,480 --> 00:13:08,910
OK so what have we got there?

214
00:13:11,200 --> 00:13:12,740
It seems to be happy with that,

215
00:13:12,740 --> 00:13:15,310
we've got a hole on
line 19 but that's not a problem

216
00:13:15,980 --> 00:13:19,110
so if I try now and solve
the word puzzle with our dictionary,

217
00:13:21,080 --> 00:13:22,510
between Hello and Haskell.

218
00:13:25,080 --> 00:13:28,028
whoops
the dictionary escaped, I'll just put that back in.

219
00:13:31,250 --> 00:13:33,342
I need to use an extension here from GHC

220
00:13:35,142 --> 00:13:36,628
called overloaded strings.

221
00:13:36,628 --> 00:13:38,250
Normally when we inaud a string,

222
00:13:38,320 --> 00:13:40,400
it's as the type
strength but obviously

223
00:13:40,400 --> 00:13:42,057
we are working with text values

224
00:13:42,050 --> 00:13:44,571
so the overloaded
string extension is going to

225
00:13:45,200 --> 00:13:46,620
let us use literal strings

226
00:13:47,740 --> 00:13:49,310
but they will have a type text.

227
00:13:49,740 --> 00:13:51,900
And as we would expect- hello and Haskell

228
00:13:51,900 --> 00:13:53,800
don't have the same length so there's

229
00:13:53,800 --> 00:13:55,370
no solution at all...move on now

230
00:13:56,140 --> 00:13:58,370
so you actually try to find some solutions.

231
00:13:59,740 --> 00:14:01,820
SP:  Might I suggest another case where we

232
00:14:02,570 --> 00:14:05,371
might be able to
rule out other possible solutions.

233
00:14:05,371 --> 00:14:05,771
OC: Sure

234
00:14:06,620 --> 00:14:09,450
SP: So if either of the
words are not in the dictionary

235
00:14:09,480 --> 00:14:11,710
I don't know
if you want to handle that now.

236
00:14:13,020 --> 00:14:14,480
OC: No that seems reasonable.

237
00:14:19,240 --> 00:14:20,685
I've just had a thought that

238
00:14:20,680 --> 00:14:23,542
I might want to have
a more efficient dictionary type,

239
00:14:23,542 --> 00:14:24,942
but we'll come to that later.

240
00:14:24,971 --> 00:14:27,371
So were giving
two words A and B and so let's see

241
00:14:28,740 --> 00:14:41,200
(inaudible)

242
00:14:55,520 --> 00:14:58,000
I think that's what we want.
See if that compiles

243
00:14:58,020 --> 00:14:58,970
I'll just save that.

244
00:15:02,450 --> 00:15:05,914
SP: You'll probably find that
Haskell will not be in the dictionary.

245
00:15:08,910 --> 00:15:11,060
OC: OK well we can check that .........

246
00:15:17,600 --> 00:15:19,400
It is in the dictionary ! (laughter)

247
00:15:19,400 --> 00:15:20,771
SP: It's a respectable word !

248
00:15:25,880 --> 00:15:28,340
I guess then we
probably need to deal with case,

249
00:15:29,540 --> 00:15:31,420
or maybe I should case sensitive an A.

250
00:15:32,740 --> 00:15:34,770
Capital Hello is not in the dictionary.

251
00:15:35,050 --> 00:15:36,650
Lower case however, will be. Yes

252
00:15:38,710 --> 00:15:40,280
I think I'll leave that for now.

253
00:15:40,310 --> 00:15:42,310
SP: I think that's how it should work. Yes.

254
00:15:42,910 --> 00:15:43,170
OC: OK

255
00:15:43,820 --> 00:15:46,370
SP: Let's presume
that the input would be exactly

256
00:15:46,370 --> 00:15:47,710
as it is in the dictionary

257
00:15:47,710 --> 00:15:49,650
or it's strictly considered invalid.

258
00:15:50,540 --> 00:15:53,170
OC: OK.  And I expect
there's another obvious pattern,

259
00:15:57,200 --> 00:15:59,250
which is, regardless of the dictionary,

260
00:16:00,220 --> 00:16:02,571
we have two words
A and B, and they are the same,

261
00:16:02,571 --> 00:16:05,142
and were done......
so that has one possible solution,

262
00:16:06,000 --> 00:16:08,450
and I think I'm still
going to put that solution

263
00:16:08,480 --> 00:16:09,370
in the word chain

264
00:16:09,970 --> 00:16:12,680
So if we go from
hello to hello, the solution will be

265
00:16:12,680 --> 00:16:15,370
one word chain
which contains just the word hello.

266
00:16:16,710 --> 00:16:17,970
so we can try that on two

267
00:16:22,570 --> 00:16:25,142
So let's see, word puzzle, dictionary, hello hello.

268
00:16:30,800 --> 00:16:32,570
It does indeed have one solution

269
00:16:32,800 --> 00:16:34,650
which is the word chain hello.
Good!

270
00:16:34,800 --> 00:16:37,370
So, beyond that
we've ruled out the obvious here

271
00:16:39,620 --> 00:16:41,800
and we need to start doing some real work.

272
00:16:41,800 --> 00:16:44,200
And I think a useful
function that we're going

273
00:16:44,220 --> 00:16:45,685
to need is something that's

274
00:16:45,714 --> 00:16:47,420
going to determine the distance

275
00:16:47,420 --> 00:16:48,371
between two words

276
00:16:48,371 --> 00:16:50,600
which is going to
be the amount of changes

277
00:16:50,910 --> 00:16:53,050
you have to
make to get between two words.

278
00:16:53,050 --> 00:16:54,457
SP: Yes, or at least whether

279
00:16:56,480 --> 00:16:58,571
they are one step
apart from each other

280
00:16:58,650 --> 00:16:58,970
OC: Yes

281
00:17:08,685 --> 00:17:10,342
The neighbours are going to be

282
00:17:10,340 --> 00:17:11,971
words some distance away... by one

283
00:17:12,770 --> 00:17:15,110
So distance is going to take two text values

284
00:17:17,310 --> 00:17:18,620
and give us back a number.

285
00:17:19,800 --> 00:17:21,800
So if they are the
same then of course,

286
00:17:22,480 --> 00:17:23,820
the distance is just zero.

287
00:17:27,340 --> 00:17:29,280
So how we going to do this next.......let's see.

288
00:17:32,220 --> 00:17:34,820
yes I'm probably
going to break the string apart

289
00:17:34,820 --> 00:17:36,420
and treat it as if it were a list,

290
00:17:36,420 --> 00:17:37,880
and I will compare the head,

291
00:17:37,880 --> 00:17:40,910
and see if they're
different, and if they're not different

292
00:17:40,910 --> 00:17:42,340
the distance there is zero

293
00:17:42,340 --> 00:17:45,085
but if they're different
the difference will be one.

294
00:17:45,910 --> 00:17:49,200
SP: Are you once again assuming
that A and B are the same length?

295
00:17:49,200 --> 00:17:52,710
OC: Yes I'm going to assume
for this function they are the same length.

296
00:17:52,710 --> 00:17:56,542
and if not,well it might actually
work even if they're different lengths.

297
00:17:59,970 --> 00:18:03,680
SP:  What comes to my mind is
zipping the characters of the two together

298
00:18:06,710 --> 00:18:08,970
and seeing how many pairs are not identical.

299
00:18:09,620 --> 00:18:12,450
OC: Yes, that sounds like
the kind of thing we could do.

300
00:18:12,940 --> 00:18:14,740
I think now because were zipping,

301
00:18:14,740 --> 00:18:17,450
even if they're
different lengths we can probably

302
00:18:17,450 --> 00:18:19,110
just drop the extra characters.

303
00:18:19,110 --> 00:18:21,370
And I think
we have a zip function already

304
00:18:21,370 --> 00:18:22,885
in the text library ...... we do.

305
00:18:26,800 --> 00:18:29,628
that's going to compare characters.
It works on text

306
00:18:31,450 --> 00:18:33,820
so we can
only use it to zip two pieces of text

307
00:18:36,170 --> 00:18:37,370
which is not so useful.

308
00:18:38,600 --> 00:18:42,600
So take A and B
and we will zip A and B so I'm going to

309
00:18:45,450 --> 00:18:49,170
use type (inaudible) here

310
00:18:49,910 --> 00:18:52,480
OK, So we need to have
a function which takes a list

311
00:18:54,280 --> 00:18:56,110
of pairs of characters to a number.

312
00:19:02,220 --> 00:19:04,628
I think first thing we'll do
is map over those,

313
00:19:06,370 --> 00:19:07,850
so we can consider each pair

314
00:19:07,850 --> 00:19:09,428
of characters independently.

315
00:19:12,170 --> 00:19:14,600
Oh dear, I'll ignore that for now, next type hole

316
00:19:18,620 --> 00:19:20,140
we have a pair of characters,

317
00:19:20,140 --> 00:19:21,910
which have to produce something.

318
00:19:30,620 --> 00:19:33,570
So if x is equal to y ......... then zero provides

319
00:19:37,570 --> 00:19:39,910
That's one possible
correction we have to do.

320
00:19:44,710 --> 00:19:47,280
Now we need to take
a list of things like a number.

321
00:19:47,280 --> 00:19:51,050
I don't know why it hasn't

322
00:19:51,050 --> 00:19:56,600
(inaudible)

323
00:19:56,600 --> 00:19:57,457
Ok, so that's good.

324
00:19:58,600 --> 00:20:00,880
So it's hacking into our distance functions

325
00:20:00,910 --> 00:20:02,280
we can switch back to GHCi

326
00:20:02,600 --> 00:20:04,110
and see what it makes of that.

327
00:20:05,740 --> 00:20:07,714
So let's see if the difference between

328
00:20:07,714 --> 00:20:09,257
dog and cog is indeed one.

329
00:20:10,400 --> 00:20:12,800
That's what you would expect.
A basic example.

330
00:20:15,880 --> 00:20:19,450
Let's see if we can
fit this into our word puzzle.

331
00:20:21,800 --> 00:20:28,540
We're certainly going
to need the dictionary. (inaud)

332
00:20:32,080 --> 00:20:33,940
So I'm going to start with the word A

333
00:20:34,310 --> 00:20:36,510
and we need to
find the neighbours of word A.

334
00:20:41,820 --> 00:20:44,480
Let's filter the
dictionary so we don't have A in it.

335
00:21:03,680 --> 00:21:06,820
That's going to give
me a dictionary that doesn't have A in it.

336
00:21:10,740 --> 00:21:13,110
Maybe if we
pair every word with its distance

337
00:21:14,140 --> 00:21:16,110
so take every word in the dictionary

338
00:21:16,740 --> 00:21:18,740
and find its distance against word A

339
00:21:18,740 --> 00:21:21,740
and then I can take
the ones that just have a distance of 1

340
00:21:22,850 --> 00:21:25,820
and that again
feels like I'm zipping 2 lists together.

341
00:21:26,650 --> 00:21:26,910
SP: OK

342
00:21:29,820 --> 00:21:32,050
OC:  First we need to map that for every word.

343
00:21:34,770 --> 00:21:37,540
We're going to keep
the word and I'm also going to keep

344
00:21:37,540 --> 00:21:39,000
the distance between A and W.

345
00:21:43,510 --> 00:21:45,510
Actually this is like what I'm saying.

346
00:21:46,340 --> 00:21:48,370
Let's say neighbours, takes dictionary

347
00:21:49,800 --> 00:21:52,020
and a word
and it gives back a list of words.

348
00:22:04,340 --> 00:22:05,600
And now we've got this map

349
00:22:06,680 --> 00:22:08,850
and we need to filter this for all things

350
00:22:08,850 --> 00:22:10,570
that have a distance of exactly 1.

351
00:22:11,770 --> 00:22:12,771
So let's filter .......

352
00:22:23,340 --> 00:22:25,800
It's a bit long there...... I'll reform that slightly

353
00:22:37,000 --> 00:22:39,220
Bit of a hole there, we can come back to that,

354
00:22:39,970 --> 00:22:44,710
so (inaudible) build.

355
00:22:44,710 --> 00:22:46,110
Ok, so what have we got here?

356
00:22:49,250 --> 00:22:51,910
Ah, Ok, so I've filtered this
but I also need to map it

357
00:22:54,480 --> 00:22:56,510
just so it will
take the word, so that's A,

358
00:22:56,510 --> 00:22:58,420
and once more, and take just the word

359
00:23:00,740 --> 00:23:03,680
and the (inaudible) distance.

360
00:23:03,680 --> 00:23:05,770
SP: Is there a function for that, is it fst ?

361
00:23:07,020 --> 00:23:08,220
OC: Yes, we can use fst now.

362
00:23:23,400 --> 00:23:25,620
Good, so we're
back to compiling once more.

363
00:23:27,480 --> 00:23:28,570
So I'll give that a try.

364
00:23:41,200 --> 00:23:42,710
Let's find neighbours of dog,

365
00:23:44,710 --> 00:23:46,800
and we need the dictionary there as well.

366
00:23:49,540 --> 00:23:51,680
It doesn't seem quite right to me (laughter)

367
00:23:52,020 --> 00:23:54,510
SP: I think this is probably a result of zipping,

368
00:23:55,820 --> 00:23:58,510
not taking into
consideration that the lengths

369
00:24:00,880 --> 00:24:03,710
of the two words
are different, then zip would finish

370
00:24:05,940 --> 00:24:08,050
at the shortest sequence.
OC: Right, yes

371
00:24:08,080 --> 00:24:10,000
SP: And so, all of these like 'downfall'

372
00:24:12,250 --> 00:24:14,370
would be only
one letter away from 'dog'

373
00:24:15,885 --> 00:24:17,485
so maybe you should only look

374
00:24:17,485 --> 00:24:18,742
at the first one.
OC: Yes

375
00:24:18,942 --> 00:24:21,942
OC: Maybe we should be
filtering the dictionary first

376
00:24:21,942 --> 00:24:24,428
on getting words
that are only the same length.

377
00:24:24,428 --> 00:24:26,510
We certainly have done that here.
SP: Yes

378
00:24:37,710 --> 00:24:40,540
OC: I'm going to bring
in some smaller functions there.

379
00:24:53,570 --> 00:24:56,971
The idea here is I'm
probably going to use the Applicative Syntax

380
00:24:56,971 --> 00:24:58,742
to combine 2 operations together

381
00:24:59,450 --> 00:25:01,880
so I want to take
things that are not equal to A.

382
00:25:03,940 --> 00:25:05,970
SP: And also the (inaudible) operator?

383
00:25:06,450 --> 00:25:07,450
OC: Oh yes, of course,

384
00:25:09,740 --> 00:25:12,370
in fact we'll put that (inaud) in there.

385
00:25:15,680 --> 00:25:17,600
So we need it to satisfy 2 conditions.

386
00:25:23,400 --> 00:25:24,820
We should be able to do this,

387
00:25:25,650 --> 00:25:26,480
and its length .......

388
00:25:29,200 --> 00:25:31,220
is equal, to the length of A.

389
00:25:36,340 --> 00:25:39,540
I think we'll probably be
able to tidy that function up as well.

390
00:25:40,280 --> 00:25:41,600
So I'll take those back out

391
00:25:43,020 --> 00:25:45,850
and we're going to
need to import Control .Applicative.

392
00:25:47,600 --> 00:25:50,570
SP: So I notice here
that even though you presumably knew

393
00:25:50,570 --> 00:25:53,370
that you
were going to import Control.Applicative

394
00:25:53,740 --> 00:25:56,057
your habit is to immediately try compiling

395
00:25:59,050 --> 00:26:01,420
and have the compiler to tell you that.
OC: Yes.

396
00:26:01,420 --> 00:26:05,020
SP: So this is really an analogue of the T  (inaudible)

397
00:26:05,657 --> 00:26:07,057
going for the failing test

398
00:26:07,420 --> 00:26:08,370
OC: That's right yes,

399
00:26:22,450 --> 00:26:24,280
And I have to context switch again.

400
00:26:26,370 --> 00:26:28,400
I've used length from the prelude here,

401
00:26:28,420 --> 00:26:29,620
but we have text values

402
00:26:29,770 --> 00:26:31,910
and length cannot be used on text values.

403
00:26:33,340 --> 00:26:34,620
so we need to use T.length.

404
00:26:40,540 --> 00:26:42,771
so hopefully were back to compiling that.

405
00:26:44,170 --> 00:26:45,510
So let's try that one again.

406
00:26:45,910 --> 00:26:47,740
See if it makes more sense this time.

407
00:26:51,620 --> 00:26:53,080
That looks a lot better to me.

408
00:26:53,850 --> 00:26:54,020
OK!

409
00:26:59,170 --> 00:27:01,770
SP: Now Ollie could you explain this section here

410
00:27:01,770 --> 00:27:05,020
where you've used
the operators from Control.Applicative.

411
00:27:06,910 --> 00:27:09,620
OC:  We're working
under the reader applicative here,

412
00:27:10,310 --> 00:27:12,680
which is
basically an applicative functor

413
00:27:13,250 --> 00:27:14,970
that works for function arrows.

414
00:27:15,250 --> 00:27:17,620
So what I want to
do is, take the same argument

415
00:27:17,620 --> 00:27:19,280
as I filter over the dictionary

416
00:27:19,280 --> 00:27:20,885
for every word in the dictionary.

417
00:27:20,914 --> 00:27:23,220
I need to check  that
that word is not equal to A.

418
00:27:23,220 --> 00:27:25,280
And I also need to check that its length

419
00:27:25,280 --> 00:27:26,680
is equal to the length of A.

420
00:27:27,080 --> 00:27:29,400
So I need to
do an operation on the same value.

421
00:27:30,171 --> 00:27:30,770
SP: Right

422
00:27:30,770 --> 00:27:33,020
OC: So I could have introduced a lambda here

423
00:27:33,310 --> 00:27:35,340
and banged that to a variable called W

424
00:27:35,340 --> 00:27:36,680
and said W is not equal to A

425
00:27:37,740 --> 00:27:39,914
and that the
length  of W is the length of A.

426
00:27:41,480 --> 00:27:43,680
But by using this syntax here, its going to

427
00:27:43,680 --> 00:27:45,910
implicitly thread that argument through

428
00:27:46,570 --> 00:27:48,020
to both the functions for me

429
00:27:48,020 --> 00:27:49,542
so I don't have to worry about

430
00:27:49,542 --> 00:27:51,142
passing the right argument in.

431
00:27:51,140 --> 00:27:52,942
By using the right structure here

432
00:27:52,940 --> 00:27:54,285
that kind of comes for free.

433
00:27:54,285 --> 00:27:56,420
And there's one
other thing that I think

434
00:27:56,420 --> 00:27:58,800
I want to tidy up
this is looking a bit weird,

435
00:27:58,800 --> 00:28:00,200
and we've got some helpful

436
00:28:00,228 --> 00:28:02,340
functions in the Data.Function library,

437
00:28:02,340 --> 00:28:04,510
that comes in the base library of Haskell,

438
00:28:05,680 --> 00:28:08,370
so I'm wondering if
maybe we can use something there,

439
00:28:08,370 --> 00:28:11,020
so I'm going to have a quick look at the base library

440
00:28:11,020 --> 00:28:13,220
just to see if anything looks useful there.

441
00:28:15,540 --> 00:28:16,940
SP: Do you tend to use Hoogle?

442
00:28:17,570 --> 00:28:20,050
OC: I do use Hoogle occasionally but that's more

443
00:28:20,050 --> 00:28:22,680
when I know the
function that I'm going to work with,

444
00:28:22,680 --> 00:28:25,714
whereas in this case
I just want to have a look at the types

445
00:28:25,714 --> 00:28:27,342
and see if anything stands out.

446
00:28:27,342 --> 00:28:29,910
SP: Because in Hoogle
you can search by the type.

447
00:28:29,940 --> 00:28:32,680
OC: Right yes, but here
I suppose I'm not entirely sure

448
00:28:33,420 --> 00:28:35,340
what type
I'm going to be looking for,

449
00:28:35,740 --> 00:28:37,370
so I  want to just look through it

450
00:28:37,370 --> 00:28:39,400
and see if anything comes intuitively.

451
00:28:39,420 --> 00:28:40,942
But if we don't find anything

452
00:28:40,942 --> 00:28:42,940
then maybe I will just leave it for now.

453
00:28:42,940 --> 00:28:45,370
But it's
these combinators down here, like 'on'

454
00:28:45,370 --> 00:28:47,740
which is probably going to be the most useful.

455
00:28:47,740 --> 00:28:49,770
So, you can see that 'on' as a typical usage

456
00:28:49,770 --> 00:28:51,450
lets you call the same function

457
00:28:51,450 --> 00:28:52,910
on two different arguments.

458
00:28:52,910 --> 00:28:54,370
So let's see if we can use that.

459
00:28:55,510 --> 00:28:57,450
So we're certainly going to be doing 'on'

460
00:28:58,050 --> 00:28:59,450
well it takes 2 arguments

461
00:29:00,620 --> 00:29:03,770
and: .....it takes a function of two arguments

462
00:29:04,370 --> 00:29:06,250
and also a function of one argument.

463
00:29:06,250 --> 00:29:08,540
Well our function one argument is T.length,

464
00:29:11,650 --> 00:29:14,310
and our function two arguments is just equality.

465
00:29:15,820 --> 00:29:18,080
So we need the check for equality on length.

466
00:29:26,450 --> 00:29:27,800
So you can normally use it

467
00:29:27,800 --> 00:29:29,450
with infix notation like this,

468
00:29:31,250 --> 00:29:33,880
but that's when
you've got two arguments to supply.

469
00:29:34,680 --> 00:29:36,740
We're only going to supply one argument,

470
00:29:36,740 --> 00:29:39,600
so I think
I'm actually going to switch this back round

471
00:29:39,620 --> 00:29:41,280
and do a normal prefix notation.

472
00:29:41,280 --> 00:29:42,970
So 'on' equality, T.length against 'A'

473
00:29:44,340 --> 00:29:47,020
and it's going to
supply us with  a second argument

474
00:29:47,020 --> 00:29:49,170
for each word in the dictionary.
SP: Right.

475
00:29:50,280 --> 00:29:52,650
OC: So compile that
and we're going to be told

476
00:29:52,650 --> 00:29:53,940
that we need to import it,

477
00:29:53,940 --> 00:29:56,480
so let's bring that in..... and that's in.... Data.Function,

478
00:30:04,080 --> 00:30:05,770
Good! So that's back to compiling

479
00:30:06,510 --> 00:30:08,080
and we're back in the hole here.

480
00:30:08,510 --> 00:30:10,000
So I think I'm happy with that,

481
00:30:10,000 --> 00:30:12,310
it's a fairly
clean readable description.

482
00:30:12,800 --> 00:30:15,110
We do have quite a lot of loops going on there,

483
00:30:15,110 --> 00:30:16,880
but I'm going to ignore that for now,

484
00:30:16,880 --> 00:30:19,340
maybe we can
optimise that later, but for now

485
00:30:19,680 --> 00:30:21,680
that's certainly solved the problem.

486
00:30:26,620 --> 00:30:28,940
For our actual
word puzzle problem, we know

487
00:30:28,940 --> 00:30:31,540
that the words
are different, but the same length.

488
00:30:31,570 --> 00:30:34,340
I'm going to find all
the neighbours around the word A,

489
00:30:34,340 --> 00:30:36,540
and then try and find all of the solutions

490
00:30:36,540 --> 00:30:38,170
from all of
the neighbours of A.

491
00:30:38,710 --> 00:30:40,170
See if any of them gets us to B.

492
00:30:40,650 --> 00:30:42,510
In which case (inaudible) solutions.

493
00:30:42,510 --> 00:30:44,857
OC: So we'll start by taking the neighbours of A.

494
00:30:44,850 --> 00:30:49,770
(inaudible) dictionary (inaudible).

495
00:30:53,540 --> 00:30:54,600
I've got a hole here

496
00:30:54,600 --> 00:30:56,771
so I'm going to write some sort of function

497
00:30:56,771 --> 00:30:58,680
that will take all these neighbours.

498
00:30:58,680 --> 00:31:00,510
Let's have a look at the type of that.

499
00:31:02,000 --> 00:31:04,340
We're going to
have a list of text and we need

500
00:31:04,340 --> 00:31:05,800
to go to a list of word chains.

501
00:31:06,940 --> 00:31:09,657
so that list of text
is all the possible neighbours

502
00:31:09,657 --> 00:31:11,485
So I'm going
to map over that and now

503
00:31:12,420 --> 00:31:15,285
I have the function that
goes from  text to word chain.

504
00:31:18,142 --> 00:31:18,628
SP: OK

505
00:31:20,600 --> 00:31:22,000
OC: So how is best to do this.

506
00:31:38,940 --> 00:31:42,085
Even though this has
the same type I want to see what we get to.

507
00:31:42,080 --> 00:31:44,285
We're going to be using the same dictionary

508
00:31:44,428 --> 00:31:46,571
and were going to go to b and  (inaud) and N to B.

509
00:31:52,850 --> 00:31:54,910
That's probably not going to type check.

510
00:31:57,600 --> 00:31:59,970
We could have matched a list of text with text.

511
00:32:00,250 --> 00:32:02,800
Oh! that's because
the word chain is a list of text

512
00:32:02,800 --> 00:32:04,740
so it's expecting a single word chain

513
00:32:05,800 --> 00:32:07,942
but we've actually
got many word chains.

514
00:32:07,971 --> 00:32:10,057
So I think
the problem here is that if we

515
00:32:11,140 --> 00:32:13,650
put another
type hole there, well see that this

516
00:32:13,650 --> 00:32:15,080
could actually typecheck,

517
00:32:15,110 --> 00:32:17,400
provided we
had a function that went from

518
00:32:17,400 --> 00:32:20,285
a list of lists word
chains to just a list of word chains.

519
00:32:20,314 --> 00:32:21,685
Which is of course 'concat',

520
00:32:22,200 --> 00:32:24,650
and we have a
function in the standard library

521
00:32:25,310 --> 00:32:29,000
(inaudible) that hole.

522
00:32:29,000 --> 00:32:31,800
There's a function
in the standard library that does

523
00:32:31,820 --> 00:32:33,770
these two things together.... Concat map

524
00:32:33,770 --> 00:32:35,570
that just such a common operation.

525
00:32:35,570 --> 00:32:36,710
Concat that there...... and

526
00:32:39,740 --> 00:32:40,970
I guess we'll leave that ,

527
00:32:43,140 --> 00:32:46,540
there's a hole for now (inaudible) GCHi again.

528
00:32:46,540 --> 00:32:49,540
By loading the dictionary, I should be able to know

529
00:32:49,570 --> 00:32:52,600
(inaudible) problems.

530
00:32:52,600 --> 00:32:54,714
Let's try word puzzles dict. and dog to cat.

531
00:33:04,250 --> 00:33:06,770
That is impressively slow right now (laughter)

532
00:33:07,250 --> 00:33:10,170
And I'm not sure if that's because this doesn't  terminate

533
00:33:10,170 --> 00:33:12,220
or because were being so inefficient.

534
00:33:12,250 --> 00:33:14,280
SP: No,
by the time you go from dog to dot

535
00:33:16,740 --> 00:33:18,600
one of the neighbours of dot is dog

536
00:33:19,370 --> 00:33:22,371
OC: So we're actually
going back on ourselves probably

537
00:33:22,371 --> 00:33:24,370
SP: (inaudible)

538
00:33:24,370 --> 00:33:26,370
That sounds very reasonable to me. Yes.

539
00:33:28,370 --> 00:33:31,140
so we need to probably
carry some extra state around.

540
00:33:33,170 --> 00:33:34,850
So I'm going to put this down here.

541
00:33:39,570 --> 00:33:42,710
We probably need
to remove something from the dictionary

542
00:33:43,970 --> 00:33:46,170
which I guess
is going to be when we go here.

543
00:33:47,940 --> 00:33:50,140
It will probably want to be a dictionary

544
00:33:51,200 --> 00:33:53,314
without the word N itself and also not A.

545
00:33:59,650 --> 00:34:01,057
I've already removed A here

546
00:34:01,650 --> 00:34:03,970
so I'm wondering
if maybe that should be done

547
00:34:03,970 --> 00:34:04,820
further up here.

548
00:34:07,800 --> 00:34:09,880
We'll try it anyway,
let's just try it here.

549
00:34:17,850 --> 00:34:19,485
So let's filter the dictionary

550
00:34:20,680 --> 00:34:22,342
for stuff that's not to equal to N.

551
00:34:28,280 --> 00:34:29,771
It's still having (inaudible)

552
00:34:38,080 --> 00:34:41,257
That's better but apparently
we now have no solutions at all,

553
00:34:41,250 --> 00:34:43,028
at least we do terminate. (laughter)

554
00:34:46,450 --> 00:34:49,680
SP: So termination we're wrong
is better than no termination.

555
00:34:49,680 --> 00:34:52,514
OC: I think so.
At least we know that it will eventually

556
00:34:52,514 --> 00:34:54,542
deliver and so give us the right answer.

557
00:34:54,910 --> 00:34:56,310
So what I want to check now,

558
00:34:56,910 --> 00:34:58,940
we expected
this sort of chain dog, cog,

559
00:34:59,420 --> 00:35:01,650
cot to cat,
so maybe if we just try cot to cat

560
00:35:03,650 --> 00:35:05,050
see if we get that solution.

561
00:35:05,050 --> 00:35:06,714
OC: For the smallest (inaudible)

562
00:35:09,371 --> 00:35:12,400
that was cot to cat.
Again that seems to have no solutions.

563
00:35:18,657 --> 00:35:21,910
It does indeed contain
cat but it's right there at the start,

564
00:35:21,910 --> 00:35:24,542
so we should certainly be seeing that.
So let's see,

565
00:35:29,280 --> 00:35:31,710
The neighbours around A
and for each of those

566
00:35:33,850 --> 00:35:35,000
We've got a word puzzle

567
00:35:42,110 --> 00:35:42,740
Save target

568
00:35:50,880 --> 00:35:53,820
SP: So here your excluding
words that are the neighbour

569
00:35:56,020 --> 00:35:56,340
OC: Yes

570
00:35:56,340 --> 00:35:58,800
SP: Whereas,
perhaps you should be excluding A.

571
00:36:00,450 --> 00:36:03,400
Because that's the
one you don't want to return to later.

572
00:36:09,000 --> 00:36:10,942
You know that you've got that one.
Yes.

573
00:36:11,310 --> 00:36:15,680
(inaudible)

574
00:36:15,680 --> 00:36:18,280
OC:  So we don't want
to come back to where we started

575
00:36:20,140 --> 00:36:21,770
that certainly does make sense.

576
00:36:30,110 --> 00:36:31,570
And now we go from cot to cat.

577
00:36:33,850 --> 00:36:36,050
OC: Were certainly finding some solutions

578
00:36:37,220 --> 00:36:39,370
but never stopping the search (laughter)

579
00:36:41,680 --> 00:36:44,080
which is interesting. So, what's going on there?

580
00:36:46,740 --> 00:36:48,200
when we loop over there this  ......

581
00:36:49,480 --> 00:36:53,650
Well I'm interested to see
if this will actually terminate at the same length

582
00:36:53,650 --> 00:36:55,170
for all the neighbours of cot.

583
00:36:58,820 --> 00:37:00,400
But maybe this won't terminate.

584
00:37:07,080 --> 00:37:08,280
OK, maybe not (laughter).

585
00:37:09,540 --> 00:37:13,310
SP: The (inaudible) indicated that some where (inaudible) (laughter)

586
00:37:13,310 --> 00:37:18,570
OC: (inaud) we certainly are OK.

587
00:37:20,020 --> 00:37:22,340
So, we're not hitting our base case properly,

588
00:37:23,450 --> 00:37:24,600
which is interesting.

589
00:37:34,140 --> 00:37:36,450
We're certainly getting here because that's

590
00:37:38,000 --> 00:37:39,420
where we return the result.

591
00:37:49,480 --> 00:37:52,080
Maybe if we
take all the solutions of neighbour.

592
00:37:58,710 --> 00:38:01,570
So if we couldn't
find any solutions there then we won't

593
00:38:03,280 --> 00:38:05,280
be able to find any bigger solutions

594
00:38:14,850 --> 00:38:16,140
If we did find a solution

595
00:38:16,910 --> 00:38:18,620
then we should be able to go for it.

596
00:38:23,940 --> 00:38:25,370
Yes, that seems reasonable.

597
00:38:27,020 --> 00:38:28,420
So I think that's largely OK.

598
00:38:32,820 --> 00:38:34,740
We've got an error on that somewhere.

599
00:38:36,110 --> 00:38:37,680
So N is expecting a word chain

600
00:38:40,220 --> 00:38:41,850
that's actually a piece of text

601
00:38:43,540 --> 00:38:44,820
that seems somewhat odd.

602
00:38:49,770 --> 00:38:52,570
SP: So the word puzzle
will return a list of solutions

603
00:38:53,620 --> 00:38:55,085
so do you not need to prepend

604
00:38:56,457 --> 00:38:59,680
each of the items in that list (inaudible)

605
00:38:59,680 --> 00:39:00,650
OC: Ah! of course, yes.

606
00:39:02,057 --> 00:39:04,714
SP: So I think it would be just 'map of prepend.
OC: Yes

607
00:39:05,420 --> 00:39:07,540
OC:  We could also use Applicative Syntax

608
00:39:08,510 --> 00:39:10,020
which is not much different,

609
00:39:10,080 --> 00:39:12,450
(inaudible) something like that

610
00:39:12,450 --> 00:39:14,628
for every S we're going to prepend it with N.

611
00:39:15,600 --> 00:39:16,050
SP: Right

612
00:39:18,620 --> 00:39:20,620
OC: OK,
so we're back to compiling again

613
00:39:33,400 --> 00:39:35,510
Let's see if
we can make any sense of that.

614
00:39:37,540 --> 00:39:40,480
Cat to cat and then
every other word in the dictionary.

615
00:39:40,680 --> 00:39:43,940
We're eventually getting to cat.
That's certainly happening.

616
00:39:45,740 --> 00:39:48,020
I guess that is a valid word chain (laughter).

617
00:39:48,800 --> 00:39:52,220
Is it just that there
are this many possible word chains ? I guess

618
00:39:52,970 --> 00:39:55,080
The first one is certainly wrong though.

619
00:39:55,080 --> 00:39:57,280
That's certainly not a chain from cat to cat.

620
00:39:57,280 --> 00:39:58,970
That should be cot to cat.
SP: Yes

621
00:40:00,600 --> 00:40:04,080
(inaudible)

622
00:40:08,480 --> 00:40:09,940
SP: They are very long chains

623
00:40:09,940 --> 00:40:11,400
SP: Cod to cat was the next one.

624
00:40:12,650 --> 00:40:15,110
They're certainly valid chains though
SP: Yes

625
00:40:19,370 --> 00:40:21,770
OC: So what's going on on that first one though?

626
00:40:26,940 --> 00:40:27,685
We have cat.

627
00:40:29,940 --> 00:40:32,857
The problem is I think
we should have been prepending .....

628
00:40:34,850 --> 00:40:36,910
A rather than N - or possibly both of them.

629
00:40:38,970 --> 00:40:41,400
Let's just see what that is, because we want to go

630
00:40:41,400 --> 00:40:42,970
from the word we're starting at.

631
00:40:48,910 --> 00:40:52,080
and now we certainly
have the right solution at the front

632
00:40:52,080 --> 00:40:54,020
and we can of course exploit laziness,

633
00:40:54,020 --> 00:40:56,420
hopefully just see the very first solution

634
00:40:56,420 --> 00:40:57,428
and it terminates.

635
00:40:58,480 --> 00:41:00,285
and finally that's one word chain

636
00:41:00,280 --> 00:41:01,942
that has certainly got us there.

637
00:41:01,940 --> 00:41:02,285
SP: OK

638
00:41:03,450 --> 00:41:05,850
OC: So we need to
decide where we want to go next.

639
00:41:05,850 --> 00:41:08,110
If we want to
find all possible word chains,

640
00:41:08,110 --> 00:41:10,680
in a short amount of time,
or if we want to make sure

641
00:41:10,680 --> 00:41:12,940
that this is definitely the shortest chain.

642
00:41:15,220 --> 00:41:18,080
At this point,
finding the shortest chain we just need

643
00:41:18,080 --> 00:41:19,800
to sort by the length descending.

644
00:41:23,250 --> 00:41:26,000
But this now
because if we're sorting  the entire list

645
00:41:26,000 --> 00:41:29,600
Is going to have to
consider the entire set of possible solutions.

646
00:41:30,140 --> 00:41:31,942
SP: We probably need to think about

647
00:41:32,771 --> 00:41:34,771
expanding the chains progressively,

648
00:41:39,310 --> 00:41:42,020
and returning first
the ones that are the shortest.

649
00:41:44,400 --> 00:41:46,910
OC: Right so reading
the search, as we go through.

650
00:41:50,250 --> 00:41:52,310
I'm going to try and see how long it takes

651
00:41:53,110 --> 00:41:55,050
to solve the whole list of solutions.

652
00:41:55,420 --> 00:41:57,685
We have a function here, 'sort by' which takes

653
00:41:58,940 --> 00:42:01,571
a list of type A and
if we have a way to compare them

654
00:42:02,050 --> 00:42:03,940
for an ordering we can do something.

655
00:42:03,940 --> 00:42:05,710
So Data.Function also has Data.Ord

656
00:42:12,400 --> 00:42:13,510
So we have  comparing.

657
00:42:14,570 --> 00:42:16,885
So we can say comparing on length (inaudible)

658
00:42:21,400 --> 00:42:22,800
which is just what we want

659
00:42:23,510 --> 00:42:25,080
a word chain as a  list of texts.

660
00:42:26,620 --> 00:42:28,110
So sort by comparing length

661
00:42:35,280 --> 00:42:37,280
and it's certainly not a good solution.

662
00:42:37,570 --> 00:42:40,770
In the original spec of the (inaudible) it said

663
00:42:40,770 --> 00:42:43,600
it should be
returning results in less than a second

664
00:42:43,600 --> 00:42:44,800
but were well over that.

665
00:42:59,080 --> 00:43:01,910
So I think we got
our one solution there from cog to cat,

666
00:43:03,680 --> 00:43:06,910
purely by chance
because cat comes first in the dictionary.

667
00:43:06,940 --> 00:43:09,910
What we're doing here
is basically a depth first search.

668
00:43:09,910 --> 00:43:12,080
OC: So the moment we hit that one neighbour,

669
00:43:12,080 --> 00:43:13,370
we go as far away  as we can

670
00:43:13,370 --> 00:43:15,400
to try and get all the way to cat which is

671
00:43:15,420 --> 00:43:17,770
not really the most efficient use of our time.

672
00:43:17,770 --> 00:43:21,140
We're going to need to
change this from a depth first solution

673
00:43:21,140 --> 00:43:22,650
to a breadth first solution.

674
00:43:23,080 --> 00:43:25,910
What we're going to do
is go over each of the neighbours

675
00:43:25,910 --> 00:43:28,450
and try to expand
that word chain of the neighbour

676
00:43:28,450 --> 00:43:29,310
to go one bigger,

677
00:43:29,370 --> 00:43:31,620
and hopefully we will eventually end at B.

678
00:43:32,510 --> 00:43:34,620
B is certainly in the dictionary itself,

679
00:43:35,450 --> 00:43:38,280
in which case we've finished our breadth first search.

680
00:43:38,280 --> 00:43:40,000
At least to get the shortest path

681
00:43:40,000 --> 00:43:42,420
SP: And since your removing the word each time

682
00:43:42,420 --> 00:43:44,420
eventually you won't be able to expand

683
00:43:44,420 --> 00:43:45,740
your search any further

684
00:43:46,140 --> 00:43:48,420
because you'll run out of neighbours.
OC, Yes.

685
00:43:48,420 --> 00:43:51,340
OC: So I'm going to
leave word puzzle alone for the moment

686
00:43:53,770 --> 00:43:55,740
Instead let's try and use some kind of

687
00:43:57,220 --> 00:43:58,110
expand function.

688
00:43:58,540 --> 00:44:01,200
So that's going to
take a word chain and give us back

689
00:44:02,220 --> 00:44:04,480
all possible expansions of the word chain,

690
00:44:04,480 --> 00:44:06,480
we need the dictionary there as well.

691
00:44:09,170 --> 00:44:10,770
I think that's what I want to do.

692
00:44:20,450 --> 00:44:22,820
We're going to
work from the head of the chain

693
00:44:22,820 --> 00:44:24,020
and try to expand that.

694
00:44:26,250 --> 00:44:28,600
There is
obviously the case where we've got

695
00:44:29,570 --> 00:44:31,020
no words at all in the chain.

696
00:44:31,020 --> 00:44:35,570
That's not really (inaudible) to have the code,

697
00:44:35,570 --> 00:44:39,740
in which case there's no expansions on that.

698
00:44:40,510 --> 00:44:42,880
Otherwise we have
a word on some other words

699
00:44:46,370 --> 00:44:48,880
and now by all
the neighbours in the dictionary

700
00:44:51,050 --> 00:44:53,510
W and put those
on the word chain we've got so far.

701
00:45:04,370 --> 00:45:06,650
So neighbours
gives us a list of words and

702
00:45:08,370 --> 00:45:10,280
that's already a list of word chains.

703
00:45:15,770 --> 00:45:18,370
Find the neighbours
of W but I need to use a  list

704
00:45:22,050 --> 00:45:24,050
(inaudible) there.

705
00:45:32,420 --> 00:45:36,340
I'm going to move away from the top there.

706
00:45:41,680 --> 00:45:44,770
SP: That's not a bad example
of a case for a miscomprehension.

707
00:45:46,510 --> 00:45:46,770
OC: OK.

708
00:45:49,340 --> 00:45:52,140
OC: Sure well let's
try another one of those conventions

709
00:45:52,220 --> 00:45:56,910
(inaudible) we need to go over there

710
00:45:56,910 --> 00:46:01,200
(inaudible) neighbours dict. W

711
00:46:08,370 --> 00:46:11,650
and we'll put that into (inaudible) N.

712
00:46:14,050 --> 00:46:16,510
Now I need to
produce a single word chain here,

713
00:46:18,620 --> 00:46:20,220
that will be NW dot something.

714
00:46:26,340 --> 00:46:27,940
Back to compiling again - good.

715
00:46:29,800 --> 00:46:31,970
I should be able to put the dictionary in...

716
00:46:39,370 --> 00:46:41,020
and expand and type that back up...

717
00:46:46,140 --> 00:46:49,050
word chains,
so why don't I just start with the word cat.

718
00:46:50,620 --> 00:46:52,940
So that seems
to be doing what I would expect,

719
00:46:52,940 --> 00:46:54,770
the expansion is on the front, so now

720
00:46:55,740 --> 00:46:58,650
let's see if we can
feed this back in to our word puzzle.

721
00:47:01,620 --> 00:47:03,571
I think I'll leave this around for now.

722
00:47:09,880 --> 00:47:12,140
So we're going
to  start at word A and we need

723
00:47:12,140 --> 00:47:13,114
to reach word B.

724
00:47:15,200 --> 00:47:16,850
So we'll start with a word chain

725
00:47:18,680 --> 00:47:19,910
which is just the word A

726
00:47:20,740 --> 00:47:22,250
(inaudible)

727
00:47:22,280 --> 00:47:24,910
and expand that
to a list of possible word chains.

728
00:47:27,050 --> 00:47:28,850
Let's see what I need to do with that.

729
00:47:31,510 --> 00:47:33,370
Well that one actually works so far,

730
00:47:33,370 --> 00:47:35,800
but it's certainly
not going to be the solution.

731
00:47:35,800 --> 00:47:40,940
(inaudible)

732
00:47:47,880 --> 00:47:50,280
So that's just one
level breadth-first search.

733
00:47:51,420 --> 00:47:54,542
we need to go a bit further
than that to find something useful,

734
00:47:54,570 --> 00:47:56,910
so I think now
we just need to keep expanding

735
00:48:00,820 --> 00:48:03,170
until we have B at the front of the list.
SP: Yes.

736
00:48:11,110 --> 00:48:13,280
OC: We can probably use iterate to do that.

737
00:48:13,280 --> 00:48:15,970
SP: Or until you don't
have any further expansions.

738
00:48:15,970 --> 00:48:18,170
OC: Ah ! that's one
thing we've not done so far

739
00:48:19,170 --> 00:48:20,740
yes, reducing this dictionary.

740
00:48:26,340 --> 00:48:27,650
Where would I put that in?

741
00:48:27,650 --> 00:48:30,570
so after one expansion,
this is probably returning me

742
00:48:33,170 --> 00:48:34,770
a smaller dictionary as well.

743
00:48:36,020 --> 00:48:39,220
When I expand a word chain
the dictionary becomes smaller.

744
00:48:45,480 --> 00:48:46,940
SP: That would be reasonable.

745
00:48:46,940 --> 00:48:48,650
OC: let's see what we get with that...

746
00:48:52,650 --> 00:48:54,420
so word chain and the dictionary.

747
00:49:00,620 --> 00:49:03,940
SP: The alternative is
that you keep the dictionary the same

748
00:49:04,250 --> 00:49:06,510
each time, but you don't allow the addition

749
00:49:07,220 --> 00:49:09,450
into the chain of a word that's already in it.

750
00:49:11,310 --> 00:49:12,850
OC: Yes, but were
going to  keep

751
00:49:13,570 --> 00:49:15,770
searching through a word chain every time,

752
00:49:15,770 --> 00:49:18,400
it feels like
we just make the dictionary smaller

753
00:49:18,420 --> 00:49:20,910
then our neighbours gradually become smaller.

754
00:49:21,000 --> 00:49:23,910
so we return the possible
list of word chains as before.

755
00:49:27,940 --> 00:49:30,050
Now I'm thinking
it would be nice if we had

756
00:49:30,050 --> 00:49:32,400
a bridger (inaudible) type for our dictionary.

757
00:49:32,650 --> 00:49:34,970
Like a set
or something like that, so I can  do a

758
00:49:34,970 --> 00:49:37,880
set difference and easily
remove a set of words from it.

759
00:49:39,280 --> 00:49:39,600
SP: Yes

760
00:49:40,420 --> 00:49:42,457
OC: That's going to be a bit of a
back jump

761
00:49:42,485 --> 00:49:44,285
but I think it's going to be worth it

762
00:49:45,200 --> 00:49:47,770
so I'm going to import
the Data.Set library as well

763
00:49:54,085 --> 00:49:56,714
and that also works best
when you import qualified.

764
00:50:00,000 --> 00:50:02,910
We need to depend on
the containment library for that.

765
00:50:06,400 --> 00:50:08,510
And to get that I need to put that in there.

766
00:50:11,110 --> 00:50:13,400
Actually  it looks as if we already have that.

767
00:50:17,200 --> 00:50:18,885
Bit of a misnomer there I reckon.

768
00:50:21,200 --> 00:50:24,570
So now that we've got
set imported maybe we can make this like so.

769
00:50:28,220 --> 00:50:30,110
So rather than having a list of text,

770
00:50:30,110 --> 00:50:31,310
let's go with A set text,

771
00:50:32,970 --> 00:50:35,740
and we'll just ask
the compiler to tell us everything

772
00:50:35,740 --> 00:50:37,540
we need to update to change.
SP: Yes

773
00:50:40,450 --> 00:50:42,820
Well, first thing we
need to do is return a set

774
00:50:42,820 --> 00:50:44,770
rather than a list: that's easy enough,

775
00:50:44,770 --> 00:50:46,314
we can just say S.list

776
00:50:48,680 --> 00:50:50,820
which takes a list and turns it into a set.

777
00:50:51,510 --> 00:50:54,000
Next, rather than checking a list to see if (inaud)

778
00:50:57,420 --> 00:50:59,857
use S.member, which checks to see if an element

779
00:51:03,050 --> 00:51:04,050
is a member of a set.

780
00:51:06,140 --> 00:51:07,600
(inaudible) the same here. ......

781
00:51:17,280 --> 00:51:18,880
That has put a hole back there.

782
00:51:25,820 --> 00:51:27,680
That should probably just return.

783
00:51:34,540 --> 00:51:35,050
.....like that .....

784
00:51:41,280 --> 00:51:45,050
The filter is for lists but we
have a set so we ask S.filter to filter a set.

785
00:51:55,970 --> 00:51:57,770
I'll check the type of that in there.

786
00:52:05,370 --> 00:52:07,742
OK, I've some idea
of where that error came up.

787
00:52:10,540 --> 00:52:12,480
Ah yes,  we can't map over a set like that.

788
00:52:17,480 --> 00:52:20,570
Do we have that.. yes we do ...
so we just change that to S.dot map

789
00:52:24,220 --> 00:52:29,510
(inaudible)

790
00:52:29,510 --> 00:52:31,880
Now this is not going to give us a list of text,

791
00:52:31,940 --> 00:52:33,620
it's going to give us a set of text.

792
00:52:39,885 --> 00:52:42,514
SP: There are built in facilities like traversible.

793
00:52:46,910 --> 00:52:49,510
Does that help with
this sort of code where you

794
00:52:49,510 --> 00:52:51,400
change from one data type to another?

795
00:52:53,400 --> 00:52:55,710
There are some gereralised forms of some of

796
00:52:55,710 --> 00:52:57,200
these functions arn't there.

797
00:52:57,540 --> 00:52:59,850
OC: Right. We can't generalise map I dont think

798
00:53:00,620 --> 00:53:03,340
because this is a set and sets have the constraint

799
00:53:03,340 --> 00:53:05,850
that the things inside the set must be orderable.

800
00:53:05,850 --> 00:53:06,110
SP: Ok

801
00:53:06,110 --> 00:53:08,220
We can't map between our 3 types because

802
00:53:08,220 --> 00:53:10,820
we wouldn't necessarily map the same (inaudible)

803
00:53:10,850 --> 00:53:13,740
The filter - there's probably something in Data. Foldable

804
00:53:15,710 --> 00:53:17,910
that will probably let us filter the set.

805
00:53:17,910 --> 00:53:20,571
But I think I'm quite happy working with sets here.

806
00:53:23,000 --> 00:53:23,710
SP: That's fine.

807
00:53:23,710 --> 00:53:25,250
OC: I don't think generalising

808
00:53:25,250 --> 00:53:27,170
would give us much of a benefit here.

809
00:53:27,170 --> 00:53:30,228
SP: Why I was wondering
is because I like to use that myself.

810
00:53:33,142 --> 00:53:36,971
OC: Now we may not be able to
use the list comprehension anymore.

811
00:53:39,110 --> 00:53:41,370
what we could do
though is just go to a list.

812
00:53:44,770 --> 00:53:46,310
We could turn this into a list.

813
00:53:51,880 --> 00:53:53,970
And now were back to trying to solve this.

814
00:53:54,370 --> 00:53:56,450
To recap where
we were, we wanted to have

815
00:53:57,140 --> 00:53:59,140
the dictionary smaller and smaller

816
00:53:59,140 --> 00:54:01,400
we return the
word chain and now we need to

817
00:54:01,940 --> 00:54:04,600
return the dictionary
but without a set of words

818
00:54:06,370 --> 00:54:08,020
that we've already considered.

819
00:54:08,400 --> 00:54:11,800
I believe those are going
to be to the head of the list of chains

820
00:54:13,540 --> 00:54:16,970
that we just expanded
to so that will be all the neighbours again.

821
00:54:19,570 --> 00:54:23,050
Although maybe it's more
beneficial to bring more neighbours out

822
00:54:25,310 --> 00:54:26,310
as a set of binding.

823
00:54:27,820 --> 00:54:28,140
SP: Yes.

824
00:54:33,400 --> 00:54:36,770
So now we can take
the dictionary without any of the neighbours.

825
00:54:36,770 --> 00:54:39,020
I've got a slightly smaller dictionary now.

826
00:54:39,020 --> 00:54:40,420
And let's start type checks.

827
00:54:44,710 --> 00:54:47,050
We certainly want to call in expand and then

828
00:54:47,050 --> 00:54:48,057
we need to work out

829
00:54:48,057 --> 00:54:50,114
what were going to do with that result.

830
00:54:50,114 --> 00:54:52,571
We have to write
a function that's going to take

831
00:54:52,570 --> 00:54:54,457
a list of word chains, the dictionary,

832
00:54:54,457 --> 00:54:56,285
and eventually gets to a word chain.

833
00:54:59,280 --> 00:55:01,400
I think we'll end up using some functions

834
00:55:02,940 --> 00:55:04,770
that are already in prelude anyway

835
00:55:04,770 --> 00:55:06,910
but let's just follow the types manually.

836
00:55:06,910 --> 00:55:08,250
and see what we end up with.

837
00:55:08,620 --> 00:55:11,250
OC: (inaudible) some function (inaudible) that's going to take a chain

838
00:55:11,250 --> 00:55:14,450
and a new dictionary (inaudible) something

839
00:55:16,850 --> 00:55:18,250
and pull that there as well.

840
00:55:22,510 --> 00:55:25,370
Now we want to expand
every single one of these chains

841
00:55:26,080 --> 00:55:27,680
using the smaller dictionary.

842
00:55:28,770 --> 00:55:33,200
So do something with chain and chain is (inaud).

843
00:55:33,220 --> 00:55:35,800
These type holes are not going to help (inaudible)

844
00:55:35,800 --> 00:55:38,200
just have to
trust our intuition a bit more.

845
00:55:38,970 --> 00:55:40,740
but I should be able to map expand.

846
00:55:48,480 --> 00:55:50,370
I should bring this down a little bit.

847
00:55:54,680 --> 00:55:57,285
Expand takes
the dictionary in first position

848
00:55:57,370 --> 00:55:59,800
and word chain (inaudible) second

849
00:55:59,800 --> 00:56:01,680
so that's going to work quite nicely,

850
00:56:01,680 --> 00:56:02,850
Apart from (inaudible)

851
00:56:05,050 --> 00:56:06,480
so that was a list of chains.

852
00:56:16,000 --> 00:56:17,880
Going in the right direction there.

853
00:56:19,850 --> 00:56:22,450
We need to go from
a list of a list of word chains.

854
00:56:23,050 --> 00:56:25,000
to (inaudible) word chain

855
00:56:27,880 --> 00:56:29,050
So, expand every chain.

856
00:56:31,200 --> 00:56:33,310
I'm going to
have to call F on that again.

857
00:56:42,820 --> 00:56:45,600
So, I think we're
struggling to find a nice kind of way

858
00:56:45,620 --> 00:56:47,850
to repeatedly apply this expand function,

859
00:56:47,850 --> 00:56:49,400
and what comes to mind here is,

860
00:56:49,400 --> 00:56:52,220
it looks like an
unfold which is like the dual to fold,

861
00:56:52,220 --> 00:56:54,310
which a lot of people are familiar with.

862
00:56:54,310 --> 00:56:56,450
When you fold
you have a list and you keep

863
00:56:56,450 --> 00:56:58,340
reducing it into something smaller.

864
00:56:58,570 --> 00:57:01,850
Whereas in this case
we actually want to get something bigger.

865
00:57:01,850 --> 00:57:03,710
Which as unfolding until the point

866
00:57:03,710 --> 00:57:05,400
where we maybe can't go any bigger.

867
00:57:05,400 --> 00:57:07,850
So we have a
function in the Prelude to do that

868
00:57:09,620 --> 00:57:10,742
which is unfoldr.

869
00:57:13,800 --> 00:57:16,480
But that requires
for this function that we have

870
00:57:16,480 --> 00:57:18,880
something that returns maybe any value.
SP: OK

871
00:57:18,880 --> 00:57:20,940
OC: But this actually looks quite a lot

872
00:57:20,940 --> 00:57:22,600
like what we have in expand here.

873
00:57:22,940 --> 00:57:24,600
OC: But we don't have a maybe here,

874
00:57:24,940 --> 00:57:26,910
so the maybe represents the fact that

875
00:57:26,910 --> 00:57:28,600
you can't actually go any bigger,

876
00:57:28,710 --> 00:57:31,940
which is what we were
modeling here with this pattern match,

877
00:57:32,200 --> 00:57:35,450
where we simply said
we have an endless list of word chains,

878
00:57:35,450 --> 00:57:37,650
but that felt a bit weird, so maybe let's try

879
00:57:38,800 --> 00:57:40,170
bringing in a "maybe" there.

880
00:57:42,200 --> 00:57:43,740
SP: Maybe let's maybe (laughter)

881
00:57:45,540 --> 00:57:47,940
OC: Ok, so in this case
there's nothing we can do,

882
00:57:49,650 --> 00:57:50,820
so we just say nothing

883
00:57:51,310 --> 00:57:52,420
whereas in this case,

884
00:57:54,000 --> 00:57:56,020
we have just that result  of word chains.

885
00:57:57,140 --> 00:57:59,850
NARRATOR: We're going to speed through this section

886
00:57:59,850 --> 00:58:02,050
because Ollie and Steve found themselves

887
00:58:02,050 --> 00:58:03,280
deep into a Rabbit hole.

888
00:58:03,680 --> 00:58:05,250
They eventually backtracked

889
00:58:05,250 --> 00:58:06,800
on this idea of using unfoldr,

890
00:58:07,600 --> 00:58:09,370
so let's skip ahead to the section

891
00:58:09,420 --> 00:58:10,880
where they changed course.

892
00:58:14,740 --> 00:58:17,450
SP: You are typing faster than I can think.
(laughter)

893
00:58:18,370 --> 00:58:20,170
OC: Even though we're using unfold,

894
00:58:20,170 --> 00:58:22,710
which does feel
like the right thing to be using

895
00:58:23,450 --> 00:58:25,370
I think we're getting ourselves into

896
00:58:25,370 --> 00:58:27,910
a bit of a muddle here.
And one of the big culprits

897
00:58:27,910 --> 00:58:30,200
is what we're doing
in this expand function

898
00:58:30,250 --> 00:58:32,170
so I'm going to try and simplify that

899
00:58:32,170 --> 00:58:34,400
and see if a
nice solution comes out there.

900
00:58:35,000 --> 00:58:36,710
What I'm going to go with instead ..

901
00:58:36,820 --> 00:58:40,170
expands going to take
a single word chain and the dictionary

902
00:58:41,310 --> 00:58:43,250
and it's going to expand that to a list

903
00:58:44,200 --> 00:58:47,000
of possible word
chains and smaller dictionaries.

904
00:58:48,080 --> 00:58:48,340
SP:OK

905
00:58:48,540 --> 00:58:50,400
OC: So whenever I make one expansion,

906
00:58:50,400 --> 00:58:52,680
I consider all of the neighbours around the

907
00:58:52,680 --> 00:58:54,140
first word of the word chain.

908
00:58:54,140 --> 00:58:56,080
And for each of those new word chains,

909
00:58:56,080 --> 00:58:57,910
I'll have the neighbour at the front,

910
00:58:57,910 --> 00:58:59,680
and we're going to remove that word

911
00:58:59,680 --> 00:59:01,885
from the dictionary because we don't want

912
00:59:01,880 --> 00:59:03,171
to go back on ourselves.

913
00:59:03,514 --> 00:59:05,542
OC: So I have a word chain with nothing in

914
00:59:05,542 --> 00:59:07,000
but there's nothing I can do.

915
00:59:07,510 --> 00:59:10,310
We have to
(inaudible) but otherwise if we have a chain

916
00:59:12,200 --> 00:59:13,600
that starts with the word W,

917
00:59:14,820 --> 00:59:16,542
we have the dictionary and then

918
00:59:18,110 --> 00:59:20,220
we need to take
the neighbours around W

919
00:59:24,310 --> 00:59:26,200
which will equal N, and put that on the

920
00:59:26,200 --> 00:59:28,080
front of the chain, so N is going to be

921
00:59:29,080 --> 00:59:31,914
the neighbours using the
same dictionary around W.

922
00:59:37,540 --> 00:59:38,940
But we also need to return

923
00:59:38,940 --> 00:59:40,820
this slightly smaller dictionary.

924
00:59:43,740 --> 00:59:45,370
Tootle (inaudible) that up with......

925
00:59:48,280 --> 00:59:49,400
the same dictionary,........

926
00:59:52,540 --> 00:59:54,540
but  we'll delete N from the dictionary.

927
00:59:54,540 --> 00:59:55,000
SP: Right

928
00:59:55,170 --> 00:59:56,000
OC: Lets try that......

929
00:59:59,800 --> 01:00:01,400
get rid of our old definition.

930
01:00:02,400 --> 01:00:04,080
You can see this is very similar

931
01:00:04,080 --> 01:00:05,885
to what we had in pattern (inaud) one.

932
01:00:05,885 --> 01:00:07,828
OC: (inaudible) from there smaller one

933
01:00:12,910 --> 01:00:13,680
So ignore this ...........

934
01:00:15,510 --> 01:00:17,140
lets keep that (inaudible) there

935
01:00:22,050 --> 01:00:24,910
and that's expecting
a list of text from the other set

936
01:00:24,910 --> 01:00:25,510
(inaud) list

937
01:00:36,480 --> 01:00:37,280
we're back - good!

938
01:00:41,570 --> 01:00:43,740
So if we load
the dictionary in we should

939
01:00:49,000 --> 01:00:50,970
be able to use expand with (inaudible)

940
01:00:50,970 --> 01:00:52,080
one expansion of cat.

941
01:00:54,340 --> 01:00:55,710
So what we're doing here is

942
01:00:55,710 --> 01:00:58,085
we end up printing the out dictionary as well.

943
01:00:58,085 --> 01:01:00,114
SP: Yes. (inaudible)

944
01:01:00,140 --> 01:01:01,280
OC: Map first over that,

945
01:01:06,480 --> 01:01:08,600
and we see just the one level expansion.

946
01:01:08,600 --> 01:01:09,485
(inaudible)

947
01:01:11,771 --> 01:01:13,971
So we're going
to repeatedly apply this

948
01:01:13,971 --> 01:01:15,542
but we'll keep the small chains.

949
01:01:15,542 --> 01:01:17,850
Then we will have the
bigger chains on the end.

950
01:01:17,850 --> 01:01:20,000
So that's giving us a flattening of a tree

951
01:01:20,000 --> 01:01:22,020
of a breadth-first search. Which I think

952
01:01:22,020 --> 01:01:24,620
is going to be better
than the depth first search

953
01:01:24,620 --> 01:01:25,650
that we saw earlier.

954
01:01:28,110 --> 01:01:28,657
SP: Ok

955
01:01:30,680 --> 01:01:33,220
I'm going to do a little function up here called go.

956
01:01:37,740 --> 01:01:40,170
Go is going to
take a list of word word chains

957
01:01:44,170 --> 01:01:45,370
and the dictionaries.

958
01:01:46,480 --> 01:01:47,910
And this becomes apparent

959
01:01:47,910 --> 01:01:50,710
you can see how I'm
going to pull the cursor backwards

960
01:01:51,310 --> 01:01:53,910
And it's going to
give us back a list of word chains.

961
01:01:55,110 --> 01:01:57,310
and that's going to let us repeatedly apply

962
01:01:57,310 --> 01:01:58,250
that to ourselves

963
01:01:58,250 --> 01:02:00,770
OC: So if we have
nothing in the first (inaudible)

964
01:02:00,770 --> 01:02:03,220
There's nothing we
can do, we simply return that

965
01:02:03,800 --> 01:02:06,310
Otherwise we have
some chains so what we can do

966
01:02:08,050 --> 01:02:11,110
SP: We have some
combinations of chains and dictionaries.

967
01:02:11,110 --> 01:02:13,650
OC: Yes, but for every word chain in the dictionary

968
01:02:13,650 --> 01:02:15,400
we want to expand that word chain

969
01:02:15,400 --> 01:02:16,740
using its own dictionary.

970
01:02:17,880 --> 01:02:19,450
So I'm going to map over chains,

971
01:02:20,940 --> 01:02:22,940
and what we'll have here is a word chain

972
01:02:22,940 --> 01:02:24,540
and the dictionary. We want to

973
01:02:25,050 --> 01:02:26,940
expand the chain in the dictionary.

974
01:02:28,050 --> 01:02:30,400
We're going to have
to concat on that because

975
01:02:30,400 --> 01:02:32,370
expand gives us a list of word chains.

976
01:02:34,820 --> 01:02:36,450
SP: Can you rename chains there ?

977
01:02:37,450 --> 01:02:38,400
OC: Sure (inaudible)

978
01:02:41,600 --> 01:02:43,428
or did you want to drop it entirely?

979
01:02:47,080 --> 01:02:49,250
We're not going to
be able to because we've

980
01:02:49,250 --> 01:02:50,710
pattern matched on one here.

981
01:02:50,710 --> 01:02:51,620
SP: Maybe in pairs

982
01:02:51,770 --> 01:02:53,450
OC: Ok, because of the dictionary.

983
01:03:11,680 --> 01:03:12,280
So that's ok ...

984
01:03:12,970 --> 01:03:15,140
but what we've
done now is, we've throw away

985
01:03:16,540 --> 01:03:17,740
these original chains

986
01:03:17,740 --> 01:03:19,800
we need to retain those as well.
SP: Right.

987
01:03:25,110 --> 01:03:26,370
OC: So we'll keep the pairs,

988
01:03:27,770 --> 01:03:30,000
and then add on
the expansions afterwards.

989
01:03:30,000 --> 01:03:30,340
SP: Yes.

990
01:03:30,650 --> 01:03:33,000
So for the smaller
chains that might already

991
01:03:33,020 --> 01:03:34,620
have finished, we'll keep those.

992
01:03:34,940 --> 01:03:37,510
SP: So then later
you would look at all the chains

993
01:03:37,510 --> 01:03:39,310
starting with the smallest first

994
01:03:42,510 --> 01:03:44,420
and try to select only the ones that

995
01:03:44,420 --> 01:03:46,250
finish on the target word.
OC: Right.

996
01:03:46,770 --> 01:03:49,570
OC: And because in
expand we're putting neighbours

997
01:03:50,450 --> 01:03:52,710
at the front of the list, were going to have to

998
01:03:52,710 --> 01:03:55,200
filter word chains that start with our target

999
01:03:55,710 --> 01:03:58,771
It's a bit weird but
obviously cons is a lot more efficient

1000
01:03:59,620 --> 01:04:01,420
to the (inaudible) because we don't

1001
01:04:01,420 --> 01:04:03,050
have to traverse the list at all.

1002
01:04:03,050 --> 01:04:05,000
SP: We can always reverse the solution.

1003
01:04:05,020 --> 01:04:05,650
OC: We can yes.

1004
01:04:08,880 --> 01:04:11,480
I'll just check that
that's all the compiling done.

1005
01:04:11,480 --> 01:04:13,820
We should be able
to have a play with this now.

1006
01:04:13,828 --> 01:04:15,571
(inaudible) GHCi

1007
01:04:15,828 --> 01:04:17,028
So we've got go so I'll try ....

1008
01:04:19,971 --> 01:04:22,050
to bring the dictionary back into scope.

1009
01:04:23,940 --> 01:04:25,914
Word chains plus words, so I'll try cat

1010
01:04:27,340 --> 01:04:29,571
and it needs
a dictionary in there as well.

1011
01:04:35,280 --> 01:04:37,080
And we'll start with just that one.

1012
01:04:37,170 --> 01:04:41,080
And that's going to expand forever (inaudible) go

1013
01:04:41,080 --> 01:04:42,370
SP: Ok.

1014
01:04:42,370 --> 01:04:43,820
OC: And take the head of that.

1015
01:04:44,850 --> 01:04:46,450
There's a lot of possibilities ...

1016
01:04:46,480 --> 01:04:47,910
because of the dictionary.

1017
01:04:52,340 --> 01:04:54,540
We'll just take the word chains out of that

1018
01:04:54,770 --> 01:04:59,050
(inaudible)

1019
01:05:09,020 --> 01:05:10,540
So every time we take one more

1020
01:05:10,540 --> 01:05:12,000
our chains get a bit longer

1021
01:05:12,000 --> 01:05:13,342
SP: Can you see the next one?

1022
01:05:15,020 --> 01:05:17,110
Oh ! that's because we've flattened it, yes.

1023
01:05:19,280 --> 01:05:22,540
SP: That's not the level
that's just the chains as they change.

1024
01:05:23,820 --> 01:05:24,140
OC: Yes

1025
01:05:24,140 --> 01:05:27,250
SP: (inaudible)

1026
01:05:30,680 --> 01:05:34,250
OC: So gradually they're
going to start getting bigger at some point

1027
01:05:35,250 --> 01:05:37,250
(inaudible)

1028
01:05:44,370 --> 01:05:45,457
That's not re cursing.

1029
01:05:46,680 --> 01:05:48,620
Actually go is never calling itself,

1030
01:05:49,080 --> 01:05:50,480
which is the problem here.

1031
01:05:50,680 --> 01:05:53,250
So were only ever
looking at one level expansion.

1032
01:05:54,050 --> 01:05:56,340
so if we take the original pairs and what we

1033
01:05:56,340 --> 01:05:58,400
need to do is go again on the concat map.

1034
01:06:02,880 --> 01:06:03,340
SP: Right

1035
01:06:03,340 --> 01:06:06,280
So we're going to
keep going to bigger and bigger chains.

1036
01:06:06,280 --> 01:06:08,340
But we're always putting these chains

1037
01:06:08,370 --> 01:06:09,480
on the end of the list.

1038
01:06:18,710 --> 01:06:20,828
So if we go back to taking 20 we should be

1039
01:06:20,828 --> 01:06:21,942
back to where we were

1040
01:06:23,400 --> 01:06:25,257
and as I take more, you can see we are

1041
01:06:26,770 --> 01:06:29,110
starting to get
bigger and bigger chains now.

1042
01:06:29,110 --> 01:06:31,020
SP: Right, and all of them ending on cat.

1043
01:06:31,600 --> 01:06:32,000
OC: Yes

1044
01:06:34,800 --> 01:06:36,680
SP: That's because that was our start.

1045
01:06:37,280 --> 01:06:38,820
OC: Yes, were going out from cat

1046
01:06:39,480 --> 01:06:43,000
SP: (inaudible)

1047
01:06:44,850 --> 01:06:47,940
OC: So now were ready
to put this back into the  word puzzle

1048
01:06:47,970 --> 01:06:49,850
to solve the puzzle properly .. again !

1049
01:06:52,880 --> 01:06:54,970
So we need to
call go and we're going to be

1050
01:06:56,050 --> 01:06:57,828
using the (inaudible) dictionary.

1051
01:06:58,050 --> 01:07:00,800
But were going
to have to delete our starting word

1052
01:07:00,800 --> 01:07:02,450
from the dictionary.
SP: Right

1053
01:07:03,420 --> 01:07:05,857
OC: Because we don't
want to go back to the start.

1054
01:07:05,857 --> 01:07:08,000
And we're going to
start with a word chain

1055
01:07:08,028 --> 01:07:09,314
that begins at the word A.

1056
01:07:11,200 --> 01:07:13,420
And this is going to give us all the chains

1057
01:07:13,420 --> 01:07:14,340
that start from A.

1058
01:07:14,340 --> 01:07:16,800
But we're interested
in chains that start at A

1059
01:07:16,828 --> 01:07:17,600
and finish at B.

1060
01:07:17,940 --> 01:07:19,650
So we filter the result of chains

1061
01:07:21,370 --> 01:07:22,680
by  taking ........ for each chain.

1062
01:07:26,080 --> 01:07:28,110
Sorry, first we should just throw away

1063
01:07:29,450 --> 01:07:30,710
the extra dictionaries.

1064
01:07:30,710 --> 01:07:33,420
SP: Because the two (inaudible) will come back from go.

1065
01:07:33,540 --> 01:07:35,570
OC: Yes, so it will give us two word chains

1066
01:07:35,570 --> 01:07:36,800
from the dictionaries,

1067
01:07:37,250 --> 01:07:39,685
whereas we're
only interested in word chains.

1068
01:07:39,685 --> 01:07:42,080
(inaudible)

1069
01:07:42,080 --> 01:07:43,857
Now we've got a list of word chains.

1070
01:07:44,080 --> 01:07:46,771
I can filter the list for ones whose first element

1071
01:07:48,820 --> 01:07:54,050
is equal to our target. (inaudible)
SP: Right

1072
01:07:54,050 --> 01:07:55,710
OC: And I think that's what we need

1073
01:07:56,910 --> 01:07:59,110
to solve the puzzle..so that all compiles

1074
01:08:04,370 --> 01:08:05,820
Put that dictionary back in

1075
01:08:05,820 --> 01:08:08,800
(inaudible) word puzzle using the dictionary

1076
01:08:08,800 --> 01:08:10,800
it will go from dog to cat.

1077
01:08:15,620 --> 01:08:17,420
And we are indeed getting result.

1078
01:08:19,000 --> 01:08:21,080
The interesting thing we're seeing here

1079
01:08:21,080 --> 01:08:23,142
is as it's gradually printing results,

1080
01:08:23,142 --> 01:08:25,220
we are seeing how Haskells' (inaudible)

1081
01:08:25,220 --> 01:08:27,050
evaluation works to our advantage.

1082
01:08:27,850 --> 01:08:30,340
So if I only wanted
to get the very first result,

1083
01:08:30,340 --> 01:08:33,020
I could simply
take the head of all the solutions

1084
01:08:33,020 --> 01:08:34,650
and the result is already done,

1085
01:08:34,650 --> 01:08:37,310
it didn't bother
computing all the extra values.

1086
01:08:37,420 --> 01:08:39,680
But if I needed the extra results, maybe if I

1087
01:08:39,680 --> 01:08:42,110
wanted to find
the first ten shortest chains

1088
01:08:43,220 --> 01:08:45,770
I could just take10
and that's going to give you

1089
01:08:45,770 --> 01:08:47,570
10 word chains and then terminate,

1090
01:08:48,970 --> 01:08:50,600
which is really nice.
SP: Right.

1091
01:08:52,600 --> 01:08:55,080
OC: I think that
solves the problem that we had

1092
01:08:57,370 --> 01:08:58,970
in the original problem spec.

1093
01:08:59,910 --> 01:09:01,650
SP: Shall we try it on longer input ?

1094
01:09:02,400 --> 01:09:04,200
How about the words Ruby and Code.

1095
01:09:05,800 --> 01:09:07,650
OC: Ok so I'll take the first of those.

1096
01:09:24,050 --> 01:09:25,910
It's certainly a lot slower but we do

1097
01:09:25,910 --> 01:09:27,280
get a word chain in the end.

1098
01:09:32,050 --> 01:09:34,600
So it might be worth trying to improve the forms

1099
01:09:34,620 --> 01:09:36,050
of this text (inaudible).

1100
01:09:36,050 --> 01:09:38,257
SP: Absolutely,
there are longer examples

1101
01:09:39,310 --> 01:09:40,770
such as from house to shout,

1102
01:09:42,110 --> 01:09:43,710
we could see if that completes

1103
01:09:43,710 --> 01:09:45,370
in a reasonable amount of time.

1104
01:09:45,880 --> 01:09:48,510
This one's quite
tricky because the search space

1105
01:09:48,880 --> 01:09:51,000
for it is quite large in the dictionary

1106
01:09:51,000 --> 01:09:51,970
that I've given you.

1107
01:09:53,650 --> 01:09:56,280
OC: This looks like
it's terminating any time soon.

1108
01:09:58,140 --> 01:10:00,370
SP: So maybe we
can have a look to determine

1109
01:10:02,170 --> 01:10:03,480
where the bottle neck is ?

1110
01:10:04,370 --> 01:10:06,370
OC: Yes, well I'm going to leave that one

1111
01:10:06,370 --> 01:10:09,310
running in the
background anyway, see if we get a result

1112
01:10:09,310 --> 01:10:11,310
while we start looking for some (inaudible).

1113
01:10:11,310 --> 01:10:13,200
To me, the biggest source of expense

1114
01:10:14,540 --> 01:10:16,540
feels like this neighbours function.

1115
01:10:17,450 --> 01:10:19,480
We're filtering twice and the map twice

1116
01:10:20,510 --> 01:10:22,280
and we are doing this repeatedly

1117
01:10:22,280 --> 01:10:23,800
every single time we expand.

1118
01:10:23,800 --> 01:10:26,000
And the set of
neighbours around a word

1119
01:10:27,020 --> 01:10:28,220
doesn't really change.

1120
01:10:28,228 --> 01:10:30,571
There may be
potential neighbours that we

1121
01:10:30,650 --> 01:10:33,620
can't consider because
we've already looked at them once.

1122
01:10:33,620 --> 01:10:35,370
and we would go back on ourselves.

1123
01:10:36,280 --> 01:10:39,540
But we can probably prune
the set of neighbours afterwards

1124
01:10:39,540 --> 01:10:42,050
I'm thinking maybe
we can have an optimisation

1125
01:10:42,050 --> 01:10:43,742
where we have a map of neighbours

1126
01:10:48,220 --> 01:10:51,114
It's going to be a map
from text to its set of neighbours.

1127
01:10:55,285 --> 01:10:56,485
And we should be able to

1128
01:10:56,485 --> 01:10:58,714
pre-compute this against the dictionary .

1129
01:10:59,340 --> 01:11:01,220
We're going to need the map data type

1130
01:11:01,850 --> 01:11:03,250
which comes from Data.Map,

1131
01:11:06,340 --> 01:11:08,620
again I'll be importing this from qualified.

1132
01:11:15,370 --> 01:11:17,250
Now we look up the list of neighbours.

1133
01:11:21,220 --> 01:11:23,420
We can still take the dictionary as input

1134
01:11:23,770 --> 01:11:26,080
but rather than just taking that, we can also

1135
01:11:26,450 --> 01:11:27,770
take in a neighbours map

1136
01:11:29,110 --> 01:11:30,310
and the word to look up

1137
01:11:30,310 --> 01:11:32,940
and it's going to
give us a set of neighbours again.

1138
01:11:32,940 --> 01:11:35,200
And the reason I'm taking that dictionary

1139
01:11:35,200 --> 01:11:37,400
is because we keep making that dictionary

1140
01:11:37,400 --> 01:11:39,480
smaller and smaller. We want to make sure

1141
01:11:39,480 --> 01:11:41,510
the neighbours we look up from this map

1142
01:11:41,510 --> 01:11:43,657
are actually in the dictionary because

1143
01:11:43,650 --> 01:11:45,600
we might have made the dictionary smaller

1144
01:11:45,600 --> 01:11:47,420
and removed possible names

1145
01:11:47,428 --> 01:11:49,200
so we're going to filter those out.

1146
01:11:49,228 --> 01:11:50,971
OK, so we've got, I'll call that M and W.

1147
01:11:52,510 --> 01:11:54,370
And this becomes straightforward,

1148
01:11:54,370 --> 01:12:01,080
we simply do a map look-up (inaudible)

1149
01:12:01,110 --> 01:12:04,020
which will throw up an error
if the word isn't in the map

1150
01:12:04,740 --> 01:12:07,314
but we'll have to
gloss over that for now I guess.

1151
01:12:08,420 --> 01:12:09,600
SP: yes,  (inaud) maybes'.

1152
01:12:10,200 --> 01:12:12,200
OC: If I was doing this production code

1153
01:12:12,200 --> 01:12:14,714
I would probably want
to keep the maybes' and the

1154
01:12:14,710 --> 01:12:16,171
chance of possibly failing

1155
01:12:16,171 --> 01:12:17,680
and reflect that in the types

1156
01:12:17,685 --> 01:12:19,620
that would add up, but for our purposes

1157
01:12:19,910 --> 01:12:21,340
this should be sufficient.

1158
01:12:21,910 --> 01:12:23,400
So, this is saying in the map M

1159
01:12:25,400 --> 01:12:26,310
look up the word W.

1160
01:12:28,770 --> 01:12:30,510
We need to take the intersection

1161
01:12:31,280 --> 01:12:33,080
of the set of possible neighbours.

1162
01:12:37,170 --> 01:12:38,620
We take the set into section

1163
01:12:40,200 --> 01:12:42,114
SP: Is it (inaudible), ?
I can't remember.

1164
01:12:43,540 --> 01:12:46,571
OC: From map I believe
it's just a single exclamation mark,

1165
01:12:46,742 --> 01:12:49,140
whereas for lists it's two exclamation marks.

1166
01:12:55,850 --> 01:12:58,020
So we don't seem to have any compile errors

1167
01:12:58,020 --> 01:12:59,850
around this neighbours function.

1168
01:13:00,680 --> 01:13:02,250
That's quite straightforward.

1169
01:13:02,250 --> 01:13:04,570
We also need a
way to pre-compute neighbours.

1170
01:13:06,880 --> 01:13:09,680
So that takes the
dictionary and turns it into a map,

1171
01:13:12,770 --> 01:13:15,540
SP: So here your
starting from saying; from right down

1172
01:13:15,540 --> 01:13:17,620
in the lowest level of this computation

1173
01:13:17,620 --> 01:13:20,800
you would like to have
that extra information available

1174
01:13:21,280 --> 01:13:24,050
in a neighbour map.
and you're working your way back up

1175
01:13:24,680 --> 01:13:27,340
to the (inaudible) levels to see

1176
01:13:27,340 --> 01:13:29,340
how to pass that down into it.

1177
01:13:32,000 --> 01:13:34,050
OC: Yes.  We've got a neighbours function.

1178
01:13:34,050 --> 01:13:36,310
I would like to be able to test that in GHCi

1179
01:13:36,310 --> 01:13:38,857
but we don't have
a way to build a neighbour map yet.

1180
01:13:38,857 --> 01:13:40,600
So I'm going to work on this (inaudible)

1181
01:13:40,628 --> 01:13:42,710
neighbours function then I can (inaud)

1182
01:13:43,400 --> 01:13:44,850
GCHi so I can actually see if

1183
01:13:44,850 --> 01:13:46,740
the neighbour map seems to be working

1184
01:13:46,740 --> 01:13:47,710
as we would expect.

1185
01:13:47,710 --> 01:13:50,714
Then we can work
through the rest of the compile errors

1186
01:13:50,714 --> 01:13:54,371
(inaud).  That's what we do.

1187
01:13:55,540 --> 01:13:58,140
So this looks like
it should be straightforward,

1188
01:13:58,170 --> 01:14:00,940
we just take
our dictionary, which is a set of words,

1189
01:14:02,280 --> 01:14:03,370
so if we go set to list.

1190
01:14:05,080 --> 01:14:07,340
and  for every word
in here we can map over .....

1191
01:14:12,200 --> 01:14:14,820
Ah ! We did need our
original neighbours function

1192
01:14:14,850 --> 01:14:16,340
which I have thrown away now

1193
01:14:16,970 --> 01:14:18,370
because we want to use that.

1194
01:14:19,740 --> 01:14:21,620
OC: So let's see if I can go back to that.

1195
01:14:26,450 --> 01:14:27,510
So I'll call this one ............

1196
01:14:30,570 --> 01:14:31,620
neighboursLookup

1197
01:14:37,620 --> 01:14:39,080
and this is back to how it was.

1198
01:14:53,080 --> 01:14:56,080
SP: We could also call this
neighbours and could the old

1199
01:14:56,080 --> 01:14:58,970
neighbours function
simply be a function returning

1200
01:15:01,370 --> 01:15:04,220
a list of the words
with the neighbours and distances?

1201
01:15:05,140 --> 01:15:06,880
OC: In the neighbours function or ....

1202
01:15:08,050 --> 01:15:09,940
SP: Yes, so you could - at this level here

1203
01:15:12,620 --> 01:15:14,650
where your returning W with distance,

1204
01:15:18,340 --> 01:15:21,485
in order to avoid having two similar (inaudible) functions.

1205
01:15:21,971 --> 01:15:23,342
Maybe we should continue ....

1206
01:15:23,342 --> 01:15:25,742
OC: It's probably worth renaming this though

1207
01:15:25,771 --> 01:15:27,371
because we want compile error,

1208
01:15:27,370 --> 01:15:29,828
well we're going to get compile errors anyway

1209
01:15:29,828 --> 01:15:31,371
because the types different.

1210
01:15:31,770 --> 01:15:34,428
I'm going to move this
into preview of neighbours

1211
01:15:38,000 --> 01:15:38,942
whatever I do ....

1212
01:15:39,428 --> 01:15:42,110
because we don't
have any reason to ever call this

1213
01:15:42,110 --> 01:15:43,770
other than inside string names.

1214
01:15:48,740 --> 01:15:50,450
SP: And you can rename the top one.

1215
01:15:50,457 --> 01:15:52,685
OC: Exactly,
The dictionary is going to be 

1216
01:15:54,457 --> 01:15:55,820
available up here anyway,

1217
01:16:01,000 --> 01:16:03,657
We need to turn our
dictionary into a list of words

1218
01:16:04,740 --> 01:16:06,480
move that neighbours over there.

1219
01:16:12,110 --> 01:16:14,940
So I need to pair
them up with the original word as well.

1220
01:16:17,770 --> 01:16:20,910
There's a fairly nice
function in the Control.Arrow module

1221
01:16:22,710 --> 01:16:25,510
which lets us run two
functions on the same argument.

1222
01:16:27,400 --> 01:16:29,080
I can say that it and neighbours

1223
01:16:29,770 --> 01:16:33,110
so that's the identity
function and the neighbours function

1224
01:16:33,114 --> 01:16:35,171
and it's going to Tootle (inaudible) those up for me.

1225
01:16:35,171 --> 01:16:35,680
SP: OK.

1226
01:16:37,400 --> 01:16:38,970
OC: I think I'll just import that ....

1227
01:16:42,480 --> 01:16:44,110
We've got a lot of compile errors.

1228
01:17:12,110 --> 01:17:14,680
We apparently need the word A as well. (inaudible)

1229
01:17:17,710 --> 01:17:28,200
(inaudible)

1230
01:17:31,480 --> 01:17:33,880
OC: So now we have
prelude neighbours but that's

1231
01:17:33,880 --> 01:17:36,050
not returning the neighbours from there.

1232
01:17:41,420 --> 01:17:44,050
We don't really need to (inaudible)

1233
01:17:44,050 --> 01:17:47,140
because were using that in neighbours

1234
01:17:48,910 --> 01:17:52,110
Now this is going to be a list of tootles (inaudible)

1235
01:17:52,110 --> 01:17:54,910
OC: We can turn that into a map. (inaud)

1236
01:17:58,140 --> 01:18:00,680
So we've turned our
dictionary into a list of text

1237
01:18:00,680 --> 01:18:02,910
and for every text and for every text value

1238
01:18:02,910 --> 01:18:04,970
turned that into the text word itself

1239
01:18:06,000 --> 01:18:07,400
and its set of neighbours.

1240
01:18:08,000 --> 01:18:10,680
SP: And each word will
be distinct so you don't need

1241
01:18:10,970 --> 01:18:12,740
to worry about combining entries.

1242
01:18:13,850 --> 01:18:14,480
OC: Right, yes

1243
01:18:17,600 --> 01:18:19,310
OC: Let's see what we get from that.

1244
01:18:23,370 --> 01:18:25,800
Neighbours is
going to be neighbours look up

1245
01:18:28,080 --> 01:18:31,171
so that's ... well, yes
let's keep it as neighboursLookup

1246
01:18:38,220 --> 01:18:41,280
OC: I'm just checking to
see if that's the only compile error

1247
01:18:41,280 --> 01:18:42,942
we've got, and it looks like it is,

1248
01:18:42,942 --> 01:18:44,800
so we've just got two arrows up here.

1249
01:18:46,370 --> 01:18:49,340
That means expand
rather than just take the dictionary

1250
01:18:49,340 --> 01:18:50,742
it also need to take a nMap.

1251
01:19:02,220 --> 01:19:04,340
The order here is dictionary, nMap

1252
01:19:10,250 --> 01:19:11,650
I just had a thought there,

1253
01:19:11,650 --> 01:19:15,000
because we're always
passing these two things together maybe

1254
01:19:15,000 --> 01:19:16,450
I should be combining these.

1255
01:19:16,450 --> 01:19:18,142
SP: I was having the same thought.

1256
01:19:18,228 --> 01:19:20,220
OC: So I think maybe our neighbour map

1257
01:19:20,220 --> 01:19:23,310
could be a data type
containing the full pre-computed map,

1258
01:19:24,510 --> 01:19:26,020
but also a set of exclusions.

1259
01:19:26,820 --> 01:19:29,510
And every time we
need to drop something out of the

1260
01:19:29,510 --> 01:19:32,110
neighbour map
we can do that quite efficiently.

1261
01:19:33,250 --> 01:19:33,710
SP: Right.

1262
01:19:33,710 --> 01:19:36,000
OC: Or we maybe (inaud) but we'll see

1263
01:19:36,000 --> 01:19:37,420
I'll come back to that later,

1264
01:19:37,600 --> 01:19:39,770
but it certainly does feel suspect so far.

1265
01:19:42,420 --> 01:19:44,850
So I think I better
put this the right way round

1266
01:19:46,480 --> 01:19:48,080
...dictionary and neighbour map

1267
01:19:50,080 --> 01:19:52,200
This is the dictionary and neighbour map

1268
01:19:59,740 --> 01:20:02,340
and now expand
needs that neighbour map as well.

1269
01:20:05,000 --> 01:20:07,880
But interestingly,
this doesn't have to be added to go.

1270
01:20:07,880 --> 01:20:10,371
Because the neighbour map doesn't ever change 

1271
01:20:11,257 --> 01:20:13,771
from what we've got so far. So that's just a constant. (inaudible)

1272
01:20:19,742 --> 01:20:22,600
SP: (inaudible)the first one.

1273
01:20:22,600 --> 01:20:23,250
OC: Yes it did.

1274
01:20:28,280 --> 01:20:30,314
And, we need to call that recurser map (inaudible

1275
01:20:36,200 --> 01:20:38,020
and you can use pass in here as well.

1276
01:20:38,600 --> 01:20:43,200
So here (inaudible)

1277
01:20:58,970 --> 01:21:01,800
So now our word puzzle
should be using this preview as

1278
01:21:01,820 --> 01:21:03,200
neighbours map.
SP: Right.

1279
01:21:03,820 --> 01:21:06,280
And were using
our more efficient neighbours

1280
01:21:06,280 --> 01:21:07,880
look-up function. So hopefully

1281
01:21:07,880 --> 01:21:09,510
we are going to see some results.

1282
01:21:10,450 --> 01:21:13,600
Impressively its still
trying to find solutions between

1283
01:21:13,600 --> 01:21:15,220
house and shout, on the old code.

1284
01:21:16,250 --> 01:21:18,020
So let's see what we get out of this.

1285
01:21:20,850 --> 01:21:23,220
We didn't really
look at seeing a pre-compute

1286
01:21:24,540 --> 01:21:27,600
preview of neighbours,
so let's have a quick look at that.

1287
01:21:35,310 --> 01:21:40,940
OK, so (inaud) type checks.

1288
01:21:44,628 --> 01:21:46,800
Let's bind that to it, something like that.

1289
01:21:47,428 --> 01:21:48,142
We can do nMap ....

1290
01:21:54,340 --> 01:21:55,942
SP: Jellow and hells. (laughter)

1291
01:21:56,914 --> 01:21:59,428
OC: So bringing in
neighbours does seem to be working.

1292
01:21:59,428 --> 01:22:01,510
We seem to be getting some actual neighbours,

1293
01:22:01,514 --> 01:22:04,857
so let's see what happens
with the others, let's do ruby code then.

1294
01:22:08,942 --> 01:22:11,628
It doesn't seem to
be a huge amount more efficient

1295
01:22:14,428 --> 01:22:17,142
But maybe we'll
actually get a result from this now

1296
01:22:24,400 --> 01:22:26,114
We've still got a little bit to go.

1297
01:22:30,000 --> 01:22:32,657
SP: Does it take long
to re-compute the entire map ?

1298
01:22:33,000 --> 01:22:34,914
can you force that computation on c. ?

1299
01:22:36,400 --> 01:22:38,857
OC: We can try
forcing that and see what happens.

1300
01:22:40,110 --> 01:22:42,942
SP: So of course here
your going to be pre-computing the

1301
01:22:45,600 --> 01:22:48,680
neighbours across
the full dictionary, not necessarily

1302
01:22:48,680 --> 01:22:51,914
the dictionary
pruned down to only the the words (inaudible)

1303
01:22:52,880 --> 01:22:55,200
OC: Yes that's probably worth doing already.

1304
01:22:57,140 --> 01:22:59,857
Rather than ridding
the dictionary of everything.

1305
01:23:01,080 --> 01:23:03,457
We're using a
lazy map here which means that

1306
01:23:04,250 --> 01:23:07,342
we'll get a map back
that contains all of the words as keys,

1307
01:23:09,340 --> 01:23:12,480
but the values underneath
that map won't be fully evaluated.

1308
01:23:12,480 --> 01:23:14,940
So it's only when we
look up those keys in the map

1309
01:23:14,940 --> 01:23:16,257
that we will do that work.

1310
01:23:17,110 --> 01:23:19,742
So hopefully
having the full dictionary in there

1311
01:23:19,742 --> 01:23:21,200
doesn't make any difference.

1312
01:23:21,710 --> 01:23:24,485
But I think for clarity
that's slightly nicer if we

1313
01:23:25,000 --> 01:23:27,085
just say filter, length, equal to length

1314
01:23:36,514 --> 01:23:38,885
SP: Of course, this way your run length across....

1315
01:23:40,257 --> 01:23:42,228
is it hundreds of thousands of words ?

1316
01:23:42,570 --> 01:23:42,914
OC: Yes.

1317
01:23:44,570 --> 01:23:45,600
SP: So its a tradeoff.

1318
01:24:06,542 --> 01:24:07,771
OC. So we take the length.......

1319
01:24:11,940 --> 01:24:14,457
I think that's
because we have text values here.

1320
01:24:16,220 --> 01:24:19,285
We've already seen
this type of function before anyway.

1321
01:24:21,740 --> 01:24:25,171
So (inaudible) here.
Maybe we could do something about that.

1322
01:24:29,020 --> 01:24:31,850
The maybe neighbours
doesn't have to worry about that,

1323
01:24:31,850 --> 01:24:33,314
we've already done that once.

1324
01:24:33,850 --> 01:24:36,280
I think I'll just
leave that for now, see if that

1325
01:24:36,280 --> 01:24:37,457
has made a difference.

1326
01:24:44,770 --> 01:24:46,742
It seems a bit saggy doesn't it?
SP: Yes

1327
01:24:49,771 --> 01:24:51,280
SP:: So the acid test. (laughter)

1328
01:24:55,970 --> 01:24:58,571
There's still no
results between house and shout.

1329
01:25:03,800 --> 01:25:05,942
SP: So that's great, we've reached a point now

1330
01:25:05,942 --> 01:25:08,542
were we're able to
find chains quite efficiently,

1331
01:25:08,571 --> 01:25:11,142
Not just from cat to dog
but also from rude to code.

1332
01:25:15,371 --> 01:25:17,885
SP: Where do you
think you would go next with this ?

1333
01:25:19,940 --> 01:25:23,457
OC: One thing that's always (inaud) quite a bit is

1334
01:25:24,280 --> 01:25:26,028
in go we are using  foss boss (inaud)

1335
01:25:27,828 --> 01:25:30,400
which means that
because were always having to

1336
01:25:30,400 --> 01:25:32,085
put things on the end of the list.

1337
01:25:32,085 --> 01:25:34,914
we're always have to
walk through the start of the list

1338
01:25:34,914 --> 01:25:37,857
to get to the end.
And we're having to do that repeatedly.

1339
01:25:39,257 --> 01:25:41,857
There's a couple of
well known ways we can go about

1340
01:25:41,857 --> 01:25:43,314
optimising that at Haskell.

1341
01:25:43,314 --> 01:25:45,257
Difference lists are one possiblity.

1342
01:25:45,942 --> 01:25:48,571
Which means that
appending has much less of a cost

1343
01:25:50,020 --> 01:25:53,085
provided we don't
ever try to inspect the front early on

1344
01:25:53,085 --> 01:25:55,142
but we don't need to do that, we only need

1345
01:25:55,142 --> 01:25:58,485
to start inspecting
once we've built up this big computation

1346
01:25:58,480 --> 01:26:00,514
of all possible solutions, and then we can

1347
01:26:00,514 --> 01:26:02,480
start filtering things off the front.

1348
01:26:02,485 --> 01:26:05,371
So that could be
an interesting optimisation to see.

1349
01:26:05,371 --> 01:26:06,942
Maybe we'll be able to allocate

1350
01:26:06,942 --> 01:26:08,542
a bit less than the go function.

1351
01:26:08,542 --> 01:26:11,710
Beyond that I'd probably
want to look at the code profiling.

1352
01:26:11,714 --> 01:26:13,200
Try and work out (inaudible)

1353
01:26:13,800 --> 01:26:15,510
a little too frequently, and see

1354
01:26:15,510 --> 01:26:17,000
if we can do something there

1355
01:26:20,020 --> 01:26:22,740
Obvious strategies
and any graph search problem

1356
01:26:22,740 --> 01:26:24,000
would be memorisation.

1357
01:26:26,057 --> 01:26:28,085
Which works really nicely at Haskell.

1358
01:26:28,085 --> 01:26:29,885
That wouldn't be too hard to add in.

1359
01:26:29,885 --> 01:26:33,457
It's just a case of
working out exactly what needs to be optimised.

1360
01:26:34,000 --> 01:26:35,480
And a couple of other things.

1361
01:26:35,480 --> 01:26:37,480
Just in terms of the feel of this code,

1362
01:26:37,480 --> 01:26:38,740
that I'd want to clean up.

1363
01:26:38,740 --> 01:26:40,971
As I pointed out earlier, the neighbour map

1364
01:26:40,970 --> 01:26:43,885
always has to be
paired with the dictionary so forcing

1365
01:26:43,885 --> 01:26:46,685
the user to pass the
dictionary and the neighbour map

1366
01:26:46,685 --> 01:26:48,228
around felt a bit cumbersome.

1367
01:26:48,370 --> 01:26:51,880
It would be nice if
we could work out some sort of abstraction there.

1368
01:26:51,880 --> 01:26:55,000
A neighbour map
data type that has an operation like look - up

1369
01:26:55,000 --> 01:26:55,571
and remove ........

1370
01:26:57,000 --> 01:26:59,310
SP: Or the dictionary itself is more complex

1371
01:26:59,310 --> 01:27:02,650
and opaque structure
which can provide you with neighbours.

1372
01:27:02,650 --> 01:27:03,457
OC: Absolutely,

1373
01:27:04,650 --> 01:27:06,600
SP:  Because that's the only operation

1374
01:27:07,710 --> 01:27:09,828
we have on the (inaudible)

1375
01:27:09,820 --> 01:27:12,371
OC: Yes, it needs
efficient look up and efficient

1376
01:27:12,371 --> 01:27:14,400
removal of the things you've already seen.

1377
01:27:14,457 --> 01:27:17,028
Beyond that,
we don't have any other requirements.

1378
01:27:17,020 --> 01:27:19,085
I think were using a new (inaudible) set...

1379
01:27:23,171 --> 01:27:23,685
we did yes.

1380
01:27:24,114 --> 01:27:26,885
so the set does
have efficient look up and deletion.

1381
01:27:27,250 --> 01:27:29,285
But if we were able to combine that with

1382
01:27:31,714 --> 01:27:33,342
the pre-computed neighbour map

1383
01:27:33,620 --> 01:27:35,620
we would probably get a much nicer api.

1384
01:27:35,620 --> 01:27:37,400
SP: And having worked through this, 

1385
01:27:37,942 --> 01:27:41,400
the overall approach of using
lists to represent the word chains

1386
01:27:42,514 --> 01:27:43,914
and  expanding those lists.

1387
01:27:48,000 --> 01:27:50,085
Is that the approach you would use again ?

1388
01:27:50,657 --> 01:27:53,142
OC: I think, now that we've got more familiar with

1389
01:27:53,140 --> 01:27:54,485
the problem,and its clear

1390
01:27:54,480 --> 01:27:56,028
that it has this tree structure

1391
01:27:56,028 --> 01:27:57,800
when you do a breadth-first search.

1392
01:27:57,800 --> 01:28:00,257
It would have been
nice to make that explicit

1393
01:28:00,257 --> 01:28:01,542
in the types themselves.

1394
01:28:01,542 --> 01:28:03,910
So use some
sort of tree structure to represent

1395
01:28:03,910 --> 01:28:05,657
the branching out, because I think

1396
01:28:05,650 --> 01:28:07,771
a couple of times we've confused ourselves

1397
01:28:07,771 --> 01:28:10,400
with lists of lists of text,
when we actually wanted

1398
01:28:10,400 --> 01:28:12,142
a list of texts, and it was  unclear

1399
01:28:12,142 --> 01:28:13,657
how we actually got them from  

1400
01:28:13,657 --> 01:28:15,514
that nest of lists to a single list.

1401
01:28:15,685 --> 01:28:17,940
Was compact
the right version to be using

1402
01:28:17,940 --> 01:28:20,085
or have we
made a mistake somewhere else.

1403
01:28:20,085 --> 01:28:22,540
So we didn't really (inaudible) on the types there,

1404
01:28:22,540 --> 01:28:25,420
it would have  been nice
if we could have taken a bit more

1405
01:28:25,420 --> 01:28:27,110
advantage from the type system.

1406
01:28:27,110 --> 01:28:29,514
I think if I
were to do it again I would choose

1407
01:28:29,514 --> 01:28:31,280
a slightly better data structure

1408
01:28:32,028 --> 01:28:33,857
for word chains in the first place

1409
01:28:34,028 --> 01:28:36,420
SP: So there's a built in tree type,
isn't there?

1410
01:28:36,420 --> 01:28:38,740
OC: Yes, its not
one that I'm very familiar with.

1411
01:28:38,740 --> 01:28:41,200
It's in the same library
as data.set and data.map.

1412
01:28:42,910 --> 01:28:44,685
It doesn't have a hugh avi/api(inaud)

1413
01:28:46,400 --> 01:28:48,371
but it does avoid me (inaud) in terms of

1414
01:28:49,110 --> 01:28:50,857
just coming up with the data type.

1415
01:28:51,110 --> 01:28:54,050
And the other thing
that I might be interested in doing

1416
01:28:54,050 --> 01:28:56,057
there's a lot of hidden recursion here.

1417
01:28:57,000 --> 01:28:58,771
It's quite hard to follow this code,

1418
01:28:59,940 --> 01:29:01,710
it calls itself in different ways.

1419
01:29:02,914 --> 01:29:04,628
It's more of a (inaudible) Haskell

1420
01:29:06,828 --> 01:29:08,914
where you can
split that recursion out

1421
01:29:08,914 --> 01:29:10,280
and make it very explicit.

1422
01:29:10,280 --> 01:29:12,371
You have some
N functions that operate

1423
01:29:12,370 --> 01:29:14,114
on just one thing, and then you have

1424
01:29:14,114 --> 01:29:16,085
a recursion scheme you can apply to that.

1425
01:29:16,085 --> 01:29:18,828
And that might
come out with some slightly cleaner code,

1426
01:29:18,828 --> 01:29:21,314
but it's going to
take a lot more work to get that.

1427
01:29:23,200 --> 01:29:24,680
But I think maybe (inaudible)

1428
01:29:24,680 --> 01:29:26,371
could clear up a lot of this code.

1429
01:29:27,420 --> 01:29:29,857
SP: Right, that seems like a successful session.

1430
01:29:30,770 --> 01:29:32,457
OC: I think so - got there in the end.

1431
01:29:32,770 --> 01:29:33,485
SP: Yes, thanks.

1432
01:29:36,280 --> 01:29:36,542
OC: OK
