1
00:00:01,224 --> 00:00:02,976
NARRATOR: Welcome to Peer to Peer

2
00:00:02,976 --> 00:00:06,776
where you can hone your skills
by watching live coding videos.

3
00:00:07,904 --> 00:00:10,424
Our guest today is Paul Battley.

4
00:00:10,420 --> 00:00:12,120
Who is a veteran Ruby developer,

5
00:00:12,120 --> 00:00:15,824
who has worked with agencies,
startups and Government departments.

6
00:00:17,080 --> 00:00:21,248
Our host is Jamie White, and the
challenge that he has set for Paul is called

7
00:00:21,472 --> 00:00:24,128
Encoding Images As Quad Trees.

8
00:00:25,992 --> 00:00:30,384
Jamie White: OK, so how about
we start by reading the challenge?

9
00:00:30,720 --> 00:00:32,224
Paul Battley: OK, so...

10
00:00:32,272 --> 00:00:37,992
Write a program to convert a given binary
image into a quad tree and serialize it to disk.

11
00:00:38,248 --> 00:00:43,352
Write another program to take a
serialized quad tree and turn it back into an image.

12
00:00:43,460 --> 00:00:47,608
The quad tree for an image is generated
by splitting the image into four quadrants

13
00:00:47,608 --> 00:00:51,152
then successively splitting each
of these into further quadrants.

14
00:00:51,176 --> 00:00:55,952
When a quadrant consists of a single
color, it may be considered a terminal node.

15
00:00:57,400 --> 00:01:03,880
JW: I have provided this beautiful
binary image for you to work with.

16
00:01:03,880 --> 00:01:07,280
PB: Not quite the right time,
depending on when your watching this.

17
00:01:07,312 --> 00:01:10,656
JW: It's in a Windows 1Bit bitmap format.

18
00:01:10,650 --> 00:01:14,048
So, it's up to you how you make use of that.

19
00:01:14,128 --> 00:01:17,310
[New Chapter]

20
00:01:17,552 --> 00:01:22,950
PB: So the first thing we want
to do is pass the bitmap file.

21
00:01:22,950 --> 00:01:36,832
If I recall correctly, that's a bunch of
bytes, and huge bits of each byte is an image.

22
00:01:37,136 --> 00:01:42,176
I don't know which order it goes in so
I'm going to look it up on Wikipedia and find out.

23
00:01:42,170 --> 00:01:45,560
Inaudible.

24
00:01:45,976 --> 00:01:51,064
So I'll look up the BMP file format.

25
00:01:53,810 --> 00:01:58,728
Been through that, OK what
have I got... Pixel array inaudible.

26
00:01:58,790 --> 00:02:01,848
I hope it's not compressed. I guess we'll find out.

27
00:02:02,630 --> 00:02:06,640
If it is we can find some other way of processing it.

28
00:02:07,290 --> 00:02:13,112
1 bit pixel. Each bit is
indexed into a table of two colors.

29
00:02:14,450 --> 00:02:18,776
That's interesting, so inaudible
colors even though there's only two.

30
00:02:18,816 --> 00:02:21,904
We don't really need to...

31
00:02:21,900 --> 00:02:26,432
In our case it doesn't really
matter, as long as we're consistent.

32
00:02:27,368 --> 00:02:33,088
So... I suggest that we look
at the file to see how long it is.

33
00:02:33,080 --> 00:02:36,072
[Silence]

34
00:02:37,120 --> 00:02:42,048
Ls - L on whatever .bmp

35
00:02:43,800 --> 00:02:45,816
8256 bytes.

36
00:02:46,664 --> 00:02:49,888
And... do we know the size of it?

37
00:02:49,880 --> 00:02:53,768
We can find that out with identify.

38
00:02:56,336 --> 00:02:59,328
Inaudible.

39
00:02:59,560 --> 00:03:09,432
256 by 256 would be 64K except that
we're less 8 bits of a pixel... so 8 pixels.

40
00:03:09,712 --> 00:03:16,240
Sorry pixels per byte, so inaudible so 856 sounds just about right.

41
00:03:17,456 --> 00:03:19,128
So it's not compressed.

42
00:03:19,752 --> 00:03:27,744
And according to this, it's just
the end of the file so I can probably...

43
00:03:28,180 --> 00:03:31,512
ignore the header and just take the pixels.

44
00:03:31,720 --> 00:03:39,040
So I'm going to write a bit of
code that reads in this bitmap,

45
00:03:39,470 --> 00:03:45,072
and spits out the pixels as,
maybe hashes and spaces on screen.

46
00:03:45,070 --> 00:03:47,608
That should give us an idea of whether its working.

47
00:03:47,600 --> 00:03:51,000
Inaudible and a bit wierd, but we'll work it out.

48
00:03:51,696 --> 00:03:58,768
So I'm going to play around, and call this print-bmp.rb.

49
00:03:59,664 --> 00:04:06,192
And now I'm going to say something like...

50
00:04:06,440 --> 00:04:10,624
I can load it all into memory... bits = File.read.

51
00:04:10,620 --> 00:04:18,224
I could use ARGF here but I'm going to use
ARGV first because I want to specify the encoding.

52
00:04:18,680 --> 00:04:23,832
JW: So ARGF gives you the final pass
into the command rather than inaudible

53
00:04:27,180 --> 00:04:32,504
PB: Well it gives you both so you can either inaudible something or it will give you the first one.

54
00:04:33,000 --> 00:04:37,832
Its very handy but I'm not
sure how that would handle inaudible.

55
00:04:38,080 --> 00:04:41,176
I know that we need to be
able to handle the inaudible.

56
00:04:41,180 --> 00:04:45,144
ARGV, I think it's...

57
00:04:45,140 --> 00:04:48,032
Inaudible encoding...

58
00:04:48,030 --> 00:04:51,144
[Silence]

59
00:04:53,368 --> 00:04:56,728
ASCII 8 Bit,

60
00:04:57,480 --> 00:05:00,024
which is not ASCII actually but...

61
00:05:03,656 --> 00:05:06,008
Let's say that's byte.

62
00:05:07,888 --> 00:05:12,216
And then I can say "print how many bytes I have got".

63
00:05:13,984 --> 00:05:18,000
Which should be something like 256, if that works.

64
00:05:18,560 --> 00:05:22,808
So I'm going to split this screen.

65
00:05:22,800 --> 00:05:26,632
Actually, no I'll make a new inaudible.

66
00:05:30,250 --> 00:05:32,400
Quad trees...

67
00:05:32,808 --> 00:05:38,696
Now if I say Ruby and print
bnp and give it a style of bnp.

68
00:05:39,840 --> 00:05:42,016
Inaudible array to string.

69
00:05:42,856 --> 00:05:46,824
ARGV [They both talk at once]

70
00:05:51,152 --> 00:05:55,408
OK so I'm going to read inaudible, that seems right.

71
00:05:59,270 --> 00:06:01,456
I'm going to hard code the width and height.

72
00:06:01,470 --> 00:06:08,632
So I'm going to say width
equals 256 and height  equals 256

73
00:06:08,630 --> 00:06:16,832
And then I'm going to say
that image bytes is bytes from...

74
00:06:18,040 --> 00:06:27,432
Actually let's just say minus
width, width x height to the end.

75
00:06:29,752 --> 00:06:33,088
Then if I go... make that one image bytes

76
00:06:33,080 --> 00:06:36,712
[Silence]

77
00:06:36,712 --> 00:06:38,710
Put some space in there.

78
00:06:42,208 --> 00:06:46,760
I can run this at inaudible percent.

79
00:06:49,376 --> 00:06:50,968
Inaudible.

80
00:06:52,464 --> 00:06:56,000
And define the length nil nil class by 5.

81
00:06:56,056 --> 00:06:59,040
[Silence]

82
00:06:59,856 --> 00:07:02,008
That's interesting.

83
00:07:02,440 --> 00:07:04,872
Apparently image bytes is nil.

84
00:07:06,896 --> 00:07:09,624
Let's see if that's really true.

85
00:07:09,620 --> 00:07:12,584
[Silence]

86
00:07:14,528 --> 00:07:17,400
Yes, why is that nil?

87
00:07:17,832 --> 00:07:20,968
I know that bytes works.

88
00:07:20,960 --> 00:07:23,936
[Silence]

89
00:07:24,800 --> 00:07:26,128
Maybe it's confused by...

90
00:07:26,120 --> 00:07:30,528
JW: Is that all bytes are like a string?

91
00:07:30,520 --> 00:07:32,888
PB: Your right, exactly.

92
00:07:32,880 --> 00:07:35,896
[Silence]

93
00:07:36,880 --> 00:07:43,536
PB: So in that case, maybe I should
just unpack it into an array of bytes.

94
00:07:43,530 --> 00:07:46,552
[Silence]

95
00:07:50,936 --> 00:07:53,904
Inaudible again.

96
00:07:57,152 --> 00:07:59,720
JW: I rarely use the unpack method.

97
00:08:00,328 --> 00:08:02,504
That notation... what does it mean?

98
00:08:03,648 --> 00:08:12,880
PB: If I recall correctly, that C means that
each byte will be unpacked as its byte.

99
00:08:12,880 --> 00:08:17,920
So you will get an array of integers
that are the byte value of each character.

100
00:08:21,176 --> 00:08:25,464
[Paul thinks]

101
00:08:28,128 --> 00:08:34,240
Let's just try saying leave bytes
and just take 10 of them or something.

102
00:08:34,270 --> 00:08:39,152
In fact, I'm going to say take 10 and
see if I've got something sensible there.

103
00:08:39,176 --> 00:08:42,208
[Silence]

104
00:08:45,856 --> 00:08:49,272
Yes, that seems useful.

105
00:08:51,920 --> 00:08:56,880
In fact I could also say bytes dot...

106
00:08:58,296 --> 00:09:00,464
Yes, in fact...

107
00:09:02,976 --> 00:09:05,232
So I've got an array...

108
00:09:07,776 --> 00:09:11,088
Where is 256?  Ah, there is my problem, right there.

109
00:09:11,128 --> 00:09:15,784
The width is the number of bits.

110
00:09:16,000 --> 00:09:19,704
I want it to be the number of
characters, so it's width x height.

111
00:09:20,312 --> 00:09:29,344
And let's say bits per pixels... is that what it says?

112
00:09:32,976 --> 00:09:36,264
Hard code here, I think we know what 8 is.

113
00:09:36,720 --> 00:09:42,256
Width x height, this is all assuming
it's multiples of 8 and in this case it is.

114
00:09:45,016 --> 00:09:49,880
8192 that's the number I was
looking for, that's the power of 2.

115
00:09:50,768 --> 00:09:54,904
JW: Would you mind printing out the
difference between bytes.length and image bytes?

116
00:09:54,900 --> 00:09:56,280
Just to see how big the header is.

117
00:09:56,280 --> 00:09:58,368
PB: Yes, that's a good idea.

118
00:09:58,360 --> 00:10:03,624
So bytes.length minus image bytes.length.

119
00:10:03,620 --> 00:10:06,712
[Silence]

120
00:10:10,456 --> 00:10:12,544
64 bytes.

121
00:10:14,264 --> 00:10:18,008
That's good so let's see... inaudible.

122
00:10:18,848 --> 00:10:34,416
So in fact... I could say header - bytes.take 64
and then I could say image bytes.drop.

123
00:10:34,456 --> 00:10:38,232
I'm not sure if that's sensible though
because the header might change.

124
00:10:38,904 --> 00:10:47,392
So instead I'm going to say
header equals bytes.take... that much.

125
00:10:49,592 --> 00:10:53,408
So I've now got the image
the bytes and the header.

126
00:10:53,400 --> 00:10:55,104
Now let's try to draw the image

127
00:10:55,100 --> 00:10:57,176
So I'm going to say...

128
00:10:59,688 --> 00:11:01,512
(What's the best way to do this...?)

129
00:11:02,704 --> 00:11:14,424
Say height.times do - that can be Y
and width.times do and that can be our X.

130
00:11:14,464 --> 00:11:17,472
[Paul thinks]

131
00:11:20,056 --> 00:11:23,096
Then we should in fact...

132
00:11:26,112 --> 00:11:28,176
inaudible it's not going to do it.

133
00:11:28,170 --> 00:11:31,200
[Silence]

134
00:11:33,480 --> 00:11:40,016
So then our byte is going to be the image bytes.

135
00:11:41,040 --> 00:11:48,880
And the index of width over 8 x Y.

136
00:11:48,952 --> 00:11:51,832
[Silence]

137
00:11:52,650 --> 00:11:54,896
Plus X.

138
00:11:57,176 --> 00:12:04,696
And then we want 8.times do,
what shall we call this one - i.

139
00:12:05,848 --> 00:12:07,896
Inaudible

140
00:12:07,960 --> 00:12:12,152
So for each of these I'm going to say...

141
00:12:14,830 --> 00:12:21,216
I want to find the inaudible bit of it,
but I don't know which way round they are do I?

142
00:12:21,224 --> 00:12:23,176
JW: Ah, that's true.

143
00:12:23,170 --> 00:12:25,104
Inaudible

144
00:12:26,704 --> 00:12:29,792
PB: Maybe it will say in Wikipedia.

145
00:12:29,790 --> 00:12:32,896
[Silence]

146
00:12:36,808 --> 00:12:42,480
It's probably reasonable to assume
that the most significant ones on the left,

147
00:12:42,544 --> 00:12:45,400
Like numbers are.

148
00:12:48,408 --> 00:12:53,704
Yes, so if I start off with my, (a kind of ugly
way of doing it but it will work for now).

149
00:12:53,700 --> 00:12:58,816
If I start off with my bit mask, I want to be...

150
00:12:58,810 --> 00:13:01,808
[Silence]

151
00:13:02,720 --> 00:13:09,336
Yes, in fact this ought to work well,
so bitmask wants to be Ob1OOOOOOO.

152
00:13:09,656 --> 00:13:19,024
Then my bit is just bitmask white shifted by i.

153
00:13:19,248 --> 00:13:23,816
So that's going to be starting
from zero and then increasing.

154
00:13:24,140 --> 00:13:31,040
And I can take that and inaudible that with the byte.

155
00:13:33,176 --> 00:13:39,072
And then take the whole thing...

156
00:13:39,070 --> 00:13:42,112
[Paul thinks]

157
00:13:44,296 --> 00:13:51,864
And then right shift the whole thing by 8 bytes.

158
00:13:51,860 --> 00:13:56,128
So my first one will be a
right shift by nothing inaudible.

159
00:13:57,568 --> 00:14:02,136
Yes, so my first one will be right shifted
by 8, which means it's the least significant.

160
00:14:02,672 --> 00:14:04,920
It;s like program C isn't it? [Laughter]

161
00:14:04,920 --> 00:14:13,832
OK, so now I am just going to say print bit to S.

162
00:14:13,830 --> 00:14:16,856
[Paul thinks]

163
00:14:19,020 --> 00:14:29,568
Or maybe I'll do print bit equals 1 # space.

164
00:14:29,600 --> 00:14:31,392
That should be more readable.

165
00:14:31,390 --> 00:14:36,920
And then at the end of each row is a put

166
00:14:39,008 --> 00:14:42,448
Alright... we will see.

167
00:14:45,320 --> 00:14:47,592
Let's try this again.

168
00:14:47,590 --> 00:14:49,560
We got all zeros.

169
00:14:49,560 --> 00:14:55,664
JW: The features in the image are down towards
the bottom so presumably we didn't hit them yet.

170
00:14:55,680 --> 00:15:03,670
PB: That's true, it might be
worth shrinking the text size.

171
00:15:04,856 --> 00:15:07,496
No that's definitely all zeros.

172
00:15:08,168 --> 00:15:11,312
So have I got this right...

173
00:15:11,310 --> 00:15:14,320
[Paul thinks]

174
00:15:14,320 --> 00:15:18,040
JW: We could just try printing the bits to begin with.
PB: Yes.

175
00:15:18,040 --> 00:15:21,040
[Silence]

176
00:15:23,872 --> 00:15:26,672
There's the zeros.

177
00:15:26,670 --> 00:15:31,176
inaudible line banks which looks about right doesn't it?

178
00:15:31,170 --> 00:15:35,200
I'm not sure how many
characters I've got across actually but...

179
00:15:35,888 --> 00:15:38,920
1234567890

180
00:15:41,392 --> 00:15:46,040
Yes, it looks about right for the length
of the line. That seems inaudible.

181
00:15:48,880 --> 00:15:51,840
How about instead of this, I just print out the byte?
JW: Yes.

182
00:15:53,344 --> 00:15:59,912
So I'll skip that and just say print byte.to S

183
00:16:02,648 --> 00:16:05,376
That looks promising.

184
00:16:05,370 --> 00:16:13,376
Hey, I can kind of see the shape. In fact if
you squint maybe you can see the hands there.

185
00:16:13,384 --> 00:16:14,056
JW: Yes.

186
00:16:14,050 --> 00:16:20,296
PB: In fact if I did that to S16 inaudible and the same width.

187
00:16:20,290 --> 00:16:23,120
that should give us an even better indication of ...

188
00:16:24,680 --> 00:16:27,336
[laughter]

189
00:16:27,330 --> 00:16:31,016
The zero is still there but you get the idea.

190
00:16:31,010 --> 00:16:32,744
JW: There's an image in there somewhere.

191
00:16:33,010 --> 00:16:37,424
PB: Yes, we can see something inaud and long, which is...

192
00:16:37,456 --> 00:16:44,368
In fact, let's go back to that.

193
00:16:44,360 --> 00:16:49,312
Now this makes me wonder... it's upside down isn't it?

194
00:16:49,310 --> 00:16:51,368
JW: Oh yes...

195
00:16:51,360 --> 00:16:55,888
PB: I think inaud is the case with
bnp which is upside down.

196
00:16:56,408 --> 00:17:02,808
But that doesn't matter for us, as long as it says
our output is upside down, it should be fine.

197
00:17:04,360 --> 00:17:16,784
OK so bytes are OK, bitmask is OK, let's just get rid of...

198
00:17:16,780 --> 00:17:19,848
[Silence]

199
00:17:22,424 --> 00:17:26,288
We'll get rid of that entirely
and see what results we get.

200
00:17:26,280 --> 00:17:29,280
[Silence]

201
00:17:30,728 --> 00:17:35,008
OK that's a bunch of different things except...

202
00:17:35,000 --> 00:17:38,080
[Silence]

203
00:17:39,400 --> 00:17:43,080
Yes, I think that's right, the last row has...

204
00:17:45,672 --> 00:17:48,592
There's a lot of white space at
the top so we would expect...

205
00:17:49,368 --> 00:17:52,056
This also means our inaud as well.

206
00:17:53,792 --> 00:17:56,928
Again, as long as we're consistent that's fine.

207
00:17:59,816 --> 00:18:01,984
OK so...

208
00:18:04,480 --> 00:18:12,672
The easiest way of doing this then is
to just say if it's zero, zero acts as one

209
00:18:13,120 --> 00:18:14,832
Or rather...

210
00:18:14,830 --> 00:18:17,912
[Silence]

211
00:18:24,920 --> 00:18:33,944
Yes, I think that's modularly inaud shrink list. [Laughter]

212
00:18:33,968 --> 00:18:36,992
[Silence]

213
00:18:37,208 --> 00:18:39,424
JW: Awsome.

214
00:18:41,010 --> 00:18:48,320
So... we know that we can get
the bitmap in and in a format which,

215
00:18:48,328 --> 00:18:54,960
whilst it might not look exactly how we
want to see it - it seems to be flipped basically,

216
00:18:55,512 --> 00:19:01,088
for the purpose of taking an image and
processing it and exporting it again, that's fine.

217
00:19:03,064 --> 00:19:06,656
JW: Looks like a good time to commit.
PB Yes, I agree.

218
00:19:06,650 --> 00:19:09,696
[Silence]

219
00:19:11,312 --> 00:19:15,376
Don't know what I typed there... some junk... right.

220
00:19:15,370 --> 00:19:18,368
[Silence]

221
00:19:21,310 --> 00:19:27,752
That want's a simple BMP printer.

222
00:19:31,448 --> 00:19:41,768
OK, now that we've got rid of
that lot it would be nice to wrap this

223
00:19:42,136 --> 00:19:49,792
in a method that we give a
file and it gives us the bits.

224
00:19:49,790 --> 00:19:52,592
[Paul thinks]

225
00:19:52,616 --> 00:19:55,680
Yes, I think that would be good.

226
00:19:57,904 --> 00:20:02,056
If I had a bunch of small test images,
I would write some tests for this,

227
00:20:02,050 --> 00:20:09,744
but given the size of the image... I don't know how easily if I can make a bnp inaud

228
00:20:11,360 --> 00:20:16,664
inaud def read bmp.

229
00:20:17,760 --> 00:20:22,352
And inaud file object.

230
00:20:22,350 --> 00:20:25,696
[Silence]

231
00:20:27,072 --> 00:20:30,568
And... get it to take this stuff.

232
00:20:30,560 --> 00:20:33,568
[Silence]

233
00:20:34,664 --> 00:20:39,424
In fact I'm going to make a bnp file construct.

234
00:20:39,744 --> 00:20:44,304
In fact, I will put something in
class, I think that will be easier.

235
00:20:44,544 --> 00:20:46,008
Because it's got a header and other things,

236
00:20:46,000 --> 00:20:50,016
I think it's best to keep it all
together in the same class BMP which...

237
00:20:50,010 --> 00:20:53,096
[Silence]

238
00:20:55,104 --> 00:20:59,528
And I can say def initialize.

239
00:20:59,520 --> 00:21:02,520
[Silence]

240
00:21:02,520 --> 00:21:05,136
inaud file some kind.

241
00:21:07,696 --> 00:21:14,968
inaud, the interface below is going to be something like...

242
00:21:15,504 --> 00:21:19,424
BMPImage.new

243
00:21:20,152 --> 00:21:23,390
inaud first encoding.

244
00:21:25,432 --> 00:21:30,592
Something like that will give me the
power to inject a file that's alright for it.

245
00:21:31,480 --> 00:21:34,328
Nothing... should be able to say...

246
00:21:34,320 --> 00:21:37,352
[Silence]

247
00:21:37,656 --> 00:21:40,200
In fact, if I say that it will be file.open.

248
00:21:40,200 --> 00:21:43,224
[Silence]

249
00:21:44,820 --> 00:21:48,592
And I can say file.read.upack.

250
00:21:49,090 --> 00:21:54,952
So now I'm going to put this in initialize

251
00:21:55,112 --> 00:21:59,144
I might want to move it somewhere
else later but I think for now that will work.

252
00:21:59,140 --> 00:22:02,144
[Silence]

253
00:22:04,040 --> 00:22:07,048
inaud

254
00:22:07,040 --> 00:22:09,248
Then say pixels.

255
00:22:10,984 --> 00:22:13,056
And...

256
00:22:13,312 --> 00:22:16,824
In fact, let's have width and height as...

257
00:22:16,820 --> 00:22:19,808
[Silence]

258
00:22:28,056 --> 00:22:38,176
inaud height, while we're here I'm just
going to change width to width... yes yes yes.

259
00:22:38,928 --> 00:22:40,816
And do the same for height.

260
00:22:42,864 --> 00:22:48,376
Strange how my hands type a completely
different word as the one I was intending to.

261
00:22:48,800 --> 00:22:52,584
inaud

262
00:22:52,580 --> 00:22:55,640
[Silence]

263
00:23:00,816 --> 00:23:02,952
And this one...

264
00:23:04,880 --> 00:23:13,792
Width height pixels in there, inaudible and put this in a private method.

265
00:23:13,790 --> 00:23:16,744
[Silence]

266
00:23:16,912 --> 00:23:26,344
inaud and say private section and say def image bytes.

267
00:23:26,340 --> 00:23:29,392
[Silence]

268
00:23:29,390 --> 00:23:36,080
I will cache that and say image bytes inaudible.

269
00:23:36,600 --> 00:23:39,100
And I'm going to say def header,
and the reason I'm doing this

270
00:23:39,100 --> 00:23:43,672
is because I know we want to write one
out later, so it's helpful to keep the header.

271
00:23:43,712 --> 00:23:46,664
[Silence]

272
00:23:47,704 --> 00:23:51,136
Again I can say header...

273
00:23:52,808 --> 00:23:55,936
bytes.take... that's got to be at bytes.

274
00:23:58,208 --> 00:24:01,936
at bytes.length and inaud bytes.

275
00:24:04,192 --> 00:24:09,128
So we've inaud bytes, OK.

276
00:24:11,976 --> 00:24:19,928
Here we have image bytes available to us inaud moved up the top somewhere.

277
00:24:22,000 --> 00:24:25,208
Or can it. It doesn't mutate it does it inaud?

278
00:24:25,890 --> 00:24:28,856
[Silence]

279
00:24:31,050 --> 00:24:37,928
So at the moment pixels is still doing
that puts stuff, so for now I'm going to do

280
00:24:38,480 --> 00:24:41,510
dot pixels,and see if I get the same sensible result.

281
00:24:41,510 --> 00:24:44,608
[Silence]

282
00:24:48,144 --> 00:24:51,136
inaud because I haven't given it the width and the height.

283
00:24:51,130 --> 00:24:54,128
[Silence]

284
00:24:55,096 --> 00:24:59,872
inaud

285
00:25:01,720 --> 00:25:05,264
At a later stage, I could probably
work out where to find those in the header,

286
00:25:05,260 --> 00:25:11,976
and read them but that's not the
most interesting thing we can do today.

287
00:25:13,280 --> 00:25:15,800
OK, seems good.

288
00:25:16,056 --> 00:25:19,040
inaud yes, that seems good.

289
00:25:20,992 --> 00:25:21,952
OK...

290
00:25:21,992 --> 00:25:24,976
[Silence]

291
00:25:32,016 --> 00:25:36,568
I'll commit this before I change it slightly.

292
00:25:39,088 --> 00:25:43,848
Make a BMPImage class, this
is still a work in progress so...

293
00:25:44,088 --> 00:25:47,816
I think everything will be a
work in progress today actually.

294
00:25:48,360 --> 00:25:58,920
So now I want to make this return, in fact
what I think I want is an array of arrays of pixels.

295
00:25:59,400 --> 00:26:02,120
I think that's the most sensible thing to do.

296
00:26:02,120 --> 00:26:09,104
It might not be the most
helpful thing later on, but for now...

297
00:26:09,160 --> 00:26:11,100
Height I can map...

298
00:26:12,024 --> 00:26:16,680
because each of those inaud

299
00:26:16,680 --> 00:26:23,064
I would like to do the inaud style of functional things with the braces.

300
00:26:23,104 --> 00:26:24,570
Width over 8.

301
00:26:24,570 --> 00:26:29,816
Now this one... I need to do
something like a flat map I think.

302
00:26:30,320 --> 00:26:32,680
Flat_map with x.

303
00:26:32,680 --> 00:26:35,696
[Silence]

304
00:26:36,296 --> 00:26:41,048
And then byte, this will be 8.times.map.

305
00:26:41,040 --> 00:26:44,080
[Silence]

306
00:26:45,592 --> 00:26:51,896
JW: So with flat map the arrays returned by
the block will be concating together effectively?

307
00:26:52,080 --> 00:26:54,800
PB: Yes, I think I can demonstrate actually.

308
00:26:54,800 --> 00:26:59,968
It's the same as dot map and dot
flatten... I don't know how deep it goes.

309
00:27:00,416 --> 00:27:03,912
It inaud, but if I say...

310
00:27:03,910 --> 00:27:06,920
[Paul thinks]

311
00:27:06,920 --> 00:27:14,704
Yes, let's say... 1,2,3,4, something like that.

312
00:27:15,424 --> 00:27:21,360
If I did .map a.map

313
00:27:24,240 --> 00:27:27,672
That should give me inaud but...

314
00:27:27,670 --> 00:27:31,512
And then if I did .flatten... I would get that.

315
00:27:31,528 --> 00:27:36,320
And I think if I replace this one
with flat map, its the same as map.flatten.

316
00:27:36,840 --> 00:27:41,024
So you see map.flatten in there, which gives me the same inaud

317
00:27:43,640 --> 00:27:46,520
I don't know if it's any easier conceptually, but...

318
00:27:48,248 --> 00:27:54,400
I don't need that and I don't need that,
so I'm going to say bitmask and that gives me 0 or 1.

319
00:27:57,128 --> 00:27:59,296
And I should be able to say puts....

320
00:27:59,290 --> 00:28:02,288
[Paul thinks]

321
00:28:03,752 --> 00:28:06,680
Or P, actually that should be an array of...

322
00:28:09,040 --> 00:28:12,408
Yes, that should work... we'll see.

323
00:28:12,536 --> 00:28:14,776
I think if take...

324
00:28:14,800 --> 00:28:17,968
[Paul thinks]

325
00:28:18,704 --> 00:28:21,376
It might be quite wide on the screen but...

326
00:28:21,370 --> 00:28:24,384
[Silence]

327
00:28:28,496 --> 00:28:30,896
No, that's not quite right is it, or is it?

328
00:28:30,890 --> 00:28:34,408
JW: It might be that we just can't see because...

329
00:28:34,400 --> 00:28:36,920
You could put and join them with a new line.

330
00:28:36,920 --> 00:28:38,512
PB: Yes.

331
00:28:38,510 --> 00:28:41,520
[Silence]

332
00:28:46,208 --> 00:28:48,032
inaud

333
00:28:48,030 --> 00:28:51,072
[Silence]

334
00:28:53,224 --> 00:28:56,992
I'll split this up because it's
a bit long for this small screen.

335
00:28:57,712 --> 00:29:00,504
Image.pixels.each.

336
00:29:00,504 --> 00:29:02,500
Do row.

337
00:29:03,120 --> 00:29:07,000
Row.each.do pixel.

338
00:29:08,976 --> 00:29:12,576
I'm already thinking that inaud pixels was the wrong thing to do but

339
00:29:12,570 --> 00:29:15,368
we'll have to inaud or something.

340
00:29:15,368 --> 00:29:17,360
inaud

341
00:29:19,280 --> 00:29:21,072
So I might do that.

342
00:29:21,840 --> 00:29:24,632
Puts print.

343
00:29:25,624 --> 00:29:28,464
Pixel and then puts.

344
00:29:31,432 --> 00:29:33,992
Ideally this should give us the same thing.

345
00:29:35,144 --> 00:29:37,008
Yes.

346
00:29:38,660 --> 00:29:42,544
OK good, and I'm going to change
that to rows, because having used it,

347
00:29:42,576 --> 00:29:45,896
it feels like that's actually what I'm getting back.

348
00:29:45,890 --> 00:29:48,888
[Silence]

349
00:29:57,944 --> 00:29:59,888
I'm just going to run together just in case...

350
00:30:00,568 --> 00:30:02,848
Yes, tha's working.

351
00:30:03,896 --> 00:30:07,288
So I'll say that.

352
00:30:09,840 --> 00:30:13,296
inaud

353
00:30:15,768 --> 00:30:20,608
BMPImage returns rows... OK.

354
00:30:23,736 --> 00:30:28,560
I should probably have gone
hunting for a bitmap image but never mind.

355
00:30:29,112 --> 00:30:30,328
We can now move on.

356
00:30:30,320 --> 00:30:33,872
[New chapter]

357
00:30:33,992 --> 00:30:39,848
So now, what would be nice,
is to have some kind of object.

358
00:30:40,056 --> 00:30:44,832
which when given rows with some
item in them takes each of the quadrants.

359
00:30:44,830 --> 00:30:49,624
So inad writing that I think I can test quite
easily, so I'm going to start doing things that way.

360
00:30:49,620 --> 00:30:50,944
Perfect.

361
00:30:50,940 --> 00:30:52,968
So I now need to...

362
00:30:52,960 --> 00:30:55,920
I'm going to use rspec
because I like the rspec runner.

363
00:30:55,920 --> 00:31:04,944
So say vim Gemfile, source https.

364
00:31:05,376 --> 00:31:10,224
I always think this should be built in but it's not.

365
00:31:10,616 --> 00:31:14,512
And then gem rspec...
that should give me something sensible.

366
00:31:14,952 --> 00:31:16,784
And then I'll say bundle

367
00:31:16,780 --> 00:31:22,744
[Silence]

368
00:31:26,600 --> 00:31:28,784
Good.

369
00:31:30,472 --> 00:31:36,016
Now I'm going to make a spec to actually live.

370
00:31:37,296 --> 00:31:44,304
And I'll go back to here and say edit spec.

371
00:31:45,064 --> 00:31:51,272
I'm going to call it, what shall I call it? Quad node.

372
00:31:51,500 --> 00:31:55,176
That seems like a reasonable name
and makes sense to me at the moment.

373
00:31:55,230 --> 00:32:05,224
inaud, rspec rb and inaud

374
00:32:05,232 --> 00:32:08,384
Rspec.describe.

375
00:32:11,312 --> 00:32:14,376
Quadnode do.

376
00:32:16,824 --> 00:32:19,192
Is that right, somehow I feel...

377
00:32:19,744 --> 00:32:24,200
It's the kind of thing I never write inaud, I just copy it off another file

378
00:32:26,512 --> 00:32:30,384
but let's say require rspec

379
00:32:30,424 --> 00:32:33,472
[Silence]

380
00:32:36,152 --> 00:32:40,560
Yes, that should fail... and it does,

381
00:32:42,096 --> 00:32:44,168
because we don't have a quadnode.

382
00:32:44,216 --> 00:32:47,208
[Silence]

383
00:32:49,610 --> 00:32:51,984
Lib.quadenode.

384
00:32:52,952 --> 00:32:57,952
And say class QuadNode.

385
00:33:00,960 --> 00:33:03,832
And that should pass.

386
00:33:03,830 --> 00:33:06,608
Good, there will probably be something else inaud.

387
00:33:08,104 --> 00:33:10,176
I haven't required it yet.

388
00:33:10,170 --> 00:33:13,208
[Silence]

389
00:33:15,872 --> 00:33:17,192
Good, OK.

390
00:33:17,960 --> 00:33:26,504
So I'm going to say, it should return it's rows.

391
00:33:26,536 --> 00:33:29,552
[Silence]

392
00:33:30,808 --> 00:33:35,632
I'm just going to say subject is going to be...

393
00:33:37,048 --> 00:33:39,456
described class.new.

394
00:33:40,752 --> 00:33:45,752
And I'm going to give it some
simple rows so I can work with them later.

395
00:33:45,750 --> 00:33:48,784
[Silence]

396
00:33:50,080 --> 00:33:52,896
So I'm going to give it 4x4.

397
00:33:52,890 --> 00:33:57,008
I'm just going to give them 1,2,3,4...

398
00:34:00,224 --> 00:34:02,784
5,6,7,8.

399
00:34:03,936 --> 00:34:09,320
I realise I should have put more spacing in... 9,10,11,12.

400
00:34:11,470 --> 00:34:13,456
13,14.

401
00:34:14,696 --> 00:34:16,736
15,16.

402
00:34:16,730 --> 00:34:19,720
[Silence]

403
00:34:22,672 --> 00:34:23,584
inaud

404
00:34:23,580 --> 00:34:26,608
[Silence]

405
00:34:29,160 --> 00:34:31,208
OK.

406
00:34:31,200 --> 00:34:34,216
[Silence]

407
00:34:34,880 --> 00:34:41,312
Now I should say subject.rows.

408
00:34:41,352 --> 00:34:44,384
[Silence]

409
00:34:45,552 --> 00:34:49,088
Expect rows to equal...

410
00:34:49,080 --> 00:34:52,088
[Silence]

411
00:34:52,864 --> 00:34:59,392
inaud, I could present a constant
but it's so much easier like this.

412
00:35:01,400 --> 00:35:03,336
inaud

413
00:35:05,440 --> 00:35:08,408
Probably gone wrong because
I haven't commit the initializer.

414
00:35:08,930 --> 00:35:16,640
Def initialize rows at rows equals rows.

415
00:35:17,664 --> 00:35:23,504
And then I'll say attr-reader rows.

416
00:35:25,232 --> 00:35:29,784
And now from this... it works, so I just have a thing that says inaud.

417
00:35:30,208 --> 00:35:32,824
Now, the next thing we want is to take up quadrants.

418
00:35:33,280 --> 00:35:35,952
JW: Shall we commit to keep
this test bootstrap in place?

419
00:35:35,952 --> 00:35:37,950
PB: Yes, that's a good idea.

420
00:35:39,464 --> 00:35:41,230
OK...

421
00:35:41,230 --> 00:35:44,224
[Silence]

422
00:35:50,432 --> 00:35:55,712
And say implement a basic quadnode.

423
00:35:56,224 --> 00:35:58,320
It shouldn't do anything but...

424
00:35:58,320 --> 00:36:01,360
[Silence]

425
00:36:05,936 --> 00:36:10,864
The next thing is to be able to
take each quadrant out of it, so...

426
00:36:11,736 --> 00:36:16,000
It should return the northwest quadrant.

427
00:36:16,000 --> 00:36:19,032
[Silence]

428
00:36:19,030 --> 00:36:25,096
JW: Actually, for reasons
that may become clear later on,

429
00:36:26,656 --> 00:36:30,920
let's read the quadrants in counter
clockwise order, starting in the northeast.

430
00:36:31,120 --> 00:36:33,208
PB: OK.

431
00:36:33,528 --> 00:36:36,488
I was only going to expose
it as a method called dot NW.

432
00:36:36,480 --> 00:36:37,968
JW: OK.

433
00:36:38,032 --> 00:36:41,496
PB: Which means we don't have to inaud.

434
00:36:43,110 --> 00:36:47,032
Yes, we can pack them together if we
want, so if we want to break it into quadrants,

435
00:36:47,072 --> 00:36:50,584
which it sounds like what we will want to do.

436
00:36:51,656 --> 00:36:55,728
OK, so this is going to be something very similar.

437
00:36:56,768 --> 00:37:01,968
It's going to be something like
expect subject.northwest to  equal.

438
00:37:04,984 --> 00:37:07,368
Perhaps this should be 1,2...

439
00:37:10,010 --> 00:37:12,168
and 5,6.

440
00:37:12,160 --> 00:37:15,184
[Silence]

441
00:37:22,872 --> 00:37:25,272
Yes, inaud.

442
00:37:25,270 --> 00:37:28,240
[Silence]

443
00:37:28,288 --> 00:37:31,280
[Paul thinks]

444
00:37:32,864 --> 00:37:35,344
This one is very easy to implement.

445
00:37:37,670 --> 00:37:40,960
What I  don't know yet is how
many columns I have though.

446
00:37:42,160 --> 00:37:45,768
So, maybe I'm going to let this one sit for a minute.

447
00:37:47,184 --> 00:37:50,080
And say that it should return a number of columns.

448
00:37:50,080 --> 00:37:53,056
It's going to assume that the...

449
00:37:54,208 --> 00:37:58,208
In fact I'm going to get it to give me the number
of rows and the number of columns, in here.

450
00:37:58,200 --> 00:38:04,288
It should return the number of columns.

451
00:38:07,072 --> 00:38:11,256
And say expect subjects dot...

452
00:38:11,304 --> 00:38:14,344
[Paul thinks]

453
00:38:15,776 --> 00:38:19,424
number of columns, column count, height, width maybe.

454
00:38:19,608 --> 00:38:21,368
I think that would be sensible.

455
00:38:21,360 --> 00:38:27,120
Number of columns, width so expect inaud width to equal...

456
00:38:27,120 --> 00:38:30,152
[Silence]

457
00:38:30,816 --> 00:38:34,280
It's probably not a brilliant
test because they are both 4.

458
00:38:34,328 --> 00:38:37,544
but I'm never going to know if... but...

459
00:38:40,040 --> 00:38:42,248
Let's see.

460
00:38:43,000 --> 00:38:45,920
Perhaps there's no width.

461
00:38:47,624 --> 00:38:52,328
Width, and that can be just rows.first.length.

462
00:38:55,272 --> 00:39:01,304
OK... I did the same for rows.

463
00:39:01,300 --> 00:39:04,288
[Silence]

464
00:39:04,336 --> 00:39:08,064
inaud here, as I say I could have
inaud this wrong and still got the same.

465
00:39:08,940 --> 00:39:13,840
Same result so, I'm going to accept that for now.

466
00:39:14,592 --> 00:39:17,400
JW: We can be reasonably confident.
PB: Yes.

467
00:39:17,400 --> 00:39:20,416
[Silence]

468
00:39:20,416 --> 00:39:22,410
And that's just rows.length.

469
00:39:22,410 --> 00:39:25,400
[Silence]

470
00:39:27,296 --> 00:39:30,248
OK, so going back to my first quadrant...

471
00:39:32,040 --> 00:39:41,000
I want to say that quadrant
width equals width over 2.

472
00:39:42,144 --> 00:39:46,416
Quadrant height equals height over 2.

473
00:39:46,410 --> 00:39:50,536
We're conveniently seeing that
everything is a nice power of two.

474
00:39:52,136 --> 00:39:56,688
Which is why you've helpfully
given me the 256 pixel image.

475
00:39:56,704 --> 00:40:00,060
JW: Yes, that assumption
is built into this challenge.

476
00:40:01,352 --> 00:40:04,208
PB: I suppose if not we
could scale the image first but...

477
00:40:05,944 --> 00:40:08,920
Yes, so I've got quadrant width which is half width,

478
00:40:09,232 --> 00:40:14,912
and then I want to say rows.take.

479
00:40:17,664 --> 00:40:19,872
Quadrant height.

480
00:40:19,896 --> 00:40:22,904
[Silence]

481
00:40:23,120 --> 00:40:29,304
I wonder if for this test it might be
sensible to give it another couple of rows.

482
00:40:29,512 --> 00:40:34,848
Because just for things that are only
doing one level deep, that does work.

483
00:40:35,152 --> 00:40:36,992
Or is that daft?

484
00:40:36,990 --> 00:40:39,952
[Paul thinks]

485
00:40:42,832 --> 00:40:44,744
JW: I have to say I don't see the need.

486
00:40:44,740 --> 00:40:47,920
I think probably [they both talk at once]

487
00:40:48,064 --> 00:40:51,648
PB: I'm just worried I might
be confusing height and width.

488
00:40:52,240 --> 00:41:00,760
So take height and that and I get
a row and I can finish that row.take.

489
00:41:02,088 --> 00:41:04,256
inaud width.

490
00:41:06,360 --> 00:41:08,384
So I think that should do it.

491
00:41:09,400 --> 00:41:14,104
inaud full, which are going to be quite similar.

492
00:41:14,152 --> 00:41:17,152
[Paul thinks]

493
00:41:19,040 --> 00:41:22,488
I'm going to write the test
for all of them first and then...

494
00:41:23,840 --> 00:41:26,248
say which are northwest and northeast.

495
00:41:28,976 --> 00:41:31,816
And that's 1,2,3.

496
00:41:31,810 --> 00:41:36,072
Helpfully, because I know what these
numbers are I don't have to go check inaud page.

497
00:41:36,408 --> 00:41:39,536
3,4,5,6,7,8.

498
00:41:39,530 --> 00:41:42,536
[Silence]

499
00:41:44,496 --> 00:41:46,864
I'll write these tests as well.

500
00:41:48,232 --> 00:41:50,616
I'll make that one southwest.

501
00:41:52,584 --> 00:41:57,152
That one should be 1 to 10.

502
00:41:57,150 --> 00:42:00,136
[Silence]

503
00:42:03,216 --> 00:42:09,680
And 11, 12 both southwest.

504
00:42:12,720 --> 00:42:14,808
And the last one is southeast.

505
00:42:14,856 --> 00:42:17,856
[Silence]

506
00:42:19,680 --> 00:42:24,488
That's not going to be 11, 12 it's going to be 13,14.

507
00:42:27,256 --> 00:42:30,352
That one is 11,12...

508
00:42:30,904 --> 00:42:33,432
and 15 and 16.

509
00:42:35,710 --> 00:42:43,384
I'll check that's right so 9,10,13,14,11,12,15,16,9,12... yes.

510
00:42:47,624 --> 00:42:51,648
So implement northeast... doesn't work.

511
00:42:51,640 --> 00:42:54,608
[Silence]

512
00:42:56,288 --> 00:43:00,088
I can pull these out into methods.

513
00:43:00,080 --> 00:43:03,072
[Silence]

514
00:43:15,016 --> 00:43:18,064
inaud def.

515
00:43:18,060 --> 00:43:21,104
[Silence]

516
00:43:25,560 --> 00:43:30,168
This one I would say rows dot...

517
00:43:30,160 --> 00:43:34,360
Northwest is there, northeast
I still want the first 2 rows.

518
00:43:35,608 --> 00:43:40,310
Because north... but with this one a drop to take.

519
00:43:40,310 --> 00:43:43,296
[Silence]

520
00:43:43,856 --> 00:43:45,400
JW: Yes, nice.

521
00:43:45,408 --> 00:43:47,936
PB: I can do the same for
these hopefully in short order,

522
00:43:47,936 --> 00:43:53,408
So that should say southwest and southeast.

523
00:43:55,304 --> 00:43:59,536
I should have copied and pasted
these entirely because it's a case of...

524
00:43:59,530 --> 00:44:02,544
[Silence]

525
00:44:10,760 --> 00:44:15,224
So we have our 4 quadrants... I'm going to check those in.

526
00:44:15,220 --> 00:44:18,248
[Silence]

527
00:44:30,020 --> 00:44:33,520
JW: Right so we've got a quad node class which...

528
00:44:33,544 --> 00:44:38,216
given the input pixels can give you each inaud.

529
00:44:38,210 --> 00:44:44,632
PB: Yes, it is successively splitting
each of these into sub-quadrants.

530
00:44:45,312 --> 00:44:53,904
A nice thing to do next might
be some kind of recursive split.

531
00:44:53,900 --> 00:44:56,552
Now, you mentioned a particular order.

532
00:44:56,552 --> 00:44:58,550
JW: Yes.

533
00:44:59,040 --> 00:45:05,576
PB: So I'm going to write a split function
(I should have put a space in there)...

534
00:45:05,816 --> 00:45:09,136
I'm going to write a split function which...

535
00:45:11,896 --> 00:45:18,232
Let's see how can I do this.. I want to be able
to equate things when I get them out in the end.

536
00:45:20,048 --> 00:45:24,336
So it should split...

537
00:45:24,330 --> 00:45:27,328
[Paul thinks]

538
00:45:30,032 --> 00:45:32,272
Let's do one level splitting first.

539
00:45:33,130 --> 00:45:46,688
It should split into the four quadrants in order.

540
00:45:47,360 --> 00:45:52,744
And we know that is
anti-clockwise from the northeast.

541
00:45:54,480 --> 00:45:57,120
So anti-clockwise from northeast.

542
00:45:57,120 --> 00:46:00,152
[Silence]

543
00:46:09,904 --> 00:46:25,032
So in that case I should be
able to say expectsubject.split.to equal...

544
00:46:26,920 --> 00:46:33,224
In fact I should be able to say that I get
an array of the four things that are already there,

545
00:46:33,220 --> 00:46:35,624
assuming those to be equal.

546
00:46:35,620 --> 00:46:40,608
Then I'm going to say subject dot...

547
00:46:42,360 --> 00:46:45,480
(I'll put this onto a new line because inaud)

548
00:46:46,800 --> 00:47:00,792
[Paul dictates what he writes]

549
00:47:04,904 --> 00:47:07,320
JW: I see a strait ?Q in there, where you want a W.

550
00:47:07,320 --> 00:47:11,432
PB: Yes, [Laughter]

551
00:47:14,072 --> 00:47:17,432
It should fail because there is no split.

552
00:47:17,472 --> 00:47:20,464
[Silence]

553
00:47:24,288 --> 00:47:33,256
And then I'm going to say northeast,
northwest, southwest, southeast.

554
00:47:33,250 --> 00:47:36,272
[Silence]

555
00:47:39,272 --> 00:47:43,792
OK great, that works, but it's not recursive.

556
00:47:44,856 --> 00:47:47,856
[Paul thinks]

557
00:47:50,848 --> 00:47:55,112
I'm going to get additional thing which is...

558
00:47:55,760 --> 00:47:58,888
I'm going to put all of these into...

559
00:47:58,880 --> 00:48:01,888
[Paul thinks]

560
00:48:02,820 --> 00:48:21,904
Actually I may as well do a special case and
say context when it cannot be sub-divided...

561
00:48:22,016 --> 00:48:25,048
[Silence]

562
00:48:29,688 --> 00:48:33,520
And I'm going to say that then...

563
00:48:33,520 --> 00:48:39,688
it should return itself split.

564
00:48:40,376 --> 00:48:45,496
I'm not sure if that is the most
sensible thing to do but I'll do it for now.

565
00:48:45,912 --> 00:48:52,304
I'll just take this lot and say that (I'm
going to have to redefine the subject in here)

566
00:48:52,544 --> 00:48:58,984
Subject is going to be described class.new,

567
00:48:59,112 --> 00:49:04,896
and I'm going to give it just one row to work on.

568
00:49:05,648 --> 00:49:08,760
and then this one, don't need any of that.

569
00:49:09,192 --> 00:49:12,904
And I should say expect split to equal subject.

570
00:49:12,900 --> 00:49:15,800
[Silence]

571
00:49:17,320 --> 00:49:21,728
And it's not, it's giving me empty
things, but it's interesting what it has done.

572
00:49:23,360 --> 00:49:34,056
Yes, so I can say if divisible that...

573
00:49:36,216 --> 00:49:41,520
inaud for you.

574
00:49:41,520 --> 00:49:47,704
I had an interesting bug the other
day where I just mis-touched something

575
00:49:47,700 --> 00:49:51,200
when I was inaud and had a really weird error,

576
00:49:51,200 --> 00:49:55,528
and I found out I had replaced
something with a completely different word.

577
00:49:55,592 --> 00:49:58,608
[Silence]

578
00:49:59,776 --> 00:50:02,176
inaud

579
00:50:03,328 --> 00:50:07,632
I'll put these into a private section as
well, I don't think I need those again.

580
00:50:08,776 --> 00:50:10,928
Def divisible...

581
00:50:12,016 --> 00:50:16,888
And that should be height is greater than 2,

582
00:50:17,568 --> 00:50:24,128
and equal to 2, and width is greater than equals 2.

583
00:50:26,552 --> 00:50:31,368
Because our things are all square,
we don't need to check that much but...

584
00:50:33,960 --> 00:50:41,380
So the next thing I think I want is some
kind of recursive split, but let's just commit first.

585
00:50:41,380 --> 00:50:47,360
[Silence]

586
00:50:58,224 --> 00:51:03,096
I don't really like the name split
anymore so I might change that.

587
00:51:04,304 --> 00:51:08,600
I might change it to sub-divides.

588
00:51:08,600 --> 00:51:11,640
[Silence]

589
00:51:14,744 --> 00:51:20,800
Yes, in fact... oh so we've got split there, that's fine

590
00:51:21,360 --> 00:51:24,440
So then I want to do it recursively.

591
00:51:25,456 --> 00:51:32,032
So I'm going to add... it should split recursively.

592
00:51:32,030 --> 00:51:35,056
[Silence]

593
00:51:37,488 --> 00:51:40,336
So what I should end up with...

594
00:51:42,400 --> 00:51:47,776
rather than specifying all the data for
this, I'm goiung to just look at a bit of the data.

595
00:51:49,192 --> 00:51:53,048
So I know it's going to have 4 things inside it.

596
00:51:53,520 --> 00:51:59,072
And each of that is going to have 4 things inside
it, and each of those will have one thing inside it.

597
00:52:01,248 --> 00:52:03,984
So we'll say...

598
00:52:03,980 --> 00:52:06,976
[Paul thinks]

599
00:52:09,704 --> 00:52:16,120
Result equals inaud

600
00:52:16,120 --> 00:52:19,120
[Silence]

601
00:52:19,728 --> 00:52:22,016
Split recursive.

602
00:52:22,010 --> 00:52:25,032
[Silence]

603
00:52:25,504 --> 00:52:33,592
I'm going to say expect (what do I get out of this)...

604
00:52:33,590 --> 00:52:36,592
[Paul thinks]

605
00:52:44,048 --> 00:52:46,872
I actually just get an array out of this don't I?

606
00:52:48,208 --> 00:52:52,760
I think that's alright, but I'm wondering
if I would rather have an object out of it.

607
00:52:54,560 --> 00:52:57,408
I'll go with array aqnd see how that works.

608
00:52:57,400 --> 00:53:05,512
JW: There is a slight suggestion that northeast

orthwest could return another quadnode.

609
00:53:06,808 --> 00:53:09,160
PB: Yes.

610
00:53:12,424 --> 00:53:16,064
Of course, because inaud

611
00:53:17,408 --> 00:53:22,024
So in fact split, hmm...

612
00:53:22,020 --> 00:53:25,016
[Paul thinks]

613
00:53:26,592 --> 00:53:28,832
Yes, split at one level gives you those,

614
00:53:28,830 --> 00:53:33,856
once I get down to the bottom level I'm
going to have nodes that are just one item,

615
00:53:33,880 --> 00:53:38,640
so maybe I should put that to
one side for the moment and...

616
00:53:41,760 --> 00:53:44,776
instead of returning itself
it should return the value.

617
00:53:44,840 --> 00:53:47,432
JW: Is the value not in an array display?

618
00:53:47,430 --> 00:53:50,416
[Paul thinks]

619
00:53:52,656 --> 00:53:55,432
PB: That's a good question.

620
00:53:58,360 --> 00:54:03,400
Maybe an array, it's going to
be easy enough to change but...

621
00:54:03,400 --> 00:54:06,432
[Silence]

622
00:54:10,280 --> 00:54:14,816
Yes, I would expect... let's try that inaud.

623
00:54:17,650 --> 00:54:21,632
An array of...

624
00:54:21,688 --> 00:54:24,696
[Paul thinks]

625
00:54:26,184 --> 00:54:31,632
Yes, so it always returns an array until it gets
to the bottom and there are no more arrays.

626
00:54:32,624 --> 00:54:34,992
That is a leaf node.

627
00:54:36,120 --> 00:54:39,560
Yes, because that will work
recursively quite nicely, won't it?

628
00:54:39,616 --> 00:54:42,688
[Paul thinks]

629
00:54:48,848 --> 00:54:50,792
Yes, I've been confusing myself there.

630
00:54:51,096 --> 00:54:55,280
I'm going to leave this for now and go back to this.

631
00:54:55,344 --> 00:54:59,576
JW: Perhaps when we come back to make use of this...

632
00:54:59,880 --> 00:55:04,904
PB: So it's split recursively, so
I'm going to say something like:

633
00:55:05,944 --> 00:55:09,408
expect result.split.

634
00:55:09,456 --> 00:55:12,464
[Paul thinks]

635
00:55:14,384 --> 00:55:17,640
I think it should have length
for, that's the first thing I...

636
00:55:17,640 --> 00:55:20,632
[Silence]

637
00:55:27,008 --> 00:55:30,592
inaud so let's implement that.

638
00:55:30,680 --> 00:55:33,696
[Silence]

639
00:55:35,520 --> 00:55:38,224
And I'm just going to make inaud split, for now.

640
00:55:38,280 --> 00:55:41,288
[Silence]

641
00:55:52,448 --> 00:55:54,440
The first one...

642
00:55:54,512 --> 00:55:57,528
[Silence]

643
00:55:59,576 --> 00:56:01,624
which should also be 4 long.

644
00:56:02,400 --> 00:56:08,456
At this point I'm thinking that I should
actually be returning some other kind of object,

645
00:56:08,450 --> 00:56:13,456
but as long as it returns the length that will be OK.

646
00:56:16,160 --> 00:56:20,704
So that fails because it's got
something else. It's got a list.

647
00:56:23,944 --> 00:56:25,656
What I've got here...

648
00:56:27,640 --> 00:56:31,160
I suppose I get northeast,
northwest, southwest, southeast.

649
00:56:31,856 --> 00:56:34,128
So split recursive should be...

650
00:56:34,120 --> 00:56:40,168
[Paul thinks]

651
00:56:51,032 --> 00:56:53,272
Node...

652
00:56:53,312 --> 00:56:56,336
[Silence]

653
00:56:57,512 --> 00:57:01,816
This will get stuck in an endless loop because...

654
00:57:02,210 --> 00:57:06,704
JW: Am I right in thinking that it won't
be nodes as well, it will be regular arrays?

655
00:57:06,704 --> 00:57:12,192
PB: That's right, so that's what I've
done wrong isn't it, that actually split.

656
00:57:15,512 --> 00:57:19,488
It should actually wrap
these things in a new quadrant.

657
00:57:19,480 --> 00:57:22,464
[Silence]

658
00:57:26,300 --> 00:57:34,976
So that will give me rows, which are those,
and it's like sub.class.new with those rows.

659
00:57:37,880 --> 00:57:49,120
Which means of course, that this will be pending.

660
00:57:49,184 --> 00:57:52,144
[Silence]

661
00:57:53,568 --> 00:58:02,128
So now those are failing, because
it's not giving me quadrants.

662
00:58:02,424 --> 00:58:05,296
So that particular one...

663
00:58:06,096 --> 00:58:11,816
I want to make sure that all 4 are
packed quadrants, which I can do.

664
00:58:15,200 --> 00:58:18,528
Describe class... in fact I can
do that all the way down there.

665
00:58:20,600 --> 00:58:23,288
[Paul dictates as he types]

666
00:58:23,280 --> 00:58:29,288
[Silence]

667
00:58:33,008 --> 00:58:35,312
inaud better.

668
00:58:36,488 --> 00:58:39,768
OK, so something else has happened.

669
00:58:42,008 --> 00:58:43,736
JW: It doesn't know how to compare...

670
00:58:43,730 --> 00:58:46,456
PB: It doesn't, so let's give it that.

671
00:58:48,352 --> 00:58:50,216
So what shall we do...

672
00:58:53,016 --> 00:58:58,896
Other, and we'll just say set.rows equals other.rows.

673
00:58:58,890 --> 00:59:01,872
[Silence]

674
00:59:05,112 --> 00:59:07,192
Yes, cool.

675
00:59:09,144 --> 00:59:13,192
So now I can go down... and this one I expect to...

676
00:59:13,240 --> 00:59:16,232
[Silence]

677
00:59:18,416 --> 00:59:21,400
Given that I've got 4 things, I'm going to have...

678
00:59:22,810 --> 00:59:28,784
So I have 16 cells altogether, and the first one
I'll get 4 which has those 4 which has which has 1H

679
00:59:28,790 --> 00:59:34,792
So the first one should have length
4, the second level down should have 4,

680
00:59:34,800 --> 00:59:39,096
the third level down I think should have length 1,

681
00:59:43,600 --> 00:59:46,752
Which I think means that this should be that.

682
00:59:49,368 --> 00:59:51,672
But let's leave that test for now.

683
00:59:51,670 --> 00:59:54,664
[Silence]

684
00:59:57,504 --> 01:00:04,864
JW: I think that in that expectation, the third one...

685
01:00:07,600 --> 01:00:09,688
Cool.

686
01:00:14,280 --> 01:00:17,584
PB: There we need something
representing the leaf node.

687
01:00:24,792 --> 01:00:31,192
Maybe that's fine, maybe simply having
one element in it is... that leaf node.

688
01:00:31,816 --> 01:00:34,952
So what I might say is...

689
01:00:35,208 --> 01:00:36,950
inaud

690
01:00:37,072 --> 01:00:40,088
[Paul thinks]

691
01:00:41,550 --> 01:00:46,096
In this case I'm going to say it's a leaf node.

692
01:00:46,144 --> 01:00:49,144
[Silence]

693
01:00:51,784 --> 01:00:58,720
Then I'm going to say... it can't
be sub-divided, it is a leaf node.

694
01:00:58,720 --> 01:01:01,680
[Silence]

695
01:01:04,712 --> 01:01:06,848
I could just say expect...

696
01:01:06,840 --> 01:01:11,416
I know there's some syntax that would let
me do that even shorter, but I can't remember it.

697
01:01:13,640 --> 01:01:17,872
[Paul dictates as he types]

698
01:01:33,960 --> 01:01:35,320
JW: I think you already have a...

699
01:01:35,320 --> 01:01:38,424
PB: Yes, we have divisible,
which is the opposite to leaf.

700
01:01:41,232 --> 01:01:43,928
So it's a leaf if it's not divisible.

701
01:01:43,920 --> 01:01:46,864
[Silence]

702
01:01:52,296 --> 01:01:55,320
So that's good... and then this one...

703
01:01:57,240 --> 01:01:59,192
yes, that's also good.

704
01:02:00,232 --> 01:02:02,264
Everything's fine.

705
01:02:02,260 --> 01:02:05,256
[Silence]

706
01:02:05,976 --> 01:02:08,952
That feels a bit happier so I'll check those in.

707
01:02:08,950 --> 01:02:11,952
[Silence]

708
01:02:22,616 --> 01:02:25,600
[Paul dictates what he writes]

709
01:02:26,760 --> 01:02:32,688
inaud

710
01:02:32,760 --> 01:02:36,096
[New Chapter]

711
01:02:36,472 --> 01:02:38,744
PB: The next thing was that...

712
01:02:38,740 --> 01:02:43,008
When a quadrant consists of a single color,
it may be considered a terminal node.

713
01:02:43,768 --> 01:02:49,928
So although we have this leaf method,
which is the point at which we stop.

714
01:02:53,270 --> 01:02:58,936
We want to add some additional logic to that
which is when a quadrant consists of a single color.

715
01:02:58,944 --> 01:03:03,070
So what I want to do now... [Paul thinks]

716
01:03:03,070 --> 01:03:08,216
is... that's my logic, but I don't
want to put that in the node

717
01:03:08,392 --> 01:03:10,912
because inaud about the color.

718
01:03:10,936 --> 01:03:14,536
So this should split recursively.

719
01:03:17,472 --> 01:03:20,472
I'm going to need a different set of data for this.

720
01:03:22,504 --> 01:03:25,960
So I'm going to say...

721
01:03:26,600 --> 01:03:33,328
[Paul dictates what he types]

722
01:03:36,168 --> 01:03:43,272
And I'm going to inaud quite easily, so I'm going to say...

723
01:03:44,272 --> 01:03:46,912
This quadrant is all one.

724
01:03:48,160 --> 01:03:50,840
Oh, it's not actually all 1.

725
01:03:52,300 --> 01:03:59,376
I'm going to say that this quadrant is all 2.

726
01:03:59,500 --> 01:04:02,520
[Silence]

727
01:04:07,152 --> 01:04:10,496
And I'm going to leave the rest of them different.

728
01:04:10,640 --> 01:04:13,688
[Paul thinks]

729
01:04:15,176 --> 01:04:20,448
I'm going to say it should split recursively...

730
01:04:20,440 --> 01:04:23,480
[Silence]

731
01:04:26,160 --> 01:04:29,352
based upon supplied predicate.

732
01:04:29,350 --> 01:04:32,344
[Silence]

733
01:04:33,416 --> 01:04:38,312
So in this case, if I give... that needs to be subject.

734
01:04:40,456 --> 01:04:43,856
I'm going to try it with a
couple of different predicates.

735
01:04:43,850 --> 01:04:46,856
[Silence]

736
01:04:48,608 --> 01:04:50,568
And I'm going to say...

737
01:04:50,752 --> 01:04:53,736
[Paul thinks]

738
01:04:55,560 --> 01:04:59,944
Firstly, I'm going to break this down into cells.

739
01:04:59,940 --> 01:05:06,224
[Paul talks to himself]

740
01:05:06,220 --> 01:05:09,232
[Paul thinks]

741
01:05:09,688 --> 01:05:14,040
Olander, which is going to be...

742
01:05:15,184 --> 01:05:20,200
I think the simplest thing is to give
it the four items in the same order.

743
01:05:20,688 --> 01:05:27,568
So if I say Ive got A,B,C, and D
going from northeast anticlockwise.

744
01:05:30,848 --> 01:05:33,112
And I'm just going to return true.

745
01:05:36,376 --> 01:05:41,104
No, I'm going to say A equals B equal C equals B.

746
01:05:41,100 --> 01:05:44,128
[Silence]

747
01:05:49,304 --> 01:05:53,960
And then we're going to end
up here with a recursive split.

748
01:05:53,960 --> 01:05:56,912
[Silence]

749
01:06:00,110 --> 01:06:05,096
And then give it that predicate
as a block, or olander, whatever.

750
01:06:05,096 --> 01:06:08,848
[Paul dictates what he types]

751
01:06:08,840 --> 01:06:12,152
It turned into a inaud.

752
01:06:13,144 --> 01:06:16,896
Now, what do I expect...

753
01:06:18,216 --> 01:06:26,576
I expect result naught which
is the northeast quadrant,

754
01:06:26,570 --> 01:06:29,640
[Paul thinks]

755
01:06:29,720 --> 01:06:32,520
to be a leaf.

756
01:06:33,968 --> 01:06:36,344
JW: It's starting to read quite nicely.

757
01:06:37,776 --> 01:06:41,104
PB: Expect 1 to be a leaf, so result...

758
01:06:42,392 --> 01:06:49,104
[Paul dictates what he writes]

759
01:06:49,100 --> 01:06:52,144
[Silence]

760
01:06:55,400 --> 01:06:59,144
I'm just going to add one more
inaud to make sure it's going down.

761
01:06:59,848 --> 01:07:04,560
I want to say that result 3...

762
01:07:04,560 --> 01:07:07,552
[Paul thinks]

763
01:07:14,336 --> 01:07:18,768
JW: I think result 3 will be [they both talk at once].

764
01:07:19,230 --> 01:07:21,400
PB: Yes.

765
01:07:21,464 --> 01:07:24,504
[Paul thinks]

766
01:07:28,632 --> 01:07:33,424
Maybe I should make it result inaud that might be nice.

767
01:07:33,880 --> 01:07:36,544
[Paul dictates what he writes]

768
01:07:36,540 --> 01:07:38,928
So in that case...

769
01:07:38,976 --> 01:07:41,992
[Silence]

770
01:07:43,200 --> 01:07:45,400
So in this case...

771
01:07:45,480 --> 01:07:48,488
[Paul thinks]

772
01:07:51,496 --> 01:07:55,184
So here I get quad tree quad tree...

773
01:07:57,072 --> 01:08:01,560
[Paul dictates what he writes]

774
01:08:09,440 --> 01:08:14,744
I'm not sure if that makes any sense any more,
but it depends what the rules for splitting are.

775
01:08:14,768 --> 01:08:17,736
[Paul thinks]

776
01:08:18,128 --> 01:08:21,264
I'm going to forget this for now and get that bit away.

777
01:08:22,930 --> 01:08:25,952
That doesn't work at all... which is OK.

778
01:08:26,008 --> 01:08:30,352
So you cant do that, which is a shame.

779
01:08:30,688 --> 01:08:33,704
[Paul thinks]

780
01:08:38,632 --> 01:08:43,960
In fact I could even say...
[Paul dictates what he writes]

781
01:09:05,424 --> 01:09:08,304
That inaud wrong I've got an array of nodes.

782
01:09:10,000 --> 01:09:12,240
So actually I want...

783
01:09:13,104 --> 01:09:15,664
So I split...

784
01:09:16,248 --> 01:09:23,968
So the first thing that's wrong is
that it's not actually to the block.

785
01:09:24,024 --> 01:09:27,064
[Paul thinks]

786
01:09:31,104 --> 01:09:33,904
It doesn't really matter if I do it or not so...

787
01:09:33,968 --> 01:09:36,920
[Paul dictates what he writes on screen]

788
01:09:56,976 --> 01:10:00,152
So this one, I want to know if I can split here.

789
01:10:00,456 --> 01:10:03,080
So I need to check if it's divisible.

790
01:10:05,984 --> 01:10:09,840
I need to duplicate that, and I think
I just need to put the logic in there.

791
01:10:09,920 --> 01:10:12,912
[Silence]

792
01:10:33,352 --> 01:10:35,872
So that needs to be split_recursive.

793
01:10:35,920 --> 01:10:38,904
[Silence]

794
01:10:39,640 --> 01:10:43,312
I feel like I'm slightly off track here.

795
01:10:43,310 --> 01:10:46,352
[Paul thinks]

796
01:10:50,432 --> 01:10:53,104
I'm sure there's a simpler thing that I've missed.

797
01:10:53,100 --> 01:10:56,104
[Paul thinks]

798
01:10:56,464 --> 01:11:01,592
So now do we get inaud for the quadnode.

799
01:11:05,360 --> 01:11:07,760
I'm going to stop and read over what I've done.

800
01:11:07,832 --> 01:11:10,840
[Silence]

801
01:11:19,128 --> 01:11:23,040
I'm thinking that perhaps...

802
01:11:24,600 --> 01:11:29,224
each of things should at some point be a node.

803
01:11:29,960 --> 01:11:34,312
So each of these should be the same kind of thing.

804
01:11:36,360 --> 01:11:40,464
So I'm going to inaud here
and I'm going to stash my changes.

805
01:11:40,544 --> 01:11:43,568
[Silence]

806
01:11:45,816 --> 01:11:49,576
JW: You know you attempted to
change the name of split earlier on,

807
01:11:49,848 --> 01:11:52,888
I wonder if children might be a better name.

808
01:11:53,400 --> 01:11:56,712
It would tease out the 'treesness' of it.

809
01:11:56,710 --> 01:12:01,624
PB: Yes, let's try that... so I need to do some surgery here.

810
01:12:03,904 --> 01:12:10,024
I feel there's a whole load of duplication
here but there probably actually isn't.

811
01:12:12,336 --> 01:12:16,024
I'm just going to see inaud.

812
01:12:18,960 --> 01:12:21,416
So yes, it needs to be here.

813
01:12:21,672 --> 01:12:26,688
I inaud a wrap function which,
because I'm doing this quite a lot...

814
01:12:29,024 --> 01:12:35,024
[Paul dictates what he types]... given some rows.

815
01:12:35,640 --> 01:12:38,480
It's an easier way of doing that.

816
01:12:38,544 --> 01:12:41,592
[Silence]

817
01:12:42,544 --> 01:12:44,984
Just get each of these...

818
01:12:45,016 --> 01:12:48,024
[Silence]

819
01:12:59,520 --> 01:13:02,176
So I'm going to do that.

820
01:13:02,240 --> 01:13:05,264
[Paul thinks]

821
01:13:05,616 --> 01:13:08,824
JW: Actually you don't need
the mapping on line 26 anymore.

822
01:13:10,480 --> 01:13:12,720
Or even to map it at all.

823
01:13:16,040 --> 01:13:17,680
PB: Yes, that's a bit nicer isn't it.

824
01:13:17,952 --> 01:13:23,144
I'm going to put this onto one line because
the screen is small and it's nicer to see more.

825
01:13:23,184 --> 01:13:26,192
[Silence]

826
01:13:43,928 --> 01:13:46,520
split recurser... erm...

827
01:13:48,496 --> 01:13:54,240
Again, it's wrong it should be pulling
split recurser when it should be pulling sub-nodes.

828
01:13:54,800 --> 01:13:57,304
Let's try using this to children.

829
01:13:58,808 --> 01:14:01,168
No let's finish and see what breaks.

830
01:14:04,288 --> 01:14:08,632
OK, so that's expected.

831
01:14:08,630 --> 01:14:13,904
Those will fail because it
expected to get different things back.

832
01:14:15,648 --> 01:14:21,928
Expect rows, yes inaud which is in northeast quadrant and that should be...

833
01:14:22,432 --> 01:14:27,480
JW: We could just call .rows on that and it would...

834
01:14:27,576 --> 01:14:29,480
PB: Yes, we could.

835
01:14:32,816 --> 01:14:34,752
Yes, I think that's fine.

836
01:14:34,848 --> 01:14:37,904
[Silence]

837
01:14:50,280 --> 01:14:52,672
I wonder if I should store work.

838
01:14:53,080 --> 01:14:55,080
Don't think I did that but...

839
01:14:56,360 --> 01:14:59,496
OK so 4 quadrants.

840
01:15:00,272 --> 01:15:02,400
JW: It looks like they're double wrapped.

841
01:15:03,728 --> 01:15:04,848
PB: Yes.

842
01:15:04,976 --> 01:15:07,512
JW: Because in the test we're...

843
01:15:10,040 --> 01:15:11,992
PB: Yes, that's right.

844
01:15:12,072 --> 01:15:15,072
[Silence]

845
01:15:24,224 --> 01:15:25,896
Cool, yes.

846
01:15:26,632 --> 01:15:29,240
JW: That might be worth a commit.

847
01:15:29,384 --> 01:15:32,368
[Silence]

848
01:15:42,664 --> 01:15:45,960
[Paul dictates what he writes]

849
01:15:54,760 --> 01:15:59,312
PB: OK, so we've got split inaud nodes, and that feels better.

850
01:16:02,256 --> 01:16:06,480
I'm going to take your suggestion and make children...

851
01:16:06,480 --> 01:16:10,440
... because I think children and split
being different will make more sense.

852
01:16:10,808 --> 01:16:13,088
So I'll change split to children.

853
01:16:13,120 --> 01:16:16,136
[Silence]

854
01:16:19,976 --> 01:16:23,016
inaud is that yes... No.

855
01:16:23,088 --> 01:16:26,088
[Paul thinks]

856
01:16:36,448 --> 01:16:40,776
Change all this to children, no, yes, yes.

857
01:16:40,864 --> 01:16:43,856
[Silence]

858
01:16:49,130 --> 01:16:52,216
So we now have children.

859
01:16:53,184 --> 01:16:58,800
[Paul mumbles as he types]

860
01:17:01,600 --> 01:17:07,104
Children inaud I'm going to change that test.

861
01:17:08,240 --> 01:17:10,488
Should children... no.

862
01:17:10,752 --> 01:17:13,776
[Silence]

863
01:17:23,096 --> 01:17:26,720
[Paul dictates what he writes]

864
01:17:28,872 --> 01:17:32,584
I shouldn't have put should
in everything, but never mind.

865
01:17:34,840 --> 01:17:40,696
Yes, so... change split to children.

866
01:17:41,368 --> 01:17:48,176
It's now a lot clearer that we have a method
that just gives us the immediate children.

867
01:17:48,696 --> 01:17:53,056
Whether something has children or not,
it doesn't matter what our rules are,

868
01:17:53,050 --> 01:17:56,072
it always has children.

869
01:17:56,352 --> 01:18:01,728
Splitting recursively is a slightly
different process where we have some kind of

870
01:18:02,728 --> 01:18:05,984
choice to make whether each one is split.

871
01:18:09,264 --> 01:18:15,768
Which now, if I've got inaud

872
01:18:15,760 --> 01:18:18,752
[Silence]

873
01:18:19,768 --> 01:18:21,648
NARRATOR: We're going to speed through this section,

874
01:18:21,640 --> 01:18:24,672
because Paul and Jamie
found themselves at a dead end.

875
01:18:25,328 --> 01:18:28,608
They eventually backtracked on
this idea of using a lambda.

876
01:18:28,632 --> 01:18:31,760
So let's skip ahead to the
section where they changed course.

877
01:18:33,536 --> 01:18:38,384
PB: I think I'm going to take all
the stuff I've been doing and say...

878
01:18:38,380 --> 01:18:42,792
[Paul dictates what he writes]

879
01:18:44,008 --> 01:18:46,464
And then I'm going to re-set...

880
01:18:46,460 --> 01:18:48,888
[Paul dictates what he writes]

881
01:18:48,880 --> 01:18:52,040
It's basically a posh version of stash.

882
01:18:52,090 --> 01:18:59,352
I still have it somewhere until it gets garbage
collected but I'm probably not going to use it.

883
01:19:00,210 --> 01:19:04,424
I'm going to re-load this.

884
01:19:04,420 --> 01:19:11,432
OK so I'm going to write some
spectre on some smaller notes.

885
01:19:11,430 --> 01:19:15,240
So I'm going to put this
into something saying context.

886
01:19:17,256 --> 01:19:27,616
[Paul dictates what he writes]

887
01:19:29,672 --> 01:19:33,848
And I put all of those inside except inaud.

888
01:19:33,840 --> 01:19:36,864
[Silence]

889
01:19:39,600 --> 01:19:43,824
JW: I think it's quite nice that
we've moved away from the idea of color

890
01:19:44,312 --> 01:19:48,992
and it's simply about... [they both talk at once].

891
01:19:49,368 --> 01:19:59,576
So I'm going to call this one at the
bottom: context, and call it a 1 element dataset.

892
01:20:01,800 --> 01:20:07,240
Or it could be a 1 element
quadtree, that might make more sense.

893
01:20:07,740 --> 01:20:15,808
So this one, I want to say that its children is itself.

894
01:20:16,008 --> 01:20:24,144
So our basic building block is a
quadtree which has one element which is a leaf.

895
01:20:27,072 --> 01:20:30,208
JW: Maybe we can ask it if it's a leaf to begin with...

896
01:20:30,200 --> 01:20:33,896
PB: Yes, in fact that's what we've already got.

897
01:20:35,992 --> 01:20:40,176
So we know that works, and I'm going to
move that one up to the top because I think

898
01:20:40,170 --> 01:20:44,352
it would be nicer to have the simple case at the top.

899
01:20:44,352 --> 01:20:46,160
JW: Yes.

900
01:20:46,160 --> 01:20:52,296
PB: And then I'm going to do something
similar with 4 because 4 is still quite simple

901
01:20:52,290 --> 01:20:58,776
but it's easy to think about and we inaud.

902
01:20:59,224 --> 01:21:05,064
Let's get rid of that entirely, and inaud our dataset something like...

903
01:21:05,060 --> 01:21:08,056
[Silence]

904
01:21:09,752 --> 01:21:15,040
This is a heterogeneous data
set as well, so that's important.

905
01:21:17,232 --> 01:21:22,128
And there's 1,2,3 and 4.

906
01:21:22,216 --> 01:21:25,208
[Silence]

907
01:21:25,720 --> 01:21:28,416
So it is NOT a leaf node.

908
01:21:28,410 --> 01:21:31,464
[Silence]

909
01:21:33,200 --> 01:21:36,528
Good, OK, I'm happy with that.

910
01:21:38,080 --> 01:21:46,192
And it has 4 children.

911
01:21:46,272 --> 01:21:49,272
[Silence]

912
01:21:51,250 --> 01:22:05,472
I'm going to say: [Paul dictates what he writes]

913
01:22:09,520 --> 01:22:14,552
And let's do the same thing
with this one, some basic stuff like...

914
01:22:17,220 --> 01:22:20,368
(actually I'm going to get rid
of all these 'shoulds')

915
01:22:20,416 --> 01:22:23,416
[Silence]

916
01:22:44,144 --> 01:22:47,056
I really typed that a lot didn't I?

917
01:22:48,480 --> 01:22:50,784
OK, so I'm going to get rid of that.

918
01:22:50,920 --> 01:23:03,072
All these things are...

919
01:23:03,112 --> 01:23:06,904
Yes, so there's 16 inaud.

920
01:23:07,312 --> 01:23:12,664
I also want to say this is not a leaf node,

921
01:23:13,888 --> 01:23:18,320
which is kind of obvious, but
it makes things consistent.

922
01:23:18,384 --> 01:23:21,384
[Silence]

923
01:23:25,616 --> 01:23:27,856
[They both talk at once]

924
01:23:27,944 --> 01:23:30,944
[Silence]

925
01:23:34,024 --> 01:23:36,728
OK, so that's all fine.

926
01:23:36,776 --> 01:23:39,776
[Silence]

927
01:23:42,144 --> 01:23:50,000
Right, I think the next thing I want
to do... I think all that stuff is fine.

928
01:23:50,000 --> 01:23:55,072
It returns northwest quadrant, northeast quadrant,
southwest quadrant, and southeast quadrant.

929
01:23:58,600 --> 01:24:02,792
We'll get rid of this split
recursively, I don't think I care about that.

930
01:24:03,944 --> 01:24:08,472
inaud and split in here as well.

931
01:24:11,880 --> 01:24:17,816
I'm also tempted to get rid
of divisible and just have leaf.

932
01:24:18,376 --> 01:24:21,296
But... maybe that doesn't make sense.

933
01:24:21,328 --> 01:24:25,112
JW: Divisible is a private API at the moment?
PB: Yes.

934
01:24:31,504 --> 01:24:35,104
JW: Shall we just commit,
since it's quite a clean state. PB: Yes.

935
01:24:35,100 --> 01:24:38,080
[Silence]

936
01:24:38,296 --> 01:24:44,072
[Paul dictates what he types]

937
01:24:44,096 --> 01:24:47,104
[Silence]

938
01:24:47,648 --> 01:24:57,856
Now I think I want to add some kind of compression.

939
01:25:01,800 --> 01:25:06,704
JW: You don't want to do the case
of a homogeneous 4 element dataset?

940
01:25:07,624 --> 01:25:14,040
PB: Ah, yes I will, that's exactly what
I mean so I want to say that compression

941
01:25:14,040 --> 01:25:19,344
heterogeneous 1 should give me the
same, the children should be the same.

942
01:25:19,984 --> 01:25:26,504
It should have 4 children but if I
compress it I should get a leaf node and the value.

943
01:25:27,288 --> 01:25:34,184
It's first row, first column
should be the individual value.

944
01:25:34,180 --> 01:25:40,120
Let's do this as our inaud.

945
01:25:41,720 --> 01:25:44,000
homogeneous dataset.

946
01:25:44,088 --> 01:25:47,088
[Silence]

947
01:25:48,980 --> 01:25:54,360
So we're moving away from having
a particular plugin way of comparing things

948
01:25:54,360 --> 01:25:58,656
because I think that making
it the same is reasonable.

949
01:25:59,648 --> 01:26:02,864
I'm going to make this all ones.

950
01:26:06,584 --> 01:26:08,736
Yes, so that's all ones.

951
01:26:08,730 --> 01:26:12,272
This one should be a leaf node... and so it is.

952
01:26:15,472 --> 01:26:17,992
Let's stick with leaf node now.

953
01:26:19,496 --> 01:26:25,144
At this point, it's perhaps nice
that divisible and leaf node are separate.

954
01:26:25,140 --> 01:26:39,120
So leaf node can be... [Paul dictates what he types]

955
01:26:39,120 --> 01:26:43,168
All the values inside are the same.

956
01:26:45,360 --> 01:26:47,280
Yes, they are all here.

957
01:26:47,280 --> 01:26:50,288
[Silence]

958
01:26:52,000 --> 01:26:56,264
Good, so in that case...

959
01:26:56,260 --> 01:26:59,256
[Paul thinks]

960
01:27:00,272 --> 01:27:03,640
Let's see F1 homogeneous dataset...

961
01:27:07,776 --> 01:27:11,808
Maybe we could call our method
compress or something, does that make sense?

962
01:27:11,800 --> 01:27:16,424
Or should it just be that that's all there is...

963
01:27:17,400 --> 01:27:21,384
[Paul thinks]

964
01:27:21,624 --> 01:27:27,688
Yes, that would make sense, if I have
a 4 element homogeneous dataset

965
01:27:29,504 --> 01:27:40,280
within a 16 element dataset, then maybe I can
say that I get a non leaf, a leaf ,a non leaf, a non leaf.

966
01:27:41,520 --> 01:27:45,072
And that each of those has 4
that is a leaf... does that make sense?

967
01:27:45,070 --> 01:27:48,080
[Jamie and Paul think in silence]

968
01:27:49,848 --> 01:27:50,440
JW: Yes.

969
01:27:50,440 --> 01:27:52,720
PB: So for example...

970
01:27:52,768 --> 01:27:55,776
[Silence]

971
01:27:56,680 --> 01:28:05,296
I'm going to say somewhere here, this is a
16 element dataset with 1 homogeneous quadrant.

972
01:28:05,384 --> 01:28:08,392
[Silence]

973
01:28:13,056 --> 01:28:17,816
And in case I'm going to change
this upper left quadrant to be ones.

974
01:28:20,640 --> 01:28:21,976
And then I'm going to say...

975
01:28:22,008 --> 01:28:25,016
[Paul dictates what he writes on screen]

976
01:28:50,792 --> 01:28:53,064
So now I can say...

977
01:28:53,208 --> 01:28:56,224
[Paul dictates what he writes on screen]

978
01:28:58,208 --> 01:29:01,704
In fact, I can just say inaud, so northeast.

979
01:29:01,888 --> 01:29:04,872
[Paul dictates what he writes on screen]

980
01:29:15,040 --> 01:29:18,496
JW: Well, that obviously ends the context.

981
01:29:18,490 --> 01:29:20,896
PB: Oh yes, OK.

982
01:29:23,744 --> 01:29:27,752
So that fails because we got false.

983
01:29:28,384 --> 01:29:31,400
[Paul thinks]

984
01:29:33,992 --> 01:29:36,624
JW: I think it was the NW we were expecting to be a...

985
01:29:36,620 --> 01:29:42,984
PB: Yes that would also explain why it failed.

986
01:29:45,424 --> 01:29:47,848
Oh! it does one, yes.

987
01:29:49,464 --> 01:29:53,280
[Paul thinks]

988
01:29:53,830 --> 01:30:00,016
It does not compress the other quadrants.

989
01:30:00,112 --> 01:30:03,104
[Silence]

990
01:30:04,816 --> 01:30:13,816
And I'll say for NE for example,
[Paul dictates what he rights]

991
01:30:13,920 --> 01:30:16,936
[Silence]

992
01:30:17,176 --> 01:30:18,088
Yes, so that's fine.

993
01:30:18,080 --> 01:30:20,784
[New Chapter]

994
01:30:21,640 --> 01:30:25,400
JW: I think at this point, to give us
a concrete target to work towards,

995
01:30:25,400 --> 01:30:31,896
we could maybe step out of
quadnode itself into some sort of serializer.

996
01:30:32,808 --> 01:30:38,048
Give it a root quadnode and it can walk
the tree and chop off the bits it doesn't need.

997
01:30:38,568 --> 01:30:42,416
PB: Yes so let's write a spec for that.

998
01:30:42,656 --> 01:30:44,784
Spec has got a serializer.

999
01:30:44,848 --> 01:30:47,848
[Silence]

1000
01:30:49,600 --> 01:30:52,616
JW: It might help inform the
interface of quadnode as well.

1001
01:30:52,632 --> 01:30:55,648
PB: Yes so [Paul dictates what he writes on screen]

1002
01:31:24,710 --> 01:31:31,384
It serializes to... we could say
to a single value, to an integer.

1003
01:31:32,144 --> 01:31:34,176
Or should we do an array?

1004
01:31:34,170 --> 01:31:40,632
JW: I guess the question is what do
we want the representation to be.

1005
01:31:40,630 --> 01:31:45,208
PB: For now let's say [Paul dictates what he writes]

1006
01:31:56,704 --> 01:32:00,440
Actually I'm just going to write it like inaud.

1007
01:32:00,728 --> 01:32:03,928
I think that makes more sense.

1008
01:32:05,830 --> 01:32:08,968
Actually, I'm going to need a serializer anyway.

1009
01:32:10,056 --> 01:32:17,816
[Paul dictates what he writes on screen]

1010
01:32:21,592 --> 01:32:31,968
[Paul dictates what he writes]

1011
01:32:35,968 --> 01:32:39,856
I could use some kind of locking
there, but I think I'd rather not.

1012
01:32:42,040 --> 01:32:45,792
inaud some value.

1013
01:32:46,960 --> 01:32:54,168
Then I'm going to say [Paul dictates what he writes]

1014
01:32:56,032 --> 01:32:58,024
With that node.

1015
01:33:00,000 --> 01:33:08,616
And then say [Paul dictates what he writes]

1016
01:33:09,192 --> 01:33:15,936
It's actually not strictly serialize,
given that we've got an array of values but...

1017
01:33:17,616 --> 01:33:20,280
maybe that's OK for now.

1018
01:33:20,280 --> 01:33:26,384
JW: Maybe you could take the\approach of giving it to a method, or a...

1019
01:33:27,824 --> 01:33:28,608
PB: Yes.

1020
01:33:28,600 --> 01:33:32,528
JW: I imagine you could potentially...

1021
01:33:32,520 --> 01:33:34,368
turn these quadnodes into a json.

1022
01:33:34,376 --> 01:33:41,736
PB: I agree, let's give it a inaud and that will give us something nice.

1023
01:33:41,776 --> 01:33:45,520
And now I should have... 42

1024
01:33:45,584 --> 01:33:48,568
[Silence]

1025
01:33:50,008 --> 01:33:55,576
Yes, it definitely doesn't work
because I say def initialize with a node.

1026
01:33:57,360 --> 01:34:01,584
Actually let's call that root because
it's a bit clearer what we're doing.

1027
01:34:01,640 --> 01:34:04,640
[Silence]

1028
01:34:07,912 --> 01:34:12,272
And I'm going to say [Paul dictates what he writes]

1029
01:34:12,288 --> 01:34:17,200
And then, root.rows, which I
think will give us everything we want.

1030
01:34:18,776 --> 01:34:23,808
Or not... [Paul laughs]... requires a serializer.

1031
01:34:23,856 --> 01:34:26,840
[Silence]

1032
01:34:31,016 --> 01:34:33,976
inaud

1033
01:34:34,056 --> 01:34:37,072
[Silence]

1034
01:34:38,896 --> 01:34:43,024
OK, so let's say context...

1035
01:34:44,990 --> 01:34:56,288
So it's leaped straight into...
with a 4 heterogeneous... 4-item node.

1036
01:34:56,328 --> 01:34:59,320
[Silence]

1037
01:34:59,656 --> 01:35:05,688
[Paul dictates what he writes]

1038
01:35:08,664 --> 01:35:14,900
That, in fact I can copy out of
here, where I have a heterogeneous thing.

1039
01:35:16,350 --> 01:35:18,552
Like that.

1040
01:35:18,584 --> 01:35:21,592
[Silence]

1041
01:35:24,280 --> 01:35:31,490
Then I should get [1,2] ,[3,4]

1042
01:35:35,000 --> 01:35:37,830
So now I need to deal with the homogeneous dataset.

1043
01:35:37,904 --> 01:35:40,960
[Silence]

1044
01:35:49,848 --> 01:35:59,696
That's a 2, and it serializes
to a single row and column.

1045
01:36:02,720 --> 01:36:07,384
JW: So this is curious because how do we...

1046
01:36:07,480 --> 01:36:12,384
With this serialization format, we can't,
at the moment, tell the difference between...

1047
01:36:13,270 --> 01:36:18,360
A. What started of as a one item node and inaud

1048
01:36:18,392 --> 01:36:22,192
PB: I was thinking about that but
then I realised that it doesn't matter,

1049
01:36:22,190 --> 01:36:33,568
because suppose you're reconstructing
a picture and it only has one color,

1050
01:36:34,120 --> 01:36:38,220
it doesn't matter how big you
make it, you get the same input.

1051
01:36:38,320 --> 01:36:41,792
Having thought about that,
I'm not sure about this actually.

1052
01:36:42,120 --> 01:36:48,760
If it is important we could sort out a inaud as a target size.

1053
01:36:51,840 --> 01:37:00,520
In our case, it should be possible to
reconstruct it by one walk through the trees or...

1054
01:37:00,520 --> 01:37:02,960
so when you get to the
bottom you will have enough data

1055
01:37:02,992 --> 01:37:06,320
to work out what the minimal representation is.

1056
01:37:06,320 --> 01:37:08,064
JW: OK.

1057
01:37:08,304 --> 01:37:11,460
PB: Well yes, it might make trying interesting.

1058
01:37:11,776 --> 01:37:15,688
I don't think it's an inherent
property of a quad tree though is it?

1059
01:37:17,520 --> 01:37:18,856
We'll see.

1060
01:37:19,712 --> 01:37:24,280
JW: Yes inaud we've not specified any kind of serialization format.

1061
01:37:26,512 --> 01:37:31,112
So serializer... let's say... [Paul thinks]

1062
01:37:35,048 --> 01:37:38,696
The simplest way to make
the tests pass, of course is to say...

1063
01:37:39,150 --> 01:37:43,424
if root.leaf... and then do that.

1064
01:37:45,200 --> 01:37:48,304
Otherwise, do something else
but I don't think that's quite...

1065
01:37:51,224 --> 01:37:56,240
JW: I suppose we could re-curse,
but it might not make any difference,

1066
01:37:56,240 --> 01:38:00,576
because inaud doesn't change whether it's a leaf or not.

1067
01:38:00,570 --> 01:38:02,632
PB: No, exactly.

1068
01:38:02,680 --> 01:38:08,824
JW: I guess you could flattening
and uniquing in here perhaps.

1069
01:38:09,816 --> 01:38:11,680
It seems a bit like implication.

1070
01:38:11,680 --> 01:38:13,776
PB: Yes, it does erm.....

1071
01:38:13,840 --> 01:38:16,824
[Silence]

1072
01:38:21,472 --> 01:38:24,776
How about if I said...

1073
01:38:24,856 --> 01:38:27,864
[Silence]

1074
01:38:31,368 --> 01:38:36,064
inaud, in fact our serializer might end up not doing anything at this point,

1075
01:38:36,120 --> 01:38:40,520
but maybe we will want to take the
array and turn it back into a string later on.

1076
01:38:41,520 --> 01:38:44,392
but it's still a good way of
driving out our API perhaps.

1077
01:38:46,936 --> 01:38:50,984
So maybe if we said that we wanted some way of...

1078
01:38:50,980 --> 01:38:53,976
[Paul thinks]

1079
01:38:56,664 --> 01:39:00,712
So we could make our serializer
a recursive effect actually.

1080
01:39:04,640 --> 01:39:09,280
JW: If it's a leaf we want an array
back containing that one value.

1081
01:39:11,448 --> 01:39:14,016
This is a bit ugly but I just want to try it...

1082
01:39:14,904 --> 01:39:17,568
[Paul dictates what he writes]

1083
01:39:31,616 --> 01:39:36,824
This will work but I still need
something else to make it work.

1084
01:39:38,710 --> 01:39:42,376
So that works, but in the
case of  having something deeper,

1085
01:39:42,416 --> 01:39:47,320
so I'm going to take one of
our quadnodes back, to take this one

1086
01:39:48,930 --> 01:39:54,648
that has one homogeneous
quadrant... just that part of it.

1087
01:39:56,448 --> 01:40:00,110
And then serialize the spec... let's see...

1088
01:40:00,160 --> 01:40:03,168
[Silence]

1089
01:40:07,720 --> 01:40:10,176
That's quite a nice name for it.

1090
01:40:10,240 --> 01:40:13,264
[Silence]

1091
01:40:25,528 --> 01:40:30,040
I could pull this up to the top
because it's the same everywhere.

1092
01:40:30,424 --> 01:40:33,424
It's just the node that varies according to context.

1093
01:40:33,488 --> 01:40:36,480
[Silence]

1094
01:40:38,960 --> 01:40:41,472
So now I  can say...

1095
01:40:41,544 --> 01:40:44,544
[Silence]

1096
01:40:45,144 --> 01:40:47,456
Let node be that.

1097
01:40:47,520 --> 01:40:50,552
[Silence]

1098
01:40:52,584 --> 01:40:55,864
And this one will be the real test.

1099
01:40:57,816 --> 01:41:01,712
But I'm going to say it serializes to...

1100
01:41:02,960 --> 01:41:05,952
[Paul thinks]

1101
01:41:07,472 --> 01:41:12,312
[Paul dictates what he writes]

1102
01:41:20,712 --> 01:41:23,888
That kind of makes sense to me, so now...

1103
01:41:23,880 --> 01:41:26,872
[Silence]

1104
01:41:27,304 --> 01:41:30,208
I mostly want this data.

1105
01:41:31,040 --> 01:41:35,480
I want this to equal... [Paul thinks]

1106
01:41:36,928 --> 01:41:40,664
I want one for that part.

1107
01:41:41,448 --> 01:41:46,336
Then I want three, (sorry, it's
the other way around isn't it?)

1108
01:41:47,330 --> 01:41:55,048
I want to start at inaud... so I want 3,4,7 and 8.

1109
01:41:55,820 --> 01:42:00,192
Which is the northwest
quadrant, which is just one thing.

1110
01:42:01,584 --> 01:42:07,904
Then I want the southwest one which is 9,10,13 and 14.

1111
01:42:10,880 --> 01:42:18,024
And then the remaining
quadrant which is 11,12... Hang on!

1112
01:42:20,032 --> 01:42:27,112
I'm doing this wrong... No, it's fine, sorry,
I was just realizing that I've got different data

1113
01:42:28,376 --> 01:42:31,064
It's in a different order when
it's in arrays but that's OK.

1114
01:42:31,060 --> 01:42:37,408
JW: This is interesting because it's
the first spec that demonstrates the

1115
01:42:37,528 --> 01:42:40,480
compressing quality of the quadtree.

1116
01:42:40,530 --> 01:42:43,528
[Silence]

1117
01:42:46,104 --> 01:42:51,160
PB: I'm just going to split this up a bit so
it's a bit clearer which one's which node.

1118
01:42:51,272 --> 01:42:54,272
[Silence]

1119
01:43:01,952 --> 01:43:05,792
JW: So you can see one quadrant
is compressed down to single figures.

1120
01:43:05,790 --> 01:43:09,792
PB: Yes, so there we got...
something completely different!

1121
01:43:11,536 --> 01:43:17,520
And the reason is because we've just
called rows and columns... is that right?

1122
01:43:17,520 --> 01:43:26,344
JW: Can I suggest an alternative...
let's just re-wind to the other case,

1123
01:43:26,440 --> 01:43:31,728
where I was wondering whether it
was the correct serialization or not.

1124
01:43:31,720 --> 01:43:35,320
So when we ended up with 2 by itself

1125
01:43:35,320 --> 01:43:38,392
PB: It's not, because it should inaud.

1126
01:43:38,432 --> 01:43:41,448
[Silence]

1127
01:43:43,344 --> 01:43:47,080
That one ?
JW: Yes. PB: yes it does doesn't it?

1128
01:43:48,992 --> 01:43:53,336
But I also think that another thing is wrong...

1129
01:43:54,920 --> 01:44:03,872
I think that the way we serialize
it should be in the same order.

1130
01:44:04,040 --> 01:44:07,056
[Paul thinks]

1131
01:44:08,008 --> 01:44:15,128
The thing that is confusing is that we want...

1132
01:44:15,120 --> 01:44:18,152
[Paul thinks]

1133
01:44:18,528 --> 01:44:27,552
We know node looks like that, or we've
decided a node is just the rows and columns.

1134
01:44:30,224 --> 01:44:32,624
Except...

1135
01:44:32,672 --> 01:44:35,520
[Paul thinks]

1136
01:44:37,376 --> 01:44:41,240
I'm thinking that our
serialization should form out of that.

1137
01:44:42,912 --> 01:44:45,056
I'm just going to write it here.

1138
01:44:46,832 --> 01:44:49,136
I'm going to ignore the inaud for now.

1139
01:44:49,592 --> 01:44:52,744
[Paul dictates what he writes]

1140
01:44:58,536 --> 01:45:00,928
X which is 1.

1141
01:45:03,024 --> 01:45:06,792
Then it should be... [Paul dictates what he writes]

1142
01:45:22,224 --> 01:45:23,608
JW: Yes.

1143
01:45:23,640 --> 01:45:26,008
PB: Yes, that's how the serialization should be.

1144
01:45:26,008 --> 01:45:28,000
JW: Agreed.

1145
01:45:28,552 --> 01:45:32,488
So it's OK if we create
something with linear data but...

1146
01:45:32,528 --> 01:45:35,528
[Silence]

1147
01:45:38,560 --> 01:45:42,088
JW: Yes, and in fact that
demonstrates the compression even better.

1148
01:45:42,080 --> 01:45:44,000
PB: Yes.

1149
01:45:44,024 --> 01:45:46,888
So let's revisit these earlier ones.

1150
01:45:47,864 --> 01:45:51,104
That should compress down to just 2.

1151
01:45:52,152 --> 01:45:53,128
That.

1152
01:45:53,128 --> 01:45:55,120
JW: Yes, indeed.

1153
01:45:57,304 --> 01:46:00,704
Oh no, in fact, it maybe still should be in an array.

1154
01:46:03,456 --> 01:46:06,096
PB: If we do that then, each of these should be an array

1155
01:46:06,096 --> 01:46:08,090
and each of these should be an array.

1156
01:46:08,090 --> 01:46:10,824
[Jamie thinks about that]

1157
01:46:14,620 --> 01:46:20,296
It's one way of doing it, but at some point
we have to come down to whatever our base value is

1158
01:46:20,290 --> 01:46:26,408
and that's either an individual value
in an array or it's a fair number.

1159
01:46:28,384 --> 01:46:35,304
JW: Yes, inaud number is fine, maybe 2A is not the right method name anymore.

1160
01:46:36,512 --> 01:46:40,432
PB So yes... [Paul dictates what he writes]

1161
01:46:40,504 --> 01:46:43,520
[Silence]

1162
01:46:48,280 --> 01:46:54,050
Is it to array...? (I'll check it later)

1163
01:46:56,368 --> 01:47:01,952
So this one should be 2,1,3,4

1164
01:47:01,950 --> 01:47:04,952
[Silence]

1165
01:47:05,400 --> 01:47:07,912
This one should be just lone 2.

1166
01:47:10,240 --> 01:47:14,880
JW: I guess if the dimensions are
kept externally, as you mentioned earlier,

1167
01:47:15,120 --> 01:47:21,352
then combining this value structure with
the dimensions, allows you to read those.

1168
01:47:22,136 --> 01:47:25,816
PB: Yes. inaud, that's fine.

1169
01:47:27,280 --> 01:47:29,800
If it's a leaf it should just be the bare inaud

1170
01:47:31,896 --> 01:47:36,944
otherwise, and this will not
completely work, but I'm going to say...

1171
01:47:36,940 --> 01:47:41,288
[Paul dictates what he writes]

1172
01:47:43,840 --> 01:47:47,000
Actually I think if I make it inaud

1173
01:47:47,104 --> 01:47:50,296
[Paul dictates what he types]

1174
01:47:51,272 --> 01:47:53,840
I don't like this already. [laughter]

1175
01:47:53,840 --> 01:47:56,840
[Silence]

1176
01:47:58,248 --> 01:48:00,080
Serializer is a new node.

1177
01:48:03,048 --> 01:48:06,936
It's kind of horrible but... I think it might work.

1178
01:48:08,344 --> 01:48:12,768
JW: Wow, cool.

1179
01:48:14,552 --> 01:48:16,864
PB: I don't know why I feel it's horrible, erm....

1180
01:48:17,200 --> 01:48:24,608
JW: It does feel like the serializer need
not be separate, but it gave us a space to

1181
01:48:25,190 --> 01:48:28,000
jump out of the internals of quadnode.

1182
01:48:28,000 --> 01:48:35,264
PB: Yes... I'm just going to see if
I can find a better name for 2A.

1183
01:48:35,352 --> 01:48:38,376
[Silence]

1184
01:48:40,720 --> 01:48:42,704
Maybe I'm just going to call it serialize.

1185
01:48:42,700 --> 01:48:45,520
JW: Maybe if you called it values.

1186
01:48:48,648 --> 01:48:50,704
PB: Or 'value'.

1187
01:48:50,736 --> 01:48:52,984
JW: Yes, something like that.

1188
01:48:54,152 --> 01:48:57,008
PB: Yes, it's as good as anything I think.

1189
01:48:57,776 --> 01:49:00,608
Change inaud

1190
01:49:00,664 --> 01:49:03,640
[Paul checks the changes]

1191
01:49:03,712 --> 01:49:06,720
[Silence]

1192
01:49:07,096 --> 01:49:09,344
OK let's commit that.

1193
01:49:09,416 --> 01:49:12,416
[Silence]

1194
01:49:13,264 --> 01:49:16,536
What have we changed?  As yes, we changed leaf

1195
01:49:16,600 --> 01:49:19,608
[Silence]

1196
01:49:27,176 --> 01:49:35,672
JW: I wonder if we've now got enough
in place to approach it from the other side,

1197
01:49:36,256 --> 01:49:42,616
and given that this structure that
the serializer produces, plus the dimensions...

1198
01:49:43,080 --> 01:49:44,736
PB: Can we reconstruct it? JW: Yes.

1199
01:49:44,750 --> 01:49:47,568
PB: Yes, that seems like a nice thing to do.

1200
01:49:48,632 --> 01:49:57,230
We can make it a proper serializer
by saying 2S which is a JSON serialization.

1201
01:49:59,224 --> 01:50:03,952
I'll say require json - that's in
the standard library these days.

1202
01:50:05,288 --> 01:50:08,272
And we'll just say... [Paul dictates what he writes]

1203
01:50:11,560 --> 01:50:15,080
inaud, or inaud actually.

1204
01:50:15,976 --> 01:50:18,984
JSON.dump? JW: Yes.

1205
01:50:21,040 --> 01:50:25,240
PB: So that should hide a whole
bunch of things... unless I actually test it.

1206
01:50:25,640 --> 01:50:29,640
JW: If you change all these current tests
to use 2S instead, then we don't have to...

1207
01:50:30,080 --> 01:50:31,760
deal with the inaud value anymore.

1208
01:50:31,792 --> 01:50:33,864
PB: Yes, let's make that private.

1209
01:50:36,512 --> 01:50:39,760
Hide our shame somewhere [laughter].

1210
01:50:40,912 --> 01:50:44,472
[Paul dictates what he writes]

1211
01:50:47,432 --> 01:50:50,896
[Paul checks the changed values]

1212
01:50:50,890 --> 01:50:53,888
And then... [Paul thinks]

1213
01:50:55,800 --> 01:50:59,704
I hope the spacing is the same...
we might find it's not in the end.

1214
01:50:59,952 --> 01:51:02,448
Let's try one of them first and see...

1215
01:51:03,200 --> 01:51:06,056
... program value called...

1216
01:51:07,856 --> 01:51:11,224
Ah! Yes, that doesn't work because...

1217
01:51:12,136 --> 01:51:15,520
we cant get the inaud, not yet anyway, but we will.

1218
01:51:15,520 --> 01:51:18,648
Could we have 'protected'? I'm
never quite sure how that works.

1219
01:51:19,880 --> 01:51:22,328
Do they work like friend methods?

1220
01:51:22,520 --> 01:51:25,592
JW: That's the first time I've ever
seen a reason to use protected.

1221
01:51:25,610 --> 01:51:33,568
PB: Yes, and it's a bad reason I think, bu
 apart for all the extra spaces, which we can say...

1222
01:51:33,624 --> 01:51:36,616
[Silence]

1223
01:51:47,440 --> 01:51:52,192
inaud I'll do the same for the
other ones, which are much shorter so...

1224
01:51:52,248 --> 01:51:55,248
[Silence]

1225
01:51:56,328 --> 01:51:58,336
That's easier... 

1226
01:51:59,128 --> 01:52:01,072
This one is...

1227
01:52:01,160 --> 01:52:04,152
[Silence]

1228
01:52:10,824 --> 01:52:15,112
Well actually, my test name was completely wrong.

1229
01:52:15,200 --> 01:52:18,216
[Paul thinks]

1230
01:52:18,520 --> 01:52:23,456
Check the serializer has rows and columns in inaud....

1231
01:52:25,464 --> 01:52:27,488
[Paul dictates what he writes]

1232
01:52:27,560 --> 01:52:30,544
[Silence]

1233
01:52:32,992 --> 01:52:34,848
So it's a single value.

1234
01:52:36,820 --> 01:52:40,120
I don't know if any of this is really important but...

1235
01:52:40,688 --> 01:52:43,872
Yes, I think that's cool, let's see if it works.

1236
01:52:45,072 --> 01:52:47,208
OK, let's add that.

1237
01:52:49,672 --> 01:52:51,640
Yes.

1238
01:52:51,712 --> 01:52:54,712
[Silence]

1239
01:52:56,472 --> 01:53:00,048
JW: It actually serialized. [Laughter]

1240
01:53:00,104 --> 01:53:03,120
[Silence]

1241
01:53:04,056 --> 01:53:07,104
[New Chapter]

1242
01:53:07,800 --> 01:53:14,260
PB: So let's look at our print bmp. I'm gong to
pull this out into a class so we can use it on it's own.

1243
01:53:14,664 --> 01:53:19,800
We don't really test for this,
we test ad-hoc but that's alright.

1244
01:53:20,160 --> 01:53:22,664
[Paul dictates what he writes]

1245
01:53:23,880 --> 01:53:25,904
inaud

1246
01:53:26,328 --> 01:53:31,832
So now I want to see just how much we do compress.

1247
01:53:31,896 --> 01:53:34,872
[Paul thinks]

1248
01:53:38,656 --> 01:53:42,488
I'm going to close this path because
it doesn't seem useful any more.

1249
01:53:42,640 --> 01:53:47,728
I need a new file called something like dump, err...

1250
01:53:47,784 --> 01:53:50,784
[Paul thinks]

1251
01:53:53,080 --> 01:53:55,624
... dot image or something.

1252
01:53:56,520 --> 01:53:59,128
And I'm going to say require...

1253
01:53:59,208 --> 01:54:02,864
[Silence]

1254
01:54:03,688 --> 01:54:06,744
bnp image, so that I can load it.

1255
01:54:06,740 --> 01:54:12,008
I'm going to require
serializer, so that I can serialize it.

1256
01:54:13,500 --> 01:54:19,552
And I'm going to require quadnode.

1257
01:54:19,616 --> 01:54:22,208
I've already forgotten my inaud.

1258
01:54:22,232 --> 01:54:25,240
[Paul thinks]

1259
01:54:26,160 --> 01:54:29,664
So now we can say, for example...

1260
01:54:31,824 --> 01:54:36,864
We've got JSON, so first of all let's say...

1261
01:54:36,944 --> 01:54:39,952
[Paul thinks]

