1
00:00:01,224 --> 00:00:02,976
NARRATOR: Welcome to Peer to Peer

2
00:00:02,976 --> 00:00:06,776
where you can hone your skills
by watching live coding videos.

3
00:00:07,904 --> 00:00:10,424
Our guest today is Paul Battley.

4
00:00:10,420 --> 00:00:12,120
Who is a veteran Ruby developer,

5
00:00:12,120 --> 00:00:15,824
who has worked with agencies,
startups and Government departments.

6
00:00:17,080 --> 00:00:21,248
Our host is Jamie White, and the
challenge that he has set for Paul is called

7
00:00:21,472 --> 00:00:24,128
Encoding Images As Quad Trees.

8
00:00:25,992 --> 00:00:30,384
Jamie White: OK, so how about
we start by reading the challenge?

9
00:00:30,720 --> 00:00:32,224
Paul Battley: OK, so...

10
00:00:32,272 --> 00:00:37,992
Write a program to convert a given binary
image into a quad tree and serialize it to disk.

11
00:00:38,248 --> 00:00:43,352
Write another program to take a
serialized quad tree and turn it back into an image.

12
00:00:43,460 --> 00:00:47,608
The quad tree for an image is generated
by splitting the image into four quadrants

13
00:00:47,608 --> 00:00:51,152
then successively splitting each
of these into further quadrants.

14
00:00:51,176 --> 00:00:55,952
When a quadrant consists of a single
color, it may be considered a terminal node.

15
00:00:57,400 --> 00:01:03,880
JW: I have provided this beautiful
binary image for you to work with.

16
00:01:03,880 --> 00:01:07,280
PB: Not quite the right time,
depending on when your watching this.

17
00:01:07,312 --> 00:01:10,656
JW: It's in a Windows 1Bit bitmap format.

18
00:01:10,650 --> 00:01:14,048
So, it's up to you how you make use of that.

19
00:01:14,128 --> 00:01:17,310
[New Chapter]

20
00:01:17,552 --> 00:01:22,950
PB: So the first thing we want
to do is pass the bitmap file.

21
00:01:22,950 --> 00:01:36,832
If I recall correctly, that's a bunch of
bytes, and huge bits of each byte is an image.

22
00:01:37,136 --> 00:01:42,176
I don't know which order it goes in so
I'm going to look it up on Wikipedia and find out.

23
00:01:42,170 --> 00:01:45,560
Inaudible.

24
00:01:45,976 --> 00:01:51,064
So I'll look up the BMP file format.

25
00:01:53,810 --> 00:01:58,728
Been through that, OK what
have I got... Pixel array inaudible.

26
00:01:58,790 --> 00:02:01,848
I hope it's not compressed. I guess we'll find out.

27
00:02:02,630 --> 00:02:06,640
If it is we can find some other way of processing it.

28
00:02:07,290 --> 00:02:13,112
1 bit pixel. Each bit is
indexed into a table of two colors.

29
00:02:14,450 --> 00:02:18,776
That's interesting, so inaudible
colors even though there's only two.

30
00:02:18,816 --> 00:02:21,904
We don't really need to...

31
00:02:21,900 --> 00:02:26,432
In our case it doesn't really
matter, as long as we're consistent.

32
00:02:27,368 --> 00:02:33,088
So... I suggest that we look
at the file to see how long it is.

33
00:02:33,080 --> 00:02:36,072
[Silence]

34
00:02:37,120 --> 00:02:42,048
Ls - L on whatever .bmp

35
00:02:43,800 --> 00:02:45,816
8256 bytes.

36
00:02:46,664 --> 00:02:49,888
And... do we know the size of it?

37
00:02:49,880 --> 00:02:53,768
We can find that out with identify.

38
00:02:56,336 --> 00:02:59,328
Inaudible.

39
00:02:59,560 --> 00:03:09,432
256 by 256 would be 64K except that
we're less 8 bits of a pixel... so 8 pixels.

40
00:03:09,712 --> 00:03:16,240
Sorry pixels per byte, so inaudible so 856 sounds just about right.

41
00:03:17,456 --> 00:03:19,128
So it's not compressed.

42
00:03:19,752 --> 00:03:27,744
And according to this, it's just
the end of the file so I can probably...

43
00:03:28,180 --> 00:03:31,512
ignore the header and just take the pixels.

44
00:03:31,720 --> 00:03:39,040
So I'm going to write a bit of
code that reads in this bitmap,

45
00:03:39,470 --> 00:03:45,072
and spits out the pixels as,
maybe hashes and spaces on screen.

46
00:03:45,070 --> 00:03:47,608
That should give us an idea of whether its working.

47
00:03:47,600 --> 00:03:51,000
Inaudible and a bit wierd, but we'll work it out.

48
00:03:51,696 --> 00:03:58,768
So I'm going to play around, and call this print-bmp.rb.

49
00:03:59,664 --> 00:04:06,192
And now I'm going to say something like...

50
00:04:06,440 --> 00:04:10,624
I can load it all into memory... bits = File.read.

51
00:04:10,620 --> 00:04:18,224
I could use ARGF here but I'm going to use
ARGV first because I want to specify the encoding.

52
00:04:18,680 --> 00:04:23,832
JW: So ARGF gives you the final pass
into the command rather than inaudible

53
00:04:27,180 --> 00:04:32,504
PB: Well it gives you both so you can either inaudible something or it will give you the first one.

54
00:04:33,000 --> 00:04:37,832
Its very handy but I'm not
sure how that would handle inaudible.

55
00:04:38,080 --> 00:04:41,176
I know that we need to be
able to handle the inaudible.

56
00:04:41,180 --> 00:04:45,144
ARGV, I think it's...

57
00:04:45,140 --> 00:04:48,032
Inaudible encoding...

58
00:04:48,030 --> 00:04:51,144
[Silence]

59
00:04:53,368 --> 00:04:56,728
ASCII 8 Bit,

60
00:04:57,480 --> 00:05:00,024
which is not ASCII actually but...

61
00:05:03,656 --> 00:05:06,008
Let's say that's byte.

62
00:05:07,888 --> 00:05:12,216
And then I can say "print how many bytes I have got".

63
00:05:13,984 --> 00:05:18,000
Which should be something like 256, if that works.

64
00:05:18,560 --> 00:05:22,808
So I'm going to split this screen.

65
00:05:22,800 --> 00:05:26,632
Actually, no I'll make a new inaudible.

66
00:05:30,250 --> 00:05:32,400
Quad trees...

67
00:05:32,808 --> 00:05:38,696
Now if I say Ruby and print
bnp and give it a style of bnp.

68
00:05:39,840 --> 00:05:42,016
Inaudible array to string.

69
00:05:42,856 --> 00:05:46,824
ARGV [They both talk at once]

70
00:05:51,152 --> 00:05:55,408
OK so I'm going to read inaudible, that seems right.

71
00:05:59,270 --> 00:06:01,456
I'm going to hard code the width and height.

72
00:06:01,470 --> 00:06:08,632
So I'm going to say width
equals 256 and height  equals 256

73
00:06:08,630 --> 00:06:16,832
And then I'm going to say
that image bytes is bytes from...

74
00:06:18,040 --> 00:06:27,432
Actually let's just say minus
width, width x height to the end.

75
00:06:29,752 --> 00:06:33,088
Then if I go... make that one image bytes

76
00:06:33,080 --> 00:06:36,712
[Silence]

77
00:06:36,712 --> 00:06:38,710
Put some space in there.

78
00:06:42,208 --> 00:06:46,760
I can run this at inaudible percent.

79
00:06:49,376 --> 00:06:50,968
Inaudible.

80
00:06:52,464 --> 00:06:56,000
And define the length nil nil class by 5.

81
00:06:56,056 --> 00:06:59,040
[Silence]

82
00:06:59,856 --> 00:07:02,008
That's interesting.

83
00:07:02,440 --> 00:07:04,872
Apparently image bytes is nil.

84
00:07:06,896 --> 00:07:09,624
Let's see if that's really true.

85
00:07:09,620 --> 00:07:12,584
[Silence]

86
00:07:14,528 --> 00:07:17,400
Yes, why is that nil?

87
00:07:17,832 --> 00:07:20,968
I know that bytes works.

88
00:07:20,960 --> 00:07:23,936
[Silence]

89
00:07:24,800 --> 00:07:26,128
Maybe it's confused by...

90
00:07:26,120 --> 00:07:30,528
JW: Is that all bytes are like a string?

91
00:07:30,520 --> 00:07:32,888
PB: Your right, exactly.

92
00:07:32,880 --> 00:07:35,896
[Silence]

93
00:07:36,880 --> 00:07:43,536
PB: So in that case, maybe I should
just unpack it into an array of bytes.

94
00:07:43,530 --> 00:07:46,552
[Silence]

95
00:07:50,936 --> 00:07:53,904
Inaudible again.

96
00:07:57,152 --> 00:07:59,720
JW: I rarely use the unpack method.

97
00:08:00,328 --> 00:08:02,504
That notation... what does it mean?

98
00:08:03,648 --> 00:08:12,880
PB: If I recall correctly, that C means that
each byte will be unpacked as its byte.

99
00:08:12,880 --> 00:08:17,920
So you will get an array of integers
that are the byte value of each character.

100
00:08:21,176 --> 00:08:25,464
[Paul thinks]

101
00:08:28,128 --> 00:08:34,240
Let's just try saying leave bytes
and just take 10 of them or something.

102
00:08:34,270 --> 00:08:39,152
In fact, I'm going to say take 10 and
see if I've got something sensible there.

103
00:08:39,176 --> 00:08:42,208
[Silence]

104
00:08:45,856 --> 00:08:49,272
Yes, that seems useful.

105
00:08:51,920 --> 00:08:56,880
In fact I could also say bytes dot...

106
00:08:58,296 --> 00:09:00,464
Yes, in fact...

107
00:09:02,976 --> 00:09:05,232
So I've got an array...

108
00:09:07,776 --> 00:09:11,088
Where is 256?  Ah, there is my problem, right there.

109
00:09:11,128 --> 00:09:15,784
The width is the number of bits.

110
00:09:16,000 --> 00:09:19,704
I want it to be the number of
characters, so it's width x height.

111
00:09:20,312 --> 00:09:29,344
And let's say bits per pixels... is that what it says?

112
00:09:32,976 --> 00:09:36,264
Hard code here, I think we know what 8 is.

113
00:09:36,720 --> 00:09:42,256
Width x height, this is all assuming
it's multiples of 8 and in this case it is.

114
00:09:45,016 --> 00:09:49,880
8192 that's the number I was
looking for, that's the power of 2.

115
00:09:50,768 --> 00:09:54,904
JW: Would you mind printing out the
difference between bytes.length and image bytes?

116
00:09:54,900 --> 00:09:56,280
Just to see how big the header is.

117
00:09:56,280 --> 00:09:58,368
PB: Yes, that's a good idea.

118
00:09:58,360 --> 00:10:03,624
So bytes.length minus image bytes.length.

119
00:10:03,620 --> 00:10:06,712
[Silence]

120
00:10:10,456 --> 00:10:12,544
64 bytes.

121
00:10:14,264 --> 00:10:18,008
That's good so let's see... inaudible.

122
00:10:18,848 --> 00:10:34,416
So in fact... I could say header - bytes.take 64
and then I could say image bytes.drop.

123
00:10:34,456 --> 00:10:38,232
I'm not sure if that's sensible though
because the header might change.

124
00:10:38,904 --> 00:10:47,392
So instead I'm going to say
header equals bytes.take... that much.

125
00:10:49,592 --> 00:10:53,408
So I've now got the image
the bytes and the header.

126
00:10:53,400 --> 00:10:55,104
Now let's try to draw the image

127
00:10:55,100 --> 00:10:57,176
So I'm going to say...

128
00:10:59,688 --> 00:11:01,512
(What's the best way to do this...?)

129
00:11:02,704 --> 00:11:14,424
Say height.times do - that can be Y
and width.times do and that can be our X.

130
00:11:14,464 --> 00:11:17,472
[Paul thinks]

131
00:11:20,056 --> 00:11:23,096
Then we should in fact...

132
00:11:26,112 --> 00:11:28,176
inaudible it's not going to do it.

133
00:11:28,170 --> 00:11:31,200
[Silence]

134
00:11:33,480 --> 00:11:40,016
So then our byte is going to be the image bytes.

135
00:11:41,040 --> 00:11:48,880
And the index of width over 8 x Y.

136
00:11:48,952 --> 00:11:51,832
[Silence]

137
00:11:52,650 --> 00:11:54,896
Plus X.

138
00:11:57,176 --> 00:12:04,696
And then we want 8.times do,
what shall we call this one - i.

139
00:12:05,848 --> 00:12:07,896
Inaudible

140
00:12:07,960 --> 00:12:12,152
So for each of these I'm going to say...

141
00:12:14,830 --> 00:12:21,216
I want to find the inaudible bit of it,
but I don't know which way round they are do I?

142
00:12:21,224 --> 00:12:23,176
JW: Ah, that's true.

143
00:12:23,170 --> 00:12:25,104
Inaudible

144
00:12:26,704 --> 00:12:29,792
PB: Maybe it will say in Wikipedia.

145
00:12:29,790 --> 00:12:32,896
[Silence]

146
00:12:36,808 --> 00:12:42,480
It's probably reasonable to assume
that the most significant ones on the left,

147
00:12:42,544 --> 00:12:45,400
Like numbers are.

148
00:12:48,408 --> 00:12:53,704
Yes, so if I start off with my, (a kind of ugly
way of doing it but it will work for now).

149
00:12:53,700 --> 00:12:58,816
If I start off with my bit mask, I want to be...

150
00:12:58,810 --> 00:13:01,808
[Silence]

151
00:13:02,720 --> 00:13:09,336
Yes, in fact this ought to work well,
so bitmask wants to be Ob1OOOOOOO.

152
00:13:09,656 --> 00:13:19,024
Then my bit is just bitmask white shifted by i.

153
00:13:19,248 --> 00:13:23,816
So that's going to be starting
from zero and then increasing.

154
00:13:24,140 --> 00:13:31,040
And I can take that and inaudible that with the byte.

155
00:13:33,176 --> 00:13:39,072
And then take the whole thing...

156
00:13:39,070 --> 00:13:42,112
[Paul thinks]

157
00:13:44,296 --> 00:13:51,864
And then right shift the whole thing by 8 bytes.

158
00:13:51,860 --> 00:13:56,128
So my first one will be a
right shift by nothing inaudible.

159
00:13:57,568 --> 00:14:02,136
Yes, so my first one will be right shifted
by 8, which means it's the least significant.

160
00:14:02,672 --> 00:14:04,920
It;s like program C isn't it? [Laughter]

161
00:14:04,920 --> 00:14:13,832
OK, so now I am just going to say print bit to S.

162
00:14:13,830 --> 00:14:16,856
[Paul thinks]

163
00:14:19,020 --> 00:14:29,568
Or maybe I'll do print bit equals 1 # space.

164
00:14:29,600 --> 00:14:31,392
That should be more readable.

165
00:14:31,390 --> 00:14:36,920
And then at the end of each row is a put

166
00:14:39,008 --> 00:14:42,448
Alright... we will see.

167
00:14:45,320 --> 00:14:47,592
Let's try this again.

168
00:14:47,590 --> 00:14:49,560
We got all zeros.

169
00:14:49,560 --> 00:14:55,664
JW: The features in the image are down towards
the bottom so presumably we didn't hit them yet.

170
00:14:55,680 --> 00:15:03,670
PB: That's true, it might be
worth shrinking the text size.

171
00:15:04,856 --> 00:15:07,496
No that's definitely all zeros.

172
00:15:08,168 --> 00:15:11,312
So have I got this right...

173
00:15:11,310 --> 00:15:14,320
[Paul thinks]

174
00:15:14,320 --> 00:15:18,040
JW: We could just try printing the bits to begin with.
PB: Yes.

175
00:15:18,040 --> 00:15:21,040
[Silence]

176
00:15:23,872 --> 00:15:26,672
There's the zeros.

177
00:15:26,670 --> 00:15:31,176
inaudible line banks which looks about right doesn't it?

178
00:15:31,170 --> 00:15:35,200
I'm not sure how many
characters I've got across actually but...

179
00:15:35,888 --> 00:15:38,920
1234567890

180
00:15:41,392 --> 00:15:46,040
Yes, it looks about right for the length
of the line. That seems inaudible.

181
00:15:48,880 --> 00:15:51,840
How about instead of this, I just print out the byte?
JW: Yes.

182
00:15:53,344 --> 00:15:59,912
So I'll skip that and just say print byte.to S

183
00:16:02,648 --> 00:16:05,376
That looks promising.

184
00:16:05,370 --> 00:16:13,376
Hey, I can kind of see the shape. In fact if
you squint maybe you can see the hands there.

185
00:16:13,384 --> 00:16:14,056
JW: Yes.

186
00:16:14,050 --> 00:16:20,296
PB: In fact if I did that to S16 inaudible and the same width.

187
00:16:20,290 --> 00:16:23,120
that should give us an even better indication of ...

188
00:16:24,680 --> 00:16:27,336
[laughter]

189
00:16:27,330 --> 00:16:31,016
The zero is still there but you get the idea.

190
00:16:31,010 --> 00:16:32,744
JW: There's an image in there somewhere.

191
00:16:33,010 --> 00:16:37,424
PB: Yes, we can see something inaud and long, which is...

192
00:16:37,456 --> 00:16:44,368
In fact, let's go back to that.

193
00:16:44,360 --> 00:16:49,312
Now this makes me wonder... it's upside down isn't it?

194
00:16:49,310 --> 00:16:51,368
JW: Oh yes...

195
00:16:51,360 --> 00:16:55,888
PB: I think inaud is the case with
bnp which is upside down.

196
00:16:56,408 --> 00:17:02,808
But that doesn't matter for us, as long as it says
our output is upside down, it should be fine.

197
00:17:04,360 --> 00:17:16,784
OK so bytes are OK, bitmask is OK, let's just get rid of...

198
00:17:16,780 --> 00:17:19,848
[Silence]

199
00:17:22,424 --> 00:17:26,288
We'll get rid of that entirely
and see what results we get.

200
00:17:26,280 --> 00:17:29,280
[Silence]

201
00:17:30,728 --> 00:17:35,008
OK that's a bunch of different things except...

202
00:17:35,000 --> 00:17:38,080
[Silence]

203
00:17:39,400 --> 00:17:43,080
Yes, I think that's right, the last row has...

204
00:17:45,672 --> 00:17:48,592
There's a lot of white space at
the top so we would expect...

205
00:17:49,368 --> 00:17:52,056
This also means our inaud as well.

206
00:17:53,792 --> 00:17:56,928
Again, as long as we're consistent that's fine.

207
00:17:59,816 --> 00:18:01,984
OK so...

208
00:18:04,480 --> 00:18:12,672
The easiest way of doing this then is
to just say if it's zero, zero acts as one

209
00:18:13,120 --> 00:18:14,832
Or rather...

210
00:18:14,830 --> 00:18:17,912
[Silence]

211
00:18:24,920 --> 00:18:33,944
Yes, I think that's modularly inaud shrink list. [Laughter]

212
00:18:33,968 --> 00:18:36,992
[Silence]

213
00:18:37,208 --> 00:18:39,424
JW: Awsome.

214
00:18:41,010 --> 00:18:48,320
So... we know that we can get
the bitmap in and in a format which,

215
00:18:48,328 --> 00:18:54,960
whilst it might not look exactly how we
want to see it - it seems to be flipped basically,

216
00:18:55,512 --> 00:19:01,088
for the purpose of taking an image and
processing it and exporting it again, that's fine.

217
00:19:03,064 --> 00:19:06,656
JW: Looks like a good time to commit.
PB Yes, I agree.

218
00:19:06,650 --> 00:19:09,696
[Silence]

219
00:19:11,312 --> 00:19:15,376
Don't know what I typed there... some junk... right.

220
00:19:15,370 --> 00:19:18,368
[Silence]

221
00:19:21,310 --> 00:19:27,752
That want's a simple BMP printer.

222
00:19:31,448 --> 00:19:41,768
OK, now that we've got rid of
that lot it would be nice to wrap this

223
00:19:42,136 --> 00:19:49,792
in a method that we give a
file and it gives us the bits.

224
00:19:49,790 --> 00:19:52,592
[Paul thinks]

225
00:19:52,616 --> 00:19:55,680
Yes, I think that would be good.

226
00:19:57,904 --> 00:20:02,056
If I had a bunch of small test images,
I would write some tests for this,

227
00:20:02,050 --> 00:20:09,744
but given the size of the image... I don't know how easily if I can make a bnp inaud

228
00:20:11,360 --> 00:20:16,664
inaud def read bmp.

229
00:20:17,760 --> 00:20:22,352
And inaud file object.

230
00:20:22,350 --> 00:20:25,696
[Silence]

231
00:20:27,072 --> 00:20:30,568
And... get it to take this stuff.

232
00:20:30,560 --> 00:20:33,568
[Silence]

233
00:20:34,664 --> 00:20:39,424
In fact I'm going to make a bnp file construct.

234
00:20:39,744 --> 00:20:44,304
In fact, I will put something in
class, I think that will be easier.

235
00:20:44,544 --> 00:20:46,008
Because it's got a header and other things,

236
00:20:46,000 --> 00:20:50,016
I think it's best to keep it all
together in the same class BMP which...

237
00:20:50,010 --> 00:20:53,096
[Silence]

238
00:20:55,104 --> 00:20:59,528
And I can say def initialize.

239
00:20:59,520 --> 00:21:02,520
[Silence]

240
00:21:02,520 --> 00:21:05,136
inaud file some kind.

241
00:21:07,696 --> 00:21:14,968
inaud, the interface below is going to be something like...

242
00:21:15,504 --> 00:21:19,424
BMPImage.new

243
00:21:20,152 --> 00:21:23,390
inaud first encoding.

244
00:21:25,432 --> 00:21:30,592
Something like that will give me the
power to inject a file that's alright for it.

245
00:21:31,480 --> 00:21:34,328
Nothing... should be able to say...

246
00:21:34,320 --> 00:21:37,352
[Silence]

247
00:21:37,656 --> 00:21:40,200
In fact, if I say that it will be file.open.

248
00:21:40,200 --> 00:21:43,224
[Silence]

249
00:21:44,820 --> 00:21:48,592
And I can say file.read.upack.

250
00:21:49,090 --> 00:21:54,952
So now I'm going to put this in initialize

251
00:21:55,112 --> 00:21:59,144
I might want to move it somewhere
else later but I think for now that will work.

252
00:21:59,140 --> 00:22:02,144
[Silence]

253
00:22:04,040 --> 00:22:07,048
inaud

254
00:22:07,040 --> 00:22:09,248
Then say pixels.

255
00:22:10,984 --> 00:22:13,056
And...

256
00:22:13,312 --> 00:22:16,824
In fact, let's have width and height as...

257
00:22:16,820 --> 00:22:19,808
[Silence]

258
00:22:28,056 --> 00:22:38,176
inaud height, while we're here I'm just
going to change width to width... yes yes yes.

259
00:22:38,928 --> 00:22:40,816
And do the same for height.

260
00:22:42,864 --> 00:22:48,376
Strange how my hands type a completely
different word as the one I was intending to.

261
00:22:48,800 --> 00:22:52,584
inaud

262
00:22:52,580 --> 00:22:55,640
[Silence]

263
00:23:00,816 --> 00:23:02,952
And this one...

264
00:23:04,880 --> 00:23:13,792
Width height pixels in there, inaudible and put this in a private method.

265
00:23:13,790 --> 00:23:16,744
[Silence]

266
00:23:16,912 --> 00:23:26,344
inaud and say private section and say def image bytes.

267
00:23:26,340 --> 00:23:29,392
[Silence]

268
00:23:29,390 --> 00:23:36,080
I will cache that and say image bytes inaudible.

269
00:23:36,600 --> 00:23:39,100
And I'm going to say def header,
and the reason I'm doing this

270
00:23:39,100 --> 00:23:43,672
is because I know we want to write one
out later, so it's helpful to keep the header.

271
00:23:43,712 --> 00:23:46,664
[Silence]

272
00:23:47,704 --> 00:23:51,136
Again I can say header...

273
00:23:52,808 --> 00:23:55,936
bytes.take... that's got to be at bytes.

274
00:23:58,208 --> 00:24:01,936
at bytes.length and inaud bytes.

275
00:24:04,192 --> 00:24:09,128
So we've inaud bytes, OK.

276
00:24:11,976 --> 00:24:19,928
Here we have image bytes available to us inaud moved up the top somewhere.

277
00:24:22,000 --> 00:24:25,208
Or can it. It doesn't mutate it does it inaud?

278
00:24:25,890 --> 00:24:28,856
[Silence]

279
00:24:31,050 --> 00:24:37,928
So at the moment pixels is still doing
that puts stuff, so for now I'm going to do 

280
00:24:38,480 --> 00:24:41,510
dot pixels,and see if I get the same sensible result.

281
00:24:41,510 --> 00:24:44,608
[Silence]

282
00:24:48,144 --> 00:24:51,136
inaud because I haven't given it the width and the height.

283
00:24:51,130 --> 00:24:54,128
[Silence]

284
00:24:55,096 --> 00:24:59,872
inaud

285
00:25:01,720 --> 00:25:05,264
At a later stage, I could probably
work out where to find those in the header,

286
00:25:05,260 --> 00:25:11,976
and read them but that's not the
most interesting thing we can do today.

287
00:25:13,280 --> 00:25:15,800
OK, seems good.

288
00:25:16,056 --> 00:25:19,040
inaud yes, that seems good.

289
00:25:20,992 --> 00:25:21,952
OK...

290
00:25:21,992 --> 00:25:24,976
[Silence]

291
00:25:32,016 --> 00:25:36,568
I'll commit this before I change it slightly.

292
00:25:39,088 --> 00:25:43,848
Make a BMPImage class, this
is still a work in progress so...

293
00:25:44,088 --> 00:25:47,816
I think everything will be a
work in progress today actually.

294
00:25:48,360 --> 00:25:58,920
So now I want to make this return, in fact
what I think I want is an array of arrays of pixels.

295
00:25:59,400 --> 00:26:02,120
I think that's the most sensible thing to do.

296
00:26:02,120 --> 00:26:09,104
It might not be the most
helpful thing later on, but for now...

297
00:26:09,160 --> 00:26:11,100
Height I can map...

298
00:26:12,024 --> 00:26:16,680
because each of those inaud

299
00:26:16,680 --> 00:26:23,064
I would like to do the inaud style of functional things with the braces.

300
00:26:23,104 --> 00:26:24,570
Width over 8.

301
00:26:24,570 --> 00:26:27,864
Now this one... I need to do something like a flat map.

