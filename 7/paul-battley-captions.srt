1
00:00:01,224 --> 00:00:02,976
NARRATOR: Welcome to Peer to Peer

2
00:00:02,976 --> 00:00:06,776
where you can hone your skills
by watching live coding videos.

3
00:00:07,904 --> 00:00:10,424
Our guest today is Paul Battley.

4
00:00:10,420 --> 00:00:12,120
Who is a veteran Ruby developer, 

5
00:00:12,120 --> 00:00:15,824
who has worked with agencies,
startups and Government departments.

6
00:00:17,080 --> 00:00:21,248
Our host is Jamie White, and the
challenge that he has set for Paul is called

7
00:00:21,472 --> 00:00:24,128
Encoding Images As Quad Trees.

8
00:00:25,992 --> 00:00:30,384
Jamie White: OK, so how about
we start by reading the challenge?

9
00:00:30,720 --> 00:00:32,224
Paul Battley: OK, so... 

10
00:00:32,272 --> 00:00:37,992
Write a program to convert a given binary
image into a quad tree and serialize it to disk.

11
00:00:38,248 --> 00:00:43,352
Write another program to take a
serialized quad tree and turn it back into an image.

12
00:00:43,460 --> 00:00:47,608
The quad tree for an image is generated
by splitting the image into four quadrants

13
00:00:47,608 --> 00:00:51,152
then successively splitting each
of these into further quadrants.

14
00:00:51,176 --> 00:00:55,952
When a quadrant consists of a single
color, it may be considered a terminal node.

15
00:00:57,400 --> 00:01:03,880
JW: I have provided this beautiful
binary image for you to work with.

16
00:01:03,880 --> 00:01:07,280
PB: Not quite the right time,
depending on when your watching this.

17
00:01:07,312 --> 00:01:10,656
JW: It's in a Windows 1Bit bitmap format.

18
00:01:10,650 --> 00:01:14,048
So, it's up to you how you make use of that.

19
00:01:14,128 --> 00:01:17,310
[New Chapter]

20
00:01:17,552 --> 00:01:22,950
PB: So the first thing we want
to do is pass the bitmap file.

21
00:01:22,950 --> 00:01:36,832
If I recall correctly, that's a bunch of
bytes, and huge bits of each byte is an image.

22
00:01:37,136 --> 00:01:42,176
I don't know which order it goes in so
I'm going to look it up on Wikipedia and find out.

23
00:01:42,170 --> 00:01:45,560
Inaudible.

24
00:01:45,976 --> 00:01:51,064
So I'll look up the BMP file format.

25
00:01:53,810 --> 00:01:58,728
Been through that, OK what
have I got... Pixel array inaudible.

26
00:01:58,790 --> 00:02:01,848
I hope it's not compressed. I guess we'll find out.

27
00:02:02,630 --> 00:02:06,640
If it is we can find some other way of processing it.

28
00:02:07,290 --> 00:02:13,112
1 bit pixel. Each bit is
indexed into a table of two colors.

29
00:02:14,450 --> 00:02:18,776
That's interesting, so inaudible
colors even though there's only two.

30
00:02:18,816 --> 00:02:21,904
We don't really need to...

31
00:02:21,900 --> 00:02:26,432
In our case it doesn't really
matter, as long as we're consistent.

32
00:02:27,368 --> 00:02:33,088
So... I suggest that we look
at the file to see how long it is.

33
00:02:33,080 --> 00:02:36,072
[Silence]

34
00:02:37,120 --> 00:02:42,048
Ls - L on whatever .bmp

35
00:02:43,800 --> 00:02:45,816
8256 bytes.

36
00:02:46,664 --> 00:02:49,888
And... do we know the size of it?

37
00:02:49,880 --> 00:02:53,768
We can find that out with identify.

38
00:02:56,336 --> 00:02:59,328
Inaudible.

39
00:02:59,560 --> 00:03:09,432
256 by 256 would be 64K except that
we're less 8 bits of a pixel... so 8 pixels.

40
00:03:09,712 --> 00:03:16,240
Sorry pixels per byte, so inaudible so 856 sounds just about right.

41
00:03:17,456 --> 00:03:19,128
So it's not compressed.

42
00:03:19,752 --> 00:03:27,744
And according to this, it's just
the end of the file so I can probably...

43
00:03:28,180 --> 00:03:31,512
ignore the header and just take the pixels.

44
00:03:31,720 --> 00:03:39,040
So I'm going to write a bit of
code that reads in this bitmap,

45
00:03:39,470 --> 00:03:45,072
and spits out the pixels as,
maybe hashes and spaces on screen.

46
00:03:45,070 --> 00:03:47,608
That should give us an idea of whether its working.

47
00:03:47,600 --> 00:03:51,000
Inaudible and a bit wierd, but we'll work it out.

48
00:03:51,696 --> 00:03:58,768
So I'm going to play around, and call this print-bmp.rb.

49
00:03:59,664 --> 00:04:06,192
And now I'm going to say something like...

50
00:04:06,440 --> 00:04:10,624
I can load it all into memory... bits = File.read.

51
00:04:10,620 --> 00:04:18,224
I could use ARGF here but I'm going to use
ARGV first because I want to specify the encoding.

52
00:04:18,680 --> 00:04:23,832
JW: So ARGF gives you the final pass
into the command rather than inaudible

53
00:04:27,180 --> 00:04:32,504
PB: Well it gives you both so you can either inaudible something or it will give you the first one. 

54
00:04:33,000 --> 00:04:37,832
Its very handy but I'm not
sure how that would handle inaudible.

55
00:04:38,080 --> 00:04:41,176
I know that we need to be
able to handle the inaudible.

56
00:04:41,180 --> 00:04:45,144
ARGV, I think it's...

57
00:04:45,140 --> 00:04:48,032
Inaudible encoding...

58
00:04:48,030 --> 00:04:51,144
[Silence]

59
00:04:53,368 --> 00:04:56,728
ASCII 8 Bit,

60
00:04:57,480 --> 00:05:00,024
which is not ASCII actually but...

61
00:05:03,656 --> 00:05:06,008
Let's say that's byte.

62
00:05:07,888 --> 00:05:12,216
And then I can say "print how many bytes I have got".

63
00:05:13,984 --> 00:05:18,000
Which should be something like 256, if that works.

64
00:05:18,560 --> 00:05:22,808
So I'm going to split this screen.

65
00:05:22,800 --> 00:05:26,632
Actually, no I'll make a new inaudible.

66
00:05:30,250 --> 00:05:32,400
Quad trees...

67
00:05:32,808 --> 00:05:38,696
Now if I say Ruby and print
bnp and give it a style of bnp.

68
00:05:39,840 --> 00:05:42,016
Inaudible array to string.

69
00:05:42,856 --> 00:05:46,824
ARGV [They both talk at once]

70
00:05:51,152 --> 00:05:55,408
OK so I'm going to read inaudible, that seems right.

71
00:05:59,270 --> 00:06:01,456
I'm going to hard code the width and height.

72
00:06:01,470 --> 00:06:08,632
So I'm going to say width
equals 256 and height  equals 256

73
00:06:08,630 --> 00:06:16,832
And then I'm going to say
that image bytes is bytes from...

74
00:06:18,040 --> 00:06:27,432
Actually let's just say minus
width, width x height to the end.

75
00:06:29,752 --> 00:06:33,088
Then if I go... make that one image bytes

76
00:06:33,080 --> 00:06:36,712
[Silence]

77
00:06:36,712 --> 00:06:38,710
Put some space in there.

78
00:06:42,208 --> 00:06:46,760
I can run this at inaudible percent.

79
00:06:49,376 --> 00:06:50,968
Inaudible.

80
00:06:52,464 --> 00:06:56,000
And define the length nil nil class by 5.

81
00:06:56,056 --> 00:06:59,040
[Silence]

82
00:06:59,856 --> 00:07:02,008
That's interesting.

83
00:07:02,440 --> 00:07:04,872
Apparently image bytes is nil.

84
00:07:06,896 --> 00:07:09,624
Let's see if that's really true.

85
00:07:09,620 --> 00:07:12,584
[Silence]

86
00:07:14,528 --> 00:07:17,400
Yes, why is that nil?

87
00:07:17,832 --> 00:07:20,968
I know that bytes works.

88
00:07:20,960 --> 00:07:23,936
[Silence]

89
00:07:24,800 --> 00:07:26,128
Maybe it's confused by...

90
00:07:26,120 --> 00:07:30,528
JW: Is that all bytes are like a string?

91
00:07:30,520 --> 00:07:32,888
PB: Your right, exactly.

92
00:07:32,880 --> 00:07:35,896
[Silence]

93
00:07:36,880 --> 00:07:43,536
PB: So in that case, maybe I should
just unpack it into an array of bytes.

94
00:07:43,530 --> 00:07:46,552
[Silence]

95
00:07:50,936 --> 00:07:53,904
Inaudible again.

96
00:07:57,152 --> 00:07:59,720
JW: I rarely use the unpack method.

97
00:08:00,328 --> 00:08:02,504
That notation... what does it mean?

98
00:08:03,648 --> 00:08:12,880
PB: If I recall correctly, that C means that
each byte will be unpacked as its byte.

99
00:08:12,880 --> 00:08:17,920
So you will get an array of integers
that are the byte value of each character.

100
00:08:21,176 --> 00:08:25,464
[Paul thinks]

101
00:08:28,128 --> 00:08:34,240
Let's just try saying leave bytes
and just take 10 of them or something.

102
00:08:34,270 --> 00:08:39,152
In fact, I'm going to say take 10 and
see if I've got something sensible there.

103
00:08:39,176 --> 00:08:42,208
[Silence]

104
00:08:45,856 --> 00:08:49,272
Yes, that seems useful.

105
00:08:51,920 --> 00:08:56,880
In fact I could also say bytes dot...

106
00:08:58,296 --> 00:09:00,464
Yes, in fact...

107
00:09:02,976 --> 00:09:05,232
So I've got an array...

108
00:09:07,776 --> 00:09:11,088
Where is 256?  Ah, there is my problem, right there.

109
00:09:11,128 --> 00:09:15,784
The width is the number of bits.

110
00:09:16,000 --> 00:09:19,704
I want it to be the number of
characters, so it's width x height.

111
00:09:20,312 --> 00:09:29,344
And let's say bits per pixels... is that what it says?

112
00:09:32,976 --> 00:09:36,264
Hard code here, I think we know what 8 is.

