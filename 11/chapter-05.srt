1
00:00:00,000 --> 00:00:03,908
Chapter 05
Unit testing the Target class.

2
00:00:04,240 --> 00:00:09,790
JC: So this is an example that I
should probably turn into a test now.

3
00:00:09,790 --> 00:00:16,034
There's not really enough here that there's
any integration vs unit test separation .

4
00:00:16,057 --> 00:00:17,428
There's only a tiny amount of code.

5
00:00:17,440 --> 00:00:28,720
So I think I'll start by moving target into the
source code of the project and write a test for it.

6
00:00:32,740 --> 00:00:39,634
Let's make a thing called lib,
and let's move scratch target into...

7
00:00:39,880 --> 00:00:52,925
No let's make a directory called  lib.fakemake,
and then move scratch target to that.

8
00:00:55,394 --> 00:01:02,020
Then also name spacer... Like that.

9
00:01:05,600 --> 00:01:07,737
OK.

10
00:01:08,030 --> 00:01:14,765
And we're going to want some
tests, and something to run them.

11
00:01:14,760 --> 00:01:21,428
Go to inaud and get some gems.

12
00:01:25,177 --> 00:01:27,862
I've got the gem file and put rspec in there.

13
00:01:28,160 --> 00:01:34,891
Save that, and install it into the project.

14
00:01:35,040 --> 00:01:38,571
[Silence]

15
00:01:44,460 --> 00:01:47,657
Did I make a spec directory – yes I did. 

16
00:01:47,771 --> 00:01:51,394
[Silence]

17
00:01:52,171 --> 00:01:58,480
So let's try to write a test
for this file, I called it a target..

18
00:01:58,730 --> 00:02:01,920
[Silence]

19
00:02:04,670 --> 00:02:08,582
Obligatory require 'spec_helper'. 

20
00:02:09,017 --> 00:02:14,434
and (not end) which I've not written but...

21
00:02:18,274 --> 00:02:27,520
This will require_relative 'lib/fakemake', 

22
00:02:28,982 --> 00:02:33,748
which also doesn't exist so I'm going to create it.

23
00:02:34,285 --> 00:02:37,760
Module FakeMake.

24
00:02:41,222 --> 00:02:46,697
I usually use autoloads for these, so it loads things lazily.

25
00:02:47,760 --> 00:02:51,451
[Silence]

26
00:02:52,582 --> 00:02:54,811
And path.

27
00:02:55,005 --> 00:02:58,537
[Silence]

28
00:03:00,045 --> 00:03:09,737
And then autoload target
from root + fakemake target. 

29
00:03:11,920 --> 00:03:18,491
That ought to be enough to load things.
So if we go back to target spec and...

30
00:03:22,468 --> 00:03:26,742
Describe FakeMake target.

31
00:03:30,880 --> 00:03:35,970
Does that at least run.

32
00:03:36,022 --> 00:03:40,137
Yes, it didn't complain about anything.

33
00:03:40,130 --> 00:03:50,331
So, looking back at the code,
there's already a few scenarios here. 

34
00:03:52,777 --> 00:04:02,708
The only thing this actually does, I suppose, is that
it takes a list of instructions and executes them.

35
00:04:04,194 --> 00:04:10,800
But now we're coming to a test we can
pass in some alternative output thing.

36
00:04:11,154 --> 00:04:14,571
[Silence]

37
00:04:18,650 --> 00:04:21,725
I'll make that be that - output.

38
00:04:25,390 --> 00:04:32,445
The test I have in mind is if you write
a target with no instructions that's fine. 

39
00:04:33,897 --> 00:04:39,965
If you write a target with an
instruction it gets printed and executed. 

40
00:04:41,108 --> 00:04:47,474
And if you write one with many
instructions, they all get executed. 

41
00:04:47,611 --> 00:04:53,691
Although we should also check to see what happens
if you write an instruction that doesn't work. 

42
00:04:55,371 --> 00:05:04,430
So system will return nil if you
run a command that has a inaud status.

43
00:05:06,430 --> 00:05:14,148
Rather than shelling out, running stuff on the
system we can stubb system to work or not work.

44
00:05:16,811 --> 00:05:23,897
So make a few variables. 

45
00:05:25,954 --> 00:05:32,137
This value wont really matter
it's just something to pass in.

46
00:05:32,420 --> 00:05:47,211
The target will be target.new, which takes the
pathname and the instructions and the output.

47
00:05:49,360 --> 00:05:52,548
Let's also make an output for inaud.

48
00:05:58,925 --> 00:06:02,320
And then we can have some scenarios.

49
00:06:02,320 --> 00:06:06,651
Let's describe the build method.

50
00:06:10,137 --> 00:06:16,822
When there are no instructions we
said that nothing should happen.

51
00:06:17,154 --> 00:06:20,160
[Silence]

52
00:06:23,480 --> 00:06:28,148
It should not print anything.

53
00:06:31,177 --> 00:06:39,337
And expect output not to receive puts.

54
00:06:40,570 --> 00:06:44,617
And target build.

55
00:06:44,920 --> 00:06:48,148
[Silence]

56
00:06:51,131 --> 00:06:54,411
I'll make a new shell over here.

57
00:06:56,820 --> 00:07:01,828
Ah! I didn't put my ruby on the path.

58
00:07:02,022 --> 00:07:05,417
[Silence]

59
00:07:16,220 --> 00:07:18,080
I'm not doing the good TDD thing here.

60
00:07:18,125 --> 00:07:23,650
I should probably see this break just
to check if that test is doing something.

61
00:07:24,308 --> 00:07:34,160
So let's have this do output.puts something bad.

62
00:07:36,331 --> 00:07:40,114
That does fail so that's fine.

63
00:07:44,560 --> 00:07:48,148
And it should not execute anything.

64
00:07:48,320 --> 00:07:51,805
[Silence]

65
00:07:53,691 --> 00:08:00,285
We're calling system on target
itself... It's a kernel method.

66
00:08:00,411 --> 00:08:06,114
I could have called puts on target
itself and stubbed it in inaud here. 

67
00:08:06,502 --> 00:08:12,125
But that also means... Like at some point
we're going to have a graph of these things. 

68
00:08:12,342 --> 00:08:18,388
And you might not have direct access in your
test to the actual thing that's printing something. 

69
00:08:18,422 --> 00:08:20,948
So you want to be able to
pass this output object along. 

70
00:08:21,302 --> 00:08:25,051
So it's a thing you have a handle on in your
test and you can make assertions against it.

71
00:08:25,050 --> 00:08:25,725
TS: Right

72
00:08:25,790 --> 00:08:33,062
JC: Maybe I should do the same thing with execution.
I could tell kernel to expect to receive system.

73
00:08:33,108 --> 00:08:36,342
TS: And then pass kernel in as another argument, or...?

74
00:08:36,388 --> 00:08:38,457
JC: That's what I'm not sure about.

75
00:08:38,525 --> 00:08:44,697
Because I'm not sure I think I should
leave it for now, until it becomes a problem.

76
00:08:45,500 --> 00:08:50,457
The output thing... I knew I didn't want
stuff printing things in the middle of my tests, 

77
00:08:50,500 --> 00:08:56,960
whereas you also don't want the unit
tests to go and execute system commands. 

78
00:08:58,617 --> 00:09:01,140
Because I've used a string io here for the output, 

79
00:09:01,154 --> 00:09:04,651
those put commands are just going to go
into the ether and not be used anywhere.

80
00:09:04,670 --> 00:09:08,160
We don't have any instructions yet,

81
00:09:08,290 --> 00:09:14,217
but when we do and I write some of the test for
printing, it will then go and execute the thing. 

82
00:09:14,342 --> 00:09:17,588
I'll have to stub out system to make it not do that.

83
00:09:17,760 --> 00:09:22,010
But I'm not sure that the object that we're
calling it on is the problem in that situation. 

84
00:09:22,010 --> 00:09:25,942
You'd have to do that in any case.

85
00:09:26,491 --> 00:09:30,182
So the target should not receive the system... types
Ok, two passing tests.
When there is an instruction let the instruction be... it doesn't really matter what it is... let's say echo, but we're never going to execute it, so it doesn't matter, as long as it's some unique value. And that should be an array shouldn't it.
It prints the instruction. And we expect the output to receive puts with instruction once. And it executes the instruction.
With the instruction... once.

