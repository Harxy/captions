1
00:00:00,000 --> 00:00:03,588
Chapter 12.
Returning fresh mtime from a regenerated Target.

2
00:00:04,057 --> 00:00:08,777
JC: If we go back to our code. 

3
00:00:09,080 --> 00:00:15,965
What do we need to do? We've got
these mtimes so we need to store that. 

4
00:00:18,160 --> 00:00:20,754
Ensure updated dependencies. 

5
00:00:20,857 --> 00:00:25,691
We've said in our test that calling build
on a dependency will return its' mtime. 

6
00:00:25,690 --> 00:00:37,074
So let's store that in here when we build the
dependencies and call map so we get the values.

7
00:00:39,748 --> 00:00:54,217
And then here we can say return unless any of
the dependent times are greater than our own.

8
00:00:57,257 --> 00:01:00,285
I think that will be OK. 

9
00:01:00,502 --> 00:01:04,982
What I do need to do for this to work... 

10
00:01:05,337 --> 00:01:08,605
The build method will need to return mtime.

11
00:01:08,600 --> 00:01:13,462
But I haven't written a test that requires that yet.

12
00:01:13,630 --> 00:01:20,262
I'm just thinking how I would force myself
to do that, but we'll get to that in a second.

13
00:01:20,620 --> 00:01:25,040
"undefined method `>' for nil:NilClass

14
00:01:25,070 --> 00:01:30,560
So that must mean that I've
stubbed mtime to somehow return (hmm)... 

15
00:01:31,302 --> 00:01:35,017
So this is Target spec 33. 

16
00:01:36,194 --> 00:01:39,954
What's going on in there?

17
00:01:42,205 --> 00:01:49,970
Oh yes, in this test those build
targets are not returning anything.

18
00:01:50,388 --> 00:01:54,388
TS: So they're getting nil back and
then trying to compare it to something.

19
00:01:54,400 --> 00:02:02,971
JC: Exactly. I think this is the point where I need
to put a value that actually makes sense in here.

20
00:02:03,108 --> 00:02:07,291
[Silence]

21
00:02:07,885 --> 00:02:10,937
Now everything passes. 

22
00:02:14,388 --> 00:02:17,417
This is a bit of an illusion because it doesn't (hmm)...

23
00:02:17,474 --> 00:02:24,640
I'm surprised that the integration test
works because build isn't returning the mtime.

24
00:02:24,777 --> 00:02:29,462
[James thinks]

25
00:02:29,828 --> 00:02:36,034
TS: It's the integration test of the previous
behaviour that you're expecting to break?

26
00:02:36,170 --> 00:02:38,971
JC: Yes. 

27
00:02:39,417 --> 00:02:43,085
That's probably because in the integration
test we're building things that don't exist. 

28
00:02:43,080 --> 00:02:46,000
So it isn't hitting that code path.

29
00:02:47,142 --> 00:02:51,508
TS: So we don't have an integration
test for this laziness behaviour right?

30
00:02:51,500 --> 00:02:52,674
JC: No.

31
00:02:52,760 --> 00:02:55,085
Dependent targets.

32
00:02:55,360 --> 00:03:01,485
[James thinks]

33
00:03:02,034 --> 00:03:03,360
When one target depends on another... 

34
00:03:03,360 --> 00:03:13,942
We could put a context in here that creates one.txt
and then sees if the second one will build.

35
00:03:14,260 --> 00:03:25,440
context when one target
already exists do file one.text.

36
00:03:30,620 --> 00:03:38,102
Let's just make it include one rather than from
where the files it was previously derived from are.

37
00:03:39,782 --> 00:03:44,822
No let's not do that. I don't want this test
to get into setting mtimes on various files. 

38
00:03:44,820 --> 00:03:48,731
They're going to be created in a certain order .

39
00:03:48,770 --> 00:03:53,222
But the time resolution on those
time stamps on the files is only a second.

40
00:03:53,268 --> 00:03:59,920
So sometimes, depending on whether your
test execution overlaps a second boundary,

41
00:03:59,954 --> 00:04:05,577
there will sometimes be the same value and
sometimes not. The ordering is not predictable.

42
00:04:06,571 --> 00:04:18,651
To be safe, I'm going to make this have the value
that it would have if you had built it from source.

43
00:04:19,280 --> 00:04:24,628
Builds the final target successfully.

44
00:04:26,000 --> 00:04:32,022
I suppose successfully is implicit
when you're writing any sort of test but...

45
00:04:32,742 --> 00:04:35,645
Yeah...

46
00:04:37,634 --> 00:04:40,662
I could just do that.

47
00:04:41,660 --> 00:04:50,491
This is still saying when you build the second
target it should have that content based on that.

48
00:04:50,525 --> 00:05:01,302
But this ought to trigger the
first target to try to check the...

49
00:05:02,570 --> 00:05:08,617
No, the first target will try to check the
mtimes of the files a and b that it depends on.

50
00:05:08,650 --> 00:05:14,674
and it will get nil from their build
methods, so this should fall over. 

51
00:05:15,020 --> 00:05:17,577
Yes, so a second error out of that.

52
00:05:17,600 --> 00:05:20,491
TS: So this is not yet a test
of the laziness functionality, 

53
00:05:20,525 --> 00:05:24,388
but it is exercising more of the code
than the previous integration test was?

54
00:05:24,380 --> 00:05:33,954
JC: Yes. That integration test makes sure
that you can rebuild a partially built system.

55
00:05:34,050 --> 00:05:40,262
It means you need a test for
build that returns the mtime.

56
00:05:44,000 --> 00:05:55,028
Going back to our unit tests, where did
we have something with a dependency?

57
00:05:55,588 --> 00:06:01,085
This doesn't necessarily mean
there are dependencies.

58
00:06:01,080 --> 00:06:03,154
There's actually two cases for this. 

59
00:06:03,170 --> 00:06:07,714
If the file already exists and is up
to date it should return its existing mtime. 

60
00:06:07,725 --> 00:06:13,965
but if you had to rebuild it, it
should return time.now, I guess.

61
00:06:14,060 --> 00:06:20,274
So we can build those in to here.

62
00:06:20,285 --> 00:06:32,251
So when the dependencies are newer than the target
it returns the later of the dependencies.

63
00:06:32,605 --> 00:06:39,268
It could either return the latest
of the dependencies build times, 

64
00:06:40,360 --> 00:06:46,491
but building a target will take time so it might be
a few seconds later than its' dependencies were.

65
00:06:48,770 --> 00:06:54,880
Or, if its' dependencies were touched a very long
time ago, but they're still newer than you are...

66
00:06:54,914 --> 00:07:02,182
We might get into like... Something
appears older than it actually is.

67
00:07:02,217 --> 00:07:07,222
So I think I should probably return time.now. 

68
00:07:07,222 --> 00:07:09,220
He types then pauses..
In this context we've already stubbed out time.

TS: This reminds me of something I was confused about, in the build self we get the mtime of the possibly stale file, but you're talking about not the mtime of that file at that point but almost the end point of that file after its been regenerated.

