1
00:00:01,270 --> 00:00:03,062
Welcome to Peer to Peer,

2
00:00:03,190 --> 00:00:06,982
where you can hone your
skills by watching live coding videos.

3
00:00:07,730 --> 00:00:09,737
Our guest today is Jamie White,

4
00:00:10,020 --> 00:00:13,725
who's a Ruby and JavaScript
developer at With Associates

5
00:00:13,760 --> 00:00:17,131
and a co-organizer of the London Ember meetup.

6
00:00:17,150 --> 00:00:19,120
I'm your host, Drew Neil,

7
00:00:19,300 --> 00:00:23,371
And the challenge that I set for
Jamie is called Deducing Collaborations.

8
00:00:23,908 --> 00:00:27,160
DN: OK, Jamie, would you like to
start by reading out the challenge?

9
00:00:27,177 --> 00:00:31,330
JW: OK. Generate a data
structure representing the collaborations

10
00:00:31,330 --> 00:00:34,728
between guests and hosts
in the Peer to Peer catalog.

11
00:00:34,720 --> 00:00:37,617
A collaboration has an
episode, one guest and one host.

12
00:00:37,610 --> 00:00:45,520
It appears in sequence, with an optional
prequel (0 or 1) and optional sequels (0 or more).

13
00:00:45,520 --> 00:00:49,337
Build this data structure from the
data provided as two JSON documents:

14
00:00:49,337 --> 00:00:52,590
episode.json and partners.json.

15
00:00:52,590 --> 00:00:56,720
Render a simple representation
of the data structure in a web browser.

16
00:00:56,906 --> 00:01:02,830
And on page 2, this is
how the sequencing should look.

17
00:01:02,830 --> 00:01:06,697
Episode 1 begins a sequence,
and is follod by Episode 2.

18
00:01:06,690 --> 00:01:09,645
2 follows 1 followed by 5.

19
00:01:09,645 --> 00:01:11,611
3 begins a sequence followed by 4.

20
00:01:11,610 --> 00:01:15,382
And a sequence is connected by guests and hosts.

21
00:01:15,390 --> 00:01:17,188
DN: Effectively yes.

22
00:01:17,200 --> 00:01:22,045
JW: So let's have a look at the data to begin with.

23
00:01:27,060 --> 00:01:29,257
I've already got this stuff.

24
00:01:36,450 --> 00:01:38,777
Let's look at past episodes to begin with.

25
00:01:38,777 --> 00:01:44,170
I'm interested in the ones that
do form parts of sequences already.

26
00:01:45,750 --> 00:01:51,862
We have episode one, where the
host was you and the guest was Tom.

27
00:01:52,900 --> 00:01:54,925
That sequence moves on to two,

28
00:01:54,925 --> 00:02:00,594
where Tom the guest becomes Tom
the host and Camille becomes the guest.

29
00:02:00,840 --> 00:02:04,000
And then this one leads on to here,

30
00:02:04,000 --> 00:02:07,702
where Camille goes from guest
to should have been host.

31
00:02:07,710 --> 00:02:13,497
DN: Yes, unfortunately Camille was
ill today so I'm standing in as host.

32
00:02:14,270 --> 00:02:20,262
In fact, this data is slightly stale.

33
00:02:21,250 --> 00:02:29,428
We could have changed it so that we have
a branch where I interview Tom and also you,

34
00:02:29,485 --> 00:02:32,810
but we're going to pretend
that Camille is acting as host today

35
00:02:32,810 --> 00:02:35,611
and stick with the sample data that we came up with.

36
00:02:35,720 --> 00:02:39,062
We can always adapt it later.

37
00:02:40,080 --> 00:02:46,217
JW: Thinking of the nouns in this description,
the data structure is composed of collaborations.

38
00:02:46,217 --> 00:02:48,630
The description is quite explicit about that.

39
00:02:48,630 --> 00:02:54,560
Now, at the moment, an
episode isn't strictly a collaboration.

40
00:02:54,610 --> 00:02:58,411
A collaboration should have an
episode but not necessarily be an episode.

41
00:02:58,410 --> 00:03:03,211
And the thing that isn't explicit in
this data is the prequels and sequels.

42
00:03:03,220 --> 00:03:08,228
But we know that we can determine
those from the host and guest ids.

43
00:03:13,420 --> 00:03:18,274
I am going to use Ember for this.

44
00:03:18,434 --> 00:03:23,120
A bit like reaching for Rails,
I won't use all of it to begin with,

45
00:03:23,154 --> 00:03:26,320
but it gives you plenty of
directions to go in once you're set up.

46
00:03:32,114 --> 00:03:35,245
Let me see what version of Ember CLI I'm running.

47
00:03:35,250 --> 00:03:39,177
Cool... Bleeding edge Ember CLI.

48
00:03:39,200 --> 00:03:44,662
And let's call this peertopeer.

49
00:03:48,900 --> 00:03:52,480
Ember CLI is installing all the
tooling dependencies we need.

50
00:03:52,502 --> 00:03:54,205
DN: OK.

51
00:03:56,200 --> 00:03:59,782
JW: It will take a while, there's quite a few of them.

52
00:03:59,780 --> 00:04:03,920
[Jamie types]

53
00:04:04,020 --> 00:04:10,800
Because I'm using a local copy of
Ember CLI– (I cloned it off Github)...

54
00:04:10,830 --> 00:04:18,960
With npm, what you tend to do when
working on packages that you're adapting is to...

55
00:04:18,971 --> 00:04:23,817
You do npm link and it will
symlink up your copy of the repository

56
00:04:23,817 --> 00:04:27,805
to the node_modules global directory.

57
00:04:28,650 --> 00:04:33,097
I can't use it straight away, I need
to first enter npm link ember-cli,

58
00:04:33,260 --> 00:04:36,560
and that says also use it inside this project.

59
00:04:37,630 --> 00:04:42,674
Now, if you follow the
trail in this local project,

60
00:04:42,685 --> 00:04:48,830
you'll find this symlink
here going to /usr/local/lib/node_modules.

61
00:04:48,830 --> 00:04:52,342
[inaudible]

62
00:04:52,370 --> 00:04:59,965
You'll find Ember CLI linked to my
very own copy of it. It's a nicety of npm.

63
00:04:59,965 --> 00:05:02,540
So now we should be able to do ember serve...

64
00:05:02,540 --> 00:05:09,874
[Silence]

65
00:05:09,870 --> 00:05:13,977
DN: [Inaudible]

66
00:05:14,240 --> 00:05:21,257
JW: Let's just make a quick change to
make sure we're doing what we think we're doing.

67
00:05:21,268 --> 00:05:28,491
[Silence]

68
00:05:28,525 --> 00:05:30,491
OK, it seems to work.

69
00:05:33,540 --> 00:05:45,268
I'm inclined to get the data in first and
get it in the browser and think about it that way.

70
00:05:45,348 --> 00:05:48,400
Pick up the data and put
it down again as many times as possible

71
00:05:48,400 --> 00:05:51,360
until some way to handle it emerges.

72
00:05:54,710 --> 00:06:01,371
Before we get going,
I'm going to install another dependency.

73
00:06:09,560 --> 00:06:14,342
So Ember is about to
undergo some significant improvements,

74
00:06:14,365 --> 00:06:19,680
and this Ember CLI add-on will let us use the future.

75
00:06:22,468 --> 00:06:27,382
And then I need to opt-in to the future.

76
00:06:30,925 --> 00:06:33,565
And I think I want to do that.

77
00:06:37,350 --> 00:06:39,748
I just want to do a quick check.

78
00:06:46,490 --> 00:06:51,771
Ember-htmlbars I want.
And there is another one.

79
00:06:51,771 --> 00:06:56,480
[Silence]

80
00:06:56,530 --> 00:06:59,942
DN: Did you just switch
to the repository for ember.js?

81
00:06:59,965 --> 00:07:02,251
JW: Yes.

82
00:07:04,890 --> 00:07:08,594
So I want these three features.

83
00:07:10,380 --> 00:07:14,971
If you're running on Canary at the
latest build off of master of Ember,

84
00:07:15,680 --> 00:07:20,765
the new things that are coming down
the pipe are hidden behind feature flags.

85
00:07:20,820 --> 00:07:28,400
That allows the core team
to release things incrementally,

86
00:07:28,470 --> 00:07:32,594
but it also allows people to try
them out without breaking the past.

87
00:07:32,690 --> 00:07:36,742
So I want those three things.
And the other thing I want is...

88
00:07:38,617 --> 00:07:44,582
I don't want this stable build of Ember,
I want the Canary build components.

89
00:07:50,857 --> 00:07:53,485
DN: OK, so this is bleeding edge all the way.

90
00:07:53,500 --> 00:07:59,760
JW: Yes, and the reason I think
it's going to be worth while is that

91
00:07:59,780 --> 00:08:07,005
Ember will be changing shortly after we record this,
and I think it's worth seeing what it's about to become.

92
00:08:07,000 --> 00:08:11,520
So I think I want that version of Handlebars.

93
00:08:11,600 --> 00:08:14,594
And that version of Ember.

94
00:08:16,171 --> 00:08:19,440
Let's check that has taken... yes.

95
00:08:22,350 --> 00:08:28,628
I'll just have a look at all these differences.

96
00:08:29,990 --> 00:08:37,497
So bleeding edge Ember opted in to
these new features and included HTMLBars,

97
00:08:37,497 --> 00:08:41,451
which is the next generation template compiler.

98
00:08:41,462 --> 00:08:45,222
I'll just make sure all that actually works.

99
00:08:52,560 --> 00:08:59,108
I've never quite understood this side
of Bower because it doesn't have a lockfile.

100
00:08:59,542 --> 00:09:02,450
It keeps the dependency
resolutions in the same file

101
00:09:02,450 --> 00:09:05,040
in which they were specified in the first place.

102
00:09:11,020 --> 00:09:13,870
There's not a lot of
difference to notice at the moment

103
00:09:13,870 --> 00:09:17,280
but things are better under
the hood for various reasons.

104
00:09:20,570 --> 00:09:22,450
I'm not going to in to tests just yet

105
00:09:22,450 --> 00:09:25,851
because I don't know
quite what the target is at the moment.

106
00:09:25,851 --> 00:09:30,022
I know I want a data structure.
But if it's something I want to display

107
00:09:30,030 --> 00:09:36,822
then I want to let the view lead
me to what would be most useful.

108
00:09:36,940 --> 00:09:39,154
Let's say for the beginning...

109
00:09:40,350 --> 00:09:44,560
Let's just a display a list of episodes.

110
00:09:44,560 --> 00:09:58,902
[Jamie types]

111
00:09:58,900 --> 00:10:02,342
I think that's right [inaudible]

112
00:10:02,340 --> 00:10:11,680
[Silence]

113
00:10:11,730 --> 00:10:18,697
Thinking back to Tom's Peer
to Peer and how often he commits,

114
00:10:18,708 --> 00:10:22,560
I realise that I'm already several
changes in without committing.

115
00:10:22,571 --> 00:10:29,220
Let me just commit my bits of bleeding edge stuff.

116
00:10:30,100 --> 00:10:34,845
DN: I didn't see you create a Git repository.
Was that done for you by the ember generate command?

117
00:10:34,845 --> 00:10:37,451
JW: Yes, ember new creates a repo.

118
00:10:37,470 --> 00:10:42,171
So that's my stuff to get up on the latest Ember.

119
00:10:42,170 --> 00:10:50,560
[Silence]

120
00:10:50,560 --> 00:10:54,605
And partly I want to demonstrate how
easy it is to use the bleeding edge of Ember.

121
00:10:54,628 --> 00:10:59,874
It's modelled after Rails and
Rails's command line tooling.

122
00:10:59,874 --> 00:11:03,760
So it should feel familiar to anyone who knows that.

123
00:11:03,870 --> 00:11:06,834
Check in that change as well.

124
00:11:08,205 --> 00:11:11,371
I'll just see what that is exactly... whoops.

125
00:11:14,460 --> 00:11:17,200
So that at the moment is fine.

126
00:11:17,210 --> 00:11:21,371
It's compiling. It's just that there's
nothing to render because there is no data.

127
00:11:21,394 --> 00:11:23,565
So I'm going to commit that.

128
00:11:23,560 --> 00:11:30,971
[Jamie types]

129
00:11:31,000 --> 00:11:39,040
Let's pull in those files. I've got
them next door. Let's pull them in...

130
00:11:40,130 --> 00:11:43,190
I'm going to pretend they're
coming from an API of some sort.

131
00:11:44,520 --> 00:11:47,405
So we'll put them in.

132
00:11:47,400 --> 00:11:56,091
[Jamie types]

133
00:11:56,130 --> 00:12:01,634
DN: So we now should be able to
fetch them from lolhost/api/episodes.

134
00:12:01,890 --> 00:12:06,045
JW: lolhost is because I always mistype it.

135
00:12:12,770 --> 00:12:16,480
I'll concentrate on episodes for
now because it looks the most like...

136
00:12:18,171 --> 00:12:22,500
I don't have an applcation route yet.
Routes are where data gets loaded in,

137
00:12:22,500 --> 00:12:27,360
so I will generate one of those... route application.

138
00:12:29,380 --> 00:12:33,325
I don't want to change the
template, but I do want the rest of it.

139
00:12:39,740 --> 00:12:43,908
In my template I wasn't referring to model directly,

140
00:12:43,908 --> 00:12:50,380
I'm referring to the episodes
and I'm going to stick with that.

141
00:12:50,400 --> 00:12:54,148
So what I want to return from here is...

142
00:12:54,170 --> 00:12:58,228
I'm just going to set up some aliases.

143
00:13:01,360 --> 00:13:04,250
I want to return a Promise to load in that data.

144
00:13:04,800 --> 00:13:18,570
So RSPV.hash and this is
episodes, and we need some ajax.

145
00:13:18,594 --> 00:13:24,594
I think I have the ic-ajax library handy.

146
00:13:24,590 --> 00:13:33,188
So what we want to get is [inaudible]

147
00:13:33,680 --> 00:13:37,291
I think that should be enough.

148
00:13:37,290 --> 00:13:40,217
Let's just see if it compiles.

149
00:13:40,594 --> 00:13:41,720
Yes, it seems to.

150
00:13:44,170 --> 00:13:56,194
[Jamie mumbles inaudibly as he types]

151
00:13:56,380 --> 00:14:03,234
I'm going to step back to something that looks a bit more like the guides.

152
00:14:03,234 --> 00:14:10,000
[Silence]

153
00:14:10,617 --> 00:14:12,640
DN: Oh wow, that was quick.

154
00:14:12,640 --> 00:14:15,520
JW: Yes (laughter).

155
00:14:15,520 --> 00:14:18,514
Oh, of course because ... yes.

156
00:14:18,510 --> 00:14:22,422
DN: The episodes.json is already namespaced.

157
00:14:22,422 --> 00:14:29,222
JW: Yes, I wasn't accounting for
that but it's actually way better.

158
00:14:29,220 --> 00:14:34,937
All you need to do to bring in
the model for this template to render,

159
00:14:34,940 --> 00:14:40,480
is promise that you're going to load it at some
point in the future and the rest will be taken care of.

160
00:14:40,480 --> 00:14:42,982
Let's just look at this template.

161
00:14:45,142 --> 00:14:48,948
Let's emit a little more data about this.

162
00:14:48,940 --> 00:15:02,628
[Silence]

163
00:15:02,640 --> 00:15:06,377
So, what else do we have to work with here?

164
00:15:08,468 --> 00:15:11,954
Guest name, host name, poster frame.

165
00:15:14,502 --> 00:15:17,497
Let's put host first.

166
00:15:17,531 --> 00:15:33,177
[Jamie types]

167
00:15:33,220 --> 00:15:40,137
This is to 'feel out' the data and see what
it suggests as a good way to move forward.

168
00:15:40,137 --> 00:15:42,114
Interestingly...

169
00:15:42,190 --> 00:15:46,685
You won't find this in current Ember,
I'm going to leave off the closing dl tag.

170
00:15:46,680 --> 00:15:53,314
And then what you'll find here
is that the new template compiler

171
00:15:53,460 --> 00:15:58,594
has worked out that I made a
semantic mistake in not closing my dl.

172
00:16:01,691 --> 00:16:03,428
So let's do that.

173
00:16:07,714 --> 00:16:11,382
Should have a bit more display... cool.

174
00:16:13,120 --> 00:16:15,931
I guess I could just...

175
00:16:29,017 --> 00:16:32,194
DN: It should work for all but the last one.

176
00:16:32,220 --> 00:16:34,560
JW: Great.

177
00:16:35,771 --> 00:16:41,120
DN: I don't have a poster frame yet for today's episode.

178
00:16:41,120 --> 00:16:48,720
[Jamie types]

179
00:16:48,971 --> 00:16:51,634
JW: We'll be doing a lot of that.

180
00:17:00,820 --> 00:17:10,685
This data, in a sense tells us everything we need
to know about how to determine a sequence.

181
00:17:12,340 --> 00:17:17,954
What I would like to do is be able to...

182
00:17:17,970 --> 00:17:20,811
If I'm going to create this
collaborators data structure.

183
00:17:20,820 --> 00:17:25,165
I feel like I want to do it in a nice, clean unit test.

184
00:17:25,200 --> 00:17:30,000
Now that I've got that rendering
of the data it's a good place to start.

185
00:17:30,850 --> 00:17:35,062
Let's just commit that.

186
00:17:35,140 --> 00:17:41,485
So I've added a route,
which brings in the episodes data.

187
00:17:41,520 --> 00:17:46,342
I've added some of that data to my
template to make sure I fully understand it.

188
00:17:47,740 --> 00:17:51,497
And I've generated some
boilerplate tests which I'll leave alone.

189
00:17:51,508 --> 00:17:53,540
I don't care too much about them at the moment.

190
00:18:12,850 --> 00:18:15,940
Maybe the simplest thing
for now is just to have a function

191
00:18:16,660 --> 00:18:27,222
that does the job of taking these two data sources
and producing all the right things as the output.

192
00:18:27,410 --> 00:18:40,354
If I generate util,
let's call it... build-collaborators...

193
00:18:40,350 --> 00:18:46,868
[Silence]

194
00:18:47,350 --> 00:18:53,040
So that's going to generate
a function in its own module.

195
00:18:53,040 --> 00:19:01,371
[Silence]

196
00:19:01,440 --> 00:19:07,017
So I need a bunch of episodes to feed this thing.

197
00:19:08,160 --> 00:19:11,600
And I might leave the partners to one side for now.

198
00:19:11,600 --> 00:19:17,142
It would be good eventually, if that
data is available that the objects are re-used.

199
00:19:17,154 --> 00:19:20,674
So that if I've got for example, one
record for Tom loaded into memory.

200
00:19:20,690 --> 00:19:24,502
It's always that same
record, wherever I reference it.

201
00:19:24,530 --> 00:19:31,017
Let's just see if the sequencing
does what we would expect for the moment.

202
00:19:32,822 --> 00:19:36,880
I'm just going to refer to this again.

203
00:19:38,760 --> 00:19:43,062
Episode 1 begins the sequence,
therefore it has no prequel.

204
00:19:43,074 --> 00:19:46,228
but it has one sequel.

205
00:19:46,360 --> 00:19:49,725
Oh no, it has two sequels according to this data.

206
00:19:49,730 --> 00:19:53,165
Episode 1 is followed by both 2...

207
00:19:53,160 --> 00:19:58,617
So episode one is followed just by 2 and 2 is followed by 5

208
00:19:59,420 --> 00:20:01,885
Are there any that have 2 sequels?

209
00:20:01,897 --> 00:20:08,910
DN: Not yet, but I think we could easily
adapt our data to accommodate that later.

210
00:20:09,270 --> 00:20:15,310
JW: OK. So let's take some of what's in this data here.

211
00:20:19,140 --> 00:20:21,750
So the episodes we're passing in are:

212
00:20:21,750 --> 00:20:35,005
[Silence]

213
00:20:35,160 --> 00:20:38,411
Let's get the prequel side of things working first.

214
00:20:38,420 --> 00:20:41,268
The challenge being...

215
00:20:42,400 --> 00:20:48,080
Let's just base this entirely on the
ids I used to begin with... So host_ud:1

216
00:21:15,790 --> 00:21:22,708
I want to know when
I build collaborators out of this:

217
00:21:25,291 --> 00:21:27,771
So these episodes...

218
00:21:29,150 --> 00:21:33,851
Basically, I want a data structure
that's exactly as described in here.

219
00:21:36,130 --> 00:21:38,548
So I want something that looks like...

220
00:21:38,540 --> 00:21:41,062
I'll just take away this OK.

221
00:21:41,060 --> 00:21:53,051
[John types]

222
00:21:53,350 --> 00:21:56,360
What I'm expecting to get
at the other end is episode...

223
00:21:57,780 --> 00:22:00,350
It's going to look a bit like...

224
00:22:00,350 --> 00:22:08,091
[Silence]

225
00:22:08,330 --> 00:22:10,571
Like that.

226
00:22:10,570 --> 00:22:17,657
[John thinks]

227
00:22:17,657 --> 00:22:23,360
Let's just deal with the sequels.

228
00:22:25,860 --> 00:22:28,674
This is an interesting aspect,

229
00:22:30,800 --> 00:22:33,360
If they point at each other...

230
00:22:34,777 --> 00:22:37,405
Let's find out.

231
00:22:39,430 --> 00:22:41,474
It could get cyclic

232
00:22:41,485 --> 00:22:43,211
DN: Yes, that's possible.

233
00:22:43,222 --> 00:22:48,377
JW: So this collaboration is
going to point to the next one.

234
00:22:48,380 --> 00:22:53,062
via sequel which is going to point
back to this one, via prequel.

235
00:22:53,130 --> 00:22:59,360
So I can't really expand out that..
They will have to refer to each other by an id I think.

236
00:22:59,390 --> 00:23:00,331
DN: Right.

237
00:23:00,360 --> 00:23:03,540
So you don't want this one containing its sequels?

238
00:23:03,670 --> 00:23:07,314
JW: Not necessarily...
[John and Drew talk at the same time]

239
00:23:09,480 --> 00:23:12,114
It would look like...

240
00:23:12,130 --> 00:23:24,520
[Silence as John types]

241
00:23:24,980 --> 00:23:28,057
So this is an episode and
it would have this one sequel.

242
00:23:28,050 --> 00:23:34,537
But then this would have a prequel, which is...

243
00:23:34,548 --> 00:23:36,640
this one again which contains sequels.

244
00:23:42,380 --> 00:23:53,097
Maybe what I want is to simply append the id of
the prequel and ids of sequels onto these episodes.

245
00:23:53,300 --> 00:23:57,805
Otherwise it will become this cyclic thing.

246
00:24:01,325 --> 00:24:04,380
Say instead that I do get episodes back...

247
00:24:04,388 --> 00:24:07,600
I get the same two episodes but with a bit more data.

248
00:24:58,990 --> 00:25:02,228
I guess we should run some tests against this.

249
00:25:02,251 --> 00:25:07,257
Let's ditch that server for now and get a test server.

250
00:25:15,554 --> 00:25:19,325
I've got no need to see the container just now.

251
00:25:19,337 --> 00:25:22,450
That's interesting,
I'm being told I've got a jshint error.

252
00:25:36,330 --> 00:25:44,034
It's telling me that the results are just true
because I've not written a line of this method yet.

253
00:25:44,548 --> 00:25:48,460
And this is the data that's expected so let's start by...

254
00:25:51,840 --> 00:25:55,497
Rather than returning true from this let's go:

255
00:25:57,020 --> 00:26:01,485
Let's return the episodes back
and make it an identity function.

256
00:26:02,380 --> 00:26:04,130
Let's see what the diff looks like.

257
00:26:05,250 --> 00:26:08,182
I'm missing the prequel and sequel ids.

258
00:26:08,230 --> 00:26:09,890
DN: So we're close.
JW: Yes.

259
00:26:09,890 --> 00:26:15,588
[John thinks]

260
00:26:15,580 --> 00:26:23,474
JW: If we take this list of episodes.
We want to reduce it to some result.

261
00:26:23,485 --> 00:26:28,937
[Silence]

262
00:26:28,930 --> 00:26:33,462
The result is another list.

263
00:26:34,210 --> 00:26:38,880
Each time we hit an episode
we can figure out what its...

264
00:26:38,880 --> 00:26:43,748
[John thinks]

265
00:26:43,770 --> 00:26:50,902
We've got a temporal advantage which is
that our list of episodes are in order of time,

266
00:26:50,920 --> 00:26:57,657
and therefore a prequel isn't going
to appear after one of its sequels.

267
00:26:57,680 --> 00:26:58,605
DN: Yes, that's true.

268
00:26:58,640 --> 00:27:01,348
JW: Although if they did come in
a different order this would break down.

269
00:27:01,348 --> 00:27:03,050
But let's just go for this to start with.

270
00:27:03,050 --> 00:27:06,377
DN: That's a safe assumption for now at least.

271
00:27:06,480 --> 00:27:08,200
JW: Yes. So let's say:

272
00:27:08,200 --> 00:27:12,742
[John types]

273
00:27:12,750 --> 00:27:17,131
I need to figure out what its prequel id is.

274
00:27:17,140 --> 00:27:21,977
I'm looking for something in
the list of episodes, that has...

275
00:27:22,000 --> 00:27:24,800
I'll pseudo code this for a second.

276
00:27:24,830 --> 00:27:29,142
It's a prequel if my current
host was guest on that episode.

277
00:27:29,748 --> 00:27:34,605
So episode host id.

278
00:27:40,994 --> 00:27:43,862
[Inaudible]

279
00:27:52,030 --> 00:27:55,330
This isn't going to be very efficient algorithmically,

280
00:27:55,330 --> 00:27:58,060
but it's a small list so it shouldn't matter too much.

281
00:27:58,180 --> 00:28:10,868
So we want to find an episode whose
guest id matches this episode's host id.

282
00:28:10,860 --> 00:28:22,422
I think that's correct at the moment,
we will push that on to our result.

283
00:28:22,770 --> 00:28:29,737
DN: I think that find by is going to return
a record isn't it? You're assigning that to prequel id.

284
00:28:29,737 --> 00:28:32,200
JW: You're absolutely right.

285
00:28:33,070 --> 00:28:36,502
Let's make sure we actually get a prequel first.

286
00:28:44,410 --> 00:28:51,062
I'm mutating the episode that has been
passed in. I want to make a shallow copy of it.

287
00:28:51,200 --> 00:28:53,051
But we'll deal with that in a second.

288
00:28:53,050 --> 00:28:54,777
So prequel_id equals...

289
00:28:54,770 --> 00:29:01,280
[Silence]

290
00:29:01,290 --> 00:29:04,377
Let's see what effect that has.

291
00:29:04,388 --> 00:29:08,480
Sure enough we do have
a prequel id on one of them.

292
00:29:10,491 --> 00:29:12,460
It's a weird diff to read.

293
00:29:14,110 --> 00:29:16,697
DN: The second one looks right.

294
00:29:16,950 --> 00:29:21,920
JW: Yes, I think this is cool, I've got
prequel id, it's just commas it's confused about.

295
00:29:21,940 --> 00:29:25,200
OK, so let's try the
same thing with sequels.

296
00:29:28,460 --> 00:29:32,274
Rather than find by we will use filter by.

297
00:29:32,380 --> 00:29:37,542
I'll refer to the docs for these methods,
just to show you where I'm getting them from.

298
00:29:37,550 --> 00:29:43,394
These are extensions to the
array prototype [inaudible]

299
00:29:43,430 --> 00:29:50,308
You don't have to opt in to extensions,
you can leave them on the floor, if you want.

300
00:29:50,320 --> 00:29:54,060
If you don't want your core object monkey-patched.

301
00:29:54,290 --> 00:29:57,965
But they are so useful most of the time.

302
00:29:58,010 --> 00:30:03,394
So a sequel is an episode whose
host id, is equal to our guest ID.

303
00:30:03,428 --> 00:30:10,617
[Silence]

304
00:30:10,730 --> 00:30:14,205
And with this one...

305
00:30:14,260 --> 00:30:19,200
Because we know it's always a list,
we don't need to check so much.

306
00:30:23,657 --> 00:30:29,485
We can do a map by,
its another thing that Ember provides.

307
00:30:29,828 --> 00:30:32,480
I'll just break this out a bit.

308
00:30:32,662 --> 00:30:35,577
I'll probably one line that.

309
00:30:36,240 --> 00:30:39,222
Let's see what's the difference here.

310
00:30:39,330 --> 00:30:41,500
DN: It's only the "prequel_id": null.

311
00:30:44,811 --> 00:30:48,700
JW: Yes, it's undefined instead rather than null.

312
00:30:48,700 --> 00:30:55,062
[John types]

313
00:30:55,080 --> 00:30:59,188
So rather than expecting null, let's just say
the key isn't even there.

314
00:30:59,180 --> 00:31:03,062
That's our data structure.

315
00:31:03,062 --> 00:31:06,860
So yes we could now...

316
00:31:06,868 --> 00:31:10,662
Let me commit this.

317
00:31:10,720 --> 00:31:12,822
See what new stuff we've got.

318
00:31:12,880 --> 00:31:15,817
I fixed a JSHint error so...

319
00:31:15,810 --> 00:31:36,800
[Silence]

320
00:31:36,834 --> 00:31:39,230
DN: You're making your commits granular there.

321
00:31:39,230 --> 00:31:40,834
JW: Yes.

322
00:31:40,850 --> 00:31:45,794
I'm not always the best at
this, but it's such good practice.

323
00:31:46,440 --> 00:31:49,400
It's probably the best habit
you can get into as a programmer.

324
00:31:50,530 --> 00:31:53,245
Let's have a quick look at what this did.

325
00:31:53,650 --> 00:31:58,102
So I've got this
inefficient object mutating function.

326
00:31:58,130 --> 00:32:04,902
It's not a very pure function, but it does
help us work out what the algorithm is

327
00:32:04,902 --> 00:32:08,148
and what it's trying to produce.

328
00:32:08,240 --> 00:32:10,948
I'll commit this.

329
00:32:13,820 --> 00:32:19,817
So Add buildCollaborators util function.

330
00:32:21,540 --> 00:32:30,788
And then I fancy giving it a quick refactor,
to make sure that they can be refactored.

331
00:32:31,190 --> 00:32:34,180
Avoid this nasty mutation.

332
00:32:35,090 --> 00:32:38,788
Ideally, what I want is...

333
00:32:39,830 --> 00:32:43,600
Rather than using the
original episode let's copy it.

334
00:32:45,750 --> 00:32:50,582
This will be a shallow copy so it will be a new object.

335
00:32:50,620 --> 00:32:53,920
but the values for each of
the fields should be the same.

336
00:33:01,780 --> 00:33:09,142
Right, so this is telling me I've not imported Ember, and I'm going to try to use it here.

337
00:33:09,140 --> 00:33:15,257
This is all using the ES6 module syntax which
assumes you don't want things off the global scope.

338
00:33:15,462 --> 00:33:18,160
So you want something
you have to import it.

339
00:33:18,171 --> 00:33:21,497
So let's import Ember from the Ember package.

340
00:33:25,417 --> 00:33:28,720
OK cool, so that still works.

341
00:33:28,780 --> 00:33:31,920
Let's see if there's anything
else that can be tidied up there.

342
00:33:31,920 --> 00:33:33,600
I think there isn't.

343
00:33:33,650 --> 00:33:37,440
I was talking about the temporal problem earlier...

344
00:33:38,180 --> 00:33:43,348
If a sequel or a prequel appeared
elsewhere, out of order, it might not find it.

345
00:33:43,370 --> 00:33:48,605
But because we're looking over the entire
list of episodes each time that doesn't matter.

346
00:33:48,650 --> 00:33:52,457
If we wanted to make this
more efficient we could assume that

347
00:33:52,468 --> 00:33:57,554
a sequel won't appear earlier up the list
 and you can only search after this point.

348
00:33:57,600 --> 00:34:00,571
But there's very little need in this case.

349
00:34:00,730 --> 00:34:01,680
So let's just add:

350
00:34:01,680 --> 00:34:16,640
[John types]

351
00:34:16,994 --> 00:34:20,080
[New Chapter]

352
00:34:20,160 --> 00:34:23,394
So now we've got that let's...

353
00:34:24,910 --> 00:34:27,337
Let's go for another test.

354
00:34:27,350 --> 00:34:30,582
I want to know that...

355
00:34:32,250 --> 00:34:35,428
I guess that what might be a good thing to do...

356
00:34:36,890 --> 00:34:42,274
A way to represent this in HTML, could just be links.

357
00:34:42,990 --> 00:34:46,040
So jumping back and
forth between different episodes

358
00:34:46,040 --> 00:34:50,285
and making sure that
sequence is maintained correctly.

359
00:34:51,942 --> 00:34:54,800
Let's see what's the best way to do this.

360
00:34:57,230 --> 00:35:04,171
I'm going to side step the problem of mocking
out the data under test because our data is static.

361
00:35:04,194 --> 00:35:10,640
and instead I'm going to say...
[inaudible] acceptance test.

362
00:35:10,730 --> 00:35:17,314
And we'll call this walking-a-sequence.

363
00:35:20,560 --> 00:35:27,645
It should generate me a failing test, although this
test isn't going to mirror what we actually want.

364
00:35:27,650 --> 00:35:33,542
You'll notice, it's trying to
look up the URL walking sequence.

365
00:35:33,550 --> 00:35:36,868
DN: It wants to live in a world of URLs.

366
00:35:36,860 --> 00:35:46,937
[Silence]

367
00:35:46,940 --> 00:35:57,988
JW: The way to prove this works is
go to the home of the representation,

368
00:35:58,670 --> 00:36:01,977
see a list of people who
have played a part in Peer to Peer,

369
00:36:02,160 --> 00:36:05,988
click on somebody's name and
see the episode they first appeared in.

370
00:36:05,980 --> 00:36:11,577
And then see the sequels and
be able to follow to a sequel.

371
00:36:11,577 --> 00:36:13,485
DN: OK yes.

372
00:36:13,480 --> 00:36:16,834
Yes I think that makes sense.

373
00:36:17,230 --> 00:36:21,650
So I want to be able to click on Tom and see the...

374
00:36:24,994 --> 00:36:27,880
I'll remind myself what the name of the episode was.

375
00:36:28,820 --> 00:36:32,525
Counting Tree Nodes, where he was the host,

376
00:36:32,720 --> 00:36:38,537
and be able to see all the sequels to the episode.

377
00:36:38,540 --> 00:36:44,148
Click on those to follow through,
and then be able to click back to the prequel.

378
00:36:44,770 --> 00:36:49,885
I think the most logical way to represent
the sequence is probably via via links.

379
00:36:49,920 --> 00:36:51,290
DN: Yes, OK.

380
00:36:52,370 --> 00:37:02,754
What would be nice later is to find a way to
represent the whole graph In one visual snapshot.

381
00:37:02,820 --> 00:37:10,914
But this is a useful way to test
being able to pull all the data in.

382
00:37:12,030 --> 00:37:19,485
Let's call this one walking from Tom to Camille.

383
00:37:19,510 --> 00:37:22,868
Let's start by visiting the home of the app.

384
00:37:33,490 --> 00:37:38,891
And click on a link that
contains the words Tom Stuart.

385
00:37:41,410 --> 00:37:44,857
What we are expecting is that...

386
00:37:44,850 --> 00:37:48,285
[John thinks]

387
00:37:48,290 --> 00:37:53,520
At that point we should see... [inaudible] episode.

388
00:37:55,170 --> 00:38:02,605
I guess what I want to do is go from the tree
episode to the Poker ranks episode and back again.

389
00:38:04,754 --> 00:38:20,110
[Silence]

390
00:38:20,120 --> 00:38:24,731
DN: I suppose another way to look at this is
rather than starting with a list of all the people,

391
00:38:24,742 --> 00:38:30,091
you could start with a list of all
the episodes that have no prequels.

392
00:38:30,102 --> 00:38:37,554
Which at the moment, Tom's episode
has no prequel and neither has Ollie's episode.

393
00:38:37,580 --> 00:38:43,268
JW:  That sounds good, that
sounds like what I was flailing for.

394
00:38:43,394 --> 00:38:45,980
DN:  If we did have a list of all the people...

395
00:38:46,020 --> 00:38:48,590
JW: Some of those people
don't have root episodes.

396
00:38:49,090 --> 00:38:53,371
Everyone has an episode
that they first appeared on.

397
00:38:53,410 --> 00:38:55,120
Yes, OK let's do that then.

398
00:38:55,140 --> 00:38:59,965
We want the root episodes,
of the different sequences.

399
00:39:00,040 --> 00:39:04,937
Counting Tree Nodes is one of those
roots. That feels like a thing we click on.

400
00:39:05,700 --> 00:39:11,394
So when we've clicked on
Counting Tree Nodes we expect to end up on...

401
00:39:12,250 --> 00:39:17,337
See what we can ask about
this... the state you've ended up in.

402
00:39:17,360 --> 00:39:21,782
We could ask something about the
URL I think that might be useful.

403
00:39:21,780 --> 00:39:30,136
We can ask "is the current path equal
to episode 2", which I believe is Poker Hands.

404
00:39:33,410 --> 00:39:41,000
The other thing I want to know is does
this episode contain a link back to its prequel.

405
00:39:43,880 --> 00:39:53,820
So I want a link whose href is episodes 1.

406
00:39:53,890 --> 00:39:58,504
DN: So if we're starting on the home page and
we click a link that says Counting Tree Nodes.

407
00:39:58,500 --> 00:40:04,864
That is episode 1 itself. So wouldn't we end
up with currentPath() being /episodes/1.

408
00:40:05,050 --> 00:40:08,144
JW: Oh yes, of course, you're right.

409
00:40:10,560 --> 00:40:13,856
Then I'd expect to be able to click a link, of course.

410
00:40:13,860 --> 00:40:15,808
I'll get there eventually.

411
00:40:15,800 --> 00:40:27,208
[Silence]

412
00:40:27,312 --> 00:40:29,528
We expect to be able to visit the home page, 

413
00:40:29,520 --> 00:40:32,256
click on Counting Tree Nodes
then click on Ranking Poker Hands.

414
00:40:34,700 --> 00:40:38,784
Maybe we could say at certain
points what URL we expect to be on.

415
00:40:40,990 --> 00:40:43,592
It doesn't matter too much.

416
00:40:45,150 --> 00:40:48,904
I'm trying to tell the story of walking
backwards and forwards through a sequence.

417
00:40:48,970 --> 00:40:53,152
To get some confidence
that we've set things up right.

418
00:40:53,168 --> 00:40:59,928
[John types]

419
00:40:59,940 --> 00:41:03,288
Let's leave it like this for now, and see where this leads.

420
00:41:03,450 --> 00:41:09,368
DN: So we're staring at the top level in
the directory of episodes that have no prequel.

421
00:41:09,380 --> 00:41:13,184
And then we click the first one which
is Counting Tree Nodes and that has a sequel,

422
00:41:13,190 --> 00:41:15,168
which is episode 2 Ranking Poker Hands?

423
00:41:15,176 --> 00:41:16,440
JW: Yes.

424
00:41:17,730 --> 00:41:21,648
See what kind of errors...

425
00:41:21,680 --> 00:41:25,232
DN:  It doesn't like the URL walking a sequence.

426
00:41:25,496 --> 00:41:27,136
JW: Let's find out.

427
00:41:27,144 --> 00:41:28,896
DN: How did it end up there?

428
00:41:28,910 --> 00:41:31,304
JW: That's a very good question.

429
00:41:34,130 --> 00:41:38,712
Anyway, the failure is that there is
no link containing Counting Tree Nodes.

430
00:41:39,560 --> 00:41:42,576
So let's head over to this template

431
00:42:04,880 --> 00:42:14,584
We want to link to a root episode.

432
00:42:14,890 --> 00:42:19,000
And the model we want to pass
in for it is this episode here.

433
00:42:19,000 --> 00:42:34,208
[John types and mumbles]

434
00:42:34,880 --> 00:42:39,230
We need to deliver this data down.

435
00:42:39,870 --> 00:42:44,256
DN: So do we need a rootEpisodes function?

436
00:42:45,970 --> 00:42:50,024
JW: We could say that the model
for the application is the root episodes.

437
00:42:50,030 --> 00:42:52,536
So if we did that...

438
00:42:52,560 --> 00:42:57,528
Now it's getting stuck for some reason and...

439
00:43:00,400 --> 00:43:04,872
I'm going to do something to the
model before handing it over, so let's say

440
00:43:04,904 --> 00:43:34,344
[John types and mumbles]

441
00:43:34,770 --> 00:43:39,800
The first test is passing so let's see
what the world looks like at this point.

442
00:43:39,808 --> 00:43:47,144
[Silence]

443
00:43:47,140 --> 00:43:49,960
So now we're expecting...

444
00:43:49,960 --> 00:43:52,560
It should be the same list of episodes actually.

445
00:43:52,560 --> 00:43:57,544
[Silence]

446
00:43:57,560 --> 00:44:01,577
DN: Ah yes, because
buildCollaborators does return the full list.

447
00:44:01,792 --> 00:44:05,184
We don't yet have
something that just returns the roots.

448
00:44:05,180 --> 00:44:09,360
[John thinks]

449
00:44:09,590 --> 00:44:14,600
That's interesting, we're passing
something into it that it doesn't understand.

450
00:44:14,616 --> 00:44:24,432
[Silence]

451
00:44:24,750 --> 00:44:32,136
That's curious, I wonder if undefined is not
a function: what's the exact stacktrace of that?

452
00:44:34,960 --> 00:44:36,840
[Inaudible]

453
00:44:36,840 --> 00:44:46,288
[Silence]

454
00:44:46,290 --> 00:44:49,970
That is probably slightly
adrift of where it really is.

455
00:44:50,800 --> 00:44:59,590
So lets see...

456
00:44:59,870 --> 00:45:02,488
Oh, I know what I've done, again.

457
00:45:03,870 --> 00:45:05,976
Let's call this data.

458
00:45:12,290 --> 00:45:14,352
DN: Unpack it.
JW: Yes.

459
00:45:15,800 --> 00:45:17,930
Now we've got a different kind of failure...

460
00:45:17,930 --> 00:45:23,016
I'm going back to the test at this point
rather than relying on the running application.

461
00:45:23,010 --> 00:45:37,432
[Silence]

462
00:45:37,440 --> 00:45:42,376
It's not bubbling up, but the error is
that we try and link to a root called episode,

463
00:45:42,370 --> 00:45:47,008
but we've not yet said what
that root is or where it lives. So let's do that.

464
00:45:47,240 --> 00:45:49,150
Before we do that let's...

465
00:45:49,160 --> 00:46:25,008
[John types and mumbles]

466
00:46:25,080 --> 00:46:28,880
I'm happy to lump all those together as one commit.

467
00:46:32,000 --> 00:46:42,224
Use buildCollaborators and emit episode links.

468
00:46:45,740 --> 00:46:49,936
There's no root just yet so let's get that working.

469
00:46:55,760 --> 00:47:04,880
So the path to this route... is going to be that.

470
00:47:07,070 --> 00:47:09,430
Let's see what kind of difference that makes.

471
00:47:09,990 --> 00:47:11,984
Cool, now on to the next.

472
00:47:11,980 --> 00:47:14,888
[John thinks]

473
00:47:15,088 --> 00:47:19,384
Right now, there's no visible
link to Counting Tree Nodes on here.

474
00:47:19,390 --> 00:47:24,912
And technically we're on root,
which doesn't do very much.

475
00:47:24,940 --> 00:47:26,770
And there's only the template for it.

476
00:47:29,940 --> 00:47:34,768
I'll have a running version of the
app to look at, alongside the tests.

477
00:47:34,930 --> 00:47:37,128
DN: OK.

478
00:47:48,450 --> 00:47:51,128
Oh that's curious [inaudible].

479
00:47:51,120 --> 00:48:06,360
[Silence]

480
00:48:06,380 --> 00:48:08,616
Oh that's interesting.

481
00:48:08,620 --> 00:48:10,680
Oh right yes.

482
00:48:11,990 --> 00:48:17,936
I'm going to do a bit of a maneuver here.

483
00:48:18,520 --> 00:48:24,520
Right now the episodes...
let me have a look at the tree roots again.

484
00:48:24,930 --> 00:48:28,968
There's an application root
which is at the top root of everything.

485
00:48:28,980 --> 00:48:29,550
DN: OK.

486
00:48:29,550 --> 00:48:32,472
The episode route will be rendered inside of it.

487
00:48:32,490 --> 00:48:39,736
And the side where I want it rendered
is in outlet so I will put the outlet here.

488
00:48:39,730 --> 00:48:45,000
But I want the main list of episodes to
go away when I step into an individual one.

489
00:48:45,000 --> 00:48:47,968
[Inaudible] templates.

490
00:48:48,872 --> 00:48:54,860
Index is a route you get
for free you don't have to define it.

491
00:48:55,910 --> 00:48:58,560
And it should inherit its model from its parents.

492
00:48:59,450 --> 00:49:02,184
That change, I wouldn't expect to do very much.

493
00:49:02,720 --> 00:49:06,500
I could be wrong, that's
why all the tests are breaking.

494
00:49:09,416 --> 00:49:12,050
That looks the same.

495
00:49:14,050 --> 00:49:18,984
I think it might be a case
of too many changes at once.

496
00:49:19,272 --> 00:49:22,088
DN: Your test error is quite fragile I see.

497
00:49:22,110 --> 00:49:26,432
JW: It is yes, but that is
probably because we're on a...

498
00:49:27,880 --> 00:49:30,070
I know that at this point in time

499
00:49:30,070 --> 00:49:36,160
the CLI is operating to a new file
watching strategy, so that may be part of it.

500
00:49:36,180 --> 00:49:39,688
It's probably still going through growing pains.

501
00:49:41,950 --> 00:49:46,232
So now we're on roughly the same point I think.

502
00:49:52,570 --> 00:49:54,256
I'll take one of these.

503
00:49:54,290 --> 00:49:59,208
We've got the right URL, there's nothing to
display, because there's no template just yet.

504
00:49:59,220 --> 00:50:04,568
So let's make a template for this route.

505
00:50:04,616 --> 00:50:06,960
In fact, let's just generate a route.

506
00:50:20,220 --> 00:50:23,560
So I've added that other route.
It doesn't want to display yet.

507
00:50:23,590 --> 00:50:28,320
That is the right direction to head in.

508
00:50:28,320 --> 00:50:31,288
[Inaudible]

509
00:50:31,280 --> 00:50:38,896
[Silence]

510
00:50:38,912 --> 00:50:42,272
I think these are all part of one step.

511
00:50:54,610 --> 00:50:56,312
So far there's not much here.

512
00:50:56,320 --> 00:51:04,896
What we ideally want is to be able to go
from episode and refer that to that acceptance test.

513
00:51:06,640 --> 00:51:10,936
We're expecting to find another link at
this point with Ranking Poker Hands on it.

514
00:51:14,120 --> 00:51:19,944
DN: So the list you are doing now,
is a list of sequels for the current episode?

515
00:51:20,304 --> 00:51:25,160
JW: Yes, [inaudible].

516
00:51:25,160 --> 00:51:33,136
[John types]

517
00:51:33,130 --> 00:51:40,384
And we'll do the same kind of thing,
link-to sequel.challenge_name.

518
00:51:42,048 --> 00:51:49,600
[John types and mumbles]

519
00:51:49,600 --> 00:51:52,512
DN; So that's the name of the route episode?

520
00:51:53,520 --> 00:52:00,104
JW: Yes, the name of the episode,
the route and the actual instance of them.

521
00:52:00,100 --> 00:52:02,520
And the model we want for that route.

522
00:52:06,720 --> 00:52:12,288
I think my buildCollaborators function
might not be the thing I wanted after all, but...

523
00:52:12,768 --> 00:52:20,352
John and Drew laugh and John thinks again.

524
00:52:20,400 --> 00:52:23,144
I might just...

525
00:52:23,144 --> 00:52:25,140
[John types]

526
00:52:27,550 --> 00:52:30,056
I'll just check out...

527
00:52:30,050 --> 00:52:40,536
[Silence]

528
00:52:40,536 --> 00:52:43,420
DN: Your going to switch to different Ember CLI?

529
00:52:43,420 --> 00:52:51,575
JW: Yes, I'm going to go to last stable releases.
I have a feeling this is the cause of my problem so...

530
00:52:52,160 --> 00:52:54,680
Narrator: We're going to speak through this section.

531
00:52:54,704 --> 00:52:57,848
We spent almost 10
minutes troubleshooting this issue.

532
00:52:57,850 --> 00:53:02,544
But, switching to the latest stable release
of Ember CLI didn't fix the tests however.

533
00:53:03,920 --> 00:53:07,584
Narrator: We'll pick up again where
Jamie came up with a 'workaround'.

534
00:53:08,370 --> 00:53:13,048
JW: Unfortunately, in the current build of Ember CLI,

535
00:53:13,048 --> 00:53:16,736
 or rather the current master build of Ember CLI,

536
00:53:16,770 --> 00:53:23,456
some aspects when rapidly re-loading
files, causes the build to fall over.

537
00:53:23,490 --> 00:53:29,912
So for the time being, instead we will run
Ember test as a 'one off', like a one shot test.

538
00:53:29,940 --> 00:53:33,200
So it will run the tests, then
it will tear it all down again.

539
00:53:33,280 --> 00:53:36,744
That will give us
something to work against

540
00:53:37,060 --> 00:53:38,750
So it's not working at the moment.

541
00:53:39,280 --> 00:53:48,464
And the reason is that although my
buildCollaborators does point to the correct ids.

542
00:53:48,696 --> 00:53:51,640
What we won't have here is...

543
00:53:51,970 --> 00:53:55,872
We're asking for model.sequels,
but there is no such thing right now.

544
00:53:55,880 --> 00:53:56,888
DN: Of course, right.

545
00:53:56,890 --> 00:54:03,320
JW: So we need to get those.

546
00:54:04,700 --> 00:54:10,808
You're probably thinking it may
be possible to do something like: 

547
00:54:10,800 --> 00:54:23,048
a href equals episodes
sequels.id, or something like that.

548
00:54:23,260 --> 00:54:30,250
We know from buildCollaborators
that we do have the sequel ids, like this:

549
00:54:30,250 --> 00:54:34,744
[Silence]

550
00:54:34,760 --> 00:54:38,792
So based on that first bit of work we
did that's as far as we got at the moment.

551
00:54:39,700 --> 00:54:42,048
Technically, that would work.

552
00:54:43,120 --> 00:54:47,280
The API doesn't actually have an end
point for that you could load up all the data

553
00:54:47,304 --> 00:54:50,408
and find the one with the correct id.

554
00:54:51,040 --> 00:55:00,128
At this point I'm inclined to lean on
Ember.Data to do some pulling together of records.

555
00:55:00,150 --> 00:55:02,760
So I'm going to...

556
00:55:03,970 --> 00:55:06,496
I'm going to put in an elbow commit.

557
00:55:08,088 --> 00:55:10,544
Let's see what I added there.

558
00:55:13,410 --> 00:55:18,280
Let's say... [John thinks]

559
00:55:18,280 --> 00:55:26,150
Attempt to add list of sequals to an episode.

560
00:55:26,150 --> 00:55:28,952
[New Chapter]

561
00:55:29,544 --> 00:55:34,288
Let's checkout a branch.

562
00:55:34,430 --> 00:55:38,120
This will be quite a
substantial thing to start to add in.

563
00:55:39,410 --> 00:55:42,424
I think that in order to
prove that is definitely working.

564
00:55:42,430 --> 00:55:48,304
I'm going to have a play with the inspector
to begin with, rather than the test environment.

565
00:55:48,300 --> 00:55:50,750
I have a gut feeling it will be quicker that way.

566
00:55:50,752 --> 00:55:54,864
So up top, in the application route.

567
00:55:55,880 --> 00:56:01,890
Rather than this quite manual process of

568
00:56:03,040 --> 00:56:08,032
getting the data and it pulling it
out and building collaborators from that.

569
00:56:08,096 --> 00:56:11,240
I'm going to return:

570
00:56:13,288 --> 00:56:17,792
Lets see, earlier on I reached for this.

571
00:56:17,790 --> 00:56:25,480
[Silence]

572
00:56:25,490 --> 00:56:30,696
The promise library has this hash
function which is a hash of promises.

573
00:56:30,690 --> 00:56:35,984
Where they all pass on this hash with the promises switched out

574
00:56:35,990 --> 00:56:39,776
for whatever they're
resolved into. So it's quite handy.

575
00:56:39,850 --> 00:56:43,384
What this let's us do is...

576
00:56:44,344 --> 00:56:46,832
Well, I want to do two things.

577
00:56:46,840 --> 00:56:50,056
I want to load the episodes.
And that returns the promise.

578
00:56:51,176 --> 00:56:59,550
I'll do this with this.store.find episode
[inaudible] and that returns a promise.

579
00:57:06,460 --> 00:57:11,968
This is going to return two promises and it's going
to wait for them both to resolve before it finishes.

580
00:57:12,020 --> 00:57:14,472
Don't need the ajax anymore.

581
00:57:14,720 --> 00:57:19,240
DN: Do we now have to define a store for each of those?

582
00:57:19,250 --> 00:57:22,632
JW: The store we get for free, but what we do need is...

583
00:57:22,650 --> 00:57:24,984
To begin with, some models.

584
00:57:24,980 --> 00:57:44,224
[Jamie types]

585
00:57:44,390 --> 00:57:49,760
So right now this is going to be
complaining that I've got no such models, I think.

586
00:57:51,020 --> 00:57:53,256
No models found for episode.

587
00:58:11,550 --> 00:58:16,192
DN: You're using camel case deliberately
here while the API uses underscore case.

588
00:58:16,200 --> 00:58:18,376
JW: It does yes.

589
00:58:18,376 --> 00:58:23,810
Just by convention Ember
tends to use camel case where possible.

590
00:58:23,810 --> 00:58:27,520
Just because that's what JavaScript looks like.

591
00:58:28,208 --> 00:58:30,490
challengeName string...

592
00:58:30,670 --> 00:58:33,432
What else have we got... we've
got host name and guest name.

593
00:58:33,432 --> 00:58:36,048
We should be able to infer those from the...

594
00:58:36,040 --> 00:58:42,032
Let's say we've got a
guest that belongs to relationship 

595
00:58:42,040 --> 00:58:45,384
and host that belongs to relationship.

596
00:58:48,360 --> 00:58:51,776
That should have made me a model for episode.

597
00:58:51,770 --> 00:58:57,000
[Silence]

598
00:58:57,480 --> 00:59:00,672
Let's generate another one of these:

599
00:59:01,520 --> 00:59:08,056
Interesting, cannot read property of ajax. 

600
00:59:08,060 --> 00:59:15,064
Ember g model partner is the other one.

601
00:59:15,820 --> 00:59:17,550
Let's just have a look at the data.

602
00:59:48,030 --> 00:59:51,088
It might get confused about what I mean here.

603
00:59:51,080 --> 00:59:54,864
[Silence]

604
00:59:54,890 --> 00:59:58,856
It will think there's a model
with that name, but in fact these are...

605
00:59:59,460 --> 01:00:02,696
It's referring to the partner model.

606
01:00:03,960 --> 01:00:07,250
And just like in rails I'll have to tell it...

607
01:00:09,056 --> 01:00:12,552
[Inaudible]

608
01:00:12,550 --> 01:00:21,840
[Silence]

609
01:00:22,000 --> 01:00:25,856
And just like in Rails, I'll have to tell it...

610
01:00:28,960 --> 01:00:33,872
what the names of the inverse relationships
are, if the names are substantially different.

611
01:00:36,610 --> 01:00:40,280
So here, the inverse is guest.

612
01:00:42,880 --> 01:00:48,048
And here the inverse is host.

613
01:01:13,030 --> 01:01:19,152
At this point, I'm looking at building
collaborators as a way to prove to myself 

614
01:01:19,160 --> 01:01:26,280
that following host and guest that way is
what's intended by the description of the challenge.

615
01:01:26,288 --> 01:01:35,080
But I have a feeling that using Ember Data like
this is going to shoulder a lot of the work for me.

616
01:01:35,600 --> 01:01:42,176
I'm just going to go for [inaudible].

617
01:01:42,170 --> 01:01:52,152
[Silence]

618
01:01:52,176 --> 01:01:57,128
OK, so what you are seeing here is,
it's trying to load episodes partners.

619
01:01:58,180 --> 01:02:01,337
It assumes those are the
end points we're looking for.

620
01:02:01,337 --> 01:02:03,880
DN: We've got them in the API namespace haven't we?

621
01:02:03,880 --> 01:02:04,880
JW: We have indeed.

622
01:02:05,820 --> 01:02:08,528
If we add some of this, lets see...

623
01:02:09,560 --> 01:02:14,776
Firstly, use emberdata.

624
01:02:15,896 --> 01:02:18,384
Canary.

625
01:02:18,380 --> 01:02:24,800
[Jamie types]

626
01:02:24,830 --> 01:02:33,664
This isn't quite the order that
things happened in [inaudible]

627
01:02:33,660 --> 01:02:37,872
[Silence]

628
01:02:37,870 --> 01:02:40,408
And then this change...

629
01:02:40,400 --> 01:02:49,472
[Silence]

630
01:02:49,490 --> 01:02:52,000
It's fine, right so...

631
01:02:52,000 --> 01:02:58,616
[Silence]

632
01:02:58,688 --> 01:03:04,770
Retrieve episodes and partners.

633
01:03:11,170 --> 01:03:14,580
It doesn't know about the
namespace of the API just yet.

634
01:03:14,580 --> 01:03:18,251
And further more it doesn't
know to stick a .json on the end.

635
01:03:18,310 --> 01:03:22,440
We need to tell it, the way
to do that is an adapter.

636
01:03:24,300 --> 01:03:32,464
We want this to be the universal rule
so we call this the application adapter.

637
01:03:32,460 --> 01:03:51,968
[Jamie types]

638
01:03:51,992 --> 01:03:54,290
DN: Ah, forgot to save the inverse.

639
01:03:54,290 --> 01:04:00,976
JW: Yes, add inverses to... I shall say partner.

640
01:04:03,530 --> 01:04:07,344
So [inaudible] adapters, application.

641
01:04:08,050 --> 01:04:10,440
At the moment it's the REST adapter.

642
01:04:10,450 --> 01:04:18,552
But the data we're working with looks quite a
lot like what active model serializers would yield.

643
01:04:18,560 --> 01:04:23,112
So let's use that instead:

644
01:04:25,360 --> 01:04:30,072
It's expecting data of this form
so it should know what to do with it.

645
01:04:30,180 --> 01:04:39,912
Then we need to tell it the namespace
and I think it is just namespace like this.

646
01:04:39,910 --> 01:04:59,440
[Silence]

647
01:04:59,510 --> 01:05:02,860
DN: Does it still need to add .json?

648
01:05:02,860 --> 01:05:03,370
JW: It does.

649
01:05:03,370 --> 01:05:08,160
Now we're getting the right path
but without the .json on the end.

650
01:05:08,160 --> 01:05:11,712
And I think there's another method adapter:

651
01:05:11,710 --> 01:05:20,536
[Silence]

652
01:05:20,650 --> 01:05:23,440
urlPrefix is not quite what we want.

653
01:05:24,970 --> 01:05:27,240
There's pathForType.

654
01:05:29,520 --> 01:05:31,640
Which might well do the job.

655
01:05:32,340 --> 01:05:36,576
Unless there's something more general
than that, which there might not be.

656
01:05:38,570 --> 01:05:42,216
[Inaudible]

657
01:05:42,230 --> 01:05:44,840
Let's do pathForType:

658
01:05:53,810 --> 01:05:57,310
Basically this calls straight
through to the superclass method.

659
01:06:01,480 --> 01:06:04,088
And then I add .json on the end.

660
01:06:07,710 --> 01:06:11,168
Now some interesting things have happened.

661
01:06:12,150 --> 01:06:18,664
We've got these warnings here: The payload
for episode contains some unknown keys.

662
01:06:18,870 --> 01:06:22,808
It's saying you've got this data but you've
not declared that you're going to use it.

663
01:06:22,816 --> 01:06:27,296
Similarly, we've got guest episode host episode.

664
01:06:40,170 --> 01:06:43,720
It's expecting simply... like that:

665
01:06:43,720 --> 01:06:44,720
DN: Yes, right.

666
01:06:44,720 --> 01:06:49,648
So we can now use a... Lets just [inaudible] the adapter.

667
01:06:49,640 --> 01:06:55,104
[Silence]

668
01:06:55,128 --> 01:06:59,210
Add namespace and suffix to adapter.

669
01:06:59,210 --> 01:07:02,824
[Silence]

670
01:07:02,840 --> 01:07:06,312
Let's generate a serializer which will enable us 

671
01:07:06,328 --> 01:07:10,616
to perform those kind of
transformations on the input data.

672
01:07:10,690 --> 01:07:18,144
Before we do that let's stop it
complaining about those missing fields.

673
01:07:18,320 --> 01:07:23,056
That's episodes, it's expecting to see,
guest name, host name, poster frame url.

674
01:07:23,464 --> 01:07:24,840
DN: They can all be strings I suppose can't they?

675
01:07:24,848 --> 01:07:27,504
JW: Yes I guess so.

676
01:07:37,480 --> 01:07:42,560
DN: Again, you're using camel case
but the API has snakecase underscores.

677
01:07:42,570 --> 01:07:43,280
JW: Yes.

678
01:07:43,280 --> 01:07:47,336
DN: So, where is that inference
happening from one format to the other?

679
01:07:47,330 --> 01:07:49,520
It's all happening in the serializer.

680
01:07:49,520 --> 01:07:50,800
DN: Ah right.

681
01:07:50,800 --> 01:07:50,968
JW: You will find that by default there's this
normalize method which does all this kind of work,
DN: Ah right.

682
01:07:50,968 --> 01:07:57,856
JW: You will find that by default there's this
normalize method which does all this kind of work,

683
01:07:57,850 --> 01:08:04,088
converting snake case into camel
case, converting plurals into singular,

684
01:08:04,320 --> 01:08:08,160
whatever is appropriate for the format.

685
01:08:08,180 --> 01:08:10,880
Now I've got rid of some of my warnings.

686
01:08:10,890 --> 01:08:14,368
But there's still this guest
episode, host episodes problem.

687
01:08:14,380 --> 01:08:18,080
So let's say [Jamie thinks].

688
01:08:18,090 --> 01:08:26,568
We don't want a serializer for everything,
we just want a serializer for partner.

689
01:08:29,824 --> 01:08:32,544
[Inaudible]

690
01:08:40,680 --> 01:08:46,776
[Silence]

691
01:08:46,770 --> 01:08:57,712
Now Ive got partner serializer and
this is again an active model serializer.

692
01:08:57,720 --> 01:09:02,496
There has got to be some hook where
I can turn these into what it's expecting.

693
01:09:04,550 --> 01:09:08,232
I've got normalize which takes type, hash and prop

694
01:09:08,800 --> 01:09:10,432
And that's going to do this work.

695
01:09:10,460 --> 01:09:19,952
So if I normalize type has prop.

696
01:09:20,740 --> 01:09:23,472
Type meaning: when you get the data through

697
01:09:26,700 --> 01:09:32,240
it's going to infer the type from
this key, under which each record lives.

698
01:09:35,150 --> 01:09:39,264
But we don't care too
much about that manipulation here.

699
01:09:39,310 --> 01:09:43,176
All we want to do is say, let's see...

700
01:09:43,710 --> 01:09:47,992
Hash is this:

701
01:09:48,230 --> 01:09:52,464
We want to move this so we're saying 

702
01:09:52,470 --> 01:10:02,616
hash.host_episode_ids equals hash.host_episodes 

703
01:10:02,616 --> 01:10:06,096
and then delete the original
key otherwise it will complain.

704
01:10:08,544 --> 01:10:19,296
And then to do a similar thing: hash.guest_episode_id
similarly equals hash_guest_episode.

705
01:10:19,290 --> 01:10:25,640
[Silence]

706
01:10:26,510 --> 01:10:35,216
Once we've done those manipulations we just want
to hand it off to the regular class method.

707
01:10:35,456 --> 01:10:39,104
[Inaudible]

708
01:10:39,120 --> 01:10:48,064
I've not been so careful to dodge a mutation
here because I think you get passed a safe hash.

709
01:10:48,064 --> 01:10:49,336
DN: Oh, OK.

710
01:10:49,330 --> 01:10:51,816
JW: I'm fairly sure that's the case.

711
01:10:53,160 --> 01:10:57,016
Host episodes [Jamie thinks]. 

712
01:10:57,010 --> 01:10:59,400
Oh right yes. [slight laugh]

713
01:11:01,400 --> 01:11:03,851
My warnings have now gone.

714
01:11:03,880 --> 01:11:07,325
It's complaining that the value
each loops over must be an array.

715
01:11:07,400 --> 01:11:09,632
We passed a record array.

716
01:11:09,660 --> 01:11:13,608
DN: So are we down to this thing called model.sequels?

717
01:11:14,150 --> 01:11:17,952
JW: Now I'm at template index.

718
01:11:18,580 --> 01:11:25,032
I'm calling model, which is this
object here containing an episode's partners.

719
01:11:25,040 --> 01:11:30,784
So I want to do model.episodes.

720
01:11:30,850 --> 01:11:36,896
DN: Ah, because now your model is in
that promise containing both models effectively.

721
01:11:36,896 --> 01:11:38,784
JW: Yes.

722
01:11:38,780 --> 01:11:40,610
So this has got me back to this point.

723
01:11:41,590 --> 01:11:43,310
But the advantage I have now,

724
01:11:44,810 --> 01:11:47,760
Before, I got to the
point where I knew the Ids

725
01:11:47,760 --> 01:11:50,450
I wanted to get to, but
I didn't have the data to hand.

726
01:11:50,450 --> 01:11:53,360
And the question was, where do I go

727
01:11:53,360 --> 01:11:54,450
and load in that data.

728
01:11:54,450 --> 01:11:55,600
Do I have it available?

729
01:11:55,600 --> 01:11:59,500
Whereas now Ember
Data is doing that work for me.

730
01:11:59,560 --> 01:12:03,230
And furthermore, here I can see
the records that have been loaded.

731
01:12:06,590 --> 01:12:08,210
I should also be able to see...

732
01:12:09,725 --> 01:12:12,068
There will be some
computed properties here.

733
01:12:12,060 --> 01:12:15,090
So you can see,
belongs to guest episode.

734
01:12:15,660 --> 01:12:18,670
There you can see it has
managed to dig up the real model.

735
01:12:20,430 --> 01:12:23,580
That was me just clicking through

736
01:12:24,570 --> 01:12:26,640
Here's an episode, "Counting Tree Nodes".

737
01:12:26,770 --> 01:12:28,960
These are its properties, here on the right.

738
01:12:39,830 --> 01:12:42,360
I should be able to go to the guest,

739
01:12:44,380 --> 01:12:45,860
See what episodes Tom hosts,

740
01:12:45,860 --> 01:12:46,810
That's a many array,

741
01:12:46,810 --> 01:12:47,580
I'll go in there.

742
01:12:48,050 --> 01:12:51,460
It's an array containing
one which is "Ranking Poker Hands".

743
01:12:51,510 --> 01:12:53,020
So you can see it flow through.

744
01:12:54,330 --> 01:12:55,020
DN: Very nice.

745
01:12:55,970 --> 01:12:58,960
JW: leaning on Ember Data makes it
a lot quicker.

746
01:13:01,280 --> 01:13:03,680
Now that's in place, let me commit this

747
01:13:03,680 --> 01:13:05,680
quite a lot all at once.

748
01:13:06,850 --> 01:13:11,510
a new serializer, changed the template a bit.

749
01:13:11,510 --> 01:13:13,510
Oh it's not too bad, OK,

750
01:13:24,220 --> 01:13:28,610
JW: Right now we have an acceptance test.

751
01:13:30,000 --> 01:13:31,980
Which at this point is still failing.

752
01:13:31,980 --> 01:13:34,180
because we've not added the list of sequels,

753
01:13:34,180 --> 01:13:36,380
nor the prequel link yet.

754
01:13:37,230 --> 01:13:39,257
I've got some unit tests which are failing

755
01:13:39,257 --> 01:13:42,190
simply because they are just boilerplate
that was generated for me

756
01:13:43,260 --> 01:13:46,280
They need to be told
more about the rest of the world.

757
01:13:49,580 --> 01:13:52,270
I could just remove them

758
01:13:52,270 --> 01:13:55,070
I feel I want to get them passing
to have a clean environment

759
01:13:55,070 --> 01:13:56,680
So I'll do that quickly:

760
01:14:10,300 --> 01:14:12,430
When I generated the episode model

761
01:14:12,600 --> 01:14:15,000
I said that it had these two relationships

762
01:14:15,200 --> 01:14:19,270
and the boilerplate test
has these two dependencies in it

763
01:14:19,270 --> 01:14:20,290
because I said that.

764
01:14:20,520 --> 01:14:25,220
But in fact there are
no such models as those

765
01:14:25,220 --> 01:14:26,140
It's just partner...

766
01:14:27,450 --> 01:14:28,410
So if I do that:

767
01:14:30,130 --> 01:14:33,010
I have to keep jumping back to tests.

768
01:14:35,300 --> 01:14:38,800
Now episode passes

769
01:14:40,880 --> 01:14:42,920
If we flip over to the partner test
you'll see a similar problem.

770
01:14:43,530 --> 01:14:45,874
Really all this wants is:

771
01:14:53,771 --> 01:14:56,490
Now I'm back to my
acceptance test which is

772
01:14:56,491 --> 01:14:58,731
the thing that is driving us towards

773
01:14:58,810 --> 01:14:59,970
the place we want to be

774
01:14:59,977 --> 01:15:02,360
which is as follows:

775
01:15:06,850 --> 01:15:11,725
Eventually what we want to see
is a list of just the root episodes

776
01:15:11,725 --> 01:15:13,942
the episodes that begin a sequence.

777
01:15:13,990 --> 01:15:15,120
Click on one of those,

778
01:15:15,120 --> 01:15:16,700
and you see it's sequels.

779
01:15:17,220 --> 01:15:17,810
DN: Yes,

780
01:15:17,810 --> 01:15:19,890
And you click on a sequel and you see it's

781
01:15:20,460 --> 01:15:22,850
sequel, and prequel as well.

782
01:15:29,800 --> 01:15:32,760
I'm using so many
styles of working with git.

783
01:15:33,260 --> 01:15:34,790
So let's commit those:

784
01:15:37,080 --> 01:15:39,250
DN: So this is the fugitive commit feature?

785
01:15:39,250 --> 01:15:39,720
JW: Yes.

786
01:15:55,650 --> 01:15:57,240
It's complaining at the moment

787
01:15:57,240 --> 01:15:59,670
because I can't
click on Ranking Poker Hands.

788
01:16:00,630 --> 01:16:02,070
So that is...

789
01:16:02,280 --> 01:16:05,600
I'm in an episode, expecting to list all the

790
01:16:05,690 --> 01:16:07,000
sequels of the model.

791
01:16:13,520 --> 01:16:14,620
I do have <u>.</u>

792
01:16:15,290 --> 01:16:16,910
So it's ready to list something.

793
01:16:17,380 --> 01:16:20,570
It' not going to
complain that this isn't an array.

794
01:16:23,590 --> 01:16:26,260
It's more useful to just fail silently,

795
01:16:26,260 --> 01:16:28,810
when your at the template point of things

796
01:16:28,950 --> 01:16:32,410
because there's so little failure
handling you can do in template.

797
01:16:32,710 --> 01:16:34,380
As a general principle it's best to

798
01:16:34,388 --> 01:16:38,045
treat these values as monadic,

799
01:16:39,920 --> 01:16:43,730
They will resolve down
to nil, or the value you want.

800
01:16:46,800 --> 01:16:48,710
I think what I need to to is...

801
01:16:49,800 --> 01:16:51,620
get hold of these sequels.

802
01:16:51,620 --> 01:16:54,540
That's going to change
later on if I don't it now.

803
01:16:57,450 --> 01:17:00,710
The question is, if I take an episode

804
01:17:01,200 --> 01:17:02,420
how do I find it's sequel?

805
01:17:07,920 --> 01:17:11,000
I'm going to add a computed property

806
01:17:11,770 --> 01:17:12,780
to this episode

807
01:17:13,880 --> 01:17:14,840
called sequels:

808
01:17:23,885 --> 01:17:26,697
Effectively I want to look
at the rest of the episodes.

809
01:17:26,697 --> 01:17:28,510
And filter them down to just a set

810
01:17:28,920 --> 01:17:30,990
where the host is my guest.

811
01:17:32,750 --> 01:17:34,540
Let's have a look at what we have

812
01:17:34,540 --> 01:17:35,910
in terms of filtering.

813
01:17:41,110 --> 01:17:43,240
Whenever you access records in Ember data

814
01:17:43,240 --> 01:17:45,200
you always go via the store.

815
01:17:45,200 --> 01:17:49,531
Which is the central book keeping object.

816
01:17:49,570 --> 01:17:51,600
And it makes sure your always getting

817
01:17:51,800 --> 01:17:53,910
the same instance you got last time.

818
01:17:53,910 --> 01:17:54,480
DN: Right.

819
01:17:56,750 --> 01:17:59,610
I do have filter here:

820
01:18:06,020 --> 01:18:08,290
I want to try asking for:

821
01:18:17,930 --> 01:18:20,700
The thing I'm going to
be filtering on is the host id.

822
01:18:29,550 --> 01:18:31,530
Let's see what the signature of this is.

823
01:18:31,570 --> 01:18:39,820
It's just going to give
me an episode to work with.

824
01:18:41,960 --> 01:18:45,360
Now this is going to
return a promise of some kind.

825
01:18:50,340 --> 01:18:52,480
It says it returns a live record array.

826
01:18:52,790 --> 01:18:54,990
So hopefully we will be able to dump that

827
01:18:54,990 --> 01:18:56,990
into the template, and it will update

828
01:18:57,940 --> 01:18:59,790
Let's find out, that might not be true.

829
01:19:16,670 --> 01:19:19,291
We could go potentially have ids here,

830
01:19:19,291 --> 01:19:22,040
but I think they will be
hidden from us by this point.

831
01:19:22,040 --> 01:19:24,870
These are fully materialized records.

832
01:19:38,440 --> 01:19:41,640
I forgot to declare
that this is a computed property.

833
01:19:42,480 --> 01:19:44,800
There we go, so that's my sequel.

834
01:19:46,460 --> 01:19:48,411
DN: Does that give us a passing acceptance
test.

835
01:19:48,411 --> 01:19:49,420
JW: Well, let's find out.

836
01:19:55,880 --> 01:19:58,605
I think I might have messed up my link-to
helper there,

837
01:19:58,640 --> 01:19:59,550
let's find out.

838
01:20:16,950 --> 01:20:24,180
This may be a problem
with my acceptance test.

839
01:20:42,780 --> 01:20:45,970
DN: Is it the exception that's failing
where it's checking the current URL?

840
01:20:46,180 --> 01:20:46,660
JW: Yes.

841
01:20:49,770 --> 01:20:51,320
I think it might be just my...

842
01:21:01,900 --> 01:21:03,720
DN: That's why you have a commit.

843
01:21:05,028 --> 01:21:07,714
JW: So we see what happened there.

844
01:21:07,770 --> 01:21:10,290
We've added a
computed property called sequels,

845
01:21:10,560 --> 01:21:13,070
that sets up a filter

846
01:21:14,260 --> 01:21:15,770
and these filters are live.

847
01:21:15,770 --> 01:21:19,420
So the idea is, if a
new episode entered the store,

848
01:21:20,240 --> 01:21:21,670
this filter should update

849
01:21:22,140 --> 01:21:24,030
anywhere it's used in the template.

850
01:21:29,070 --> 01:21:30,980
CamelCase challenge name,

851
01:21:31,530 --> 01:21:33,050
and current path apparently

852
01:21:33,330 --> 01:21:34,730
really means current root.

853
01:21:35,760 --> 01:21:38,430
whereas what we want is the current URL.

854
01:21:39,480 --> 01:21:40,180
So:

855
01:21:53,700 --> 01:21:55,410
I feel that that acceptance test

856
01:21:55,410 --> 01:21:57,980
has given me enough
confidence that things are

857
01:21:58,250 --> 01:21:59,370
working on the whole,

858
01:21:59,370 --> 01:22:01,370
and I feel that it's going to be

859
01:22:01,660 --> 01:22:04,060
more fun just to play in the UI,

860
01:22:04,110 --> 01:22:06,330
and see what other properties it has.

861
01:22:06,330 --> 01:22:08,100
And see what other things we can do.

862
01:22:09,790 --> 01:22:10,960
So jump to episode two.

863
01:22:11,530 --> 01:22:13,714
We've already got the next sequel.

864
01:22:13,828 --> 01:22:15,428
This at the moment has no sequels

865
01:22:15,428 --> 01:22:17,371
and we're not showing prequels just yet.

866
01:22:17,371 --> 01:22:18,630
So I'm going to:

867
01:22:22,990 --> 01:22:27,470
Let's give this a title.

868
01:22:27,790 --> 01:22:29,750
DN: Yes it would be nice to see the title

869
01:22:30,260 --> 01:22:32,480
of the current episode as well.

870
01:22:33,040 --> 01:22:34,480
and maybe a poster frame.

871
01:22:50,830 --> 01:22:56,430
JW: That "Welcome to Peer to Peer"
looks surplus to requirements now,
so let's ditch that.

872
01:23:02,920 --> 01:23:06,617
I'm going to make a bunch
of cosmetic changes all at once.

873
01:23:06,820 --> 01:23:09,050
And then bundle them in to a commit.

874
01:23:14,500 --> 01:23:16,950
DN: So we've got an else branch for each

875
01:23:17,050 --> 01:23:17,620
JW: Yes.

876
01:23:19,030 --> 01:23:21,160
I forget where Ember inherited this from.

877
01:23:21,580 --> 01:23:23,160
It's not unique to Ember

878
01:23:25,980 --> 01:23:32,080
It's a little like a LISP, handlebars
templating language.

879
01:23:33,100 --> 01:23:36,050
It's not really capable
of doing multiple branches.

880
01:23:36,050 --> 01:23:38,550
in a conditional, it's only a binary.

881
01:23:38,550 --> 01:23:41,820
But it does mean you can do this kind of
thing with an each:

882
01:23:46,100 --> 01:23:47,560
I'm just going to:

883
01:23:50,090 --> 01:23:51,760
Make it look a little different.

884
01:23:57,070 --> 01:23:59,420
I'm going to add in the rudiments

885
01:24:00,610 --> 01:24:02,890
of what the prequel looks like.

886
01:24:03,480 --> 01:24:05,770
Let's make a list as well

887
01:24:06,720 --> 01:24:07,930
to make it symmetric.

888
01:24:13,450 --> 01:24:15,690
This needs to be:

889
01:24:18,560 --> 01:24:19,650
DN: Or you could say

890
01:24:20,220 --> 01:24:21,950
"this episode starts a sequence".

891
01:24:22,540 --> 01:24:23,040
JW: Yes

892
01:24:24,220 --> 01:24:25,700
I'm going to use an each again.

893
01:24:30,880 --> 01:24:32,300
Semantically, that's wrong.

894
01:24:32,860 --> 01:24:34,500
You wouldn't have more prequels.

895
01:24:35,720 --> 01:24:36,900
At least at  the moment.

896
01:24:39,950 --> 01:24:41,470
the way we are going to filter,

897
01:24:41,470 --> 01:24:43,600
I think we are going to use the same filter.

898
01:24:45,020 --> 01:24:45,600
So:

899
01:24:59,540 --> 01:25:02,040
Right now this shouldn't fail

900
01:25:02,240 --> 01:25:03,570
in a spectacular way.

901
01:25:04,050 --> 01:25:07,748
It should just silently do not very much.

902
01:25:38,450 --> 01:25:42,114
Notice the silence there...

903
01:25:42,150 --> 01:25:43,760
That indicates to me a build error.

904
01:25:45,760 --> 01:25:46,870
But maybe it's OK.

905
01:26:03,500 --> 01:26:06,020
A bunch of cosmetic
stuff... Let's just add that.

906
01:26:14,050 --> 01:26:17,700
Let's see if we can get
a prequel implemented quickly.

907
01:26:17,700 --> 01:26:20,820
I'm not going to worry
about the acceptance test for this

908
01:26:21,500 --> 01:26:23,410
I have a feeling it will be extremely

909
01:26:24,690 --> 01:26:26,550
similar to sequels.

910
01:26:46,080 --> 01:26:48,130
Here we're filtering on a guest instead.

911
01:26:48,890 --> 01:26:50,770
In the episode 2s guest is our host.

912
01:27:09,220 --> 01:27:10,080
DN: Looking good.

913
01:27:11,300 --> 01:27:13,130
So I guess the missing

914
01:27:14,140 --> 01:27:17,400
element there is that list of root.

915
01:27:19,730 --> 01:27:21,550
Those episodes without a prequel.

916
01:27:21,550 --> 01:27:21,970
JW: Yes.

917
01:27:24,480 --> 01:27:27,190
There is one little thing about this...

918
01:27:30,600 --> 01:27:32,200
these prequels and sequels

919
01:27:33,360 --> 01:27:35,810
If the host of either episode was changed

920
01:27:35,810 --> 01:27:40,080
on the fly, so if this became an editing
interface.

921
01:27:41,220 --> 01:27:44,210
these would stop being in sync with things.

922
01:27:44,210 --> 01:27:47,360
So I have to declare
that this is a computed property

923
01:27:47,360 --> 01:27:49,150
that depends on the value of host.

924
01:27:49,860 --> 01:27:52,350
And this one depends on the value of guest.

925
01:27:53,090 --> 01:27:56,210
Technically it depends on store
but store not going to change.

926
01:27:58,210 --> 01:27:59,680
That's very interesting.

927
01:28:01,010 --> 01:28:04,200
Oh, I know what I've done there, oh well.

928
01:28:04,990 --> 01:28:06,450
DN: So that second argument...

929
01:28:07,150 --> 01:28:08,720
JW: Yes, I think it's if you want to

930
01:28:08,720 --> 01:28:10,970
send a different request off to the server.

931
01:28:10,970 --> 01:28:11,420
DN: I see.

932
01:28:12,900 --> 01:28:16,420
JW: It looks like it's
requesting back and forth repeatedly.

933
01:28:16,980 --> 01:28:18,720
Let's kill that off.

934
01:28:24,560 --> 01:28:25,690
That's better.

935
01:28:28,150 --> 01:28:29,100
Excellent.

936
01:28:32,450 --> 01:28:34,170
Right, so that second argument...

937
01:28:37,680 --> 01:28:40,240
Jamie reads the last paragraph (above examples).

938
01:28:49,820 --> 01:28:53,630
So it allows you to use
the data you already have

939
01:28:53,630 --> 01:28:57,270
and make a query in the background.

940
01:28:58,100 --> 01:29:00,000
Just covering all the bases I think.

941
01:29:05,410 --> 01:29:07,520
So let's add that:

942
01:29:07,860 --> 01:29:11,990
That implements prequels.

943
01:29:21,440 --> 01:29:28,530
Here, rather than
looping over the episodes,

944
01:29:28,530 --> 01:29:32,360
we want to loop over
something like root episodes.

945
01:29:32,360 --> 01:29:33,440
DN: Yes.

946
01:29:34,030 --> 01:29:35,850
JW: I'm going to say that we're going to

947
01:29:35,850 --> 01:29:37,280
loop over simply the model.

948
01:29:39,010 --> 01:29:40,560
This is going to fail at first.

949
01:29:41,080 --> 01:29:42,180
We'll go back to:

950
01:29:46,510 --> 01:29:49,360
So it's saying:

951
01:29:49,380 --> 01:29:51,700
we're trying to each over an object,

952
01:29:51,700 --> 01:29:53,040
just a hash.

953
01:29:55,920 --> 01:29:58,320
Right now, we are
not in the application route.

954
01:29:58,420 --> 01:30:00,680
We are one down in the index route.

955
01:30:00,960 --> 01:30:02,940
So if I generate a route:

956
01:30:04,790 --> 01:30:06,630
That's like  a real live route for that.

957
01:30:14,610 --> 01:30:17,130
So by default a route will take a model

958
01:30:17,130 --> 01:30:19,130
of its parent routes, as its own.

959
01:30:22,530 --> 01:30:25,270
If we say instead, the model for this

960
01:30:25,270 --> 01:30:26,180
is going to be:

961
01:30:27,680 --> 01:30:29,700
We'll get the model for the application.

962
01:30:31,100 --> 01:30:34,180
and then we want to pluck off the

963
01:30:35,970 --> 01:30:37,770
Episodes let's say, that should be

964
01:30:37,770 --> 01:30:39,770
more or less, back to where we started.

965
01:30:43,550 --> 01:30:46,690
I think the best way to
perform that transformation is here.

966
01:30:48,100 --> 01:30:49,380
Let's think...

967
01:30:53,430 --> 01:30:55,760
We could use that filter again

968
01:30:55,760 --> 01:30:58,550
We can say:

969
01:31:00,800 --> 01:31:02,170
Actually, do you know what,

970
01:31:02,170 --> 01:31:04,610
at this point these
things are already loaded.

971
01:31:04,910 --> 01:31:07,180
Therefore we could do something like this:

972
01:31:33,200 --> 01:31:35,000
It's this kind of thing.

973
01:31:39,410 --> 01:31:40,820
I don't even quite call that,

974
01:31:40,820 --> 01:31:41,830
So let's say:

975
01:31:53,420 --> 01:31:55,310
The problem with that is that this is

976
01:31:55,310 --> 01:31:57,600
probably not quite what we think it is.

977
01:32:02,290 --> 01:32:03,220
Let's find out.

978
01:32:04,210 --> 01:32:05,440
At this point in time.

979
01:32:05,890 --> 01:32:08,260
I've got a strong feeling that if we ask for

980
01:32:09,560 --> 01:32:11,680
prequels.length, you wont get back

981
01:32:14,270 --> 01:32:16,290
an ordinary array of ordinary length.

982
01:32:16,290 --> 01:32:17,100
So:

983
01:32:26,530 --> 01:32:27,920
This is a...

984
01:32:31,440 --> 01:32:32,570
I don't know what it is.

985
01:32:33,600 --> 01:32:34,570
That seems OK.

986
01:32:37,090 --> 01:32:39,110
So that's true for at least one of them.

987
01:32:52,500 --> 01:32:54,820
DN: It seems to be
returning true every time.

988
01:32:54,820 --> 01:32:55,880
JW: It does doesn't it?

989
01:32:59,330 --> 01:33:01,670
So Ranking Poker
Hands should not be in here.

990
01:33:03,350 --> 01:33:06,400
(Some sounds of confusion)

991
01:33:06,400 --> 01:33:10,010
DN: Ah, it's working! (laughter)

992
01:33:14,990 --> 01:33:17,330
JW: It suggests you
have to ask some question

993
01:33:17,330 --> 01:33:20,240
before it completes the operation.

994
01:33:25,140 --> 01:33:32,250
I think you may well find that it's these prequels.

995
01:33:33,370 --> 01:33:36,000
It might be returning
something asynchronous.

996
01:33:36,000 --> 01:33:37,110
Some kind of promise.

997
01:33:43,420 --> 01:33:46,050
Let's think, what's the
best way to deal with this?

998
01:33:46,050 --> 01:33:47,010
Let's go for:

999
01:34:02,250 --> 01:34:03,160
I'm going to add:

1000
01:34:07,240 --> 01:34:08,630
See what else is available.

1001
01:34:08,630 --> 01:34:10,630
It might be there's another primitive

1002
01:34:10,630 --> 01:34:12,100
for doing this kind of thing.

1003
01:34:15,696 --> 01:34:20,294
Maybe we ought to add a
computed property to the episode model

1004
01:34:23,898 --> 01:34:24,762
We'll call this:

1005
01:34:28,623 --> 01:34:30,282
And this is true...

1006
01:34:36,548 --> 01:34:39,268
This is going to run into
kind of the same problem.

1007
01:34:39,326 --> 01:34:42,437
DN: If they were
prequels rather than sequels...

1008
01:34:42,680 --> 01:34:43,578
JW: Yes...

1009
01:34:49,503 --> 01:34:51,566
So let's see...

1010
01:35:13,040 --> 01:35:16,050
DN: I wasn't anticipating that
this would be the hard part.

1011
01:35:16,050 --> 01:35:18,050
It's a surprise.

1012
01:35:24,909 --> 01:35:27,772
What is it... When we start with a list

1013
01:35:27,770 --> 01:35:30,964
and it's got all five
episodes, and we click on one

1014
01:35:30,964 --> 01:35:32,960
and then go back again.

1015
01:35:32,960 --> 01:35:34,960
What is it that's changed at that point?

1016
01:35:40,480 --> 01:35:41,578
And then if we go back.

1017
01:35:41,751 --> 01:35:42,821
JW: Yes so...

1018
01:35:43,035 --> 01:35:43,894
DN: Now it's OK.

1019
01:35:45,709 --> 01:35:46,572
JW: At this point...

1020
01:35:52,757 --> 01:35:54,934
We've got these
two computed properties.

1021
01:35:55,270 --> 01:35:57,376
And the way they are bound into the DOM

1022
01:35:57,372 --> 01:35:59,264
gives them a chance to fully resolve.

1023
01:35:59,392 --> 01:36:03,168
To turn from promise to a real value.

1024
01:36:03,896 --> 01:36:07,168
Whereas in our route,

1025
01:36:07,160 --> 01:36:10,496
(sort of) inherited route environment,
we don't

1026
01:36:11,440 --> 01:36:13,848
we're saying get host.

1027
01:36:15,024 --> 01:36:17,008
sorry, rather we're saying...

1028
01:36:21,888 --> 01:36:23,544
I've still got all that to save.

1029
01:36:24,896 --> 01:36:27,352
I was expecting to see
the full list at this point.

1030
01:36:46,000 --> 01:36:49,040
What we are not doing is...

1031
01:36:49,040 --> 01:36:51,789
giving that promise
a chance to resolve itself.

1032
01:36:52,210 --> 01:36:54,909
before we return the
model data to the template.

1033
01:36:55,738 --> 01:36:58,436
I was hoping that this filter would

1034
01:36:59,229 --> 01:37:02,814
change dynamically, as
new data becomes available.

1035
01:37:02,810 --> 01:37:03,374
DN: Right.

1036
01:37:03,461 --> 01:37:05,629
It seems that isn't quite the case.

1037
01:37:09,380 --> 01:37:12,734
DN: Is there some way you can
do something before the model loads?

1038
01:37:12,734 --> 01:37:14,760
Maybe on initialization or...?

1039
01:37:15,061 --> 01:37:16,247
JW: Yes.

1040
01:37:17,098 --> 01:37:21,040
The dirty way to do it
would be to do something like this:

1041
01:37:35,447 --> 01:37:37,941
DN: And that forces the
computed property to be...?

1042
01:37:39,149 --> 01:37:41,723
JW: It's going to
kick start all those promises.

1043
01:37:41,720 --> 01:37:43,927
And change the state of all those models.

1044
01:37:47,825 --> 01:37:49,330
What's going on there?

1045
01:37:49,338 --> 01:37:51,818
Oh it's saying that I've still got no model.

1046
01:38:18,872 --> 01:38:20,036
DN: Oh that does it.

1047
01:38:20,800 --> 01:38:24,843
Unfortunately, because the model is
a little state machine,

1048
01:38:26,580 --> 01:38:31,345
to account for the fact that
you may have data landing later on...

1049
01:38:33,469 --> 01:38:37,258
other models may change around
it, that it needs to know about.

1050
01:38:38,350 --> 01:38:40,894
In order to get this
richness of relationships,

1051
01:38:40,894 --> 01:38:42,807
it can't be just a pure object.

1052
01:38:43,316 --> 01:38:45,447
You end up with these sort of situations,

1053
01:38:45,447 --> 01:38:49,360
where your having to wait
for a model to get into the right state.

1054
01:38:49,850 --> 01:38:51,854
Which is tricky, because in this case

1055
01:38:51,854 --> 01:38:54,210
we know that we have all the data up front.

1056
01:38:54,210 --> 01:38:56,203
But Ember Data is so geared up for the idea

1057
01:38:56,203 --> 01:38:58,632
that you don't know when data will arrive.

1058
01:39:00,829 --> 01:39:04,232
I have a feeling there probably is a way to...

1059
01:39:10,770 --> 01:39:16,458
There are extra properties you can add.

1060
01:39:17,860 --> 01:39:22,770
So you could say explicitly that
these are asynchronous dependencies.

1061
01:39:23,701 --> 01:39:27,360
But for us, because up in
the application route,

1062
01:39:28,218 --> 01:39:31,636
we have very deliberately
loaded in an entire store of data.

1063
01:39:31,723 --> 01:39:34,072
We shouldn't need to ever worry about that.

1064
01:39:34,669 --> 01:39:37,512
It's a shame that we're
having to do that but...

1065
01:39:38,000 --> 01:39:40,894
It gets us to the point we want,

1066
01:39:40,890 --> 01:39:43,207
which is to get these root episodes.

1067
01:39:43,381 --> 01:39:44,050
DN: Yes.

1068
01:39:44,370 --> 01:39:47,607
JW: So let's make that very explicit:

1069
01:40:10,050 --> 01:40:12,014
So, Solving Word Chain puzzles...

1070
01:40:12,203 --> 01:40:15,112
then it goes on to
Building a Basic Calculator.

1071
01:40:15,110 --> 01:40:18,509
And back there and... For good measure:

1072
01:40:20,680 --> 01:40:22,548
DN: We can link back to the top one?

1073
01:40:22,574 --> 01:40:23,207
JW: Yes.

1074
01:40:50,181 --> 01:40:51,527
Something like that.

1075
01:40:54,385 --> 01:40:58,490
JW: Cool, so now I would be interested to know...

1076
01:41:00,300 --> 01:41:02,334
To see what we're getting for our money

1077
01:41:02,385 --> 01:41:04,330
I'll quickly do this:

1078
01:41:09,030 --> 01:41:12,516
It would be interesting
to add another episode in.

1079
01:41:12,510 --> 01:41:17,301
And see if our
representation updates as we expect it to.

1080
01:41:17,510 --> 01:41:21,221
DN: So how about we imagine an episode

1081
01:41:21,221 --> 01:41:25,425
where Tom sets a challenge for Steve Purcell?

1082
01:41:28,218 --> 01:41:31,345
That will mean we have
a single root in that case.

1083
01:41:31,340 --> 01:41:35,832
But there will be a branch where
Tom has interviewed Camille and also Steve.

1084
01:41:35,830 --> 01:41:38,065
JW: Yes, right.

1085
01:41:39,230 --> 01:41:41,796
So, I want to try and do this in the inspector.

1086
01:41:41,796 --> 01:41:46,712
It's a useful way to check that
your app is behaving as you want.

1087
01:41:47,500 --> 01:41:51,408
The Ember inspector
gives you introspection

1088
01:41:51,400 --> 01:41:53,568
on everything in your living system.

1089
01:41:53,560 --> 01:41:56,928
These little $E buttons
will emit an object out

1090
01:41:56,928 --> 01:41:59,816
into the global scope, so you can play with it.

1091
01:41:59,810 --> 01:42:02,552
So this is my store.

1092
01:42:06,768 --> 01:42:09,640
I could do createRecord,

1093
01:42:11,848 --> 01:42:14,912
I could use store.createRecord,
let's try this.

1094
01:42:17,136 --> 01:42:19,800
Create record implies
that you're going to pass in

1095
01:42:19,800 --> 01:42:21,120
other concrete objects.

1096
01:42:21,120 --> 01:42:22,720
Like if there's a relationship.

1097
01:42:22,720 --> 01:42:25,816
I'm going to literally
give it Steve to work with.

1098
01:42:25,810 --> 01:42:29,176
But I think it might be more
interesting to push a new payload in.

1099
01:42:29,170 --> 01:42:32,888
This is a case where, you would have for example,

1100
01:42:32,880 --> 01:42:35,208
new data coming in over a socket.

1101
01:42:35,200 --> 01:42:38,992
Imagine that Peer to
Peer was produced so often,

1102
01:42:38,990 --> 01:42:42,000
that you had a web socket,
telling the browser that the episode...

1103
01:42:42,040 --> 01:42:44,736
You can use, I believe it's pushPayload.

1104
01:42:45,410 --> 01:42:47,584
So this is the idea of imagining a new

1105
01:42:47,768 --> 01:42:51,660
chunk of data coming into the store.

1106
01:42:54,024 --> 01:42:55,464
Let's see...

1107
01:42:57,392 --> 01:43:00,864
We've got pushPayload there,
I think we can get it on store as well.

1108
01:43:13,640 --> 01:43:15,024
Let's pushPayload,

1109
01:43:15,768 --> 01:43:18,120
What did we say, Tom interviewing Steve?

1110
01:43:18,120 --> 01:43:19,712
DN: Yes.

1111
01:43:20,288 --> 01:43:22,112
We'll go back to Counting Tree Nodes,

1112
01:43:22,110 --> 01:43:25,512
and we'll pushPayLoad which looks like:

1113
01:43:26,260 --> 01:43:27,976
DN: So the nice thing about this is

1114
01:43:27,976 --> 01:43:30,024
we don't have to create any new partners.

1115
01:43:30,020 --> 01:43:33,376
We can re-use the ones that exist.

1116
01:43:33,370 --> 01:43:36,472
JW: We're saying it will have an id of 6.

1117
01:43:38,376 --> 01:43:44,304
Challenge name: some challenge
that Tom would set for Steve

1118
01:43:44,304 --> 01:43:48,640
which would probably be
something really hard. (laughter).

1119
01:43:51,504 --> 01:43:52,736
Invent a new monad.

1120
01:43:53,976 --> 01:43:56,856
DN: Sounds interesting!

1121
01:43:57,310 --> 01:44:00,184
Guest name and host
name we don't really use,

1122
01:44:00,184 --> 01:44:01,960
so I'm going to leave them be.

1123
01:44:01,960 --> 01:44:04,592
Let's just say there's no
poster image for this one.

1124
01:44:04,590 --> 01:44:08,176
So we'll say host_id is
going to be Tom, who is 2.

1125
01:44:08,832 --> 01:44:11,176
and guest id is going to be Steve...

1126
01:44:13,448 --> 01:44:15,080
who is 4.
DN: Yes.

1127
01:44:16,520 --> 01:44:20,480
I think that to get this to work
I'll have to wrap it in an episode:

1128
01:44:24,864 --> 01:44:25,920
Namespace...

1129
01:44:26,900 --> 01:44:28,920
DN: You didn't just lose all that did you?

1130
01:44:28,920 --> 01:44:29,952
JW: I did.

1131
01:44:29,952 --> 01:44:31,950
DN: Oh dear.

1132
01:44:36,032 --> 01:44:37,904
I think it will be episode singular.

1133
01:44:37,904 --> 01:44:39,900
Maybe not, let's try episodes plural:

1134
01:44:57,928 --> 01:44:59,632
That is the end of the array.

1135
01:45:09,848 --> 01:45:12,456
There we go, Inventing a New Monad.

1136
01:45:12,450 --> 01:45:14,688
DN: And it just fits right into the sequence.

1137
01:45:15,168 --> 01:45:15,680
Very nice.

1138
01:45:15,680 --> 01:45:19,008
JW: And we should be able
to have a look in Data here.

1139
01:45:19,000 --> 01:45:20,544
There we go, yes.

1140
01:45:24,200 --> 01:45:26,640
These aren't the
computed guest and host names,

1141
01:45:26,640 --> 01:45:29,224
these are the ones
that are stored on the objects

1142
01:45:29,232 --> 01:45:31,790
that we're not really using in this case.

1143
01:45:31,792 --> 01:45:33,440
DN: We can probably ignore those.

1144
01:45:33,544 --> 01:45:38,368
JW: Yes, we genuinely have Steve the guest

1145
01:45:38,504 --> 01:45:40,360
and Tom the host.

1146
01:45:44,216 --> 01:45:46,352
I'm just going to add one
more little cosmetic thing

1147
01:45:46,350 --> 01:45:50,552
to enrich this.

1148
01:45:55,424 --> 01:45:57,056
I'm going to drop...

1149
01:46:00,416 --> 01:46:03,448
Because this was all about
collaborations to begin with,

1150
01:46:03,808 --> 01:46:05,440
Let's say:

1151
01:46:28,624 --> 01:46:30,680
DN: I would say featuring guest name.

1152
01:46:34,656 --> 01:46:37,560
JW: There is a little thing
which is going to happen here

1153
01:46:37,560 --> 01:46:41,210
which is that guests don't
have a name, I don't think.

1154
01:46:41,210 --> 01:46:45,808
DN: Yes, that's right, first name and last name.

1155
01:46:46,768 --> 01:46:48,120
But we could compute that.

1156
01:46:48,120 --> 01:46:48,752
JW: Yes.

1157
01:46:51,728 --> 01:46:53,112
That's gone from memory now,

1158
01:46:53,112 --> 01:46:56,200
so I've lost that new episode.

1159
01:46:57,192 --> 01:47:00,000
Featuring... There's no name, so I'll add that.

1160
01:47:21,832 --> 01:47:24,232
DN: That one has two dependent keys then?

1161
01:47:24,448 --> 01:47:25,200
JW: Correct.

1162
01:47:27,992 --> 01:47:30,096
Then, with a little bit of luck ....

1163
01:47:34,650 --> 01:47:39,032
This gives us the other nicety which is...

1164
01:47:44,424 --> 01:47:48,248
How does Camille spell her name,
is it CAMI?

1165
01:47:49,144 --> 01:47:50,632
DN: Good question, I don't know,

1166
01:47:50,632 --> 01:47:52,630
it's certainly pronounced Camille.

1167
01:47:55,712 --> 01:47:57,368
JW: We can now edit these details

1168
01:47:57,368 --> 01:47:59,024
in one central place.

1169
01:48:04,296 --> 01:48:05,824
DN: OK... Check it in.

1170
01:48:05,820 --> 01:48:06,440
JW: Yes.

1171
01:48:22,800 --> 01:48:24,960
This is where we:

1172
01:48:35,656 --> 01:48:38,920
DN: We've got the root, that's a major change.

1173
01:48:55,680 --> 01:48:58,904
DN: You misspelled featuring
I'm afraid (laughter)

1174
01:49:10,072 --> 01:49:14,872
DN: So we've reached a
good place to call it a day I think.

1175
01:49:14,870 --> 01:49:19,664
But if you had more time, how
would you like to continue with this?

1176
01:49:22,080 --> 01:49:26,496
For anyone familiar with building this style of

1177
01:49:27,017 --> 01:49:31,097
view on data in Rails, it probably
seems relatively simplistic.

1178
01:49:32,860 --> 01:49:35,222
If wouldn't be too
hard to do this with Rails.

1179
01:49:35,220 --> 01:49:39,828
The point is we are getting these potentially disparate

1180
01:49:39,828 --> 01:49:43,314
data sources into memory and turning them into

1181
01:49:43,310 --> 01:49:45,977
a data structure that we can then
wander around in

1182
01:49:45,980 --> 01:49:48,525
Without having to do any more re-loads

1183
01:49:48,525 --> 01:49:50,331
or fetches of data.

1184
01:49:50,330 --> 01:49:55,062
So now we have these
relationships between these objects.

1185
01:49:55,097 --> 01:49:59,588
It wouldn't be too hard to
render them out in other ways.

1186
01:49:59,580 --> 01:50:03,737
The way we have it right
now, linking between them

1187
01:50:03,737 --> 01:50:07,508
I feel like it's the...

1188
01:50:07,560 --> 01:50:10,514
simplest way to represent

1189
01:50:10,514 --> 01:50:13,108
a graph of different entities.

1190
01:50:13,100 --> 01:50:19,428
That's (kind of) the web way,
its most basic form.

1191
01:50:19,420 --> 01:50:23,771
But we could render
out a visual graph of this stuff.

1192
01:50:24,240 --> 01:50:29,737
I would be inclined to reach for Graphviz

1193
01:50:30,057 --> 01:50:34,100
or potentially D3 which has some

1194
01:50:34,100 --> 01:50:38,217
modules in it for rendering
directed graphs.

1195
01:50:38,308 --> 01:50:44,320
I know Graphviz and its dot language
better than I know D3

1196
01:50:44,320 --> 01:50:48,537
So that's what I would err towards.

1197
01:50:48,670 --> 01:50:51,451
The other thing I would like to get rid of,

1198
01:50:52,930 --> 01:50:56,754
but I just can't think of how you go about it,

1199
01:50:56,750 --> 01:50:59,405
is the reliance on this here.

1200
01:50:59,400 --> 01:51:01,451
I'm sure there is a way, probably an

1201
01:51:01,451 --> 01:51:07,325
idiomatic way, but in
essence it's because of this odd

1202
01:51:09,771 --> 01:51:15,737
thing of needing to... In the
same way you want to carry a monad,

1203
01:51:15,900 --> 01:51:18,434
up until the final moment, to finally unpack it,

1204
01:51:18,430 --> 01:51:20,491
and get the value inside it.

1205
01:51:20,491 --> 01:51:24,850
Similarly here, we want to
be dealing just in terms of promises

1206
01:51:24,868 --> 01:51:28,857
until the last possible moment,
when they are put into the template.

1207
01:51:28,850 --> 01:51:32,114
and eventually allowed to
be unpacked and rendered.

1208
01:51:32,377 --> 01:51:34,228
So, I'm sure there's a way around this.

1209
01:51:34,354 --> 01:51:38,057
but, it probably doesn't
hurt too much at this point.

1210
01:51:38,460 --> 01:51:40,754
DN: The idea will probably
will spring into your head

1211
01:51:40,754 --> 01:51:42,697
just as we turn the camera off (laughter).

1212
01:51:42,708 --> 01:51:46,110
JW: In terms of the UI, it would be...

1213
01:51:48,868 --> 01:51:53,131
You could render a tree out here of
blobs connected by sticks.

1214
01:51:55,314 --> 01:51:58,285
DN: Well, it's been really interesting watching you work

1215
01:51:58,280 --> 01:51:59,371
and how you use Ember.

1216
01:51:59,382 --> 01:52:01,470
And thanks a lot for coming on the show.

1217
01:52:01,470 --> 01:52:02,834
JW: Thanks for inviting me.

