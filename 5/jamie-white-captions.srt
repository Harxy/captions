1
00:00:01,270 --> 00:00:03,062
Welcome to Peer to Peer,

2
00:00:03,190 --> 00:00:06,982
where you can hone your
skills by watching live coding videos.

3
00:00:07,730 --> 00:00:09,737
Our guest today is Jamie White,

4
00:00:10,020 --> 00:00:13,725
who's a Ruby and JavaScript
developer at With Associates

5
00:00:13,760 --> 00:00:17,131
and a co-organizer of the London Ember meetup.

6
00:00:17,150 --> 00:00:19,120
I'm your host, Drew Neil,

7
00:00:19,300 --> 00:00:23,371
And the challenge that I set for
Jamie is called Deducing Collaborations.

8
00:00:23,908 --> 00:00:27,160
DN: OK, Jamie, would you like to
start by reading out the challenge?

9
00:00:27,177 --> 00:00:31,330
JW: OK. Generate a data
structure representing the collaborations

10
00:00:31,330 --> 00:00:34,728
between guests and hosts
in the Peer to Peer catalog.

11
00:00:34,720 --> 00:00:37,617
A collaboration has an
episode, one guest and one host.

12
00:00:37,610 --> 00:00:45,520
It appears in sequence, with an optional
prequel (0 or 1) and optional sequels (0 or more).

13
00:00:45,520 --> 00:00:49,337
Build this data structure from the
data provided as two JSON documents:

14
00:00:49,337 --> 00:00:52,590
episode.json and partners.json.

15
00:00:52,590 --> 00:00:56,720
Render a simple representation
of the data structure in a web browser.

16
00:00:56,906 --> 00:01:02,830
And on page 2, this is
how the sequencing should look.

17
00:01:02,830 --> 00:01:06,697
Episode 1 begins a sequence,
and is follod by Episode 2.

18
00:01:06,690 --> 00:01:09,645
2 follows 1 followed by 5.

19
00:01:09,645 --> 00:01:11,611
3 begins a sequence followed by 4.

20
00:01:11,610 --> 00:01:15,382
And a sequence is connected by guests and hosts.

21
00:01:15,390 --> 00:01:17,188
DN: Effectively yes.

22
00:01:17,200 --> 00:01:22,045
JW: So let's have a look at the data to begin with.

23
00:01:27,060 --> 00:01:29,257
I've already got this stuff.

24
00:01:36,450 --> 00:01:38,777
Let's look at past episodes to begin with.

25
00:01:38,777 --> 00:01:44,170
I'm interested in the ones that
do form parts of sequences already.

26
00:01:45,750 --> 00:01:51,862
We have episode one, where the
host was you and the guest was Tom.

27
00:01:52,900 --> 00:01:54,925
That sequence moves on to two,

28
00:01:54,925 --> 00:02:00,594
where Tom the guest becomes Tom
the host and Camille becomes the guest.

29
00:02:00,840 --> 00:02:04,000
And then this one leads on to here,

30
00:02:04,000 --> 00:02:07,702
where Camille goes from guest
to should have been host.

31
00:02:07,710 --> 00:02:13,497
DN: Yes, unfortunately Camille was
ill today so I'm standing in as host.

32
00:02:14,270 --> 00:02:20,262
In fact, this data is slightly stale.

33
00:02:21,250 --> 00:02:29,428
We could have changed it so that we have
a branch where I interview Tom and also you,

34
00:02:29,485 --> 00:02:32,810
but we're going to pretend
that Camille is acting as host today

35
00:02:32,810 --> 00:02:35,611
and stick with the sample data that we came up with.

36
00:02:35,720 --> 00:02:39,062
We can always adapt it later.

37
00:02:40,080 --> 00:02:46,217
JW: Thinking of the nouns in this description,
the data structure is composed of collaborations.

38
00:02:46,217 --> 00:02:48,630
The description is quite explicit about that.

39
00:02:48,630 --> 00:02:54,560
Now, at the moment, an
episode isn't strictly a collaboration.

40
00:02:54,610 --> 00:02:58,411
A collaboration should have an
episode but not necessarily be an episode.

41
00:02:58,410 --> 00:03:03,211
And the thing that isn't explicit in
this data is the prequels and sequels.

42
00:03:03,220 --> 00:03:08,228
But we know that we can determine
those from the host and guest ids.

43
00:03:13,420 --> 00:03:18,274
I am going to use Ember for this.

44
00:03:18,434 --> 00:03:23,120
A bit like reaching for Rails,
I won't use all of it to begin with,

45
00:03:23,154 --> 00:03:26,320
but it gives you plenty of
directions to go in once you're set up.

46
00:03:32,114 --> 00:03:35,245
Let me see what version of Ember CLI I'm running.

47
00:03:35,250 --> 00:03:39,177
Cool... Bleeding edge Ember CLI.

48
00:03:39,200 --> 00:03:44,662
And let's call this peertopeer.

49
00:03:48,900 --> 00:03:52,480
Ember CLI is installing all the
tooling dependencies we need.

50
00:03:52,502 --> 00:03:54,205
DN: OK.

51
00:03:56,200 --> 00:03:59,782
JW: It will take a while, there's quite a few of them.

52
00:03:59,780 --> 00:04:03,920
[Jamie types].

53
00:04:04,020 --> 00:04:10,800
Because I'm using a local copy of
Ember CLI– (I cloned it off Github)...

54
00:04:10,830 --> 00:04:18,960
With npm, what you tend to do when
working on packages that you're adapting is to...

55
00:04:18,971 --> 00:04:23,817
You do npm link and it will
symlink up your copy of the repository

56
00:04:23,817 --> 00:04:27,805
to the node_modules global directory.

57
00:04:28,650 --> 00:04:33,097
I can't use it straight away, I need
to first enter npm link ember-cli,

58
00:04:33,260 --> 00:04:36,560
and that says also use it inside this project.

59
00:04:37,630 --> 00:04:42,674
Now, if you follow the
trail in this local project,

60
00:04:42,685 --> 00:04:48,830
you'll find this symlink
here going to /usr/local/lib/node_modules.

61
00:04:48,830 --> 00:04:52,342
[inaudible].

62
00:04:52,370 --> 00:04:59,965
You'll find Ember CLI linked to my
very own copy of it. It's a nicety of npm.

63
00:04:59,965 --> 00:05:02,540
So now we should be able to do ember serve...

64
00:05:02,540 --> 00:05:09,874
[Silence].

65
00:05:09,870 --> 00:05:13,977
DN: [Inaudible].

66
00:05:14,240 --> 00:05:21,257
JW: Let's just make a quick change to
make sure we're doing what we think we're doing.

67
00:05:21,268 --> 00:05:28,491
[Silence].

68
00:05:28,525 --> 00:05:30,491
OK, it seems to work.

69
00:05:33,540 --> 00:05:45,268
I'm inclined to get the data in first and
get it in the browser and think about it that way.

70
00:05:45,348 --> 00:05:48,400
Pick up the data and put
it down again as many times as possible

71
00:05:48,400 --> 00:05:51,360
until some way to handle it emerges.

72
00:05:54,710 --> 00:06:01,371
Before we get going,
I'm going to install another dependency.

73
00:06:09,560 --> 00:06:14,342
So Ember is about to
undergo some significant improvements,

74
00:06:14,365 --> 00:06:19,680
and this Ember CLI add-on will let us use the future.

75
00:06:22,468 --> 00:06:27,382
And then I need to opt-in to the future.

76
00:06:30,925 --> 00:06:33,565
And I think I want to do that.

77
00:06:37,350 --> 00:06:39,748
I just want to do a quick check.

78
00:06:46,490 --> 00:06:51,771
Ember-htmlbars I want.
And there is another one.

79
00:06:51,771 --> 00:06:56,480
[Silence].

80
00:06:56,530 --> 00:06:59,942
DN: Did you just switch
to the repository for ember.js?

81
00:06:59,965 --> 00:07:02,251
JW: Yes.

82
00:07:04,890 --> 00:07:08,594
So I want these three features.

83
00:07:10,380 --> 00:07:14,971
If you're running on Canary at the
latest build off of master of Ember,

84
00:07:15,680 --> 00:07:20,765
the new things that are coming down
the pipe are hidden behind feature flags.

85
00:07:20,820 --> 00:07:28,400
That allows the core team
to release things incrementally,

86
00:07:28,470 --> 00:07:32,594
but it also allows people to try
them out without breaking the past.

87
00:07:32,690 --> 00:07:36,742
So I want those three things.
And the other thing I want is...

88
00:07:38,617 --> 00:07:44,582
I don't want this stable build of Ember,
I want the Canary build components.

89
00:07:50,857 --> 00:07:53,485
DN: OK, so this is bleeding edge all the way.

90
00:07:53,500 --> 00:07:59,760
JW: Yes, and the reason I think
it's going to be worth while is that

91
00:07:59,780 --> 00:08:07,005
Ember will be changing shortly after we record this,
and I think it's worth seeing what it's about to become.

92
00:08:07,000 --> 00:08:11,520
So I think I want that version of Handlebars.

93
00:08:11,600 --> 00:08:14,594
And that version of Ember.

94
00:08:16,171 --> 00:08:19,440
Let's check that has taken... yes.

95
00:08:22,350 --> 00:08:28,628
I'll just have a look at all these differences.

96
00:08:29,990 --> 00:08:37,497
So bleeding edge Ember opted in to
these new features and included HTMLBars,

97
00:08:37,497 --> 00:08:41,451
which is the next generation template compiler.

98
00:08:41,462 --> 00:08:45,222
I'll just make sure all that actually works.

99
00:08:52,560 --> 00:08:59,108
I've never quite understood this side
of Bower because it doesn't have a lockfile.

100
00:08:59,542 --> 00:09:02,450
It keeps the dependency
resolutions in the same file

101
00:09:02,450 --> 00:09:05,040
in which they were specified in the first place.

102
00:09:11,020 --> 00:09:13,870
There's not a lot of
difference to notice at the moment

103
00:09:13,870 --> 00:09:17,280
but things are better under
the hood for various reasons.

104
00:09:20,570 --> 00:09:22,450
I'm not going to in to tests just yet

105
00:09:22,450 --> 00:09:25,851
because I don't know
quite what the target is at the moment.

106
00:09:25,851 --> 00:09:30,022
I know I want a data structure.
But if it's something I want to display

107
00:09:30,030 --> 00:09:36,822
then I want to let the view lead
me to what would be most useful.

108
00:09:36,940 --> 00:09:39,154
Let's say for the beginning...

109
00:09:40,350 --> 00:09:44,560
Let's just a display a list of episodes.

110
00:09:44,560 --> 00:09:58,902
[Jamie types].

111
00:09:58,900 --> 00:10:02,342
I think that's right [inaudible].

112
00:10:02,340 --> 00:10:11,680
[Silence].

113
00:10:11,730 --> 00:10:18,697
Thinking back to Tom's Peer
to Peer and how often he commits,

114
00:10:18,708 --> 00:10:22,560
I realise that I'm already several
changes in without committing.

115
00:10:22,571 --> 00:10:29,220
Let me just commit my bits of bleeding edge stuff.

116
00:10:30,100 --> 00:10:34,845
DN: I didn't see you create a Git repository.
Was that done for you by the ember generate command?

117
00:10:34,845 --> 00:10:37,451
JW: Yes, ember new creates a repo.

118
00:10:37,470 --> 00:10:42,171
So that's my stuff to get up on the latest Ember.

119
00:10:42,170 --> 00:10:50,560
[Silence].

120
00:10:50,560 --> 00:10:54,605
And partly I want to demonstrate how
easy it is to use the bleeding edge of Ember.

121
00:10:54,628 --> 00:10:59,874
It's modelled after Rails and
Rails's command line tooling.

122
00:10:59,874 --> 00:11:03,760
So it should feel familiar to anyone who knows that.

123
00:11:03,870 --> 00:11:06,834
Check in that change as well.

124
00:11:08,205 --> 00:11:11,371
I'll just see what that is exactly... whoops.

125
00:11:14,460 --> 00:11:17,200
So that at the moment is fine.

126
00:11:17,210 --> 00:11:21,371
It's compiling. It's just that there's
nothing to render because there is no data.

127
00:11:21,394 --> 00:11:23,565
So I'm going to commit that.

128
00:11:23,560 --> 00:11:30,971
[Jamie types].

129
00:11:31,000 --> 00:11:39,040
Let's pull in those files. I've got
them next door. Let's pull them in...

130
00:11:40,130 --> 00:11:43,190
I'm going to pretend they're
coming from an API of some sort.

131
00:11:44,520 --> 00:11:47,405
So we'll put them in.

132
00:11:47,400 --> 00:11:56,091
[Jamie types].

133
00:11:56,130 --> 00:12:01,634
DN: So we now should be able to
fetch them from lolhost/api/episodes.

134
00:12:01,890 --> 00:12:06,045
JW: lolhost is because I always mistype it.

135
00:12:12,770 --> 00:12:16,480
I'll concentrate on episodes for
now because it looks the most like...

136
00:12:18,171 --> 00:12:22,500
I don't have an applcation route yet.
Routes are where data gets loaded in,

137
00:12:22,500 --> 00:12:27,360
so I will generate one of those... route application.

138
00:12:29,380 --> 00:12:33,325
I don't want to change the
template, but I do want the rest of it.

139
00:12:39,740 --> 00:12:43,908
In my template I wasn't referring to model directly,

140
00:12:43,908 --> 00:12:50,380
I'm referring to the episodes
and I'm going to stick with that.

141
00:12:50,400 --> 00:12:54,148
So what I want to return from here is...

142
00:12:54,170 --> 00:12:58,228
I'm just going to set up some aliases.

143
00:13:01,360 --> 00:13:04,250
I want to return a Promise to load in that data.

144
00:13:04,800 --> 00:13:18,570
So RSPV.hash and this is
episodes, and we need some ajax.

145
00:13:18,594 --> 00:13:24,594
I think I have the ic-ajax library handy.

146
00:13:24,590 --> 00:13:33,188
So what we want to get is [inaudible].

147
00:13:33,680 --> 00:13:37,291
I think that should be enough.

148
00:13:37,290 --> 00:13:40,217
Let's just see if it compiles.

149
00:13:40,594 --> 00:13:41,720
Yes, it seems to.

150
00:13:44,170 --> 00:13:56,194
[Jamie mumbles inaudibly as he types].

151
00:13:56,380 --> 00:14:03,234
I'm going to step back to something that looks a bit more like the guides.

152
00:14:03,234 --> 00:14:10,000
[Silence].

153
00:14:10,617 --> 00:14:12,640
DN: Oh wow, that was quick.

154
00:14:12,640 --> 00:14:15,520
JW: Yes (laughter).

155
00:14:15,520 --> 00:14:18,514
Oh, of course because ... yes.

156
00:14:18,510 --> 00:14:22,422
DN: The episodes.json is already namespaced.

157
00:14:22,422 --> 00:14:29,222
JW: Yes, I wasn't accounting for
that but it's actually way better.

158
00:14:29,220 --> 00:14:34,937
All you need to do to bring in
the model for this template to render,

159
00:14:34,940 --> 00:14:40,480
is promise that you're going to load it at some
point in the future and the rest will be taken care of.

160
00:14:40,480 --> 00:14:42,982
Let's just look at this template.

161
00:14:45,142 --> 00:14:48,948
Let's emit a little more data about this.

162
00:14:48,940 --> 00:15:02,628
[Silence].

163
00:15:02,640 --> 00:15:06,377
So, what else do we have to work with here?

164
00:15:08,468 --> 00:15:11,954
Guest name, host name, poster frame.

165
00:15:14,502 --> 00:15:17,497
Let's put host first.

166
00:15:17,531 --> 00:15:33,177
[Jamie types].

167
00:15:33,220 --> 00:15:40,137
This is to 'feel out' the data and see what
it suggests as a good way to move forward.

168
00:15:40,137 --> 00:15:42,114
Interestingly...

169
00:15:42,190 --> 00:15:46,685
You won't find this in current Ember,
I'm going to leave off the closing dl tag.

170
00:15:46,680 --> 00:15:53,314
And then what you'll find here
is that the new template compiler

171
00:15:53,460 --> 00:15:58,594
has worked out that I made a
semantic mistake in not closing my dl.

172
00:16:01,691 --> 00:16:03,428
So let's do that.

173
00:16:07,714 --> 00:16:11,382
Should have a bit more display... cool.

174
00:16:13,120 --> 00:16:15,931
I guess I could just...

175
00:16:29,017 --> 00:16:32,194
DN: It should work for all but the last one.

176
00:16:32,220 --> 00:16:34,560
JW: Great.

177
00:16:35,771 --> 00:16:41,120
DN: I don't have a poster frame yet for today's episode.

178
00:16:41,120 --> 00:16:48,720
[Jamie types].

179
00:16:48,971 --> 00:16:51,634
JW: We'll be doing a lot of that.

180
00:17:00,820 --> 00:17:10,685
This data, in a sense tells us everything we need
to know about how to determine a sequence.

181
00:17:12,340 --> 00:17:17,954
What I would like to do is be able to...

182
00:17:17,970 --> 00:17:20,811
If I'm going to create this
collaborators data structure.

183
00:17:20,820 --> 00:17:25,165
I feel like I want to do it in a nice, clean unit test.

184
00:17:25,200 --> 00:17:30,000
Now that I've got that rendering
of the data it's a good place to start.

185
00:17:30,850 --> 00:17:35,062
Let's just commit that.

186
00:17:35,140 --> 00:17:41,485
So I've added a route,
which brings in the episodes data.

187
00:17:41,520 --> 00:17:46,342
I've added some of that data to my
template to make sure I fully understand it.

188
00:17:47,740 --> 00:17:51,497
And I've generated some
boilerplate tests which I'll leave alone.

189
00:17:51,508 --> 00:17:53,540
I don't care too much about them at the moment.

190
00:18:12,850 --> 00:18:15,940
Maybe the simplest thing
for now is just to have a function

191
00:18:16,660 --> 00:18:27,222
that does the job of taking these two data sources
and producing all the right things as the output.

192
00:18:27,410 --> 00:18:40,354
If I generate util,
let's call it... build-collaborators...

193
00:18:40,350 --> 00:18:46,868
[Silence].

194
00:18:47,350 --> 00:18:53,040
So that's going to generate
a function in its own module.

195
00:18:53,040 --> 00:19:01,371
[Silence].

196
00:19:01,440 --> 00:19:07,017
So I need a bunch of episodes to feed this thing.

197
00:19:08,160 --> 00:19:11,600
And I might leave the partners to one side for now.

198
00:19:11,600 --> 00:19:17,142
It would be good eventually, if that
data is available that the objects are re-used.

199
00:19:17,154 --> 00:19:20,674
So that if I've got for example, one
record for Tom loaded into memory.

200
00:19:20,690 --> 00:19:24,502
It's always that same
record, wherever I reference it.

201
00:19:24,530 --> 00:19:31,017
Let's just see if the sequencing
does what we would expect for the moment.

202
00:19:32,822 --> 00:19:36,880
I'm just going to refer to this again.

203
00:19:38,760 --> 00:19:43,062
Episode 1 begins the sequence,
therefore it has no prequel.

204
00:19:43,074 --> 00:19:46,228
but it has one sequel.

205
00:19:46,360 --> 00:19:49,725
Oh no, it has two sequels according to this data.

206
00:19:49,730 --> 00:19:53,165
Episode 1 is followed by both 2...

207
00:19:53,160 --> 00:19:58,617
So episode one is followed just by 2 and 2 is followed by 5

208
00:19:59,420 --> 00:20:01,885
Are there any that have 2 sequels?

209
00:20:01,897 --> 00:20:08,910
DN: Not yet, but I think we could easily
adapt our data to accommodate that later.

210
00:20:09,270 --> 00:20:15,310
JW: OK. So let's take some of what's in this data here.

211
00:20:19,140 --> 00:20:21,750
So the episodes we're passing in are:

212
00:20:21,750 --> 00:20:35,005
[Silence].

213
00:20:35,160 --> 00:20:38,411
Let's get the prequel side of things working first.

214
00:20:38,420 --> 00:20:41,268
The challenge being...

215
00:20:42,400 --> 00:20:48,080
Let's just base this entirely on the
ids I used to begin with... So host_ud:1

216
00:21:15,790 --> 00:21:22,708
I want to know when
I build collaborators out of this:

217
00:21:25,291 --> 00:21:27,771
So these episodes...

218
00:21:29,150 --> 00:21:33,851
Basically, I want a data structure
that's exactly as described in here.

219
00:21:36,130 --> 00:21:38,548
So I want something that looks like... 

220
00:21:38,540 --> 00:21:41,062
I'll just take away this OK.

221
00:21:41,060 --> 00:21:53,051
[John types].

222
00:21:53,350 --> 00:21:56,360
What I'm expecting to get
at the other end is episode...

223
00:21:57,780 --> 00:22:00,350
It's going to look a bit like...

224
00:22:00,350 --> 00:22:08,091
[Silence].

225
00:22:08,330 --> 00:22:10,571
Like that.

226
00:22:10,570 --> 00:22:17,657
[John thinks].

227
00:22:17,657 --> 00:22:23,360
Let's just deal with the sequels.

228
00:22:25,860 --> 00:22:28,674
This is an interesting aspect,

229
00:22:30,800 --> 00:22:33,360
If they point at each other...

230
00:22:34,777 --> 00:22:37,405
Let's find out.

231
00:22:39,430 --> 00:22:41,474
It could get cyclic

232
00:22:41,485 --> 00:22:43,211
DN: Yes, that's possible.

233
00:22:43,222 --> 00:22:48,377
JW: So this collaboration is
going to point to the next one.

234
00:22:48,380 --> 00:22:53,062
via sequel which is going to point
back to this one, via prequel.

235
00:22:53,130 --> 00:22:59,360
So I can't really expand out that..
They will have to refer to each other by an id I think.

236
00:22:59,390 --> 00:23:00,331
DN: Right.

237
00:23:00,360 --> 00:23:03,540
So you don't want this one containing its sequels?

238
00:23:03,670 --> 00:23:07,314
JW: Not necessarily...
[John and Drew talk at the same time].

239
00:23:09,480 --> 00:23:12,114
It would look like...

240
00:23:12,130 --> 00:23:24,520
[Silence as John types].

241
00:23:24,980 --> 00:23:28,057
So this is an episode and
it would have this one sequel.

242
00:23:28,050 --> 00:23:34,537
But then this would have a prequel, which is...

243
00:23:34,548 --> 00:23:36,640
this one again which contains sequels.

244
00:23:42,380 --> 00:23:53,097
Maybe what I want is to simply append the id of
the prequel and ids of sequels onto these episodes.

245
00:23:53,300 --> 00:23:57,805
Otherwise it will become this cyclic thing.

246
00:24:01,325 --> 00:24:04,380
Say instead that I do get episodes back...

247
00:24:04,388 --> 00:24:07,600
I get the same two episodes but with a bit more data.

248
00:24:58,990 --> 00:25:02,228
I guess we should run some tests against this.

249
00:25:02,251 --> 00:25:07,257
Let's ditch that server for now and get a test server.

250
00:25:15,554 --> 00:25:19,325
I've got no need to see the container just now.

251
00:25:19,337 --> 00:25:22,450
That's interesting,
I'm being told I've got a jshint error.

252
00:25:36,330 --> 00:25:44,034
It's telling me that the results are just true
because I've not written a line of this method yet.

253
00:25:44,548 --> 00:25:48,460
And this is the data that's expected so let's start by...

254
00:25:51,840 --> 00:25:55,497
Rather than returning true from this let's go:

255
00:25:57,020 --> 00:26:01,485
Let's return the episodes back
and make it an identity function.

256
00:26:02,380 --> 00:26:04,130
Let's see what the diff looks like.

257
00:26:05,250 --> 00:26:08,182
I'm missing the prequel and sequel ids.

258
00:26:08,230 --> 00:26:09,890
DN: So we're close.
JW: Yes.

259
00:26:09,890 --> 00:26:15,588
[John thinks].

260
00:26:15,580 --> 00:26:23,474
JW: If we take this list of episodes.
We want to reduce it to some result.

261
00:26:23,485 --> 00:26:28,937
[Silence].

262
00:26:28,930 --> 00:26:33,462
The result is another list.

263
00:26:34,210 --> 00:26:38,880
Each time we hit an episode
we can figure out what its...

264
00:26:38,880 --> 00:26:43,748
[John thinks].

265
00:26:43,770 --> 00:26:50,902
We've got a temporal advantage which is
that our list of episodes are in order of time,

266
00:26:50,920 --> 00:26:57,657
and therefore a prequel isn't going
to appear after one of its sequels.

267
00:26:57,680 --> 00:26:58,605
DN: Yes, that's true.

268
00:26:58,640 --> 00:27:01,250
JW: Although if they did come in
a different order this would break down.

269
00:27:01,257 --> 00:27:03,050
But let's just go for this to start with.

270
00:27:03,051 --> 00:27:05,940
DN: That's a safe assumption for now at least.

271
00:27:06,480 --> 00:27:08,200
JW: Yes. So let's say:

272
00:27:12,750 --> 00:27:16,660
I need to figure out
what its prequel id is.

273
00:27:17,140 --> 00:27:21,330
I'm looking for something in
the list of episodes, that has...

274
00:27:22,000 --> 00:27:23,874
I'll pseudo code this for a second.

275
00:27:24,834 --> 00:27:28,780
it's a prequel if my current
host was guest on that episode.

276
00:27:52,030 --> 00:27:55,330
This isn't going to be very efficient algorithmically

277
00:27:55,330 --> 00:27:58,060
But it's a small list so
it shouldn't matter too much.

278
00:27:58,180 --> 00:27:59,570
So we want to find,

279
00:28:00,450 --> 00:28:03,360
an episode whose guest id

280
00:28:05,810 --> 00:28:08,220
matches this episode's host id.

281
00:28:22,860 --> 00:28:26,420
DN: I think that find by is
going to return a record isn't it?

282
00:28:26,420 --> 00:28:29,380
You're assigning that to prequel id.

283
00:28:29,960 --> 00:28:32,205
JW: You're absolutely right.

284
00:28:33,070 --> 00:28:36,194
Let's make sure we
actually get a prequel first.

285
00:28:44,410 --> 00:28:46,930
I'm mutating the
episode that has been passed in

286
00:28:47,460 --> 00:28:50,880
I want to make a shallow copy of it.

287
00:28:51,200 --> 00:28:53,010
But we'll deal with that in a second.

288
00:29:01,290 --> 00:29:04,377
Let's see what effect that has.

289
00:29:04,388 --> 00:29:08,480
Sure enough we do have
a prequel id on one of them.

290
00:29:10,491 --> 00:29:12,460
It's a weird diff to read.

291
00:29:14,110 --> 00:29:16,697
DN: The second one looks right.

292
00:29:16,950 --> 00:29:18,300
JW: Yes, I think this is cool.

293
00:29:18,300 --> 00:29:21,380
I've got prequel id, it's
just commas it's confused about.

294
00:29:21,940 --> 00:29:25,200
OK, so let's try the
same thing with sequels.

295
00:29:28,460 --> 00:29:30,640
Rather than find
by we will use filter by.

296
00:29:32,380 --> 00:29:34,500
I'll refer to the docs for these methods,

297
00:29:34,500 --> 00:29:37,280
just to show you
where I'm getting them from.

298
00:29:37,550 --> 00:29:42,070
These are extensions
to the array prototype

299
00:29:43,430 --> 00:29:45,360
You don't have to opt in to extensions.

300
00:29:45,360 --> 00:29:47,430
You can leave them on the floor.

301
00:29:50,340 --> 00:29:54,060
If you don't want your
core object monkey-patched.

302
00:29:54,290 --> 00:29:57,140
But they are so useful most of the time

303
00:29:58,010 --> 00:30:00,740
So a sequel is an episode whose host id,

304
00:30:00,740 --> 00:30:02,080
is equal to our guest ID.

305
00:30:10,730 --> 00:30:12,340
And with this one...

306
00:30:14,260 --> 00:30:15,970
Because we know it's always a list,

307
00:30:16,090 --> 00:30:18,260
we don't need to check so much.

308
00:30:29,910 --> 00:30:31,650
I'll just break this out a bit.

309
00:30:36,240 --> 00:30:38,171
Let's see what's the difference here.

310
00:30:39,330 --> 00:30:41,500
DN: It's only the "prequel_id": null.

311
00:30:44,940 --> 00:30:48,708
JW: Yes, it's undefined instead rather than null.

312
00:30:55,080 --> 00:30:57,990
So rather than expecting null, let's just say
the key isn't even there.

313
00:30:59,170 --> 00:31:02,610
That's our data structure.

314
00:31:07,350 --> 00:31:08,970
Let me commit this.

315
00:31:10,720 --> 00:31:12,190
See what new stuff we've got.

316
00:31:12,880 --> 00:31:15,520
I fixed a JSHint error so I'll:

317
00:31:36,900 --> 00:31:39,230
DN: You're making your
commits granular there.

318
00:31:39,230 --> 00:31:39,620
JW: Yes

319
00:31:40,850 --> 00:31:42,790
I'm not always the best at this,

320
00:31:43,310 --> 00:31:45,260
but it's such good practice.

321
00:31:46,440 --> 00:31:49,400
It's probably the best habit you can get
into as a programmer

322
00:31:50,530 --> 00:31:52,490
Let's have a quick look at what this did.

323
00:31:53,650 --> 00:31:54,580
So I've got this...

324
00:31:55,170 --> 00:31:58,100
inefficient object mutating function.

325
00:31:58,130 --> 00:32:00,320
It's not a very
pure function, but it does

326
00:32:01,830 --> 00:32:04,890
help us work out what the algorithm is

327
00:32:04,890 --> 00:32:06,890
and what it's trying to produce.

328
00:32:08,240 --> 00:32:09,120
I'll commit this.

329
00:32:22,210 --> 00:32:25,140
I fancy giving it a quick refactor,

330
00:32:25,140 --> 00:32:27,280
to make sure that they can be refactored.

331
00:32:31,190 --> 00:32:34,180
Avoid this nasty mutation.

332
00:32:35,090 --> 00:32:37,420
Ideally, what I want is...

333
00:32:39,830 --> 00:32:42,620
Rather than using the
original episode let's copy it.

334
00:32:45,750 --> 00:32:50,420
This will be a shallow
copy so it will be a new object.

335
00:32:50,620 --> 00:32:53,920
but the values for each of
the fields should be the same.

336
00:33:01,780 --> 00:33:07,120
Right, so this is telling
me I've not imported Ember,

337
00:33:07,120 --> 00:33:08,760
and I'm going to try to use it here.

338
00:33:09,140 --> 00:33:11,920
This is all using the ES6 module syntax

339
00:33:12,590 --> 00:33:15,760
which assumes you don't
want things off the global scope.

340
00:33:15,760 --> 00:33:18,030
If you want
something you have to import it.

341
00:33:18,130 --> 00:33:20,820
So let's import Ember
from the Ember package.

342
00:33:28,780 --> 00:33:31,920
Let's see if there's anything
else that can be tidied up there.

343
00:33:31,920 --> 00:33:32,960
I think there isn't.

344
00:33:33,650 --> 00:33:36,340
I was talking about
the temporal problem earlier...

345
00:33:38,180 --> 00:33:40,570
If a sequel or a prequel appeared elsewhere,

346
00:33:40,570 --> 00:33:42,570
out of order,

347
00:33:42,570 --> 00:33:43,580
it might not find it.

348
00:33:43,580 --> 00:33:47,291
But because we're looking
over the entire list of episodes each time

349
00:33:47,300 --> 00:33:48,450
that doesn't matter.

350
00:33:48,650 --> 00:33:50,770
If we wanted to make this more efficient

351
00:33:50,770 --> 00:33:53,810
we could assume that a sequel won't appear

352
00:33:54,140 --> 00:33:57,300
earlier up the list, and you
can only search after this point.

353
00:33:57,600 --> 00:33:59,680
But there's very
little need in this case.

354
00:34:00,730 --> 00:34:01,680
So let's just add:

355
00:34:20,160 --> 00:34:22,210
So now we've got that let's...

356
00:34:24,910 --> 00:34:26,490
Let's go for another test.

357
00:34:27,350 --> 00:34:29,300
I want to know that...

358
00:34:32,250 --> 00:34:34,740
I guess that what
might be a good thing to do...

359
00:34:36,890 --> 00:34:40,080
a way to represent this in HTML,

360
00:34:40,710 --> 00:34:42,080
could just be links.

361
00:34:42,990 --> 00:34:46,040
So jumping back and
forth between different episodes

362
00:34:46,040 --> 00:34:49,050
and making sure that
sequence is maintained correctly.

363
00:34:52,180 --> 00:34:54,080
Let's see what's the best way to do this.

364
00:34:57,860 --> 00:35:00,500
I'm going to side step the problem of

365
00:35:01,170 --> 00:35:03,010
mocking out the data under test

366
00:35:03,010 --> 00:35:04,450
because our data is static

367
00:35:04,450 --> 00:35:05,890
and instead I'm going to say:

368
00:35:10,730 --> 00:35:12,810
We'll call this:

369
00:35:20,560 --> 00:35:22,450
It should generate me a failing test.

370
00:35:22,450 --> 00:35:26,800
although this test isn't going
to mirror what we actually want

371
00:35:27,650 --> 00:35:29,500
You'll notice, it's trying to look up

372
00:35:29,500 --> 00:35:31,800
the URL walking sequence.

373
00:35:33,550 --> 00:35:35,760
DN: It wants to live in a world of URLs.

374
00:35:46,940 --> 00:35:48,750
JW: The way to prove this works is...

375
00:35:54,730 --> 00:35:57,920
go to the home of the representation,

376
00:35:58,670 --> 00:35:59,920
see a list of people

377
00:36:00,110 --> 00:36:02,050
who have played a part in Peer to Peer

378
00:36:02,160 --> 00:36:04,570
click on somebody's
name and see the episode

379
00:36:04,570 --> 00:36:05,780
they first appeared in.

380
00:36:05,980 --> 00:36:08,990
And then see the sequels

381
00:36:09,810 --> 00:36:11,460
and be able to follow to a sequel.

382
00:36:13,570 --> 00:36:16,290
Yes I think that makes sense.

383
00:36:17,230 --> 00:36:21,650
So I want to be able
to click on Tom and see the...

384
00:36:25,220 --> 00:36:27,880
I'll remind myself what
the name of the episode was.

385
00:36:28,820 --> 00:36:32,450
Counting Tree Nodes, where he was the host,

386
00:36:32,720 --> 00:36:34,450
and be able to see...

387
00:36:36,560 --> 00:36:38,180
all the sequels to the episode

388
00:36:38,180 --> 00:36:40,180
click on those to follow through,

389
00:36:40,180 --> 00:36:41,740
and then be able to click back

390
00:36:42,180 --> 00:36:45,680
to the prequel.

391
00:36:45,680 --> 00:36:47,830
I think the most logical way to represent

392
00:36:47,830 --> 00:36:49,830
the sequence is probably via via links.

393
00:36:49,920 --> 00:36:50,560
DN: Yes, OK.

394
00:36:52,370 --> 00:36:55,020
What would be nice later is to find

395
00:36:55,020 --> 00:36:57,860
a way to represent the whole graph.

396
00:36:59,540 --> 00:37:02,090
In one visual snapshot.

397
00:37:02,820 --> 00:37:06,040
But this is a useful way to...

398
00:37:06,340 --> 00:37:08,330
test being able to pull all the data in.

399
00:37:12,030 --> 00:37:12,980
Let's call this one:

400
00:37:19,510 --> 00:37:21,860
Let's start by
visiting the home of the app.

401
00:37:33,490 --> 00:37:36,290
A link that contains the words Tom Stuart.

402
00:37:41,410 --> 00:37:43,630
What we are expecting is that...

403
00:37:48,290 --> 00:37:50,180
At that point we should see...

404
00:37:55,170 --> 00:37:57,170
I guess what I want to do is go

405
00:37:58,670 --> 00:38:02,090
from the tree episode
to the Poker ranks episode

406
00:38:02,090 --> 00:38:03,150
and back again.

407
00:38:20,090 --> 00:38:22,220
DN: I suppose another way to look at this is

408
00:38:22,220 --> 00:38:24,860
rather than starting
with a list of all the people,

409
00:38:25,250 --> 00:38:27,160
you could start with a list of all the,

410
00:38:27,670 --> 00:38:29,300
episodes that have no prequels

411
00:38:30,410 --> 00:38:31,820
which at the moment

412
00:38:32,510 --> 00:38:34,020
Tom's episode has no prequel

413
00:38:34,020 --> 00:38:36,020
and Ollie's episode has no prequel.

414
00:38:37,580 --> 00:38:39,530
JW:  That sounds good, that sounds like

415
00:38:40,180 --> 00:38:41,530
what I was flailing for.

416
00:38:43,330 --> 00:38:45,390
DN:  If we did have a list of all the people

417
00:38:46,020 --> 00:38:48,590
JW: Some of those people
don't have root episodes.

418
00:38:49,090 --> 00:38:51,900
Everyone has an
episode that they first appeared on.

419
00:38:53,410 --> 00:38:54,660
Yes, OK let's do that then.

420
00:38:55,140 --> 00:38:57,300
We want the root episodes,

421
00:38:57,300 --> 00:38:59,020
of the different sequences.

422
00:39:00,040 --> 00:39:02,260
Counting Tree Nodes
is one of those roots.

423
00:39:02,340 --> 00:39:04,160
That feels like a thing we click on.

424
00:39:06,320 --> 00:39:08,550
When we've clicked on Counting Tree Nodes

425
00:39:08,710 --> 00:39:11,100
we expect to end up on...

426
00:39:12,250 --> 00:39:13,840
see what we can ask about this.

427
00:39:15,420 --> 00:39:16,850
the state you've ended up in.

428
00:39:17,360 --> 00:39:19,250
We could ask something about the URL

429
00:39:19,250 --> 00:39:21,250
I think that might be useful.

430
00:39:33,410 --> 00:39:35,060
The other thing I want to know is

431
00:39:35,060 --> 00:39:39,060
does this episode
contain a link back to its prequel.

432
00:39:53,890 --> 00:39:55,650
DN: So if we're starting on the home page

433
00:39:55,830 --> 00:39:58,410
and we click a link
that says Counting Tree Nodes.

434
00:39:58,500 --> 00:40:00,490
That is episode 1 itself.

435
00:40:00,490 --> 00:40:04,640
So wouldn't we end up with
currentPath() being /episodes/1.

436
00:40:05,050 --> 00:40:06,640
JW: Oh yes, of course, you're right.

437
00:40:10,560 --> 00:40:13,160
Then I'd expect to be
able to click a link, of course.

438
00:40:13,860 --> 00:40:15,250
I'll get there eventually.

439
00:40:15,250 --> 00:40:15,730
DN: OK.

440
00:40:27,370 --> 00:40:29,460
We expect to be
able to visit the home page

441
00:40:29,490 --> 00:40:30,920
click on Counting Tree Nodes

442
00:40:30,920 --> 00:40:32,740
then click on Ranking Poker Hands

443
00:40:34,740 --> 00:40:36,700
We could say at certain points what

444
00:40:36,700 --> 00:40:38,260
URL we expect to be on.

445
00:40:40,990 --> 00:40:42,940
It doesn't matter too much

446
00:40:45,150 --> 00:40:47,120
I'm trying to tell the story of walking
backwards and forwards

447
00:40:47,140 --> 00:40:48,410
through a sequence.

448
00:40:48,970 --> 00:40:50,960
to get some confidence that

449
00:40:50,960 --> 00:40:52,770
we've set things up right.

450
00:40:59,940 --> 00:41:01,570
Let's leave it like this for now,

451
00:41:01,570 --> 00:41:02,850
and see where this leads.

452
00:41:03,450 --> 00:41:05,300
DN: So we're staring at the top level.

453
00:41:05,300 --> 00:41:08,800
In the directory of
episodes that have no prequel

454
00:41:09,380 --> 00:41:10,950
And then we click the first one

455
00:41:10,950 --> 00:41:12,490
which is Counting Tree Nodes

456
00:41:12,490 --> 00:41:14,000
and that has a sequel which is

457
00:41:14,000 --> 00:41:15,620
episode 2 Ranking Poker Hands?

458
00:41:15,620 --> 00:41:16,440
JW: Yes.

459
00:41:17,730 --> 00:41:19,530
See what kind of errors...

460
00:41:21,680 --> 00:41:24,520
DN:  It doesn't like
the URL walking a sequence.

461
00:41:25,610 --> 00:41:26,520
JW: Let's find out.

462
00:41:26,520 --> 00:41:28,520
DN: How did it end up there?

463
00:41:28,910 --> 00:41:30,500
JW: That's a very good question.

464
00:41:34,130 --> 00:41:36,110
Anyway, the failure is that there is no

465
00:41:36,110 --> 00:41:38,300
link containing Counting Tree Nodes.

466
00:41:39,560 --> 00:41:42,080
So let's head over to this template

467
00:42:05,120 --> 00:42:06,840
We want to link to a root episode.

468
00:42:14,890 --> 00:42:17,230
And the model we
want to pass in for it is this:

469
00:42:17,490 --> 00:42:19,230
This episode here.

470
00:42:34,880 --> 00:42:39,230
We need to deliver this data down

471
00:42:39,870 --> 00:42:42,640
DN: So do we need
a rootEpisodes function?

472
00:42:46,040 --> 00:42:49,634
We could say that the model for
the application is the root episodes.

473
00:42:49,634 --> 00:42:51,610
So if we did that:

474
00:42:52,560 --> 00:42:54,580
Now it's getting stuck.

475
00:42:55,310 --> 00:42:56,820
For some reason...

476
00:43:00,400 --> 00:43:03,542
I'm going to do something to
the model before handing it over.

477
00:43:03,542 --> 00:43:04,148
So let's say:

478
00:43:34,770 --> 00:43:36,720
The first test is passing so let's

479
00:43:37,650 --> 00:43:39,950
See what the world
looks like at this point.

480
00:43:49,960 --> 00:43:52,240
It should be the same for each episode.

481
00:43:57,560 --> 00:44:01,577
DN: Ah yes, because buildCollaborators
does return the full list.

482
00:44:02,030 --> 00:44:04,990
We don't yet have
something that just returns the roots.

483
00:44:09,480 --> 00:44:10,502
That's interesting,

484
00:44:10,502 --> 00:44:13,680
we're passing something into
it that it doesn't understand.

485
00:44:24,750 --> 00:44:27,170
That's curious, I wonder if...

486
00:44:28,080 --> 00:44:31,600
undefined is not a function: what's the
exact stacktrace of that?

487
00:44:46,290 --> 00:44:49,970
That is probably slightly
adrift of where it really is.

488
00:44:59,870 --> 00:45:01,550
Oh, I know what I've done, again.

489
00:45:03,870 --> 00:45:04,980
Let's call this:

490
00:45:12,290 --> 00:45:12,920
DN: Unpack it.

491
00:45:12,920 --> 00:45:13,300
JW: Yes.

492
00:45:15,800 --> 00:45:17,930
Now we've got a
different kind of failure.

493
00:45:17,930 --> 00:45:19,930
I'm going back to the test at this point

494
00:45:19,930 --> 00:45:22,500
rather than relying
on the running application.

495
00:45:37,440 --> 00:45:39,180
It's not bubbling up, but

496
00:45:39,180 --> 00:45:42,434
The error is that we try
and link to a root called episode

497
00:45:42,430 --> 00:45:45,657
but we've not yet said what
that root is or where it lives,

498
00:45:45,657 --> 00:45:46,580
So let's do that.

499
00:45:47,240 --> 00:45:49,150
Before we do that let's:

500
00:46:25,260 --> 00:46:28,080
I'm happy to lump all
those together as one commit.

501
00:46:45,740 --> 00:46:47,420
There's no root just yet so...

502
00:46:47,810 --> 00:46:49,230
let's get that working.

503
00:47:07,070 --> 00:47:09,430
Let's see what kind
of difference that makes.

504
00:47:09,990 --> 00:47:11,630
Cool, now on to the next.

505
00:47:15,200 --> 00:47:17,540
Right now, there's no link to

506
00:47:17,540 --> 00:47:19,000
Counting Tree Nodes on here.

507
00:47:19,390 --> 00:47:21,360
And technically we're on root

508
00:47:22,960 --> 00:47:24,560
which doesn't do very much.

509
00:47:24,940 --> 00:47:26,770
And there's only the template for it.

510
00:47:29,940 --> 00:47:33,490
I'll have a running
version of the app to look at,

511
00:47:33,490 --> 00:47:34,650
alongside the tests.

512
00:47:34,930 --> 00:47:35,530
DN: OK.

513
00:47:48,450 --> 00:47:49,340
Oh that's curious...

514
00:48:06,380 --> 00:48:07,460
Oh that's interesting.

515
00:48:08,620 --> 00:48:09,830
Oh right yes.

516
00:48:11,990 --> 00:48:13,880
I'm going to do a bit of a maneuver here.

517
00:48:20,980 --> 00:48:23,170
Let me have a look
at the tree roots again.

518
00:48:24,930 --> 00:48:26,370
There's an application root

519
00:48:26,370 --> 00:48:28,980
which is at the top root of everything.

520
00:48:28,980 --> 00:48:29,550
DN: OK.

521
00:48:29,550 --> 00:48:32,060
The episode route will
be rendered inside of it.

522
00:48:32,490 --> 00:48:34,690
And the side where I want it rendered

523
00:48:35,530 --> 00:48:39,110
is in outlet so I
will put the outlet here.

524
00:48:39,730 --> 00:48:42,240
But I want the main
list of episodes to go away

525
00:48:42,240 --> 00:48:44,120
when I step into an individual one.

526
00:48:48,930 --> 00:48:54,860
Index is a route you get
for free you don't have to define it.

527
00:48:55,910 --> 00:48:58,560
And it should inherit its model from its parents.

528
00:48:59,450 --> 00:49:01,770
That change, I wouldn't expect to do very much.

529
00:49:02,840 --> 00:49:06,502
I could be wrong, that's
why all the tests are breaking.

530
00:49:09,460 --> 00:49:12,050
That looks the same.

531
00:49:14,050 --> 00:49:16,780
I think it might be a case
of too many changes at once.

532
00:49:19,400 --> 00:49:21,600
DN: Your test error is quite fragile I see.

533
00:49:22,110 --> 00:49:25,330
JW: It is yes, but that is probably because

534
00:49:25,330 --> 00:49:26,190
we're on a...

535
00:49:27,880 --> 00:49:30,070
I know that at this point in time

536
00:49:30,070 --> 00:49:33,720
the CLI is operating to
a new file watching strategy.

537
00:49:34,340 --> 00:49:36,180
so that may be part of it.

538
00:49:36,180 --> 00:49:39,030
It's probably still going
through growing pains.

539
00:49:41,950 --> 00:49:45,140
So now we're on
roughly the same point I think.

540
00:49:52,570 --> 00:49:53,680
I'll take one of these.

541
00:49:54,290 --> 00:49:56,845
We've got the right URL, there's nothing to display,

542
00:49:56,860 --> 00:49:58,880
because there's no template just yet.

543
00:49:59,220 --> 00:50:04,411
So let's make a template for this route.

544
00:50:04,422 --> 00:50:05,940
In fact, let's just generate a route.

545
00:50:20,220 --> 00:50:21,810
So I've added that other route.

546
00:50:21,920 --> 00:50:23,531
It doesn't want to display yet.

547
00:50:23,590 --> 00:50:25,600
That is the right direction to head in.

548
00:50:39,010 --> 00:50:40,930
I think these are all part of one step.

549
00:50:54,610 --> 00:50:56,030
So far there's not much here.

550
00:50:56,320 --> 00:50:58,060
What we ideally want is to be able

551
00:50:58,060 --> 00:50:59,040
to go from episode...

552
00:51:00,530 --> 00:51:03,100
and refer that to that acceptance test.

553
00:51:06,640 --> 00:51:09,280
We're expecting to
find another link at this point

554
00:51:09,280 --> 00:51:11,280
with Ranking Poker Hands on it.

555
00:51:14,120 --> 00:51:15,710
DN: So the list you are doing now,

556
00:51:16,520 --> 00:51:20,100
is a list of sequels for the current episode.

557
00:51:20,100 --> 00:51:25,160
JW: Yes.

558
00:51:49,600 --> 00:51:51,990
DN; So that's the
name of the route episode?

559
00:51:53,520 --> 00:51:55,360
JW: Yes, the name of the episode

560
00:51:55,430 --> 00:51:56,340
the route and the

561
00:51:57,800 --> 00:51:59,930
actual instance of them.

562
00:52:00,100 --> 00:52:01,930
And the model we want for that route.

563
00:52:06,720 --> 00:52:09,790
I think my buildCollaborators function might

564
00:52:09,805 --> 00:52:12,045
not be the thing I wanted after all, but...

565
00:52:20,400 --> 00:52:21,490
I might just...

566
00:52:27,550 --> 00:52:28,930
I'll just check out...

567
00:52:40,830 --> 00:52:43,428
DN: Switch to different Ember CLI.

568
00:52:43,428 --> 00:52:46,980
JW: Yes, I'm going to go
to last stable releases.

569
00:52:47,040 --> 00:52:49,150
I have a feeling this is
the cause of my problem so...

570
00:52:52,160 --> 00:52:54,870
Narrator: We're going to
speak through this section

571
00:52:54,870 --> 00:52:57,780
We spent almost 10 minutes troubleshooting this issue.

572
00:52:57,850 --> 00:53:01,090
But, switching to the
latest stable release of Ember CLI

573
00:53:01,090 --> 00:53:02,530
didn't fix the tests however.

574
00:53:03,920 --> 00:53:06,020
Narrator: We'll pick up again where Jamie

575
00:53:06,020 --> 00:53:07,410
came up with a 'workaround'.

576
00:53:08,370 --> 00:53:11,350
JW: Unfortunately, in the current build

577
00:53:12,100 --> 00:53:13,950
of Ember CLI, or rather the current

578
00:53:13,960 --> 00:53:15,810
master build of Ember CLI,

579
00:53:16,770 --> 00:53:21,050
some aspects when rapidly re-loading files,

580
00:53:21,050 --> 00:53:22,800
causes the build to fall over.

581
00:53:23,490 --> 00:53:25,860
So for the time being, instead we will run

582
00:53:26,520 --> 00:53:27,890
Ember test as a 'one off'

583
00:53:27,890 --> 00:53:29,940
Like a one shot test.

584
00:53:29,940 --> 00:53:31,462
so it will run the tests,

585
00:53:31,470 --> 00:53:33,330
then it will tear it all down again.

586
00:53:33,330 --> 00:53:35,720
That will give us
something to work against

587
00:53:37,060 --> 00:53:38,750
So it's not working at the moment.

588
00:53:39,280 --> 00:53:41,540
And the reason is that

589
00:53:44,940 --> 00:53:47,050
Although my buildCollaborators does point to

590
00:53:47,050 --> 00:53:48,410
the correct ids.

591
00:53:48,720 --> 00:53:50,620
What we won't have here is...

592
00:53:51,977 --> 00:53:53,580
We're asking for model.sequels,

593
00:53:54,308 --> 00:53:55,885
There is no such thing right now.

594
00:53:55,885 --> 00:53:56,870
DN: Of course, right.

595
00:53:56,891 --> 00:53:59,090
JW: So we need to get those.

596
00:54:04,700 --> 00:54:06,760
You're probably thinking

597
00:54:08,780 --> 00:54:10,800
it may be possible to do something like:

598
00:54:23,260 --> 00:54:25,090
We know from buildCollaborators

599
00:54:25,090 --> 00:54:29,920
that we do have
the sequel ids, like this:

600
00:54:34,760 --> 00:54:36,920
So based on that
first bit of work we did

601
00:54:36,920 --> 00:54:38,700
that's as far as we got at the moment.

602
00:54:39,700 --> 00:54:41,250
Technically, that would work.

603
00:54:43,290 --> 00:54:45,440
The API doesn't
actually have an end point

604
00:54:45,440 --> 00:54:47,360
for that you could load up all the data

605
00:54:47,360 --> 00:54:49,220
and find the one with the correct id.

606
00:54:51,040 --> 00:54:54,720
At this point I'm inclined to lean on

607
00:54:55,370 --> 00:54:57,080
Ember.Data to do some of the

608
00:54:57,700 --> 00:54:59,860
pulling together of records:

609
00:55:00,150 --> 00:55:01,860
So I'm going to:

610
00:55:03,970 --> 00:55:05,810
I'm going to put in an elbow commit.

611
00:55:08,150 --> 00:55:09,820
Let's see what I added there.

612
00:55:13,410 --> 00:55:14,640
Let's say:

613
00:55:29,540 --> 00:55:31,170
Let's checkout a branch.

614
00:55:34,500 --> 00:55:36,540
This will be quite a substantial thing

615
00:55:36,540 --> 00:55:37,430
to start to add in.

616
00:55:39,410 --> 00:55:40,950
I think that in order to prove

617
00:55:40,950 --> 00:55:42,430
that is definitely working.

618
00:55:42,430 --> 00:55:44,742
I'm going to have a play
with the inspector to begin with,

619
00:55:44,754 --> 00:55:47,030
rather than the test environment.

620
00:55:48,300 --> 00:55:50,750
I have a gut feeling
it will be quicker that way.

621
00:55:51,900 --> 00:55:54,130
So up top, in the application route.

622
00:55:59,460 --> 00:56:01,890
Rather than this quite manual process of

623
00:56:03,040 --> 00:56:05,040
getting the data and it pulling it out

624
00:56:05,040 --> 00:56:07,350
and building collaborators from that

625
00:56:10,290 --> 00:56:11,240
I'm going to return:

626
00:56:25,490 --> 00:56:26,780
The promise library

627
00:56:27,440 --> 00:56:28,800
It has this hash function

628
00:56:28,800 --> 00:56:30,610
which is a hash of promises.

629
00:56:30,610 --> 00:56:33,300
Where they all pass on this hash

630
00:56:33,300 --> 00:56:35,560
with the promises switched out

631
00:56:35,560 --> 00:56:37,760
for whatever they're resolved into.

632
00:56:37,980 --> 00:56:39,450
So it's quite handy.

633
00:56:39,850 --> 00:56:42,860
What this let's us do is...

634
00:56:45,860 --> 00:56:47,010
I want to do two things.

635
00:56:47,010 --> 00:56:48,400
I want to load the episodes

636
00:56:57,840 --> 00:56:59,430
And that returns the promise.

637
00:57:06,354 --> 00:57:08,280
This is going to return two promises

638
00:57:08,280 --> 00:57:10,651
and it's going to wait
for them both to resolve

639
00:57:10,651 --> 00:57:11,920
before it finishes.

640
00:57:12,020 --> 00:57:13,410
Don't need the ajax anymore.

641
00:57:14,870 --> 00:57:16,890
DN: Do we now have to define a store

642
00:57:17,940 --> 00:57:19,250
for each of those?

643
00:57:19,250 --> 00:57:20,674
The store we get for free,

644
00:57:20,680 --> 00:57:22,340
but what we do need is...

645
00:57:22,650 --> 00:57:24,090
To begin with, some models,

646
00:57:44,390 --> 00:57:47,310
So right now this is
going to be complaining I need... that:

647
00:57:47,510 --> 00:57:49,490
I've got no such models I think.

648
00:57:51,020 --> 00:57:52,780
No models found for episode.

649
00:58:11,550 --> 00:58:13,890
DN: You're using
camel case deliberately here?

650
00:58:14,960 --> 00:58:16,220
while the API uses underscore case.

651
00:58:16,220 --> 00:58:16,950
JW: It does yes.

652
00:58:18,340 --> 00:58:23,810
Just by convention Ember
tends to use camel case where possible.

653
00:58:23,810 --> 00:58:26,340
Just because
that's what JavaScript looks like.

654
00:58:28,240 --> 00:58:30,491
challengeName string...

655
00:58:30,670 --> 00:58:31,714
What else have we got...

656
00:58:31,714 --> 00:58:33,400
we've got host name and guest name.

657
00:58:33,405 --> 00:58:35,965
We should be able
to infer those from the...

658
00:58:36,040 --> 00:58:37,560
So let's say we've got:

659
00:58:48,360 --> 00:58:50,790
That should have
made me a model for episode.

660
00:58:57,480 --> 00:58:59,310
Let's generate another one of these:

661
00:59:15,820 --> 00:59:17,550
Let's just have a look at the data.

662
00:59:48,030 --> 00:59:50,490
It might get
confused about what I mean here.

663
00:59:54,891 --> 00:59:57,110
It will think there's a model with that name,

664
00:59:57,110 --> 00:59:58,180
but in fact these are:

665
00:59:59,460 --> 01:00:01,860
It's referring to the partner model.

666
01:00:22,114 --> 01:00:25,291
And just like in Rails, I'll have to tell it

667
01:00:27,965 --> 01:00:30,537
what the names of the inverse relationships are.

668
01:00:30,582 --> 01:00:32,930
If the names are substantially different.

669
01:00:36,610 --> 01:00:39,210
So here, the inverse is guest.

670
01:00:42,880 --> 01:00:47,510
And here the inverse is host.

671
01:01:13,050 --> 01:01:15,960
At this point, I'm looking at
building collaborators

672
01:01:15,960 --> 01:01:19,620
as a way to prove to myself that

673
01:01:20,530 --> 01:01:24,331
following host and guest
that way is what's intended

674
01:01:24,670 --> 01:01:26,354
by the description of the challenge.

675
01:01:26,350 --> 01:01:31,131
But I have a feeling that using Ember
Data like this is going to

676
01:01:32,240 --> 01:01:35,170
shoulder a lot of the work for me.

677
01:01:35,600 --> 01:01:36,790
I'm just going to go for:

678
01:01:52,900 --> 01:01:54,160
What you are seeing here is

679
01:01:54,160 --> 01:01:57,600
It's trying to load episodes partners.

680
01:01:58,180 --> 01:02:01,337
It assumes those are the
end points we're looking for.

681
01:02:01,337 --> 01:02:03,880
DN: We've got them in the API namespace
haven't we?

682
01:02:03,880 --> 01:02:04,880
JW: We have indeed.

683
01:02:05,820 --> 01:02:07,400
If we add some of this:

684
01:02:24,830 --> 01:02:26,530
This isn't quite the order that things
happened in.

685
01:02:37,870 --> 01:02:39,620
And then this change...

686
01:02:49,490 --> 01:02:51,280
It's fine, right so:

687
01:03:11,170 --> 01:03:14,580
It doesn't know about the
namespace of the API just yet.

688
01:03:14,580 --> 01:03:18,251
And further more it doesn't know to stick
a .json on the end.

689
01:03:18,310 --> 01:03:20,930
We need to tell it, the way to do that is
an adapter

690
01:03:24,300 --> 01:03:27,700
We want this to be the universal rule

691
01:03:27,700 --> 01:03:29,870
so we call this the application adapter.

692
01:03:52,050 --> 01:03:54,290
DN: Ah, forgot to save the inverse.

693
01:03:54,290 --> 01:03:54,770
JW: Yes.

694
01:04:08,050 --> 01:04:09,840
At the moment it's the REST adapter

695
01:04:10,450 --> 01:04:14,290
but the data that we're working with

696
01:04:14,290 --> 01:04:17,860
looks quite a lot like what
active model serializers would yield.

697
01:04:18,560 --> 01:04:19,860
So let's use that instead:

698
01:04:25,360 --> 01:04:27,460
It's expecting data of this form

699
01:04:27,680 --> 01:04:29,520
So it should know what to do with it.

700
01:04:30,180 --> 01:04:33,160
Then we need to tell it the namespace

701
01:04:33,160 --> 01:04:38,580
and I think it is
just namespace like this

702
01:04:59,510 --> 01:05:02,860
DN: Does it still need to add .json?

703
01:05:02,860 --> 01:05:03,370
JW: It does.

704
01:05:03,400 --> 01:05:05,480
Now we're getting the right path

705
01:05:05,860 --> 01:05:07,480
but without the .json on the end.

706
01:05:08,160 --> 01:05:09,940
And I think there's another method:

707
01:05:20,660 --> 01:05:22,900
urlPrefix is not quite what we want.

708
01:05:24,970 --> 01:05:26,320
There's pathForType.

709
01:05:29,520 --> 01:05:30,900
Which might well do the job.

710
01:05:32,340 --> 01:05:34,950
Unless there's
something more general than that.

711
01:05:42,230 --> 01:05:43,930
Let's do pathForType:

712
01:05:53,810 --> 01:05:57,310
Basically this calls straight
through to the superclass method.

713
01:06:07,710 --> 01:06:10,150
Now some
interesting things have happened.

714
01:06:12,150 --> 01:06:14,148
We've got these warnings:

715
01:06:18,697 --> 01:06:20,320
It's saying you've got this data

716
01:06:20,320 --> 01:06:22,594
but you've not
declared that you're going to use it.

717
01:06:22,594 --> 01:06:25,900
similarly, we've got
guest episode host episode.

718
01:06:40,170 --> 01:06:43,720
It's expecting, like that:

719
01:07:02,840 --> 01:07:05,730
Let's generate a serializer which will

720
01:07:05,730 --> 01:07:09,931
enable us to perform those kind
of transformations on the input data.

721
01:07:10,690 --> 01:07:15,110
Before we do that let's stop it complaining

722
01:07:15,110 --> 01:07:17,110
about those missing fields.

723
01:07:18,320 --> 01:07:20,530
That's episodes, it's expecting to see

724
01:07:20,530 --> 01:07:22,530
guest name, host name, poster frame url

725
01:07:23,150 --> 01:07:25,211
DN: They can all be strings I suppose can't they?

726
01:07:25,234 --> 01:07:26,250
JW: Yes I guess so.

727
01:07:37,480 --> 01:07:40,400
DN: Again, you're using
camel case but the API has

728
01:07:40,400 --> 01:07:42,570
snakecase underscores.

729
01:07:42,570 --> 01:07:43,280
JW: Yes.

730
01:07:43,280 --> 01:07:45,430
DN: So, where is
that inference happening

731
01:07:45,430 --> 01:07:47,280
from one format to the other?

732
01:07:47,330 --> 01:07:49,280
It's all happening in the serializer

733
01:07:49,490 --> 01:07:50,180
DN: Ah right.

734
01:07:50,800 --> 01:07:52,760
You will find that by default

735
01:07:53,530 --> 01:07:55,690
there's this normalize method

736
01:07:55,840 --> 01:07:57,470
which does all this kind of work,

737
01:07:57,850 --> 01:07:59,630
converting snake case

738
01:07:59,940 --> 01:08:01,770
into camel case.

739
01:08:01,770 --> 01:08:06,720
converting plurals into singular,
whatever is appropriate for the format.

740
01:08:08,180 --> 01:08:10,360
Now I've got rid of some of my warnings.

741
01:08:10,890 --> 01:08:14,070
but there's still this guest
episode, host episodes problem.

742
01:08:14,380 --> 01:08:16,070
So let's say:

743
01:08:19,080 --> 01:08:21,050
We don't want a serializer

744
01:08:21,330 --> 01:08:22,780
for everything, we just want
a serializer for partner

745
01:08:57,740 --> 01:08:59,230
There has got to be some hook

746
01:08:59,240 --> 01:09:02,240
where I can turn
these into what it's expecting.

747
01:09:04,550 --> 01:09:08,060
I've got normalize which
takes type, hash and prop

748
01:09:08,800 --> 01:09:10,460
And that's going to do this work.

749
01:09:10,460 --> 01:09:11,280
So if I:

750
01:09:20,740 --> 01:09:22,980
Type meaning: when you get the data through

751
01:09:26,708 --> 01:09:28,902
it's going to infer the type from this key,

752
01:09:29,810 --> 01:09:31,510
under which each record lives.

753
01:09:35,150 --> 01:09:38,900
But we don't care too
much about that manipulation here.

754
01:09:39,310 --> 01:09:41,520
All we want to do is say:

755
01:09:43,710 --> 01:09:47,500
Hash is this:

756
01:09:48,230 --> 01:09:52,190
We want to move this so we're saying:

757
01:10:26,510 --> 01:10:28,400
Once we've done those manipulations

758
01:10:28,400 --> 01:10:29,190
we just want to hand it off to the
regular class method

759
01:10:39,120 --> 01:10:43,850
I've not been so careful
to dodge a mutation here

760
01:10:43,860 --> 01:10:47,960
because I think you
get passed a safe hash

761
01:10:47,965 --> 01:10:48,910
DN: Oh, OK.

762
01:11:01,400 --> 01:11:03,851
My warnings have now gone.

763
01:11:03,880 --> 01:11:07,325
It's complaining that the value each
loops over must be an array.

764
01:11:07,400 --> 01:11:09,400
We passed a record array.

765
01:11:09,660 --> 01:11:10,860
DN: So are we down to this

766
01:11:10,970 --> 01:11:13,000
thing called model.sequel

767
01:11:14,150 --> 01:11:17,530
Now I'm at template index.

768
01:11:18,580 --> 01:11:19,620
I'm calling model,

769
01:11:19,870 --> 01:11:21,800
which is this object here:

770
01:11:21,900 --> 01:11:24,100
containing an episode's partners.

771
01:11:25,040 --> 01:11:26,180
So I want to do:

772
01:11:30,850 --> 01:11:34,190
DN: Ah, because now
your model is in that promise

773
01:11:35,320 --> 01:11:37,310
containing both models effectively.

774
01:11:37,310 --> 01:11:37,720
JW: Yes.

775
01:11:38,780 --> 01:11:40,610
So this has got me back to this point.

776
01:11:41,590 --> 01:11:43,310
But the advantage I have now,

777
01:11:44,810 --> 01:11:47,760
Before, I got to the
point where I knew the Ids

778
01:11:47,760 --> 01:11:50,450
I wanted to get to, but
I didn't have the data to hand.

779
01:11:50,450 --> 01:11:53,360
And the question was, where do I go

780
01:11:53,360 --> 01:11:54,450
and load in that data.

781
01:11:54,450 --> 01:11:55,600
Do I have it available?

782
01:11:55,600 --> 01:11:59,500
Whereas now Ember
Data is doing that work for me.

783
01:11:59,560 --> 01:12:03,230
And furthermore, here I can see
the records that have been loaded.

784
01:12:06,590 --> 01:12:08,210
I should also be able to see...

785
01:12:09,725 --> 01:12:12,068
There will be some
computed properties here.

786
01:12:12,060 --> 01:12:15,090
So you can see,
belongs to guest episode.

787
01:12:15,660 --> 01:12:18,670
There you can see it has
managed to dig up the real model.

788
01:12:20,430 --> 01:12:23,580
That was me just clicking through

789
01:12:24,570 --> 01:12:26,640
Here's an episode, "Counting Tree Nodes".

790
01:12:26,770 --> 01:12:28,960
These are its properties, here on the right.

791
01:12:39,830 --> 01:12:42,360
I should be able to go to the guest,

792
01:12:44,380 --> 01:12:45,860
See what episodes Tom hosts,

793
01:12:45,860 --> 01:12:46,810
That's a many array,

794
01:12:46,810 --> 01:12:47,580
I'll go in there.

795
01:12:48,050 --> 01:12:51,460
It's an array containing
one which is "Ranking Poker Hands".

796
01:12:51,510 --> 01:12:53,020
So you can see it flow through.

797
01:12:54,330 --> 01:12:55,020
DN: Very nice.

798
01:12:55,970 --> 01:12:58,960
JW: leaning on Ember Data makes it
a lot quicker.

799
01:13:01,280 --> 01:13:03,680
Now that's in place, let me commit this

800
01:13:03,680 --> 01:13:05,680
quite a lot all at once.

801
01:13:06,850 --> 01:13:11,510
a new serializer, changed the template a bit.

802
01:13:11,510 --> 01:13:13,510
Oh it's not too bad, OK,

803
01:13:24,220 --> 01:13:28,610
JW: Right now we have an acceptance test.

804
01:13:30,000 --> 01:13:31,980
Which at this point is still failing.

805
01:13:31,980 --> 01:13:34,180
because we've not added the list of sequels,

806
01:13:34,180 --> 01:13:36,380
nor the prequel link yet.

807
01:13:37,230 --> 01:13:39,257
I've got some unit tests which are failing

808
01:13:39,257 --> 01:13:42,190
simply because they are just boilerplate
that was generated for me

809
01:13:43,260 --> 01:13:46,280
They need to be told
more about the rest of the world.

810
01:13:49,580 --> 01:13:52,270
I could just remove them

811
01:13:52,270 --> 01:13:55,070
I feel I want to get them passing
to have a clean environment

812
01:13:55,070 --> 01:13:56,680
So I'll do that quickly:

813
01:14:10,300 --> 01:14:12,430
When I generated the episode model

814
01:14:12,600 --> 01:14:15,000
I said that it had these two relationships

815
01:14:15,200 --> 01:14:19,270
and the boilerplate test
has these two dependencies in it

816
01:14:19,270 --> 01:14:20,290
because I said that.

817
01:14:20,520 --> 01:14:25,220
But in fact there are
no such models as those

818
01:14:25,220 --> 01:14:26,140
It's just partner...

819
01:14:27,450 --> 01:14:28,410
So if I do that:

820
01:14:30,130 --> 01:14:33,010
I have to keep jumping back to tests.

821
01:14:35,300 --> 01:14:38,800
Now episode passes

822
01:14:40,880 --> 01:14:42,920
If we flip over to the partner test
you'll see a similar problem.

823
01:14:43,530 --> 01:14:45,874
Really all this wants is:

824
01:14:53,771 --> 01:14:56,490
Now I'm back to my
acceptance test which is

825
01:14:56,491 --> 01:14:58,731
the thing that is driving us towards

826
01:14:58,810 --> 01:14:59,970
the place we want to be

827
01:14:59,977 --> 01:15:02,360
which is as follows:

828
01:15:06,850 --> 01:15:11,725
Eventually what we want to see
is a list of just the root episodes

829
01:15:11,725 --> 01:15:13,942
the episodes that begin a sequence.

830
01:15:13,990 --> 01:15:15,120
Click on one of those,

831
01:15:15,120 --> 01:15:16,700
and you see it's sequels.

832
01:15:17,220 --> 01:15:17,810
DN: Yes,

833
01:15:17,810 --> 01:15:19,890
And you click on a sequel and you see it's

834
01:15:20,460 --> 01:15:22,850
sequel, and prequel as well.

835
01:15:29,800 --> 01:15:32,760
I'm using so many
styles of working with git.

836
01:15:33,260 --> 01:15:34,790
So let's commit those:

837
01:15:37,080 --> 01:15:39,250
DN: So this is the fugitive commit feature?

838
01:15:39,250 --> 01:15:39,720
JW: Yes.

839
01:15:55,650 --> 01:15:57,240
It's complaining at the moment

840
01:15:57,240 --> 01:15:59,670
because I can't
click on Ranking Poker Hands.

841
01:16:00,630 --> 01:16:02,070
So that is...

842
01:16:02,280 --> 01:16:05,600
I'm in an episode, expecting to list all the

843
01:16:05,690 --> 01:16:07,000
sequels of the model.

844
01:16:13,520 --> 01:16:14,620
I do have <u>.</u>

845
01:16:15,290 --> 01:16:16,910
So it's ready to list something.

846
01:16:17,380 --> 01:16:20,570
It' not going to
complain that this isn't an array.

847
01:16:23,590 --> 01:16:26,260
It's more useful to just fail silently,

848
01:16:26,260 --> 01:16:28,810
when your at the template point of things

849
01:16:28,950 --> 01:16:32,410
because there's so little failure
handling you can do in template.

850
01:16:32,710 --> 01:16:34,380
As a general principle it's best to

851
01:16:34,388 --> 01:16:38,045
treat these values as monadic,

852
01:16:39,920 --> 01:16:43,730
They will resolve down
to nil, or the value you want.

853
01:16:46,800 --> 01:16:48,710
I think what I need to to is...

854
01:16:49,800 --> 01:16:51,620
get hold of these sequels.

855
01:16:51,620 --> 01:16:54,540
That's going to change
later on if I don't it now.

856
01:16:57,450 --> 01:17:00,710
The question is, if I take an episode

857
01:17:01,200 --> 01:17:02,420
how do I find it's sequel?

858
01:17:07,920 --> 01:17:11,000
I'm going to add a computed property

859
01:17:11,770 --> 01:17:12,780
to this episode

860
01:17:13,880 --> 01:17:14,840
called sequels:

861
01:17:23,885 --> 01:17:26,697
Effectively I want to look
at the rest of the episodes.

862
01:17:26,697 --> 01:17:28,510
And filter them down to just a set

863
01:17:28,920 --> 01:17:30,990
where the host is my guest.

864
01:17:32,750 --> 01:17:34,540
Let's have a look at what we have

865
01:17:34,540 --> 01:17:35,910
in terms of filtering.

866
01:17:41,110 --> 01:17:43,240
Whenever you access records in Ember data

867
01:17:43,240 --> 01:17:45,200
you always go via the store.

868
01:17:45,200 --> 01:17:49,531
Which is the central book keeping object.

869
01:17:49,570 --> 01:17:51,600
And it makes sure your always getting

870
01:17:51,800 --> 01:17:53,910
the same instance you got last time.

871
01:17:53,910 --> 01:17:54,480
DN: Right.

872
01:17:56,750 --> 01:17:59,610
I do have filter here:

873
01:18:06,020 --> 01:18:08,290
I want to try asking for:

874
01:18:17,930 --> 01:18:20,700
The thing I'm going to
be filtering on is the host id.

875
01:18:29,550 --> 01:18:31,530
Let's see what the signature of this is.

876
01:18:31,570 --> 01:18:39,820
It's just going to give
me an episode to work with.

877
01:18:41,960 --> 01:18:45,360
Now this is going to
return a promise of some kind.

878
01:18:50,340 --> 01:18:52,480
It says it returns a live record array.

879
01:18:52,790 --> 01:18:54,990
So hopefully we will be able to dump that

880
01:18:54,990 --> 01:18:56,990
into the template, and it will update

881
01:18:57,940 --> 01:18:59,790
Let's find out, that might not be true.

882
01:19:16,670 --> 01:19:19,291
We could go potentially have ids here,

883
01:19:19,291 --> 01:19:22,040
but I think they will be
hidden from us by this point.

884
01:19:22,040 --> 01:19:24,870
These are fully materialized records.

885
01:19:38,440 --> 01:19:41,640
I forgot to declare
that this is a computed property.

886
01:19:42,480 --> 01:19:44,800
There we go, so that's my sequel.

887
01:19:46,460 --> 01:19:48,411
DN: Does that give us a passing acceptance
test.

888
01:19:48,411 --> 01:19:49,420
JW: Well, let's find out.

889
01:19:55,880 --> 01:19:58,605
I think I might have messed up my link-to
helper there,

890
01:19:58,640 --> 01:19:59,550
let's find out.

891
01:20:16,950 --> 01:20:24,180
This may be a problem
with my acceptance test.

892
01:20:42,780 --> 01:20:45,970
DN: Is it the exception that's failing
where it's checking the current URL?

893
01:20:46,180 --> 01:20:46,660
JW: Yes.

894
01:20:49,770 --> 01:20:51,320
I think it might be just my...

895
01:21:01,900 --> 01:21:03,720
DN: That's why you have a commit.

896
01:21:05,028 --> 01:21:07,714
JW: So we see what happened there.

897
01:21:07,770 --> 01:21:10,290
We've added a
computed property called sequels,

898
01:21:10,560 --> 01:21:13,070
that sets up a filter

899
01:21:14,260 --> 01:21:15,770
and these filters are live.

900
01:21:15,770 --> 01:21:19,420
So the idea is, if a
new episode entered the store,

901
01:21:20,240 --> 01:21:21,670
this filter should update

902
01:21:22,140 --> 01:21:24,030
anywhere it's used in the template.

903
01:21:29,070 --> 01:21:30,980
CamelCase challenge name,

904
01:21:31,530 --> 01:21:33,050
and current path apparently

905
01:21:33,330 --> 01:21:34,730
really means current root.

906
01:21:35,760 --> 01:21:38,430
whereas what we want is the current URL.

907
01:21:39,480 --> 01:21:40,180
So:

908
01:21:53,700 --> 01:21:55,410
I feel that that acceptance test

909
01:21:55,410 --> 01:21:57,980
has given me enough
confidence that things are

910
01:21:58,250 --> 01:21:59,370
working on the whole,

911
01:21:59,370 --> 01:22:01,370
and I feel that it's going to be

912
01:22:01,660 --> 01:22:04,060
more fun just to play in the UI,

913
01:22:04,110 --> 01:22:06,330
and see what other properties it has.

914
01:22:06,330 --> 01:22:08,100
And see what other things we can do.

915
01:22:09,790 --> 01:22:10,960
So jump to episode two.

916
01:22:11,530 --> 01:22:13,714
We've already got the next sequel.

917
01:22:13,828 --> 01:22:15,428
This at the moment has no sequels

918
01:22:15,428 --> 01:22:17,371
and we're not showing prequels just yet.

919
01:22:17,371 --> 01:22:18,630
So I'm going to:

920
01:22:22,990 --> 01:22:27,470
Let's give this a title.

921
01:22:27,790 --> 01:22:29,750
DN: Yes it would be nice to see the title

922
01:22:30,260 --> 01:22:32,480
of the current episode as well.

923
01:22:33,040 --> 01:22:34,480
and maybe a poster frame.

924
01:22:50,830 --> 01:22:56,430
JW: That "Welcome to Peer to Peer"
looks surplus to requirements now,
so let's ditch that.

925
01:23:02,920 --> 01:23:06,617
I'm going to make a bunch
of cosmetic changes all at once.

926
01:23:06,820 --> 01:23:09,050
And then bundle them in to a commit.

927
01:23:14,500 --> 01:23:16,950
DN: So we've got an else branch for each

928
01:23:17,050 --> 01:23:17,620
JW: Yes.

929
01:23:19,030 --> 01:23:21,160
I forget where Ember inherited this from.

930
01:23:21,580 --> 01:23:23,160
It's not unique to Ember

931
01:23:25,980 --> 01:23:32,080
It's a little like a LISP, handlebars
templating language.

932
01:23:33,100 --> 01:23:36,050
It's not really capable
of doing multiple branches.

933
01:23:36,050 --> 01:23:38,550
in a conditional, it's only a binary.

934
01:23:38,550 --> 01:23:41,820
But it does mean you can do this kind of
thing with an each:

935
01:23:46,100 --> 01:23:47,560
I'm just going to:

936
01:23:50,090 --> 01:23:51,760
Make it look a little different.

937
01:23:57,070 --> 01:23:59,420
I'm going to add in the rudiments

938
01:24:00,610 --> 01:24:02,890
of what the prequel looks like.

939
01:24:03,480 --> 01:24:05,770
Let's make a list as well

940
01:24:06,720 --> 01:24:07,930
to make it symmetric.

941
01:24:13,450 --> 01:24:15,690
This needs to be:

942
01:24:18,560 --> 01:24:19,650
DN: Or you could say

943
01:24:20,220 --> 01:24:21,950
"this episode starts a sequence".

944
01:24:22,540 --> 01:24:23,040
JW: Yes

945
01:24:24,220 --> 01:24:25,700
I'm going to use an each again.

946
01:24:30,880 --> 01:24:32,300
Semantically, that's wrong.

947
01:24:32,860 --> 01:24:34,500
You wouldn't have more prequels.

948
01:24:35,720 --> 01:24:36,900
At least at  the moment.

949
01:24:39,950 --> 01:24:41,470
the way we are going to filter,

950
01:24:41,470 --> 01:24:43,600
I think we are going to use the same filter.

951
01:24:45,020 --> 01:24:45,600
So:

952
01:24:59,540 --> 01:25:02,040
Right now this shouldn't fail

953
01:25:02,240 --> 01:25:03,570
in a spectacular way.

954
01:25:04,050 --> 01:25:07,748
It should just silently do not very much.

955
01:25:38,450 --> 01:25:42,114
Notice the silence there...

956
01:25:42,150 --> 01:25:43,760
That indicates to me a build error.

957
01:25:45,760 --> 01:25:46,870
But maybe it's OK.

958
01:26:03,500 --> 01:26:06,020
A bunch of cosmetic
stuff... Let's just add that.

959
01:26:14,050 --> 01:26:17,700
Let's see if we can get
a prequel implemented quickly.

960
01:26:17,700 --> 01:26:20,820
I'm not going to worry
about the acceptance test for this

961
01:26:21,500 --> 01:26:23,410
I have a feeling it will be extremely

962
01:26:24,690 --> 01:26:26,550
similar to sequels.

963
01:26:46,080 --> 01:26:48,130
Here we're filtering on a guest instead.

964
01:26:48,890 --> 01:26:50,770
In the episode 2s guest is our host.

965
01:27:09,220 --> 01:27:10,080
DN: Looking good.

966
01:27:11,300 --> 01:27:13,130
So I guess the missing

967
01:27:14,140 --> 01:27:17,400
element there is that list of root.

968
01:27:19,730 --> 01:27:21,550
Those episodes without a prequel.

969
01:27:21,550 --> 01:27:21,970
JW: Yes.

970
01:27:24,480 --> 01:27:27,190
There is one little thing about this...

971
01:27:30,600 --> 01:27:32,200
these prequels and sequels

972
01:27:33,360 --> 01:27:35,810
If the host of either episode was changed

973
01:27:35,810 --> 01:27:40,080
on the fly, so if this became an editing
interface.

974
01:27:41,220 --> 01:27:44,210
these would stop being in sync with things.

975
01:27:44,210 --> 01:27:47,360
So I have to declare
that this is a computed property

976
01:27:47,360 --> 01:27:49,150
that depends on the value of host.

977
01:27:49,860 --> 01:27:52,350
And this one depends on the value of guest.

978
01:27:53,090 --> 01:27:56,210
Technically it depends on store
but store not going to change.

979
01:27:58,210 --> 01:27:59,680
That's very interesting.

980
01:28:01,010 --> 01:28:04,200
Oh, I know what I've done there, oh well.

981
01:28:04,990 --> 01:28:06,450
DN: So that second argument...

982
01:28:07,150 --> 01:28:08,720
JW: Yes, I think it's if you want to

983
01:28:08,720 --> 01:28:10,970
send a different request off to the server.

984
01:28:10,970 --> 01:28:11,420
DN: I see.

985
01:28:12,900 --> 01:28:16,420
JW: It looks like it's
requesting back and forth repeatedly.

986
01:28:16,980 --> 01:28:18,720
Let's kill that off.

987
01:28:24,560 --> 01:28:25,690
That's better.

988
01:28:28,150 --> 01:28:29,100
Excellent.

989
01:28:32,450 --> 01:28:34,170
Right, so that second argument...

990
01:28:37,680 --> 01:28:40,240
Jamie reads the last paragraph (above examples).

991
01:28:49,820 --> 01:28:53,630
So it allows you to use
the data you already have

992
01:28:53,630 --> 01:28:57,270
and make a query in the background.

993
01:28:58,100 --> 01:29:00,000
Just covering all the bases I think.

994
01:29:05,410 --> 01:29:07,520
So let's add that:

995
01:29:07,860 --> 01:29:11,990
That implements prequels.

996
01:29:21,440 --> 01:29:28,530
Here, rather than
looping over the episodes,

997
01:29:28,530 --> 01:29:32,360
we want to loop over
something like root episodes.

998
01:29:32,360 --> 01:29:33,440
DN: Yes.

999
01:29:34,030 --> 01:29:35,850
JW: I'm going to say that we're going to

1000
01:29:35,850 --> 01:29:37,280
loop over simply the model.

1001
01:29:39,010 --> 01:29:40,560
This is going to fail at first.

1002
01:29:41,080 --> 01:29:42,180
We'll go back to:

1003
01:29:46,510 --> 01:29:49,360
So it's saying:

1004
01:29:49,380 --> 01:29:51,700
we're trying to each over an object,

1005
01:29:51,700 --> 01:29:53,040
just a hash.

1006
01:29:55,920 --> 01:29:58,320
Right now, we are
not in the application route.

1007
01:29:58,420 --> 01:30:00,680
We are one down in the index route.

1008
01:30:00,960 --> 01:30:02,940
So if I generate a route:

1009
01:30:04,790 --> 01:30:06,630
That's like  a real live route for that.

1010
01:30:14,610 --> 01:30:17,130
So by default a route will take a model

1011
01:30:17,130 --> 01:30:19,130
of its parent routes, as its own.

1012
01:30:22,530 --> 01:30:25,270
If we say instead, the model for this

1013
01:30:25,270 --> 01:30:26,180
is going to be:

1014
01:30:27,680 --> 01:30:29,700
We'll get the model for the application.

1015
01:30:31,100 --> 01:30:34,180
and then we want to pluck off the

1016
01:30:35,970 --> 01:30:37,770
Episodes let's say, that should be

1017
01:30:37,770 --> 01:30:39,770
more or less, back to where we started.

1018
01:30:43,550 --> 01:30:46,690
I think the best way to
perform that transformation is here.

1019
01:30:48,100 --> 01:30:49,380
Let's think...

1020
01:30:53,430 --> 01:30:55,760
We could use that filter again

1021
01:30:55,760 --> 01:30:58,550
We can say:

1022
01:31:00,800 --> 01:31:02,170
Actually, do you know what,

1023
01:31:02,170 --> 01:31:04,610
at this point these
things are already loaded.

1024
01:31:04,910 --> 01:31:07,180
Therefore we could do something like this:

1025
01:31:33,200 --> 01:31:35,000
It's this kind of thing.

1026
01:31:39,410 --> 01:31:40,820
I don't even quite call that,

1027
01:31:40,820 --> 01:31:41,830
So let's say:

1028
01:31:53,420 --> 01:31:55,310
The problem with that is that this is

1029
01:31:55,310 --> 01:31:57,600
probably not quite what we think it is.

1030
01:32:02,290 --> 01:32:03,220
Let's find out.

1031
01:32:04,210 --> 01:32:05,440
At this point in time.

1032
01:32:05,890 --> 01:32:08,260
I've got a strong feeling that if we ask for

1033
01:32:09,560 --> 01:32:11,680
prequels.length, you wont get back

1034
01:32:14,270 --> 01:32:16,290
an ordinary array of ordinary length.

1035
01:32:16,290 --> 01:32:17,100
So:

1036
01:32:26,530 --> 01:32:27,920
This is a...

1037
01:32:31,440 --> 01:32:32,570
I don't know what it is.

1038
01:32:33,600 --> 01:32:34,570
That seems OK.

1039
01:32:37,090 --> 01:32:39,110
So that's true for at least one of them.

1040
01:32:52,500 --> 01:32:54,820
DN: It seems to be
returning true every time.

1041
01:32:54,820 --> 01:32:55,880
JW: It does doesn't it?

1042
01:32:59,330 --> 01:33:01,670
So Ranking Poker
Hands should not be in here.

1043
01:33:03,350 --> 01:33:06,400
(Some sounds of confusion)

1044
01:33:06,400 --> 01:33:10,010
DN: Ah, it's working! (laughter)

1045
01:33:14,990 --> 01:33:17,330
JW: It suggests you
have to ask some question

1046
01:33:17,330 --> 01:33:20,240
before it completes the operation.

1047
01:33:25,140 --> 01:33:32,250
I think you may well find that it's these prequels.

1048
01:33:33,370 --> 01:33:36,000
It might be returning
something asynchronous.

1049
01:33:36,000 --> 01:33:37,110
Some kind of promise.

1050
01:33:43,420 --> 01:33:46,050
Let's think, what's the
best way to deal with this?

1051
01:33:46,050 --> 01:33:47,010
Let's go for:

1052
01:34:02,250 --> 01:34:03,160
I'm going to add:

1053
01:34:07,240 --> 01:34:08,630
See what else is available.

1054
01:34:08,630 --> 01:34:10,630
It might be there's another primitive

1055
01:34:10,630 --> 01:34:12,100
for doing this kind of thing.

1056
01:34:15,696 --> 01:34:20,294
Maybe we ought to add a
computed property to the episode model

1057
01:34:23,898 --> 01:34:24,762
We'll call this:

1058
01:34:28,623 --> 01:34:30,282
And this is true...

1059
01:34:36,548 --> 01:34:39,268
This is going to run into
kind of the same problem.

1060
01:34:39,326 --> 01:34:42,437
DN: If they were
prequels rather than sequels...

1061
01:34:42,680 --> 01:34:43,578
JW: Yes...

1062
01:34:49,503 --> 01:34:51,566
So let's see...

1063
01:35:13,040 --> 01:35:16,050
DN: I wasn't anticipating that
this would be the hard part.

1064
01:35:16,050 --> 01:35:18,050
It's a surprise.

1065
01:35:24,909 --> 01:35:27,772
What is it... When we start with a list

1066
01:35:27,770 --> 01:35:30,964
and it's got all five
episodes, and we click on one

1067
01:35:30,964 --> 01:35:32,960
and then go back again.

1068
01:35:32,960 --> 01:35:34,960
What is it that's changed at that point?

1069
01:35:40,480 --> 01:35:41,578
And then if we go back.

1070
01:35:41,751 --> 01:35:42,821
JW: Yes so...

1071
01:35:43,035 --> 01:35:43,894
DN: Now it's OK.

1072
01:35:45,709 --> 01:35:46,572
JW: At this point...

1073
01:35:52,757 --> 01:35:54,934
We've got these
two computed properties.

1074
01:35:55,270 --> 01:35:57,376
And the way they are bound into the DOM

1075
01:35:57,372 --> 01:35:59,264
gives them a chance to fully resolve.

1076
01:35:59,392 --> 01:36:03,168
To turn from promise to a real value.

1077
01:36:03,896 --> 01:36:07,168
Whereas in our route,

1078
01:36:07,160 --> 01:36:10,496
(sort of) inherited route environment,
we don't

1079
01:36:11,440 --> 01:36:13,848
we're saying get host.

1080
01:36:15,024 --> 01:36:17,008
sorry, rather we're saying...

1081
01:36:21,888 --> 01:36:23,544
I've still got all that to save.

1082
01:36:24,896 --> 01:36:27,352
I was expecting to see
the full list at this point.

1083
01:36:46,000 --> 01:36:49,040
What we are not doing is...

1084
01:36:49,040 --> 01:36:51,789
giving that promise
a chance to resolve itself.

1085
01:36:52,210 --> 01:36:54,909
before we return the
model data to the template.

1086
01:36:55,738 --> 01:36:58,436
I was hoping that this filter would

1087
01:36:59,229 --> 01:37:02,814
change dynamically, as
new data becomes available.

1088
01:37:02,810 --> 01:37:03,374
DN: Right.

1089
01:37:03,461 --> 01:37:05,629
It seems that isn't quite the case.

1090
01:37:09,380 --> 01:37:12,734
DN: Is there some way you can
do something before the model loads?

1091
01:37:12,734 --> 01:37:14,760
Maybe on initialization or...?

1092
01:37:15,061 --> 01:37:16,247
JW: Yes.

1093
01:37:17,098 --> 01:37:21,040
The dirty way to do it
would be to do something like this:

1094
01:37:35,447 --> 01:37:37,941
DN: And that forces the
computed property to be...?

1095
01:37:39,149 --> 01:37:41,723
JW: It's going to
kick start all those promises.

1096
01:37:41,720 --> 01:37:43,927
And change the state of all those models.

1097
01:37:47,825 --> 01:37:49,330
What's going on there?

1098
01:37:49,338 --> 01:37:51,818
Oh it's saying that I've still got no model.

1099
01:38:18,872 --> 01:38:20,036
DN: Oh that does it.

1100
01:38:20,800 --> 01:38:24,843
Unfortunately, because the model is
a little state machine,

1101
01:38:26,580 --> 01:38:31,345
to account for the fact that
you may have data landing later on...

1102
01:38:33,469 --> 01:38:37,258
other models may change around
it, that it needs to know about.

1103
01:38:38,350 --> 01:38:40,894
In order to get this
richness of relationships,

1104
01:38:40,894 --> 01:38:42,807
it can't be just a pure object.

1105
01:38:43,316 --> 01:38:45,447
You end up with these sort of situations,

1106
01:38:45,447 --> 01:38:49,360
where your having to wait
for a model to get into the right state.

1107
01:38:49,850 --> 01:38:51,854
Which is tricky, because in this case

1108
01:38:51,854 --> 01:38:54,210
we know that we have all the data up front.

1109
01:38:54,210 --> 01:38:56,203
But Ember Data is so geared up for the idea

1110
01:38:56,203 --> 01:38:58,632
that you don't know when data will arrive.

1111
01:39:00,829 --> 01:39:04,232
I have a feeling there probably is a way to...

1112
01:39:10,770 --> 01:39:16,458
There are extra properties you can add.

1113
01:39:17,860 --> 01:39:22,770
So you could say explicitly that
these are asynchronous dependencies.

1114
01:39:23,701 --> 01:39:27,360
But for us, because up in
the application route,

1115
01:39:28,218 --> 01:39:31,636
we have very deliberately
loaded in an entire store of data.

1116
01:39:31,723 --> 01:39:34,072
We shouldn't need to ever worry about that.

1117
01:39:34,669 --> 01:39:37,512
It's a shame that we're
having to do that but...

1118
01:39:38,000 --> 01:39:40,894
It gets us to the point we want,

1119
01:39:40,890 --> 01:39:43,207
which is to get these root episodes.

1120
01:39:43,381 --> 01:39:44,050
DN: Yes.

1121
01:39:44,370 --> 01:39:47,607
JW: So let's make that very explicit:

1122
01:40:10,050 --> 01:40:12,014
So, Solving Word Chain puzzles...

1123
01:40:12,203 --> 01:40:15,112
then it goes on to
Building a Basic Calculator.

1124
01:40:15,110 --> 01:40:18,509
And back there and... For good measure:

1125
01:40:20,680 --> 01:40:22,548
DN: We can link back to the top one?

1126
01:40:22,574 --> 01:40:23,207
JW: Yes.

1127
01:40:50,181 --> 01:40:51,527
Something like that.

1128
01:40:54,385 --> 01:40:58,490
JW: Cool, so now I would be interested to know...

1129
01:41:00,300 --> 01:41:02,334
To see what we're getting for our money

1130
01:41:02,385 --> 01:41:04,330
I'll quickly do this:

1131
01:41:09,030 --> 01:41:12,516
It would be interesting
to add another episode in.

1132
01:41:12,510 --> 01:41:17,301
And see if our
representation updates as we expect it to.

1133
01:41:17,510 --> 01:41:21,221
DN: So how about we imagine an episode

1134
01:41:21,221 --> 01:41:25,425
where Tom sets a challenge for Steve Purcell?

1135
01:41:28,218 --> 01:41:31,345
That will mean we have
a single root in that case.

1136
01:41:31,340 --> 01:41:35,832
But there will be a branch where
Tom has interviewed Camille and also Steve.

1137
01:41:35,830 --> 01:41:38,065
JW: Yes, right.

1138
01:41:39,230 --> 01:41:41,796
So, I want to try and do this in the inspector.

1139
01:41:41,796 --> 01:41:46,712
It's a useful way to check that
your app is behaving as you want.

1140
01:41:47,500 --> 01:41:51,408
The Ember inspector
gives you introspection

1141
01:41:51,400 --> 01:41:53,568
on everything in your living system.

1142
01:41:53,560 --> 01:41:56,928
These little $E buttons
will emit an object out

1143
01:41:56,928 --> 01:41:59,816
into the global scope, so you can play with it.

1144
01:41:59,810 --> 01:42:02,552
So this is my store.

1145
01:42:06,768 --> 01:42:09,640
I could do createRecord,

1146
01:42:11,848 --> 01:42:14,912
I could use store.createRecord,
let's try this.

1147
01:42:17,136 --> 01:42:19,800
Create record implies
that you're going to pass in

1148
01:42:19,800 --> 01:42:21,120
other concrete objects.

1149
01:42:21,120 --> 01:42:22,720
Like if there's a relationship.

1150
01:42:22,720 --> 01:42:25,816
I'm going to literally
give it Steve to work with.

1151
01:42:25,810 --> 01:42:29,176
But I think it might be more
interesting to push a new payload in.

1152
01:42:29,170 --> 01:42:32,888
This is a case where, you would have for example,

1153
01:42:32,880 --> 01:42:35,208
new data coming in over a socket.

1154
01:42:35,200 --> 01:42:38,992
Imagine that Peer to
Peer was produced so often,

1155
01:42:38,990 --> 01:42:42,000
that you had a web socket,
telling the browser that the episode...

1156
01:42:42,040 --> 01:42:44,736
You can use, I believe it's pushPayload.

1157
01:42:45,410 --> 01:42:47,584
So this is the idea of imagining a new

1158
01:42:47,768 --> 01:42:51,660
chunk of data coming into the store.

1159
01:42:54,024 --> 01:42:55,464
Let's see...

1160
01:42:57,392 --> 01:43:00,864
We've got pushPayload there,
I think we can get it on store as well.

1161
01:43:13,640 --> 01:43:15,024
Let's pushPayload,

1162
01:43:15,768 --> 01:43:18,120
What did we say, Tom interviewing Steve?

1163
01:43:18,120 --> 01:43:19,712
DN: Yes.

1164
01:43:20,288 --> 01:43:22,112
We'll go back to Counting Tree Nodes,

1165
01:43:22,110 --> 01:43:25,512
and we'll pushPayLoad which looks like:

1166
01:43:26,260 --> 01:43:27,976
DN: So the nice thing about this is

1167
01:43:27,976 --> 01:43:30,024
we don't have to create any new partners.

1168
01:43:30,020 --> 01:43:33,376
We can re-use the ones that exist.

1169
01:43:33,370 --> 01:43:36,472
JW: We're saying it will have an id of 6.

1170
01:43:38,376 --> 01:43:44,304
Challenge name: some challenge
that Tom would set for Steve

1171
01:43:44,304 --> 01:43:48,640
which would probably be
something really hard. (laughter).

1172
01:43:51,504 --> 01:43:52,736
Invent a new monad.

1173
01:43:53,976 --> 01:43:56,856
DN: Sounds interesting!

1174
01:43:57,310 --> 01:44:00,184
Guest name and host
name we don't really use,

1175
01:44:00,184 --> 01:44:01,960
so I'm going to leave them be.

1176
01:44:01,960 --> 01:44:04,592
Let's just say there's no
poster image for this one.

1177
01:44:04,590 --> 01:44:08,176
So we'll say host_id is
going to be Tom, who is 2.

1178
01:44:08,832 --> 01:44:11,176
and guest id is going to be Steve...

1179
01:44:13,448 --> 01:44:15,080
who is 4.
DN: Yes.

1180
01:44:16,520 --> 01:44:20,480
I think that to get this to work
I'll have to wrap it in an episode:

1181
01:44:24,864 --> 01:44:25,920
Namespace...

1182
01:44:26,900 --> 01:44:28,920
DN: You didn't just lose all that did you?

1183
01:44:28,920 --> 01:44:29,952
JW: I did.

1184
01:44:29,952 --> 01:44:31,950
DN: Oh dear.

1185
01:44:36,032 --> 01:44:37,904
I think it will be episode singular.

1186
01:44:37,904 --> 01:44:39,900
Maybe not, let's try episodes plural:

1187
01:44:57,928 --> 01:44:59,632
That is the end of the array.

1188
01:45:09,848 --> 01:45:12,456
There we go, Inventing a New Monad.

1189
01:45:12,450 --> 01:45:14,688
DN: And it just fits right into the sequence.

1190
01:45:15,168 --> 01:45:15,680
Very nice.

1191
01:45:15,680 --> 01:45:19,008
JW: And we should be able
to have a look in Data here.

1192
01:45:19,000 --> 01:45:20,544
There we go, yes.

1193
01:45:24,200 --> 01:45:26,640
These aren't the
computed guest and host names,

1194
01:45:26,640 --> 01:45:29,224
these are the ones
that are stored on the objects

1195
01:45:29,232 --> 01:45:31,790
that we're not really using in this case.

1196
01:45:31,792 --> 01:45:33,440
DN: We can probably ignore those.

1197
01:45:33,544 --> 01:45:38,368
JW: Yes, we genuinely have Steve the guest

1198
01:45:38,504 --> 01:45:40,360
and Tom the host.

1199
01:45:44,216 --> 01:45:46,352
I'm just going to add one
more little cosmetic thing

1200
01:45:46,350 --> 01:45:50,552
to enrich this.

1201
01:45:55,424 --> 01:45:57,056
I'm going to drop...

1202
01:46:00,416 --> 01:46:03,448
Because this was all about
collaborations to begin with,

1203
01:46:03,808 --> 01:46:05,440
Let's say:

1204
01:46:28,624 --> 01:46:30,680
DN: I would say featuring guest name.

1205
01:46:34,656 --> 01:46:37,560
JW: There is a little thing
which is going to happen here

1206
01:46:37,560 --> 01:46:41,210
which is that guests don't
have a name, I don't think.

1207
01:46:41,210 --> 01:46:45,808
DN: Yes, that's right, first name and last name.

1208
01:46:46,768 --> 01:46:48,120
But we could compute that.

1209
01:46:48,120 --> 01:46:48,752
JW: Yes.

1210
01:46:51,728 --> 01:46:53,112
That's gone from memory now,

1211
01:46:53,112 --> 01:46:56,200
so I've lost that new episode.

1212
01:46:57,192 --> 01:47:00,000
Featuring... There's no name, so I'll add that.

1213
01:47:21,832 --> 01:47:24,232
DN: That one has two dependent keys then?

1214
01:47:24,448 --> 01:47:25,200
JW: Correct.

1215
01:47:27,992 --> 01:47:30,096
Then, with a little bit of luck ....

1216
01:47:34,650 --> 01:47:39,032
This gives us the other nicety which is...

1217
01:47:44,424 --> 01:47:48,248
How does Camille spell her name,
is it CAMI?

1218
01:47:49,144 --> 01:47:50,632
DN: Good question, I don't know,

1219
01:47:50,632 --> 01:47:52,630
it's certainly pronounced Camille.

1220
01:47:55,712 --> 01:47:57,368
JW: We can now edit these details

1221
01:47:57,368 --> 01:47:59,024
in one central place.

1222
01:48:04,296 --> 01:48:05,824
DN: OK... Check it in.

1223
01:48:05,820 --> 01:48:06,440
JW: Yes.

1224
01:48:22,800 --> 01:48:24,960
This is where we:

1225
01:48:35,656 --> 01:48:38,920
DN: We've got the root, that's a major change.

1226
01:48:55,680 --> 01:48:58,904
DN: You misspelled featuring
I'm afraid (laughter)

1227
01:49:10,072 --> 01:49:14,872
DN: So we've reached a
good place to call it a day I think.

1228
01:49:14,870 --> 01:49:19,664
But if you had more time, how
would you like to continue with this?

1229
01:49:22,080 --> 01:49:26,496
For anyone familiar with building this style of

1230
01:49:27,017 --> 01:49:31,097
view on data in Rails, it probably
seems relatively simplistic.

1231
01:49:32,860 --> 01:49:35,222
If wouldn't be too
hard to do this with Rails.

1232
01:49:35,220 --> 01:49:39,828
The point is we are getting these potentially disparate

1233
01:49:39,828 --> 01:49:43,314
data sources into memory and turning them into

1234
01:49:43,310 --> 01:49:45,977
a data structure that we can then
wander around in

1235
01:49:45,980 --> 01:49:48,525
Without having to do any more re-loads

1236
01:49:48,525 --> 01:49:50,331
or fetches of data.

1237
01:49:50,330 --> 01:49:55,062
So now we have these
relationships between these objects.

1238
01:49:55,097 --> 01:49:59,588
It wouldn't be too hard to
render them out in other ways.

1239
01:49:59,580 --> 01:50:03,737
The way we have it right
now, linking between them

1240
01:50:03,737 --> 01:50:07,508
I feel like it's the...

1241
01:50:07,560 --> 01:50:10,514
simplest way to represent

1242
01:50:10,514 --> 01:50:13,108
a graph of different entities.

1243
01:50:13,100 --> 01:50:19,428
That's (kind of) the web way,
its most basic form.

1244
01:50:19,420 --> 01:50:23,771
But we could render
out a visual graph of this stuff.

1245
01:50:24,240 --> 01:50:29,737
I would be inclined to reach for Graphviz

1246
01:50:30,057 --> 01:50:34,100
or potentially D3 which has some

1247
01:50:34,100 --> 01:50:38,217
modules in it for rendering
directed graphs.

1248
01:50:38,308 --> 01:50:44,320
I know Graphviz and its dot language
better than I know D3

1249
01:50:44,320 --> 01:50:48,537
So that's what I would err towards.

1250
01:50:48,670 --> 01:50:51,451
The other thing I would like to get rid of,

1251
01:50:52,930 --> 01:50:56,754
but I just can't think of how you go about it,

1252
01:50:56,750 --> 01:50:59,405
is the reliance on this here.

1253
01:50:59,400 --> 01:51:01,451
I'm sure there is a way, probably an

1254
01:51:01,451 --> 01:51:07,325
idiomatic way, but in
essence it's because of this odd

1255
01:51:09,771 --> 01:51:15,737
thing of needing to... In the
same way you want to carry a monad,

1256
01:51:15,900 --> 01:51:18,434
up until the final moment, to finally unpack it,

1257
01:51:18,430 --> 01:51:20,491
and get the value inside it.

1258
01:51:20,491 --> 01:51:24,850
Similarly here, we want to
be dealing just in terms of promises

1259
01:51:24,868 --> 01:51:28,857
until the last possible moment,
when they are put into the template.

1260
01:51:28,850 --> 01:51:32,114
and eventually allowed to
be unpacked and rendered.

1261
01:51:32,377 --> 01:51:34,228
So, I'm sure there's a way around this.

1262
01:51:34,354 --> 01:51:38,057
but, it probably doesn't
hurt too much at this point.

1263
01:51:38,460 --> 01:51:40,754
DN: The idea will probably
will spring into your head

1264
01:51:40,754 --> 01:51:42,697
just as we turn the camera off (laughter).

1265
01:51:42,708 --> 01:51:46,110
JW: In terms of the UI, it would be...

1266
01:51:48,868 --> 01:51:53,131
You could render a tree out here of
blobs connected by sticks.

1267
01:51:55,314 --> 01:51:58,285
DN: Well, it's been really interesting watching you work

1268
01:51:58,280 --> 01:51:59,371
and how you use Ember.

1269
01:51:59,382 --> 01:52:01,470
And thanks a lot for coming on the show.

1270
01:52:01,470 --> 01:52:02,834
JW: Thanks for inviting me.

